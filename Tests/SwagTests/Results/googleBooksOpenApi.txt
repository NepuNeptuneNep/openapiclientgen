//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	public class Annotation
	{
		
		/// <summary>
		/// Anchor text after excerpt. For requests, if the user bookmarked a screen that has no flowing text on it, then this field should be empty.
		/// </summary>
		public string AfterSelectedText { get; set; }
		
		/// <summary>
		/// Anchor text before excerpt. For requests, if the user bookmarked a screen that has no flowing text on it, then this field should be empty.
		/// </summary>
		public string BeforeSelectedText { get; set; }
		
		/// <summary>
		/// Selection ranges sent from the client.
		/// </summary>
		public AnnotationClientVersionRanges ClientVersionRanges { get; set; }
		
		/// <summary>
		/// Timestamp for the created time of this annotation.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// Selection ranges for the most recent content version.
		/// </summary>
		public AnnotationCurrentVersionRanges CurrentVersionRanges { get; set; }
		
		/// <summary>
		/// User-created data for this annotation.
		/// </summary>
		public string Data { get; set; }
		
		/// <summary>
		/// Indicates that this annotation is deleted.
		/// </summary>
		public System.Nullable<System.Boolean> Deleted { get; set; }
		
		/// <summary>
		/// The highlight style for this annotation.
		/// </summary>
		public string HighlightStyle { get; set; }
		
		/// <summary>
		/// Id of this annotation, in the form of a GUID.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("books#annotation")]
		public string Kind { get; set; } = "books#annotation";
		
		/// <summary>
		/// The layer this annotation is for.
		/// </summary>
		public string LayerId { get; set; }
		
		public AnnotationLayerSummary LayerSummary { get; set; }
		
		/// <summary>
		/// Pages that this annotation spans.
		/// </summary>
		public string[] PageIds { get; set; }
		
		/// <summary>
		/// Excerpt from the volume.
		/// </summary>
		public string SelectedText { get; set; }
		
		/// <summary>
		/// URL to this resource.
		/// </summary>
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Timestamp for the last time this annotation was modified.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
		
		/// <summary>
		/// The volume that this annotation belongs to.
		/// </summary>
		public string VolumeId { get; set; }
	}
	
	public class AnnotationClientVersionRanges
	{
		
		public BooksAnnotationsRange CfiRange { get; set; }
		
		/// <summary>
		/// Content version the client sent in.
		/// </summary>
		public string ContentVersion { get; set; }
		
		public BooksAnnotationsRange GbImageRange { get; set; }
		
		public BooksAnnotationsRange GbTextRange { get; set; }
		
		public BooksAnnotationsRange ImageCfiRange { get; set; }
	}
	
	public class BooksAnnotationsRange
	{
		
		/// <summary>
		/// The offset from the ending position.
		/// </summary>
		public string EndOffset { get; set; }
		
		/// <summary>
		/// The ending position for the range.
		/// </summary>
		public string EndPosition { get; set; }
		
		/// <summary>
		/// The offset from the starting position.
		/// </summary>
		public string StartOffset { get; set; }
		
		/// <summary>
		/// The starting position for the range.
		/// </summary>
		public string StartPosition { get; set; }
	}
	
	public class AnnotationCurrentVersionRanges
	{
		
		public BooksAnnotationsRange CfiRange { get; set; }
		
		/// <summary>
		/// Content version applicable to ranges below.
		/// </summary>
		public string ContentVersion { get; set; }
		
		public BooksAnnotationsRange GbImageRange { get; set; }
		
		public BooksAnnotationsRange GbTextRange { get; set; }
		
		public BooksAnnotationsRange ImageCfiRange { get; set; }
	}
	
	public class AnnotationLayerSummary
	{
		
		/// <summary>
		/// Maximum allowed characters on this layer, especially for the "copy" layer.
		/// </summary>
		public System.Nullable<System.Int32> AllowedCharacterCount { get; set; }
		
		/// <summary>
		/// Type of limitation on this layer. "limited" or "unlimited" for the "copy" layer.
		/// </summary>
		public string LimitType { get; set; }
		
		/// <summary>
		/// Remaining allowed characters on this layer, especially for the "copy" layer.
		/// </summary>
		public System.Nullable<System.Int32> RemainingCharacterCount { get; set; }
	}
	
	public class Annotationdata
	{
		
		/// <summary>
		/// The type of annotation this data is for.
		/// </summary>
		public string AnnotationType { get; set; }
		
		public object Data { get; set; }
		
		/// <summary>
		/// Base64 encoded data for this annotation data.
		/// </summary>
		public string Encoded_data { get; set; }
		
		/// <summary>
		/// Unique id for this annotation data.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Resource Type
		/// </summary>
		[System.ComponentModel.DefaultValue("books#annotationdata")]
		public string Kind { get; set; } = "books#annotationdata";
		
		/// <summary>
		/// The Layer id for this data. *
		/// </summary>
		public string LayerId { get; set; }
		
		/// <summary>
		/// URL for this resource. *
		/// </summary>
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Timestamp for the last time this data was updated. (RFC 3339 UTC date-time format).
		/// </summary>
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
		
		/// <summary>
		/// The volume id for this data. *
		/// </summary>
		public string VolumeId { get; set; }
	}
	
	public class Annotations
	{
		
		/// <summary>
		/// A list of annotations.
		/// </summary>
		public Annotation[] Items { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("books#annotations")]
		public string Kind { get; set; } = "books#annotations";
		
		/// <summary>
		/// Token to pass in for pagination for the next page. This will not be present if this request does not have more results.
		/// </summary>
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Total number of annotations found. This may be greater than the number of notes returned in this response if results have been paginated.
		/// </summary>
		public System.Nullable<System.Int32> TotalItems { get; set; }
	}
	
	public class AnnotationsSummary
	{
		
		[System.ComponentModel.DefaultValue("books#annotationsSummary")]
		public string Kind { get; set; } = "books#annotationsSummary";
		
		public AnnotationsSummaryLayers[] AnnotationsSummaryLayers { get; set; }
	}
	
	public class AnnotationsSummaryLayers
	{
		
		public System.Nullable<System.Int32> AllowedCharacterCount { get; set; }
		
		public string LayerId { get; set; }
		
		public string LimitType { get; set; }
		
		public System.Nullable<System.Int32> RemainingCharacterCount { get; set; }
		
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
	}
	
	public class Annotationsdata
	{
		
		/// <summary>
		/// A list of Annotation Data.
		/// </summary>
		public Annotationdata[] Items { get; set; }
		
		/// <summary>
		/// Resource type
		/// </summary>
		[System.ComponentModel.DefaultValue("books#annotationsdata")]
		public string Kind { get; set; } = "books#annotationsdata";
		
		/// <summary>
		/// Token to pass in for pagination for the next page. This will not be present if this request does not have more results.
		/// </summary>
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The total number of volume annotations found.
		/// </summary>
		public System.Nullable<System.Int32> TotalItems { get; set; }
	}
	
	public class BooksCloudloadingResource
	{
		
		public string Author { get; set; }
		
		public string ProcessingState { get; set; }
		
		public string Title { get; set; }
		
		public string VolumeId { get; set; }
	}
	
	public class BooksSubscriptionReleaseInfo
	{
		
		/// <summary>
		/// Amount in micros of the specified currency code.
		/// </summary>
		public string AmountInMicros { get; set; }
		
		/// <summary>
		/// Currency code of the amount.
		/// </summary>
		public string CurrencyCode { get; set; }
		
		/// <summary>
		/// The release number of this issue/volume/book.
		/// </summary>
		public string ReleaseNumber { get; set; }
		
		/// <summary>
		/// The release date.
		/// </summary>
		public string ReleaseTimestampUs { get; set; }
	}
	
	public class BooksVolumesRecommendedRateResponse
	{
		
		public string Consistency_token { get; set; }
	}
	
	public class Bookshelf
	{
		
		/// <summary>
		/// Whether this bookshelf is PUBLIC or PRIVATE.
		/// </summary>
		public string Access { get; set; }
		
		/// <summary>
		/// Created time for this bookshelf (formatted UTC timestamp with millisecond resolution).
		/// </summary>
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// Description of this bookshelf.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Id of this bookshelf, only unique by user.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Resource type for bookshelf metadata.
		/// </summary>
		[System.ComponentModel.DefaultValue("books#bookshelf")]
		public string Kind { get; set; } = "books#bookshelf";
		
		/// <summary>
		/// URL to this resource.
		/// </summary>
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Title of this bookshelf.
		/// </summary>
		public string Title { get; set; }
		
		/// <summary>
		/// Last modified time of this bookshelf (formatted UTC timestamp with millisecond resolution).
		/// </summary>
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
		
		/// <summary>
		/// Number of volumes in this bookshelf.
		/// </summary>
		public System.Nullable<System.Int32> VolumeCount { get; set; }
		
		/// <summary>
		/// Last time a volume was added or removed from this bookshelf (formatted UTC timestamp with millisecond resolution).
		/// </summary>
		public System.Nullable<System.DateTimeOffset> VolumesLastUpdated { get; set; }
	}
	
	public class Bookshelves
	{
		
		/// <summary>
		/// A list of bookshelves.
		/// </summary>
		public Bookshelf[] Items { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("books#bookshelves")]
		public string Kind { get; set; } = "books#bookshelves";
	}
	
	public class Category
	{
		
		/// <summary>
		/// A list of onboarding categories.
		/// </summary>
		public CategoryItems[] CategoryItems { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("onboarding#category")]
		public string Kind { get; set; } = "onboarding#category";
	}
	
	public class CategoryItems
	{
		
		public string BadgeUrl { get; set; }
		
		public string CategoryId { get; set; }
		
		public string Name { get; set; }
	}
	
	public class ConcurrentAccessRestriction
	{
		
		/// <summary>
		/// Whether access is granted for this (user, device, volume).
		/// </summary>
		public System.Nullable<System.Boolean> DeviceAllowed { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("books#concurrentAccessRestriction")]
		public string Kind { get; set; } = "books#concurrentAccessRestriction";
		
		/// <summary>
		/// The maximum number of concurrent access licenses for this volume.
		/// </summary>
		public System.Nullable<System.Int32> MaxConcurrentDevices { get; set; }
		
		/// <summary>
		/// Error/warning message.
		/// </summary>
		public string Message { get; set; }
		
		/// <summary>
		/// Client nonce for verification. Download access and client-validation only.
		/// </summary>
		public string Nonce { get; set; }
		
		/// <summary>
		/// Error/warning reason code.
		/// </summary>
		public string ReasonCode { get; set; }
		
		/// <summary>
		/// Whether this volume has any concurrent access restrictions.
		/// </summary>
		public System.Nullable<System.Boolean> Restricted { get; set; }
		
		/// <summary>
		/// Response signature.
		/// </summary>
		public string Signature { get; set; }
		
		/// <summary>
		/// Client app identifier for verification. Download access and client-validation only.
		/// </summary>
		public string Source { get; set; }
		
		/// <summary>
		/// Time in seconds for license auto-expiration.
		/// </summary>
		public System.Nullable<System.Int32> TimeWindowSeconds { get; set; }
		
		/// <summary>
		/// Identifies the volume for which this entry applies.
		/// </summary>
		public string VolumeId { get; set; }
	}
	
	public class Dictlayerdata
	{
		
		public DictlayerdataCommon Common { get; set; }
		
		public DictlayerdataDict Dict { get; set; }
		
		[System.ComponentModel.DefaultValue("books#dictlayerdata")]
		public string Kind { get; set; } = "books#dictlayerdata";
	}
	
	public class DictlayerdataCommon
	{
		
		/// <summary>
		/// The display title and localized canonical name to use when searching for this entity on Google search.
		/// </summary>
		public string Title { get; set; }
	}
	
	public class DictlayerdataDict
	{
		
		/// <summary>
		/// The source, url and attribution for this dictionary data.
		/// </summary>
		public DictlayerdataDictSource Source { get; set; }
		
		public DictlayerdataDictWords[] DictlayerdataDictWords { get; set; }
	}
	
	public class DictlayerdataDictSource
	{
		
		public string Attribution { get; set; }
		
		public string Url { get; set; }
	}
	
	public class DictlayerdataDictWords
	{
		
		public DictlayerdataDictWordsDerivatives[] DictlayerdataDictWordsDerivatives { get; set; }
		
		public DictlayerdataDictWordsExamples[] DictlayerdataDictWordsExamples { get; set; }
		
		public DictlayerdataDictWordsSenses[] DictlayerdataDictWordsSenses { get; set; }
		
		/// <summary>
		/// The words with different meanings but not related words, e.g. "go" (game) and "go" (verb).
		/// </summary>
		public DictlayerdataDictWordsSource Source { get; set; }
	}
	
	public class DictlayerdataDictWordsDerivatives
	{
		
		public DictlayerdataDictWordsDerivativesSource Source { get; set; }
		
		public string Text { get; set; }
	}
	
	public class DictlayerdataDictWordsDerivativesSource
	{
		
		public string Attribution { get; set; }
		
		public string Url { get; set; }
	}
	
	public class DictlayerdataDictWordsExamples
	{
		
		public DictlayerdataDictWordsExamplesSource Source { get; set; }
		
		public string Text { get; set; }
	}
	
	public class DictlayerdataDictWordsExamplesSource
	{
		
		public string Attribution { get; set; }
		
		public string Url { get; set; }
	}
	
	public class DictlayerdataDictWordsSenses
	{
		
		public DictlayerdataDictWordsSensesConjugations[] DictlayerdataDictWordsSensesConjugations { get; set; }
		
		public DictlayerdataDictWordsSensesDefinitions[] DictlayerdataDictWordsSensesDefinitions { get; set; }
		
		public string PartOfSpeech { get; set; }
		
		public string Pronunciation { get; set; }
		
		public string PronunciationUrl { get; set; }
		
		public DictlayerdataDictWordsSensesSource Source { get; set; }
		
		public string Syllabification { get; set; }
		
		public DictlayerdataDictWordsSensesSynonyms[] DictlayerdataDictWordsSensesSynonyms { get; set; }
	}
	
	public class DictlayerdataDictWordsSensesConjugations
	{
		
		public string Type { get; set; }
		
		public string Value { get; set; }
	}
	
	public class DictlayerdataDictWordsSensesDefinitions
	{
		
		public string Definition { get; set; }
		
		public DictlayerdataDictWordsSensesDefinitionsExamples[] DictlayerdataDictWordsSensesDefinitionsExamples { get; set; }
	}
	
	public class DictlayerdataDictWordsSensesDefinitionsExamples
	{
		
		public DictlayerdataDictWordsSensesDefinitionsExamplesSource Source { get; set; }
		
		public string Text { get; set; }
	}
	
	public class DictlayerdataDictWordsSensesDefinitionsExamplesSource
	{
		
		public string Attribution { get; set; }
		
		public string Url { get; set; }
	}
	
	public class DictlayerdataDictWordsSensesSource
	{
		
		public string Attribution { get; set; }
		
		public string Url { get; set; }
	}
	
	public class DictlayerdataDictWordsSensesSynonyms
	{
		
		public DictlayerdataDictWordsSensesSynonymsSource Source { get; set; }
		
		public string Text { get; set; }
	}
	
	public class DictlayerdataDictWordsSensesSynonymsSource
	{
		
		public string Attribution { get; set; }
		
		public string Url { get; set; }
	}
	
	public class DictlayerdataDictWordsSource
	{
		
		public string Attribution { get; set; }
		
		public string Url { get; set; }
	}
	
	public class Discoveryclusters
	{
		
		public DiscoveryclustersClusters[] DiscoveryclustersClusters { get; set; }
		
		/// <summary>
		/// Resorce type.
		/// </summary>
		[System.ComponentModel.DefaultValue("books#discovery#clusters")]
		public string Kind { get; set; } = "books#discovery#clusters";
		
		public System.Nullable<System.Int32> TotalClusters { get; set; }
	}
	
	public class DiscoveryclustersClusters
	{
		
		public DiscoveryclustersClustersBanner_with_content_container Banner_with_content_container { get; set; }
		
		public string SubTitle { get; set; }
		
		public string Title { get; set; }
		
		public System.Nullable<System.Int32> TotalVolumes { get; set; }
		
		public string Uid { get; set; }
		
		public Volume[] Volumes { get; set; }
	}
	
	public class DiscoveryclustersClustersBanner_with_content_container
	{
		
		public string FillColorArgb { get; set; }
		
		public string ImageUrl { get; set; }
		
		public string MaskColorArgb { get; set; }
		
		public string MoreButtonText { get; set; }
		
		public string MoreButtonUrl { get; set; }
		
		public string TextColorArgb { get; set; }
	}
	
	public class Volume
	{
		
		/// <summary>
		/// Any information about a volume related to reading or obtaining that volume text. This information can depend on country (books may be public domain in one country but not in another, e.g.).
		/// </summary>
		public VolumeAccessInfo AccessInfo { get; set; }
		
		/// <summary>
		/// Opaque identifier for a specific version of a volume resource. (In LITE projection)
		/// </summary>
		public string Etag { get; set; }
		
		/// <summary>
		/// Unique identifier for a volume. (In LITE projection.)
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Resource type for a volume. (In LITE projection.)
		/// </summary>
		[System.ComponentModel.DefaultValue("books#volume")]
		public string Kind { get; set; } = "books#volume";
		
		/// <summary>
		/// What layers exist in this volume and high level information about them.
		/// </summary>
		public VolumeLayerInfo LayerInfo { get; set; }
		
		/// <summary>
		/// Recommendation related information for this volume.
		/// </summary>
		public VolumeRecommendedInfo RecommendedInfo { get; set; }
		
		/// <summary>
		/// Any information about a volume related to the eBookstore and/or purchaseability. This information can depend on the country where the request originates from (i.e. books may not be for sale in certain countries).
		/// </summary>
		public VolumeSaleInfo SaleInfo { get; set; }
		
		/// <summary>
		/// Search result information related to this volume.
		/// </summary>
		public VolumeSearchInfo SearchInfo { get; set; }
		
		/// <summary>
		/// URL to this resource. (In LITE projection.)
		/// </summary>
		public string SelfLink { get; set; }
		
		/// <summary>
		/// User specific information related to this volume. (e.g. page this user last read or whether they purchased this book)
		/// </summary>
		public VolumeUserInfo UserInfo { get; set; }
		
		/// <summary>
		/// General volume information.
		/// </summary>
		public VolumeVolumeInfo VolumeInfo { get; set; }
	}
	
	public class VolumeAccessInfo
	{
		
		/// <summary>
		/// Combines the access and viewability of this volume into a single status field for this user. Values can be FULL_PURCHASED, FULL_PUBLIC_DOMAIN, SAMPLE or NONE. (In LITE projection.)
		/// </summary>
		public string AccessViewStatus { get; set; }
		
		/// <summary>
		/// The two-letter ISO_3166-1 country code for which this access information is valid. (In LITE projection.)
		/// </summary>
		public string Country { get; set; }
		
		public DownloadAccessRestriction DownloadAccess { get; set; }
		
		/// <summary>
		/// URL to the Google Drive viewer if this volume is uploaded by the user by selecting the file from Google Drive.
		/// </summary>
		public string DriveImportedContentLink { get; set; }
		
		/// <summary>
		/// Whether this volume can be embedded in a viewport using the Embedded Viewer API.
		/// </summary>
		public System.Nullable<System.Boolean> Embeddable { get; set; }
		
		/// <summary>
		/// Information about epub content. (In LITE projection.)
		/// </summary>
		public VolumeAccessInfoEpub Epub { get; set; }
		
		/// <summary>
		/// Whether this volume requires that the client explicitly request offline download license rather than have it done automatically when loading the content, if the client supports it.
		/// </summary>
		public System.Nullable<System.Boolean> ExplicitOfflineLicenseManagement { get; set; }
		
		/// <summary>
		/// Information about pdf content. (In LITE projection.)
		/// </summary>
		public VolumeAccessInfoPdf Pdf { get; set; }
		
		/// <summary>
		/// Whether or not this book is public domain in the country listed above.
		/// </summary>
		public System.Nullable<System.Boolean> PublicDomain { get; set; }
		
		/// <summary>
		/// Whether quote sharing is allowed for this volume.
		/// </summary>
		public System.Nullable<System.Boolean> QuoteSharingAllowed { get; set; }
		
		/// <summary>
		/// Whether text-to-speech is permitted for this volume. Values can be ALLOWED, ALLOWED_FOR_ACCESSIBILITY, or NOT_ALLOWED.
		/// </summary>
		public string TextToSpeechPermission { get; set; }
		
		/// <summary>
		/// For ordered but not yet processed orders, we give a URL that can be used to go to the appropriate Google Wallet page.
		/// </summary>
		public string ViewOrderUrl { get; set; }
		
		/// <summary>
		/// The read access of a volume. Possible values are PARTIAL, ALL_PAGES, NO_PAGES or UNKNOWN. This value depends on the country listed above. A value of PARTIAL means that the publisher has allowed some portion of the volume to be viewed publicly, without purchase. This can apply to eBooks as well as non-eBooks. Public domain books will always have a value of ALL_PAGES.
		/// </summary>
		public string Viewability { get; set; }
		
		/// <summary>
		/// URL to read this volume on the Google Books site. Link will not allow users to read non-viewable volumes.
		/// </summary>
		public string WebReaderLink { get; set; }
	}
	
	public class DownloadAccessRestriction
	{
		
		/// <summary>
		/// If restricted, whether access is granted for this (user, device, volume).
		/// </summary>
		public System.Nullable<System.Boolean> DeviceAllowed { get; set; }
		
		/// <summary>
		/// If restricted, the number of content download licenses already acquired (including the requesting client, if licensed).
		/// </summary>
		public System.Nullable<System.Int32> DownloadsAcquired { get; set; }
		
		/// <summary>
		/// If deviceAllowed, whether access was just acquired with this request.
		/// </summary>
		public System.Nullable<System.Boolean> JustAcquired { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("books#downloadAccessRestriction")]
		public string Kind { get; set; } = "books#downloadAccessRestriction";
		
		/// <summary>
		/// If restricted, the maximum number of content download licenses for this volume.
		/// </summary>
		public System.Nullable<System.Int32> MaxDownloadDevices { get; set; }
		
		/// <summary>
		/// Error/warning message.
		/// </summary>
		public string Message { get; set; }
		
		/// <summary>
		/// Client nonce for verification. Download access and client-validation only.
		/// </summary>
		public string Nonce { get; set; }
		
		/// <summary>
		/// Error/warning reason code. Additional codes may be added in the future. 0 OK 100 ACCESS_DENIED_PUBLISHER_LIMIT 101 ACCESS_DENIED_LIMIT 200 WARNING_USED_LAST_ACCESS
		/// </summary>
		public string ReasonCode { get; set; }
		
		/// <summary>
		/// Whether this volume has any download access restrictions.
		/// </summary>
		public System.Nullable<System.Boolean> Restricted { get; set; }
		
		/// <summary>
		/// Response signature.
		/// </summary>
		public string Signature { get; set; }
		
		/// <summary>
		/// Client app identifier for verification. Download access and client-validation only.
		/// </summary>
		public string Source { get; set; }
		
		/// <summary>
		/// Identifies the volume for which this entry applies.
		/// </summary>
		public string VolumeId { get; set; }
	}
	
	public class VolumeAccessInfoEpub
	{
		
		/// <summary>
		/// URL to retrieve ACS token for epub download. (In LITE projection.)
		/// </summary>
		public string AcsTokenLink { get; set; }
		
		/// <summary>
		/// URL to download epub. (In LITE projection.)
		/// </summary>
		public string DownloadLink { get; set; }
		
		/// <summary>
		/// Is a flowing text epub available either as public domain or for purchase. (In LITE projection.)
		/// </summary>
		public System.Nullable<System.Boolean> IsAvailable { get; set; }
	}
	
	public class VolumeAccessInfoPdf
	{
		
		/// <summary>
		/// URL to retrieve ACS token for pdf download. (In LITE projection.)
		/// </summary>
		public string AcsTokenLink { get; set; }
		
		/// <summary>
		/// URL to download pdf. (In LITE projection.)
		/// </summary>
		public string DownloadLink { get; set; }
		
		/// <summary>
		/// Is a scanned image pdf available either as public domain or for purchase. (In LITE projection.)
		/// </summary>
		public System.Nullable<System.Boolean> IsAvailable { get; set; }
	}
	
	public class VolumeLayerInfo
	{
		
		/// <summary>
		/// A layer should appear here if and only if the layer exists for this book.
		/// </summary>
		public VolumeLayerInfoLayers[] VolumeLayerInfoLayers { get; set; }
	}
	
	public class VolumeLayerInfoLayers
	{
		
		/// <summary>
		/// The layer id of this layer (e.g. "geo").
		/// </summary>
		public string LayerId { get; set; }
		
		/// <summary>
		/// The current version of this layer's volume annotations. Note that this version applies only to the data in the books.layers.volumeAnnotations.* responses. The actual annotation data is versioned separately.
		/// </summary>
		public string VolumeAnnotationsVersion { get; set; }
	}
	
	public class VolumeRecommendedInfo
	{
		
		/// <summary>
		/// A text explaining why this volume is recommended.
		/// </summary>
		public string Explanation { get; set; }
	}
	
	public class VolumeSaleInfo
	{
		
		/// <summary>
		/// URL to purchase this volume on the Google Books site. (In LITE projection)
		/// </summary>
		public string BuyLink { get; set; }
		
		/// <summary>
		/// The two-letter ISO_3166-1 country code for which this sale information is valid. (In LITE projection.)
		/// </summary>
		public string Country { get; set; }
		
		/// <summary>
		/// Whether or not this volume is an eBook (can be added to the My eBooks shelf).
		/// </summary>
		public System.Nullable<System.Boolean> IsEbook { get; set; }
		
		/// <summary>
		/// Suggested retail price. (In LITE projection.)
		/// </summary>
		public VolumeSaleInfoListPrice ListPrice { get; set; }
		
		/// <summary>
		/// Offers available for this volume (sales and rentals).
		/// </summary>
		public VolumeSaleInfoOffers[] VolumeSaleInfoOffers { get; set; }
		
		/// <summary>
		/// The date on which this book is available for sale.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> OnSaleDate { get; set; }
		
		/// <summary>
		/// The actual selling price of the book. This is the same as the suggested retail or list price unless there are offers or discounts on this volume. (In LITE projection.)
		/// </summary>
		public VolumeSaleInfoRetailPrice RetailPrice { get; set; }
		
		/// <summary>
		/// Whether or not this book is available for sale or offered for free in the Google eBookstore for the country listed above. Possible values are FOR_SALE, FOR_RENTAL_ONLY, FOR_SALE_AND_RENTAL, FREE, NOT_FOR_SALE, or FOR_PREORDER.
		/// </summary>
		public string Saleability { get; set; }
	}
	
	public class VolumeSaleInfoListPrice
	{
		
		/// <summary>
		/// Amount in the currency listed below. (In LITE projection.)
		/// </summary>
		public System.Nullable<System.Double> Amount { get; set; }
		
		/// <summary>
		/// An ISO 4217, three-letter currency code. (In LITE projection.)
		/// </summary>
		public string CurrencyCode { get; set; }
	}
	
	public class VolumeSaleInfoOffers
	{
		
		/// <summary>
		/// The finsky offer type (e.g., PURCHASE=0 RENTAL=3)
		/// </summary>
		public System.Nullable<System.Int32> FinskyOfferType { get; set; }
		
		/// <summary>
		/// Indicates whether the offer is giftable.
		/// </summary>
		public System.Nullable<System.Boolean> Giftable { get; set; }
		
		/// <summary>
		/// Offer list (=undiscounted) price in Micros.
		/// </summary>
		public VolumeSaleInfoOffersListPrice ListPrice { get; set; }
		
		/// <summary>
		/// The rental duration (for rental offers only).
		/// </summary>
		public VolumeSaleInfoOffersRentalDuration RentalDuration { get; set; }
		
		/// <summary>
		/// Offer retail (=discounted) price in Micros
		/// </summary>
		public VolumeSaleInfoOffersRetailPrice RetailPrice { get; set; }
	}
	
	public class VolumeSaleInfoOffersListPrice
	{
		
		public System.Nullable<System.Double> AmountInMicros { get; set; }
		
		public string CurrencyCode { get; set; }
	}
	
	public class VolumeSaleInfoOffersRentalDuration
	{
		
		public System.Nullable<System.Double> Count { get; set; }
		
		public string Unit { get; set; }
	}
	
	public class VolumeSaleInfoOffersRetailPrice
	{
		
		public System.Nullable<System.Double> AmountInMicros { get; set; }
		
		public string CurrencyCode { get; set; }
	}
	
	public class VolumeSaleInfoRetailPrice
	{
		
		/// <summary>
		/// Amount in the currency listed below. (In LITE projection.)
		/// </summary>
		public System.Nullable<System.Double> Amount { get; set; }
		
		/// <summary>
		/// An ISO 4217, three-letter currency code. (In LITE projection.)
		/// </summary>
		public string CurrencyCode { get; set; }
	}
	
	public class VolumeSearchInfo
	{
		
		/// <summary>
		/// A text snippet containing the search query.
		/// </summary>
		public string TextSnippet { get; set; }
	}
	
	public class VolumeUserInfo
	{
		
		/// <summary>
		/// Timestamp when this volume was acquired by the user. (RFC 3339 UTC date-time format) Acquiring includes purchase, user upload, receiving family sharing, etc.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> AcquiredTime { get; set; }
		
		/// <summary>
		/// How this volume was acquired.
		/// </summary>
		public System.Nullable<System.Int32> AcquisitionType { get; set; }
		
		/// <summary>
		/// Copy/Paste accounting information.
		/// </summary>
		public VolumeUserInfoCopy Copy { get; set; }
		
		/// <summary>
		/// Whether this volume is purchased, sample, pd download etc.
		/// </summary>
		public System.Nullable<System.Int32> EntitlementType { get; set; }
		
		/// <summary>
		/// Information on the ability to share with the family.
		/// </summary>
		public VolumeUserInfoFamilySharing FamilySharing { get; set; }
		
		/// <summary>
		/// Whether or not the user shared this volume with the family.
		/// </summary>
		public System.Nullable<System.Boolean> IsFamilySharedFromUser { get; set; }
		
		/// <summary>
		/// Whether or not the user received this volume through family sharing.
		/// </summary>
		public System.Nullable<System.Boolean> IsFamilySharedToUser { get; set; }
		
		/// <summary>
		/// Deprecated: Replaced by familySharing.
		/// </summary>
		public System.Nullable<System.Boolean> IsFamilySharingAllowed { get; set; }
		
		/// <summary>
		/// Deprecated: Replaced by familySharing.
		/// </summary>
		public System.Nullable<System.Boolean> IsFamilySharingDisabledByFop { get; set; }
		
		/// <summary>
		/// Whether or not this volume is currently in "my books."
		/// </summary>
		public System.Nullable<System.Boolean> IsInMyBooks { get; set; }
		
		/// <summary>
		/// Whether or not this volume was pre-ordered by the authenticated user making the request. (In LITE projection.)
		/// </summary>
		public System.Nullable<System.Boolean> IsPreordered { get; set; }
		
		/// <summary>
		/// Whether or not this volume was purchased by the authenticated user making the request. (In LITE projection.)
		/// </summary>
		public System.Nullable<System.Boolean> IsPurchased { get; set; }
		
		/// <summary>
		/// Whether or not this volume was user uploaded.
		/// </summary>
		public System.Nullable<System.Boolean> IsUploaded { get; set; }
		
		public ReadingPosition ReadingPosition { get; set; }
		
		/// <summary>
		/// Period during this book is/was a valid rental.
		/// </summary>
		public VolumeUserInfoRentalPeriod RentalPeriod { get; set; }
		
		/// <summary>
		/// Whether this book is an active or an expired rental.
		/// </summary>
		public string RentalState { get; set; }
		
		public Review Review { get; set; }
		
		/// <summary>
		/// Timestamp when this volume was last modified by a user action, such as a reading position update, volume purchase or writing a review. (RFC 3339 UTC date-time format).
		/// </summary>
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
		
		public VolumeUserInfoUserUploadedVolumeInfo UserUploadedVolumeInfo { get; set; }
	}
	
	public class VolumeUserInfoCopy
	{
		
		public System.Nullable<System.Int32> AllowedCharacterCount { get; set; }
		
		public string LimitType { get; set; }
		
		public System.Nullable<System.Int32> RemainingCharacterCount { get; set; }
		
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
	}
	
	public class VolumeUserInfoFamilySharing
	{
		
		/// <summary>
		/// The role of the user in the family.
		/// </summary>
		public string FamilyRole { get; set; }
		
		/// <summary>
		/// Whether or not this volume can be shared with the family by the user. This includes sharing eligibility of both the volume and the user. If the value is true, the user can initiate a family sharing action.
		/// </summary>
		public System.Nullable<System.Boolean> IsSharingAllowed { get; set; }
		
		/// <summary>
		/// Whether or not sharing this volume is temporarily disabled due to issues with the Family Wallet.
		/// </summary>
		public System.Nullable<System.Boolean> IsSharingDisabledByFop { get; set; }
	}
	
	public class ReadingPosition
	{
		
		/// <summary>
		/// Position in an EPUB as a CFI.
		/// </summary>
		public string EpubCfiPosition { get; set; }
		
		/// <summary>
		/// Position in a volume for image-based content.
		/// </summary>
		public string GbImagePosition { get; set; }
		
		/// <summary>
		/// Position in a volume for text-based content.
		/// </summary>
		public string GbTextPosition { get; set; }
		
		/// <summary>
		/// Resource type for a reading position.
		/// </summary>
		[System.ComponentModel.DefaultValue("books#readingPosition")]
		public string Kind { get; set; } = "books#readingPosition";
		
		/// <summary>
		/// Position in a PDF file.
		/// </summary>
		public string PdfPosition { get; set; }
		
		/// <summary>
		/// Timestamp when this reading position was last updated (formatted UTC timestamp with millisecond resolution).
		/// </summary>
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
		
		/// <summary>
		/// Volume id associated with this reading position.
		/// </summary>
		public string VolumeId { get; set; }
	}
	
	public class VolumeUserInfoRentalPeriod
	{
		
		public string EndUtcSec { get; set; }
		
		public string StartUtcSec { get; set; }
	}
	
	public class Review
	{
		
		/// <summary>
		/// Author of this review.
		/// </summary>
		public ReviewAuthor Author { get; set; }
		
		/// <summary>
		/// Review text.
		/// </summary>
		public string Content { get; set; }
		
		/// <summary>
		/// Date of this review.
		/// </summary>
		public string Date { get; set; }
		
		/// <summary>
		/// URL for the full review text, for reviews gathered from the web.
		/// </summary>
		public string FullTextUrl { get; set; }
		
		/// <summary>
		/// Resource type for a review.
		/// </summary>
		[System.ComponentModel.DefaultValue("books#review")]
		public string Kind { get; set; } = "books#review";
		
		/// <summary>
		/// Star rating for this review. Possible values are ONE, TWO, THREE, FOUR, FIVE or NOT_RATED.
		/// </summary>
		public string Rating { get; set; }
		
		/// <summary>
		/// Information regarding the source of this review, when the review is not from a Google Books user.
		/// </summary>
		public ReviewSource Source { get; set; }
		
		/// <summary>
		/// Title for this review.
		/// </summary>
		public string Title { get; set; }
		
		/// <summary>
		/// Source type for this review. Possible values are EDITORIAL, WEB_USER or GOOGLE_USER.
		/// </summary>
		public string Type { get; set; }
		
		/// <summary>
		/// Volume that this review is for.
		/// </summary>
		public string VolumeId { get; set; }
	}
	
	public class ReviewAuthor
	{
		
		/// <summary>
		/// Name of this person.
		/// </summary>
		public string DisplayName { get; set; }
	}
	
	public class ReviewSource
	{
		
		/// <summary>
		/// Name of the source.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Extra text about the source of the review.
		/// </summary>
		public string ExtraDescription { get; set; }
		
		/// <summary>
		/// URL of the source of the review.
		/// </summary>
		public string Url { get; set; }
	}
	
	public class VolumeUserInfoUserUploadedVolumeInfo
	{
		
		public string ProcessingState { get; set; }
	}
	
	public class VolumeVolumeInfo
	{
		
		/// <summary>
		/// Whether anonymous logging should be allowed.
		/// </summary>
		public System.Nullable<System.Boolean> AllowAnonLogging { get; set; }
		
		/// <summary>
		/// The names of the authors and/or editors for this volume. (In LITE projection)
		/// </summary>
		public string[] Authors { get; set; }
		
		/// <summary>
		/// The mean review rating for this volume. (min = 1.0, max = 5.0)
		/// </summary>
		public System.Nullable<System.Double> AverageRating { get; set; }
		
		/// <summary>
		/// Canonical URL for a volume. (In LITE projection.)
		/// </summary>
		public string CanonicalVolumeLink { get; set; }
		
		/// <summary>
		/// A list of subject categories, such as "Fiction", "Suspense", etc.
		/// </summary>
		public string[] Categories { get; set; }
		
		/// <summary>
		/// Whether the volume has comics content.
		/// </summary>
		public System.Nullable<System.Boolean> ComicsContent { get; set; }
		
		/// <summary>
		/// An identifier for the version of the volume content (text & images). (In LITE projection)
		/// </summary>
		public string ContentVersion { get; set; }
		
		/// <summary>
		/// A synopsis of the volume. The text of the description is formatted in HTML and includes simple formatting elements, such as b, i, and br tags. (In LITE projection.)
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Physical dimensions of this volume.
		/// </summary>
		public VolumeVolumeInfoDimensions Dimensions { get; set; }
		
		/// <summary>
		/// A list of image links for all the sizes that are available. (In LITE projection.)
		/// </summary>
		public VolumeVolumeInfoImageLinks ImageLinks { get; set; }
		
		/// <summary>
		/// Industry standard identifiers for this volume.
		/// </summary>
		public VolumeVolumeInfoIndustryIdentifiers[] VolumeVolumeInfoIndustryIdentifiers { get; set; }
		
		/// <summary>
		/// URL to view information about this volume on the Google Books site. (In LITE projection)
		/// </summary>
		public string InfoLink { get; set; }
		
		/// <summary>
		/// Best language for this volume (based on content). It is the two-letter ISO 639-1 code such as 'fr', 'en', etc.
		/// </summary>
		public string Language { get; set; }
		
		/// <summary>
		/// The main category to which this volume belongs. It will be the category from the categories list returned below that has the highest weight.
		/// </summary>
		public string MainCategory { get; set; }
		
		public string MaturityRating { get; set; }
		
		/// <summary>
		/// Total number of pages as per publisher metadata.
		/// </summary>
		public System.Nullable<System.Int32> PageCount { get; set; }
		
		/// <summary>
		/// A top-level summary of the panelization info in this volume.
		/// </summary>
		public VolumeVolumeInfoPanelizationSummary PanelizationSummary { get; set; }
		
		/// <summary>
		/// URL to preview this volume on the Google Books site.
		/// </summary>
		public string PreviewLink { get; set; }
		
		/// <summary>
		/// Type of publication of this volume. Possible values are BOOK or MAGAZINE.
		/// </summary>
		public string PrintType { get; set; }
		
		/// <summary>
		/// Total number of printed pages in generated pdf representation.
		/// </summary>
		public System.Nullable<System.Int32> PrintedPageCount { get; set; }
		
		/// <summary>
		/// Date of publication. (In LITE projection.)
		/// </summary>
		public string PublishedDate { get; set; }
		
		/// <summary>
		/// Publisher of this volume. (In LITE projection.)
		/// </summary>
		public string Publisher { get; set; }
		
		/// <summary>
		/// The number of review ratings for this volume.
		/// </summary>
		public System.Nullable<System.Int32> RatingsCount { get; set; }
		
		/// <summary>
		/// The reading modes available for this volume.
		/// </summary>
		public object ReadingModes { get; set; }
		
		/// <summary>
		/// Total number of sample pages as per publisher metadata.
		/// </summary>
		public System.Nullable<System.Int32> SamplePageCount { get; set; }
		
		public Volumeseriesinfo SeriesInfo { get; set; }
		
		/// <summary>
		/// Volume subtitle. (In LITE projection.)
		/// </summary>
		public string Subtitle { get; set; }
		
		/// <summary>
		/// Volume title. (In LITE projection.)
		/// </summary>
		public string Title { get; set; }
	}
	
	public class VolumeVolumeInfoDimensions
	{
		
		/// <summary>
		/// Height or length of this volume (in cm).
		/// </summary>
		public string Height { get; set; }
		
		/// <summary>
		/// Thickness of this volume (in cm).
		/// </summary>
		public string Thickness { get; set; }
		
		/// <summary>
		/// Width of this volume (in cm).
		/// </summary>
		public string Width { get; set; }
	}
	
	public class VolumeVolumeInfoImageLinks
	{
		
		/// <summary>
		/// Image link for extra large size (width of ~1280 pixels). (In LITE projection)
		/// </summary>
		public string ExtraLarge { get; set; }
		
		/// <summary>
		/// Image link for large size (width of ~800 pixels). (In LITE projection)
		/// </summary>
		public string Large { get; set; }
		
		/// <summary>
		/// Image link for medium size (width of ~575 pixels). (In LITE projection)
		/// </summary>
		public string Medium { get; set; }
		
		/// <summary>
		/// Image link for small size (width of ~300 pixels). (In LITE projection)
		/// </summary>
		public string Small { get; set; }
		
		/// <summary>
		/// Image link for small thumbnail size (width of ~80 pixels). (In LITE projection)
		/// </summary>
		public string SmallThumbnail { get; set; }
		
		/// <summary>
		/// Image link for thumbnail size (width of ~128 pixels). (In LITE projection)
		/// </summary>
		public string Thumbnail { get; set; }
	}
	
	public class VolumeVolumeInfoIndustryIdentifiers
	{
		
		/// <summary>
		/// Industry specific volume identifier.
		/// </summary>
		public string Identifier { get; set; }
		
		/// <summary>
		/// Identifier type. Possible values are ISBN_10, ISBN_13, ISSN and OTHER.
		/// </summary>
		public string Type { get; set; }
	}
	
	public class VolumeVolumeInfoPanelizationSummary
	{
		
		public System.Nullable<System.Boolean> ContainsEpubBubbles { get; set; }
		
		public System.Nullable<System.Boolean> ContainsImageBubbles { get; set; }
		
		public string EpubBubbleVersion { get; set; }
		
		public string ImageBubbleVersion { get; set; }
	}
	
	public class Volumeseriesinfo
	{
		
		/// <summary>
		/// The display number string. This should be used only for display purposes and the actual sequence should be inferred from the below orderNumber.
		/// </summary>
		public string BookDisplayNumber { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("books#volume_series_info")]
		public string Kind { get; set; } = "books#volume_series_info";
		
		/// <summary>
		/// Short book title in the context of the series.
		/// </summary>
		public string ShortSeriesBookTitle { get; set; }
		
		public VolumeseriesinfoVolumeSeries[] VolumeseriesinfoVolumeSeries { get; set; }
	}
	
	public class VolumeseriesinfoVolumeSeries
	{
		
		/// <summary>
		/// List of issues. Applicable only for Collection Edition and Omnibus.
		/// </summary>
		public VolumeseriesinfoVolumeSeriesIssue[] VolumeseriesinfoVolumeSeriesIssue { get; set; }
		
		/// <summary>
		/// The book order number in the series.
		/// </summary>
		public System.Nullable<System.Int32> OrderNumber { get; set; }
		
		/// <summary>
		/// The book type in the context of series. Examples - Single Issue, Collection Edition, etc.
		/// </summary>
		public string SeriesBookType { get; set; }
		
		/// <summary>
		/// The series id.
		/// </summary>
		public string SeriesId { get; set; }
	}
	
	public class VolumeseriesinfoVolumeSeriesIssue
	{
		
		public string IssueDisplayNumber { get; set; }
		
		public System.Nullable<System.Int32> IssueOrderNumber { get; set; }
	}
	
	public class DownloadAccesses
	{
		
		/// <summary>
		/// A list of download access responses.
		/// </summary>
		public DownloadAccessRestriction[] DownloadAccessList { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("books#downloadAccesses")]
		public string Kind { get; set; } = "books#downloadAccesses";
	}
	
	public class FamilyInfo
	{
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("books#familyInfo")]
		public string Kind { get; set; } = "books#familyInfo";
		
		/// <summary>
		/// Family membership info of the user that made the request.
		/// </summary>
		public FamilyInfoMembership Membership { get; set; }
	}
	
	public class FamilyInfoMembership
	{
		
		/// <summary>
		/// Restrictions on user buying and acquiring content.
		/// </summary>
		public string AcquirePermission { get; set; }
		
		/// <summary>
		/// The age group of the user.
		/// </summary>
		public string AgeGroup { get; set; }
		
		/// <summary>
		/// The maximum allowed maturity rating for the user.
		/// </summary>
		public string AllowedMaturityRating { get; set; }
		
		public System.Nullable<System.Boolean> IsInFamily { get; set; }
		
		/// <summary>
		/// The role of the user in the family.
		/// </summary>
		public string Role { get; set; }
	}
	
	public class Geolayerdata
	{
		
		public GeolayerdataCommon Common { get; set; }
		
		public GeolayerdataGeo Geo { get; set; }
		
		[System.ComponentModel.DefaultValue("books#geolayerdata")]
		public string Kind { get; set; } = "books#geolayerdata";
	}
	
	public class GeolayerdataCommon
	{
		
		/// <summary>
		/// The language of the information url and description.
		/// </summary>
		public string Lang { get; set; }
		
		/// <summary>
		/// The URL for the preview image information.
		/// </summary>
		public string PreviewImageUrl { get; set; }
		
		/// <summary>
		/// The description for this location.
		/// </summary>
		public string Snippet { get; set; }
		
		/// <summary>
		/// The URL for information for this location. Ex: wikipedia link.
		/// </summary>
		public string SnippetUrl { get; set; }
		
		/// <summary>
		/// The display title and localized canonical name to use when searching for this entity on Google search.
		/// </summary>
		public string Title { get; set; }
	}
	
	public class GeolayerdataGeo
	{
		
		/// <summary>
		/// The boundary of the location as a set of loops containing pairs of latitude, longitude coordinates.
		/// </summary>
		public string[] Boundary { get; set; }
		
		/// <summary>
		/// The cache policy active for this data. EX: UNRESTRICTED, RESTRICTED, NEVER
		/// </summary>
		public string CachePolicy { get; set; }
		
		/// <summary>
		/// The country code of the location.
		/// </summary>
		public string CountryCode { get; set; }
		
		/// <summary>
		/// The latitude of the location.
		/// </summary>
		public System.Nullable<System.Double> Latitude { get; set; }
		
		/// <summary>
		/// The longitude of the location.
		/// </summary>
		public System.Nullable<System.Double> Longitude { get; set; }
		
		/// <summary>
		/// The type of map that should be used for this location. EX: HYBRID, ROADMAP, SATELLITE, TERRAIN
		/// </summary>
		public string MapType { get; set; }
		
		/// <summary>
		/// The viewport for showing this location. This is a latitude, longitude rectangle.
		/// </summary>
		public GeolayerdataGeoViewport Viewport { get; set; }
		
		/// <summary>
		/// The Zoom level to use for the map. Zoom levels between 0 (the lowest zoom level, in which the entire world can be seen on one map) to 21+ (down to individual buildings). See: https://developers.google.com/maps/documentation/staticmaps/#Zoomlevels
		/// </summary>
		public System.Nullable<System.Int32> Zoom { get; set; }
	}
	
	public class GeolayerdataGeoViewport
	{
		
		public GeolayerdataGeoViewportHi Hi { get; set; }
		
		public GeolayerdataGeoViewportLo Lo { get; set; }
	}
	
	public class GeolayerdataGeoViewportHi
	{
		
		public System.Nullable<System.Double> Latitude { get; set; }
		
		public System.Nullable<System.Double> Longitude { get; set; }
	}
	
	public class GeolayerdataGeoViewportLo
	{
		
		public System.Nullable<System.Double> Latitude { get; set; }
		
		public System.Nullable<System.Double> Longitude { get; set; }
	}
	
	public class Layersummaries
	{
		
		/// <summary>
		/// A list of layer summary items.
		/// </summary>
		public Layersummary[] Items { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("books#layersummaries")]
		public string Kind { get; set; } = "books#layersummaries";
		
		/// <summary>
		/// The total number of layer summaries found.
		/// </summary>
		public System.Nullable<System.Int32> TotalItems { get; set; }
	}
	
	public class Layersummary
	{
		
		/// <summary>
		/// The number of annotations for this layer.
		/// </summary>
		public System.Nullable<System.Int32> AnnotationCount { get; set; }
		
		/// <summary>
		/// The list of annotation types contained for this layer.
		/// </summary>
		public string[] AnnotationTypes { get; set; }
		
		/// <summary>
		/// Link to get data for this annotation.
		/// </summary>
		public string AnnotationsDataLink { get; set; }
		
		/// <summary>
		/// The link to get the annotations for this layer.
		/// </summary>
		public string AnnotationsLink { get; set; }
		
		/// <summary>
		/// The content version this resource is for.
		/// </summary>
		public string ContentVersion { get; set; }
		
		/// <summary>
		/// The number of data items for this layer.
		/// </summary>
		public System.Nullable<System.Int32> DataCount { get; set; }
		
		/// <summary>
		/// Unique id of this layer summary.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Resource Type
		/// </summary>
		[System.ComponentModel.DefaultValue("books#layersummary")]
		public string Kind { get; set; } = "books#layersummary";
		
		/// <summary>
		/// The layer id for this summary.
		/// </summary>
		public string LayerId { get; set; }
		
		/// <summary>
		/// URL to this resource.
		/// </summary>
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Timestamp for the last time an item in this layer was updated. (RFC 3339 UTC date-time format).
		/// </summary>
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
		
		/// <summary>
		/// The current version of this layer's volume annotations. Note that this version applies only to the data in the books.layers.volumeAnnotations.* responses. The actual annotation data is versioned separately.
		/// </summary>
		public string VolumeAnnotationsVersion { get; set; }
		
		/// <summary>
		/// The volume id this resource is for.
		/// </summary>
		public string VolumeId { get; set; }
	}
	
	public class Metadata
	{
		
		/// <summary>
		/// A list of offline dictionary metadata.
		/// </summary>
		public MetadataItems[] MetadataItems { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("dictionary#metadata")]
		public string Kind { get; set; } = "dictionary#metadata";
	}
	
	public class MetadataItems
	{
		
		public string Download_url { get; set; }
		
		public string Encrypted_key { get; set; }
		
		public string Language { get; set; }
		
		public string Size { get; set; }
		
		public string Version { get; set; }
	}
	
	public class Notification
	{
		
		public string Body { get; set; }
		
		/// <summary>
		/// The list of crm experiment ids.
		/// </summary>
		public string[] CrmExperimentIds { get; set; }
		
		public string Doc_id { get; set; }
		
		public string Doc_type { get; set; }
		
		public System.Nullable<System.Boolean> Dont_show_notification { get; set; }
		
		public string IconUrl { get; set; }
		
		public System.Nullable<System.Boolean> Is_document_mature { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("books#notification")]
		public string Kind { get; set; } = "books#notification";
		
		public string NotificationGroup { get; set; }
		
		public string Notification_type { get; set; }
		
		public string Pcampaign_id { get; set; }
		
		public string Reason { get; set; }
		
		public System.Nullable<System.Boolean> Show_notification_settings_action { get; set; }
		
		public string TargetUrl { get; set; }
		
		public string TimeToExpireMs { get; set; }
		
		public string Title { get; set; }
	}
	
	public class Offers
	{
		
		/// <summary>
		/// A list of offers.
		/// </summary>
		public OffersItems[] OffersItems { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("promooffer#offers")]
		public string Kind { get; set; } = "promooffer#offers";
	}
	
	public class OffersItems
	{
		
		public string ArtUrl { get; set; }
		
		public string GservicesKey { get; set; }
		
		public string Id { get; set; }
		
		public OffersItemsItems[] OffersItemsItems { get; set; }
	}
	
	public class OffersItemsItems
	{
		
		public string Author { get; set; }
		
		public string CanonicalVolumeLink { get; set; }
		
		public string CoverUrl { get; set; }
		
		public string Description { get; set; }
		
		public string Title { get; set; }
		
		public string VolumeId { get; set; }
	}
	
	public class RequestAccess
	{
		
		public ConcurrentAccessRestriction ConcurrentAccess { get; set; }
		
		public DownloadAccessRestriction DownloadAccess { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("books#requestAccess")]
		public string Kind { get; set; } = "books#requestAccess";
	}
	
	public class Series
	{
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("books#series")]
		public string Kind { get; set; } = "books#series";
		
		public SeriesSeries1[] SeriesSeries1 { get; set; }
	}
	
	public class SeriesSeries1
	{
		
		public string BannerImageUrl { get; set; }
		
		public System.Nullable<System.Boolean> EligibleForSubscription { get; set; }
		
		public string ImageUrl { get; set; }
		
		public System.Nullable<System.Boolean> IsComplete { get; set; }
		
		public string SeriesFormatType { get; set; }
		
		public string SeriesId { get; set; }
		
		public SeriesSeries1SeriesSubscriptionReleaseInfo SeriesSubscriptionReleaseInfo { get; set; }
		
		public string SeriesType { get; set; }
		
		public string SubscriptionId { get; set; }
		
		public string Title { get; set; }
	}
	
	public class SeriesSeries1SeriesSubscriptionReleaseInfo
	{
		
		/// <summary>
		/// Cancellation date of the series subscription (or when it ends).
		/// </summary>
		public string CancellationTimestampUs { get; set; }
		
		public BooksSubscriptionReleaseInfo CurrentReleaseInfo { get; set; }
		
		public BooksSubscriptionReleaseInfo NextReleaseInfo { get; set; }
		
		/// <summary>
		/// series subscription type.
		/// </summary>
		public string SeriesSubscriptionType { get; set; }
	}
	
	public class Seriesmembership
	{
		
		/// <summary>
		/// Resorce type.
		/// </summary>
		[System.ComponentModel.DefaultValue("books#series#membership")]
		public string Kind { get; set; } = "books#series#membership";
		
		public Volume[] Member { get; set; }
		
		public string NextPageToken { get; set; }
	}
	
	public class Usersettings
	{
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("books#usersettings")]
		public string Kind { get; set; } = "books#usersettings";
		
		/// <summary>
		/// User settings in sub-objects, each for different purposes.
		/// </summary>
		public UsersettingsNotesExport NotesExport { get; set; }
		
		public UsersettingsNotification Notification { get; set; }
	}
	
	public class UsersettingsNotesExport
	{
		
		public string FolderName { get; set; }
		
		public System.Nullable<System.Boolean> IsEnabled { get; set; }
	}
	
	public class UsersettingsNotification
	{
		
		public UsersettingsNotificationMatchMyInterests MatchMyInterests { get; set; }
		
		public UsersettingsNotificationMoreFromAuthors MoreFromAuthors { get; set; }
		
		public UsersettingsNotificationMoreFromSeries MoreFromSeries { get; set; }
		
		public UsersettingsNotificationPriceDrop PriceDrop { get; set; }
		
		public UsersettingsNotificationRewardExpirations RewardExpirations { get; set; }
	}
	
	public class UsersettingsNotificationMatchMyInterests
	{
		
		public string Opted_state { get; set; }
	}
	
	public class UsersettingsNotificationMoreFromAuthors
	{
		
		public string Opted_state { get; set; }
	}
	
	public class UsersettingsNotificationMoreFromSeries
	{
		
		public string Opted_state { get; set; }
	}
	
	public class UsersettingsNotificationPriceDrop
	{
		
		public string Opted_state { get; set; }
	}
	
	public class UsersettingsNotificationRewardExpirations
	{
		
		public string Opted_state { get; set; }
	}
	
	public class Volume2
	{
		
		/// <summary>
		/// A list of volumes.
		/// </summary>
		public Volume[] Items { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("onboarding#volume")]
		public string Kind { get; set; } = "onboarding#volume";
		
		public string NextPageToken { get; set; }
	}
	
	public class Volumeannotation
	{
		
		/// <summary>
		/// The annotation data id for this volume annotation.
		/// </summary>
		public string AnnotationDataId { get; set; }
		
		/// <summary>
		/// Link to get data for this annotation.
		/// </summary>
		public string AnnotationDataLink { get; set; }
		
		/// <summary>
		/// The type of annotation this is.
		/// </summary>
		public string AnnotationType { get; set; }
		
		/// <summary>
		/// The content ranges to identify the selected text.
		/// </summary>
		public VolumeannotationContentRanges ContentRanges { get; set; }
		
		/// <summary>
		/// Data for this annotation.
		/// </summary>
		public string Data { get; set; }
		
		/// <summary>
		/// Indicates that this annotation is deleted.
		/// </summary>
		public System.Nullable<System.Boolean> Deleted { get; set; }
		
		/// <summary>
		/// Unique id of this volume annotation.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Resource Type
		/// </summary>
		[System.ComponentModel.DefaultValue("books#volumeannotation")]
		public string Kind { get; set; } = "books#volumeannotation";
		
		/// <summary>
		/// The Layer this annotation is for.
		/// </summary>
		public string LayerId { get; set; }
		
		/// <summary>
		/// Pages the annotation spans.
		/// </summary>
		public string[] PageIds { get; set; }
		
		/// <summary>
		/// Excerpt from the volume.
		/// </summary>
		public string SelectedText { get; set; }
		
		/// <summary>
		/// URL to this resource.
		/// </summary>
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Timestamp for the last time this anntoation was updated. (RFC 3339 UTC date-time format).
		/// </summary>
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
		
		/// <summary>
		/// The Volume this annotation is for.
		/// </summary>
		public string VolumeId { get; set; }
	}
	
	public class VolumeannotationContentRanges
	{
		
		public BooksAnnotationsRange CfiRange { get; set; }
		
		/// <summary>
		/// Content version applicable to ranges below.
		/// </summary>
		public string ContentVersion { get; set; }
		
		public BooksAnnotationsRange GbImageRange { get; set; }
		
		public BooksAnnotationsRange GbTextRange { get; set; }
	}
	
	public class Volumeannotations
	{
		
		/// <summary>
		/// A list of volume annotations.
		/// </summary>
		public Volumeannotation[] Items { get; set; }
		
		/// <summary>
		/// Resource type
		/// </summary>
		[System.ComponentModel.DefaultValue("books#volumeannotations")]
		public string Kind { get; set; } = "books#volumeannotations";
		
		/// <summary>
		/// Token to pass in for pagination for the next page. This will not be present if this request does not have more results.
		/// </summary>
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The total number of volume annotations found.
		/// </summary>
		public System.Nullable<System.Int32> TotalItems { get; set; }
		
		/// <summary>
		/// The version string for all of the volume annotations in this layer (not just the ones in this response). Note: the version string doesn't apply to the annotation data, just the information in this response (e.g. the location of annotations in the book).
		/// </summary>
		public string Version { get; set; }
	}
	
	public class Volumes
	{
		
		/// <summary>
		/// A list of volumes.
		/// </summary>
		public Volume[] Items { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("books#volumes")]
		public string Kind { get; set; } = "books#volumes";
		
		/// <summary>
		/// Total number of volumes found. This might be greater than the number of volumes returned in this response if results have been paginated.
		/// </summary>
		public System.Nullable<System.Int32> TotalItems { get; set; }
	}
	
	public partial class MyClient
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public MyClient(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Books_cloudloading_addBook cloudloading/addBook
		/// </summary>
		/// <param name="drive_document_id">A drive document id. The upload_client_token must not be set.</param>
		/// <param name="mime_type">The document MIME type. It can be set only if the drive_document_id is set.</param>
		/// <param name="name">The document name. It can be set only if the drive_document_id is set.</param>
		/// <returns>Successful response</returns>
		public async Task Books_cloudloading_addBookAsync(string drive_document_id, string mime_type, string name, string upload_client_token)
		{
			var requestUri = "cloudloading/addBook?drive_document_id=" + (drive_document_id==null? "" : System.Uri.EscapeDataString(drive_document_id))+"&mime_type=" + (mime_type==null? "" : System.Uri.EscapeDataString(mime_type))+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&upload_client_token=" + (upload_client_token==null? "" : System.Uri.EscapeDataString(upload_client_token));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Books_cloudloading_addBook cloudloading/addBook
		/// </summary>
		/// <param name="drive_document_id">A drive document id. The upload_client_token must not be set.</param>
		/// <param name="mime_type">The document MIME type. It can be set only if the drive_document_id is set.</param>
		/// <param name="name">The document name. It can be set only if the drive_document_id is set.</param>
		/// <returns>Successful response</returns>
		public void Books_cloudloading_addBook(string drive_document_id, string mime_type, string name, string upload_client_token)
		{
			var requestUri = "cloudloading/addBook?drive_document_id=" + (drive_document_id==null? "" : System.Uri.EscapeDataString(drive_document_id))+"&mime_type=" + (mime_type==null? "" : System.Uri.EscapeDataString(mime_type))+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&upload_client_token=" + (upload_client_token==null? "" : System.Uri.EscapeDataString(upload_client_token));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove the book and its contents
		/// Books_cloudloading_deleteBook cloudloading/deleteBook
		/// </summary>
		/// <param name="volumeId">The id of the book to be removed.</param>
		/// <returns>Successful response</returns>
		public async Task Books_cloudloading_deleteBookAsync(string volumeId)
		{
			var requestUri = "cloudloading/deleteBook?volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove the book and its contents
		/// Books_cloudloading_deleteBook cloudloading/deleteBook
		/// </summary>
		/// <param name="volumeId">The id of the book to be removed.</param>
		/// <returns>Successful response</returns>
		public void Books_cloudloading_deleteBook(string volumeId)
		{
			var requestUri = "cloudloading/deleteBook?volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Books_cloudloading_updateBook cloudloading/updateBook
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task Books_cloudloading_updateBookAsync(BooksCloudloadingResource requestBody)
		{
			var requestUri = "cloudloading/updateBook";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Books_cloudloading_updateBook cloudloading/updateBook
		/// </summary>
		/// <returns>Successful response</returns>
		public void Books_cloudloading_updateBook(BooksCloudloadingResource requestBody)
		{
			var requestUri = "cloudloading/updateBook";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of offline dictionary metadata available
		/// Books_dictionary_listOfflineMetadata dictionary/listOfflineMetadata
		/// </summary>
		/// <param name="cpksver">The device/version ID from which to request the data.</param>
		/// <returns>Successful response</returns>
		public async Task Books_dictionary_listOfflineMetadataAsync(string cpksver)
		{
			var requestUri = "dictionary/listOfflineMetadata?cpksver=" + (cpksver==null? "" : System.Uri.EscapeDataString(cpksver));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of offline dictionary metadata available
		/// Books_dictionary_listOfflineMetadata dictionary/listOfflineMetadata
		/// </summary>
		/// <param name="cpksver">The device/version ID from which to request the data.</param>
		/// <returns>Successful response</returns>
		public void Books_dictionary_listOfflineMetadata(string cpksver)
		{
			var requestUri = "dictionary/listOfflineMetadata?cpksver=" + (cpksver==null? "" : System.Uri.EscapeDataString(cpksver));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information regarding the family that the user is part of.
		/// Books_familysharing_getFamilyInfo familysharing/getFamilyInfo
		/// </summary>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_familysharing_getFamilyInfoAsync(string source)
		{
			var requestUri = "familysharing/getFamilyInfo?source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information regarding the family that the user is part of.
		/// Books_familysharing_getFamilyInfo familysharing/getFamilyInfo
		/// </summary>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_familysharing_getFamilyInfo(string source)
		{
			var requestUri = "familysharing/getFamilyInfo?source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Initiates sharing of the content with the user's family. Empty response indicates success.
		/// Books_familysharing_share familysharing/share
		/// </summary>
		/// <param name="docId">The docid to share.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="volumeId">The volume to share.</param>
		/// <returns>Successful response</returns>
		public async Task Books_familysharing_shareAsync(string docId, string source, string volumeId)
		{
			var requestUri = "familysharing/share?docId=" + (docId==null? "" : System.Uri.EscapeDataString(docId))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Initiates sharing of the content with the user's family. Empty response indicates success.
		/// Books_familysharing_share familysharing/share
		/// </summary>
		/// <param name="docId">The docid to share.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="volumeId">The volume to share.</param>
		/// <returns>Successful response</returns>
		public void Books_familysharing_share(string docId, string source, string volumeId)
		{
			var requestUri = "familysharing/share?docId=" + (docId==null? "" : System.Uri.EscapeDataString(docId))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Initiates revoking content that has already been shared with the user's family. Empty response indicates success.
		/// Books_familysharing_unshare familysharing/unshare
		/// </summary>
		/// <param name="docId">The docid to unshare.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="volumeId">The volume to unshare.</param>
		/// <returns>Successful response</returns>
		public async Task Books_familysharing_unshareAsync(string docId, string source, string volumeId)
		{
			var requestUri = "familysharing/unshare?docId=" + (docId==null? "" : System.Uri.EscapeDataString(docId))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Initiates revoking content that has already been shared with the user's family. Empty response indicates success.
		/// Books_familysharing_unshare familysharing/unshare
		/// </summary>
		/// <param name="docId">The docid to unshare.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="volumeId">The volume to unshare.</param>
		/// <returns>Successful response</returns>
		public void Books_familysharing_unshare(string docId, string source, string volumeId)
		{
			var requestUri = "familysharing/unshare?docId=" + (docId==null? "" : System.Uri.EscapeDataString(docId))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the current settings for the user.
		/// Books_myconfig_getUserSettings myconfig/getUserSettings
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task Books_myconfig_getUserSettingsAsync()
		{
			var requestUri = "myconfig/getUserSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the current settings for the user.
		/// Books_myconfig_getUserSettings myconfig/getUserSettings
		/// </summary>
		/// <returns>Successful response</returns>
		public void Books_myconfig_getUserSettings()
		{
			var requestUri = "myconfig/getUserSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Release downloaded content access restriction.
		/// Books_myconfig_releaseDownloadAccess myconfig/releaseDownloadAccess
		/// </summary>
		/// <param name="volumeIds">The volume(s) to release restrictions for.</param>
		/// <param name="cpksver">The device/version ID from which to release the restriction.</param>
		/// <param name="locale">ISO-639-1, ISO-3166-1 codes for message localization, i.e. en_US.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_myconfig_releaseDownloadAccessAsync(string[] volumeIds, string cpksver, string locale, string source)
		{
			var requestUri = "myconfig/releaseDownloadAccess?"+string.Join("&", volumeIds.Select(z => $"volumeIds={System.Uri.EscapeDataString(z.ToString())}"))+"&cpksver=" + (cpksver==null? "" : System.Uri.EscapeDataString(cpksver))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Release downloaded content access restriction.
		/// Books_myconfig_releaseDownloadAccess myconfig/releaseDownloadAccess
		/// </summary>
		/// <param name="volumeIds">The volume(s) to release restrictions for.</param>
		/// <param name="cpksver">The device/version ID from which to release the restriction.</param>
		/// <param name="locale">ISO-639-1, ISO-3166-1 codes for message localization, i.e. en_US.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_myconfig_releaseDownloadAccess(string[] volumeIds, string cpksver, string locale, string source)
		{
			var requestUri = "myconfig/releaseDownloadAccess?"+string.Join("&", volumeIds.Select(z => $"volumeIds={System.Uri.EscapeDataString(z.ToString())}"))+"&cpksver=" + (cpksver==null? "" : System.Uri.EscapeDataString(cpksver))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Request concurrent and download access restrictions.
		/// Books_myconfig_requestAccess myconfig/requestAccess
		/// </summary>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="volumeId">The volume to request concurrent/download restrictions for.</param>
		/// <param name="nonce">The client nonce value.</param>
		/// <param name="cpksver">The device/version ID from which to request the restrictions.</param>
		/// <param name="licenseTypes">The type of access license to request. If not specified, the default is BOTH.</param>
		/// <param name="locale">ISO-639-1, ISO-3166-1 codes for message localization, i.e. en_US.</param>
		/// <returns>Successful response</returns>
		public async Task Books_myconfig_requestAccessAsync(string source, string volumeId, string nonce, string cpksver, Books_myconfig_requestAccessLicenseTypes licenseTypes, string locale)
		{
			var requestUri = "myconfig/requestAccess?source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&nonce=" + (nonce==null? "" : System.Uri.EscapeDataString(nonce))+"&cpksver=" + (cpksver==null? "" : System.Uri.EscapeDataString(cpksver))+"&licenseTypes=" + licenseTypes+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Request concurrent and download access restrictions.
		/// Books_myconfig_requestAccess myconfig/requestAccess
		/// </summary>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="volumeId">The volume to request concurrent/download restrictions for.</param>
		/// <param name="nonce">The client nonce value.</param>
		/// <param name="cpksver">The device/version ID from which to request the restrictions.</param>
		/// <param name="licenseTypes">The type of access license to request. If not specified, the default is BOTH.</param>
		/// <param name="locale">ISO-639-1, ISO-3166-1 codes for message localization, i.e. en_US.</param>
		/// <returns>Successful response</returns>
		public void Books_myconfig_requestAccess(string source, string volumeId, string nonce, string cpksver, Books_myconfig_requestAccessLicenseTypes licenseTypes, string locale)
		{
			var requestUri = "myconfig/requestAccess?source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&nonce=" + (nonce==null? "" : System.Uri.EscapeDataString(nonce))+"&cpksver=" + (cpksver==null? "" : System.Uri.EscapeDataString(cpksver))+"&licenseTypes=" + licenseTypes+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Request downloaded content access for specified volumes on the My eBooks shelf.
		/// Books_myconfig_syncVolumeLicenses myconfig/syncVolumeLicenses
		/// </summary>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="nonce">The client nonce value.</param>
		/// <param name="cpksver">The device/version ID from which to release the restriction.</param>
		/// <param name="features">List of features supported by the client, i.e., 'RENTALS'</param>
		/// <param name="includeNonComicsSeries">Set to true to include non-comics series. Defaults to false.</param>
		/// <param name="locale">ISO-639-1, ISO-3166-1 codes for message localization, i.e. en_US.</param>
		/// <param name="showPreorders">Set to true to show pre-ordered books. Defaults to false.</param>
		/// <param name="volumeIds">The volume(s) to request download restrictions for.</param>
		/// <returns>Successful response</returns>
		public async Task Books_myconfig_syncVolumeLicensesAsync(string source, string nonce, string cpksver, string[] features, bool includeNonComicsSeries, string locale, bool showPreorders, string[] volumeIds)
		{
			var requestUri = "myconfig/syncVolumeLicenses?source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&nonce=" + (nonce==null? "" : System.Uri.EscapeDataString(nonce))+"&cpksver=" + (cpksver==null? "" : System.Uri.EscapeDataString(cpksver))+"&"+string.Join("&", features.Select(z => $"features={System.Uri.EscapeDataString(z.ToString())}"))+"&includeNonComicsSeries="+includeNonComicsSeries+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&showPreorders="+showPreorders+"&"+string.Join("&", volumeIds.Select(z => $"volumeIds={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Request downloaded content access for specified volumes on the My eBooks shelf.
		/// Books_myconfig_syncVolumeLicenses myconfig/syncVolumeLicenses
		/// </summary>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="nonce">The client nonce value.</param>
		/// <param name="cpksver">The device/version ID from which to release the restriction.</param>
		/// <param name="features">List of features supported by the client, i.e., 'RENTALS'</param>
		/// <param name="includeNonComicsSeries">Set to true to include non-comics series. Defaults to false.</param>
		/// <param name="locale">ISO-639-1, ISO-3166-1 codes for message localization, i.e. en_US.</param>
		/// <param name="showPreorders">Set to true to show pre-ordered books. Defaults to false.</param>
		/// <param name="volumeIds">The volume(s) to request download restrictions for.</param>
		/// <returns>Successful response</returns>
		public void Books_myconfig_syncVolumeLicenses(string source, string nonce, string cpksver, string[] features, bool includeNonComicsSeries, string locale, bool showPreorders, string[] volumeIds)
		{
			var requestUri = "myconfig/syncVolumeLicenses?source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&nonce=" + (nonce==null? "" : System.Uri.EscapeDataString(nonce))+"&cpksver=" + (cpksver==null? "" : System.Uri.EscapeDataString(cpksver))+"&"+string.Join("&", features.Select(z => $"features={System.Uri.EscapeDataString(z.ToString())}"))+"&includeNonComicsSeries="+includeNonComicsSeries+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&showPreorders="+showPreorders+"&"+string.Join("&", volumeIds.Select(z => $"volumeIds={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the settings for the user. If a sub-object is specified, it will overwrite the existing sub-object stored in the server. Unspecified sub-objects will retain the existing value.
		/// Books_myconfig_updateUserSettings myconfig/updateUserSettings
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task Books_myconfig_updateUserSettingsAsync(Usersettings requestBody)
		{
			var requestUri = "myconfig/updateUserSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the settings for the user. If a sub-object is specified, it will overwrite the existing sub-object stored in the server. Unspecified sub-objects will retain the existing value.
		/// Books_myconfig_updateUserSettings myconfig/updateUserSettings
		/// </summary>
		/// <returns>Successful response</returns>
		public void Books_myconfig_updateUserSettings(Usersettings requestBody)
		{
			var requestUri = "myconfig/updateUserSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of annotations, possibly filtered.
		/// Books_mylibrary_annotations_list mylibrary/annotations
		/// </summary>
		/// <param name="contentVersion">The content version for the requested volume.</param>
		/// <param name="layerId">The layer ID to limit annotation by.</param>
		/// <param name="layerIds">The layer ID(s) to limit annotation by.</param>
		/// <param name="maxResults">Maximum number of results to return
		/// Minimum: 0
		/// Maximum: 40
		// </param>
		/// <param name="pageToken">The value of the nextToken from the previous page.</param>
		/// <param name="showDeleted">Set to true to return deleted annotations. updatedMin must be in the request to use this. Defaults to false.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="updatedMax">RFC 3339 timestamp to restrict to items updated prior to this timestamp (exclusive).</param>
		/// <param name="updatedMin">RFC 3339 timestamp to restrict to items updated since this timestamp (inclusive).</param>
		/// <param name="volumeId">The volume to restrict annotations to.</param>
		/// <returns>Successful response</returns>
		public async Task Books_mylibrary_annotations_listAsync(string contentVersion, string layerId, string[] layerIds, int maxResults, string pageToken, bool showDeleted, string source, string updatedMax, string updatedMin, string volumeId)
		{
			var requestUri = "mylibrary/annotations?contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&layerId=" + (layerId==null? "" : System.Uri.EscapeDataString(layerId))+"&"+string.Join("&", layerIds.Select(z => $"layerIds={System.Uri.EscapeDataString(z.ToString())}"))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&showDeleted="+showDeleted+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&updatedMax=" + (updatedMax==null? "" : System.Uri.EscapeDataString(updatedMax))+"&updatedMin=" + (updatedMin==null? "" : System.Uri.EscapeDataString(updatedMin))+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of annotations, possibly filtered.
		/// Books_mylibrary_annotations_list mylibrary/annotations
		/// </summary>
		/// <param name="contentVersion">The content version for the requested volume.</param>
		/// <param name="layerId">The layer ID to limit annotation by.</param>
		/// <param name="layerIds">The layer ID(s) to limit annotation by.</param>
		/// <param name="maxResults">Maximum number of results to return
		/// Minimum: 0
		/// Maximum: 40
		// </param>
		/// <param name="pageToken">The value of the nextToken from the previous page.</param>
		/// <param name="showDeleted">Set to true to return deleted annotations. updatedMin must be in the request to use this. Defaults to false.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="updatedMax">RFC 3339 timestamp to restrict to items updated prior to this timestamp (exclusive).</param>
		/// <param name="updatedMin">RFC 3339 timestamp to restrict to items updated since this timestamp (inclusive).</param>
		/// <param name="volumeId">The volume to restrict annotations to.</param>
		/// <returns>Successful response</returns>
		public void Books_mylibrary_annotations_list(string contentVersion, string layerId, string[] layerIds, int maxResults, string pageToken, bool showDeleted, string source, string updatedMax, string updatedMin, string volumeId)
		{
			var requestUri = "mylibrary/annotations?contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&layerId=" + (layerId==null? "" : System.Uri.EscapeDataString(layerId))+"&"+string.Join("&", layerIds.Select(z => $"layerIds={System.Uri.EscapeDataString(z.ToString())}"))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&showDeleted="+showDeleted+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&updatedMax=" + (updatedMax==null? "" : System.Uri.EscapeDataString(updatedMax))+"&updatedMin=" + (updatedMin==null? "" : System.Uri.EscapeDataString(updatedMin))+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Inserts a new annotation.
		/// Books_mylibrary_annotations_insert mylibrary/annotations
		/// </summary>
		/// <param name="annotationId">The ID for the annotation to insert.</param>
		/// <param name="country">ISO-3166-1 code to override the IP-based location.</param>
		/// <param name="showOnlySummaryInResponse">Requests that only the summary of the specified layer be provided in the response.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_mylibrary_annotations_insertAsync(string annotationId, string country, bool showOnlySummaryInResponse, string source, Annotation requestBody)
		{
			var requestUri = "mylibrary/annotations?annotationId=" + (annotationId==null? "" : System.Uri.EscapeDataString(annotationId))+"&country=" + (country==null? "" : System.Uri.EscapeDataString(country))+"&showOnlySummaryInResponse="+showOnlySummaryInResponse+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Inserts a new annotation.
		/// Books_mylibrary_annotations_insert mylibrary/annotations
		/// </summary>
		/// <param name="annotationId">The ID for the annotation to insert.</param>
		/// <param name="country">ISO-3166-1 code to override the IP-based location.</param>
		/// <param name="showOnlySummaryInResponse">Requests that only the summary of the specified layer be provided in the response.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_mylibrary_annotations_insert(string annotationId, string country, bool showOnlySummaryInResponse, string source, Annotation requestBody)
		{
			var requestUri = "mylibrary/annotations?annotationId=" + (annotationId==null? "" : System.Uri.EscapeDataString(annotationId))+"&country=" + (country==null? "" : System.Uri.EscapeDataString(country))+"&showOnlySummaryInResponse="+showOnlySummaryInResponse+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the summary of specified layers.
		/// Books_mylibrary_annotations_summary mylibrary/annotations/summary
		/// </summary>
		/// <param name="layerIds">Array of layer IDs to get the summary for.</param>
		/// <param name="volumeId">Volume id to get the summary for.</param>
		/// <returns>Successful response</returns>
		public async Task Books_mylibrary_annotations_summaryAsync(string[] layerIds, string volumeId)
		{
			var requestUri = "mylibrary/annotations/summary?"+string.Join("&", layerIds.Select(z => $"layerIds={System.Uri.EscapeDataString(z.ToString())}"))+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the summary of specified layers.
		/// Books_mylibrary_annotations_summary mylibrary/annotations/summary
		/// </summary>
		/// <param name="layerIds">Array of layer IDs to get the summary for.</param>
		/// <param name="volumeId">Volume id to get the summary for.</param>
		/// <returns>Successful response</returns>
		public void Books_mylibrary_annotations_summary(string[] layerIds, string volumeId)
		{
			var requestUri = "mylibrary/annotations/summary?"+string.Join("&", layerIds.Select(z => $"layerIds={System.Uri.EscapeDataString(z.ToString())}"))+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes an annotation.
		/// Books_mylibrary_annotations_delete mylibrary/annotations/{annotationId}
		/// </summary>
		/// <param name="annotationId">The ID for the annotation to delete.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_mylibrary_annotations_deleteAsync(string annotationId, string source)
		{
			var requestUri = "mylibrary/annotations/"+ (annotationId==null? "" : System.Uri.EscapeDataString(annotationId))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes an annotation.
		/// Books_mylibrary_annotations_delete mylibrary/annotations/{annotationId}
		/// </summary>
		/// <param name="annotationId">The ID for the annotation to delete.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_mylibrary_annotations_delete(string annotationId, string source)
		{
			var requestUri = "mylibrary/annotations/"+ (annotationId==null? "" : System.Uri.EscapeDataString(annotationId))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an existing annotation.
		/// Books_mylibrary_annotations_update mylibrary/annotations/{annotationId}
		/// </summary>
		/// <param name="annotationId">The ID for the annotation to update.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_mylibrary_annotations_updateAsync(string annotationId, string source, Annotation requestBody)
		{
			var requestUri = "mylibrary/annotations/"+ (annotationId==null? "" : System.Uri.EscapeDataString(annotationId))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates an existing annotation.
		/// Books_mylibrary_annotations_update mylibrary/annotations/{annotationId}
		/// </summary>
		/// <param name="annotationId">The ID for the annotation to update.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_mylibrary_annotations_update(string annotationId, string source, Annotation requestBody)
		{
			var requestUri = "mylibrary/annotations/"+ (annotationId==null? "" : System.Uri.EscapeDataString(annotationId))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of bookshelves belonging to the authenticated user.
		/// Books_mylibrary_bookshelves_list mylibrary/bookshelves
		/// </summary>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_mylibrary_bookshelves_listAsync(string source)
		{
			var requestUri = "mylibrary/bookshelves?source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of bookshelves belonging to the authenticated user.
		/// Books_mylibrary_bookshelves_list mylibrary/bookshelves
		/// </summary>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_mylibrary_bookshelves_list(string source)
		{
			var requestUri = "mylibrary/bookshelves?source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves metadata for a specific bookshelf belonging to the authenticated user.
		/// Books_mylibrary_bookshelves_get mylibrary/bookshelves/{shelf}
		/// </summary>
		/// <param name="shelf">ID of bookshelf to retrieve.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_mylibrary_bookshelves_getAsync(string shelf, string source)
		{
			var requestUri = "mylibrary/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves metadata for a specific bookshelf belonging to the authenticated user.
		/// Books_mylibrary_bookshelves_get mylibrary/bookshelves/{shelf}
		/// </summary>
		/// <param name="shelf">ID of bookshelf to retrieve.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_mylibrary_bookshelves_get(string shelf, string source)
		{
			var requestUri = "mylibrary/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a volume to a bookshelf.
		/// Books_mylibrary_bookshelves_addVolume mylibrary/bookshelves/{shelf}/addVolume
		/// </summary>
		/// <param name="shelf">ID of bookshelf to which to add a volume.</param>
		/// <param name="volumeId">ID of volume to add.</param>
		/// <param name="reason">The reason for which the book is added to the library.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_mylibrary_bookshelves_addVolumeAsync(string shelf, string volumeId, Books_mylibrary_bookshelves_addVolumeReason reason, string source)
		{
			var requestUri = "mylibrary/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"/addVolume&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&reason=" + reason+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a volume to a bookshelf.
		/// Books_mylibrary_bookshelves_addVolume mylibrary/bookshelves/{shelf}/addVolume
		/// </summary>
		/// <param name="shelf">ID of bookshelf to which to add a volume.</param>
		/// <param name="volumeId">ID of volume to add.</param>
		/// <param name="reason">The reason for which the book is added to the library.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_mylibrary_bookshelves_addVolume(string shelf, string volumeId, Books_mylibrary_bookshelves_addVolumeReason reason, string source)
		{
			var requestUri = "mylibrary/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"/addVolume&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&reason=" + reason+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Clears all volumes from a bookshelf.
		/// Books_mylibrary_bookshelves_clearVolumes mylibrary/bookshelves/{shelf}/clearVolumes
		/// </summary>
		/// <param name="shelf">ID of bookshelf from which to remove a volume.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_mylibrary_bookshelves_clearVolumesAsync(string shelf, string source)
		{
			var requestUri = "mylibrary/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"/clearVolumes&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Clears all volumes from a bookshelf.
		/// Books_mylibrary_bookshelves_clearVolumes mylibrary/bookshelves/{shelf}/clearVolumes
		/// </summary>
		/// <param name="shelf">ID of bookshelf from which to remove a volume.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_mylibrary_bookshelves_clearVolumes(string shelf, string source)
		{
			var requestUri = "mylibrary/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"/clearVolumes&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Moves a volume within a bookshelf.
		/// Books_mylibrary_bookshelves_moveVolume mylibrary/bookshelves/{shelf}/moveVolume
		/// </summary>
		/// <param name="shelf">ID of bookshelf with the volume.</param>
		/// <param name="volumeId">ID of volume to move.</param>
		/// <param name="volumePosition">Position on shelf to move the item (0 puts the item before the current first item, 1 puts it between the first and the second and so on.)</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_mylibrary_bookshelves_moveVolumeAsync(string shelf, string volumeId, int volumePosition, string source)
		{
			var requestUri = "mylibrary/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"/moveVolume&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&volumePosition="+volumePosition+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Moves a volume within a bookshelf.
		/// Books_mylibrary_bookshelves_moveVolume mylibrary/bookshelves/{shelf}/moveVolume
		/// </summary>
		/// <param name="shelf">ID of bookshelf with the volume.</param>
		/// <param name="volumeId">ID of volume to move.</param>
		/// <param name="volumePosition">Position on shelf to move the item (0 puts the item before the current first item, 1 puts it between the first and the second and so on.)</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_mylibrary_bookshelves_moveVolume(string shelf, string volumeId, int volumePosition, string source)
		{
			var requestUri = "mylibrary/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"/moveVolume&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&volumePosition="+volumePosition+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes a volume from a bookshelf.
		/// Books_mylibrary_bookshelves_removeVolume mylibrary/bookshelves/{shelf}/removeVolume
		/// </summary>
		/// <param name="shelf">ID of bookshelf from which to remove a volume.</param>
		/// <param name="volumeId">ID of volume to remove.</param>
		/// <param name="reason">The reason for which the book is removed from the library.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_mylibrary_bookshelves_removeVolumeAsync(string shelf, string volumeId, Books_mylibrary_bookshelves_removeVolumeReason reason, string source)
		{
			var requestUri = "mylibrary/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"/removeVolume&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&reason=" + reason+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes a volume from a bookshelf.
		/// Books_mylibrary_bookshelves_removeVolume mylibrary/bookshelves/{shelf}/removeVolume
		/// </summary>
		/// <param name="shelf">ID of bookshelf from which to remove a volume.</param>
		/// <param name="volumeId">ID of volume to remove.</param>
		/// <param name="reason">The reason for which the book is removed from the library.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_mylibrary_bookshelves_removeVolume(string shelf, string volumeId, Books_mylibrary_bookshelves_removeVolumeReason reason, string source)
		{
			var requestUri = "mylibrary/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"/removeVolume&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&reason=" + reason+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets volume information for volumes on a bookshelf.
		/// Books_mylibrary_bookshelves_volumes_list mylibrary/bookshelves/{shelf}/volumes
		/// </summary>
		/// <param name="shelf">The bookshelf ID or name retrieve volumes for.</param>
		/// <param name="country">ISO-3166-1 code to override the IP-based location.</param>
		/// <param name="maxResults">Maximum number of results to return
		/// Minimum: 0
		// </param>
		/// <param name="projection">Restrict information returned to a set of selected fields.</param>
		/// <param name="q">Full-text search query string in this bookshelf.</param>
		/// <param name="showPreorders">Set to true to show pre-ordered books. Defaults to false.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="startIndex">Index of the first element to return (starts at 0)
		/// Minimum: 0
		// </param>
		/// <returns>Successful response</returns>
		public async Task Books_mylibrary_bookshelves_volumes_listAsync(string shelf, string country, int maxResults, Books_mylibrary_bookshelves_volumes_listProjection projection, string q, bool showPreorders, string source, int startIndex)
		{
			var requestUri = "mylibrary/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"/volumes&country=" + (country==null? "" : System.Uri.EscapeDataString(country))+"&maxResults="+maxResults+"&projection=" + projection+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&showPreorders="+showPreorders+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&startIndex="+startIndex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets volume information for volumes on a bookshelf.
		/// Books_mylibrary_bookshelves_volumes_list mylibrary/bookshelves/{shelf}/volumes
		/// </summary>
		/// <param name="shelf">The bookshelf ID or name retrieve volumes for.</param>
		/// <param name="country">ISO-3166-1 code to override the IP-based location.</param>
		/// <param name="maxResults">Maximum number of results to return
		/// Minimum: 0
		// </param>
		/// <param name="projection">Restrict information returned to a set of selected fields.</param>
		/// <param name="q">Full-text search query string in this bookshelf.</param>
		/// <param name="showPreorders">Set to true to show pre-ordered books. Defaults to false.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="startIndex">Index of the first element to return (starts at 0)
		/// Minimum: 0
		// </param>
		/// <returns>Successful response</returns>
		public void Books_mylibrary_bookshelves_volumes_list(string shelf, string country, int maxResults, Books_mylibrary_bookshelves_volumes_listProjection projection, string q, bool showPreorders, string source, int startIndex)
		{
			var requestUri = "mylibrary/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"/volumes&country=" + (country==null? "" : System.Uri.EscapeDataString(country))+"&maxResults="+maxResults+"&projection=" + projection+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&showPreorders="+showPreorders+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&startIndex="+startIndex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves my reading position information for a volume.
		/// Books_mylibrary_readingpositions_get mylibrary/readingpositions/{volumeId}
		/// </summary>
		/// <param name="volumeId">ID of volume for which to retrieve a reading position.</param>
		/// <param name="contentVersion">Volume content version for which this reading position is requested.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_mylibrary_readingpositions_getAsync(string volumeId, string contentVersion, string source)
		{
			var requestUri = "mylibrary/readingpositions/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves my reading position information for a volume.
		/// Books_mylibrary_readingpositions_get mylibrary/readingpositions/{volumeId}
		/// </summary>
		/// <param name="volumeId">ID of volume for which to retrieve a reading position.</param>
		/// <param name="contentVersion">Volume content version for which this reading position is requested.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_mylibrary_readingpositions_get(string volumeId, string contentVersion, string source)
		{
			var requestUri = "mylibrary/readingpositions/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets my reading position information for a volume.
		/// Books_mylibrary_readingpositions_setPosition mylibrary/readingpositions/{volumeId}/setPosition
		/// </summary>
		/// <param name="volumeId">ID of volume for which to update the reading position.</param>
		/// <param name="timestamp">RFC 3339 UTC format timestamp associated with this reading position.</param>
		/// <param name="position">Position string for the new volume reading position.</param>
		/// <param name="action">Action that caused this reading position to be set.</param>
		/// <param name="contentVersion">Volume content version for which this reading position applies.</param>
		/// <param name="deviceCookie">Random persistent device cookie optional on set position.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_mylibrary_readingpositions_setPositionAsync(string volumeId, string timestamp, string position, Books_mylibrary_readingpositions_setPositionAction action, string contentVersion, string deviceCookie, string source)
		{
			var requestUri = "mylibrary/readingpositions/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/setPosition&timestamp=" + (timestamp==null? "" : System.Uri.EscapeDataString(timestamp))+"&position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&action=" + action+"&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&deviceCookie=" + (deviceCookie==null? "" : System.Uri.EscapeDataString(deviceCookie))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets my reading position information for a volume.
		/// Books_mylibrary_readingpositions_setPosition mylibrary/readingpositions/{volumeId}/setPosition
		/// </summary>
		/// <param name="volumeId">ID of volume for which to update the reading position.</param>
		/// <param name="timestamp">RFC 3339 UTC format timestamp associated with this reading position.</param>
		/// <param name="position">Position string for the new volume reading position.</param>
		/// <param name="action">Action that caused this reading position to be set.</param>
		/// <param name="contentVersion">Volume content version for which this reading position applies.</param>
		/// <param name="deviceCookie">Random persistent device cookie optional on set position.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_mylibrary_readingpositions_setPosition(string volumeId, string timestamp, string position, Books_mylibrary_readingpositions_setPositionAction action, string contentVersion, string deviceCookie, string source)
		{
			var requestUri = "mylibrary/readingpositions/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/setPosition&timestamp=" + (timestamp==null? "" : System.Uri.EscapeDataString(timestamp))+"&position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&action=" + action+"&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&deviceCookie=" + (deviceCookie==null? "" : System.Uri.EscapeDataString(deviceCookie))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns notification details for a given notification id.
		/// Books_notification_get notification/get
		/// </summary>
		/// <param name="notification_id">String to identify the notification.</param>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'. Used for generating notification title and body.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_notification_getAsync(string notification_id, string locale, string source)
		{
			var requestUri = "notification/get?notification_id=" + (notification_id==null? "" : System.Uri.EscapeDataString(notification_id))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns notification details for a given notification id.
		/// Books_notification_get notification/get
		/// </summary>
		/// <param name="notification_id">String to identify the notification.</param>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'. Used for generating notification title and body.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_notification_get(string notification_id, string locale, string source)
		{
			var requestUri = "notification/get?notification_id=" + (notification_id==null? "" : System.Uri.EscapeDataString(notification_id))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List categories for onboarding experience.
		/// Books_onboarding_listCategories onboarding/listCategories
		/// </summary>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Default is en-US if unset.</param>
		/// <returns>Successful response</returns>
		public async Task Books_onboarding_listCategoriesAsync(string locale)
		{
			var requestUri = "onboarding/listCategories?locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List categories for onboarding experience.
		/// Books_onboarding_listCategories onboarding/listCategories
		/// </summary>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Default is en-US if unset.</param>
		/// <returns>Successful response</returns>
		public void Books_onboarding_listCategories(string locale)
		{
			var requestUri = "onboarding/listCategories?locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List available volumes under categories for onboarding experience.
		/// Books_onboarding_listCategoryVolumes onboarding/listCategoryVolumes
		/// </summary>
		/// <param name="categoryId">List of category ids requested.</param>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Default is en-US if unset.</param>
		/// <param name="maxAllowedMaturityRating">The maximum allowed maturity rating of returned volumes. Books with a higher maturity rating are filtered out.</param>
		/// <param name="pageSize">Number of maximum results per page to be included in the response.</param>
		/// <param name="pageToken">The value of the nextToken from the previous page.</param>
		/// <returns>Successful response</returns>
		public async Task Books_onboarding_listCategoryVolumesAsync(string[] categoryId, string locale, Books_onboarding_listCategoryVolumesMaxAllowedMaturityRating maxAllowedMaturityRating, int pageSize, string pageToken)
		{
			var requestUri = "onboarding/listCategoryVolumes?"+string.Join("&", categoryId.Select(z => $"categoryId={System.Uri.EscapeDataString(z.ToString())}"))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxAllowedMaturityRating=" + maxAllowedMaturityRating+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List available volumes under categories for onboarding experience.
		/// Books_onboarding_listCategoryVolumes onboarding/listCategoryVolumes
		/// </summary>
		/// <param name="categoryId">List of category ids requested.</param>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Default is en-US if unset.</param>
		/// <param name="maxAllowedMaturityRating">The maximum allowed maturity rating of returned volumes. Books with a higher maturity rating are filtered out.</param>
		/// <param name="pageSize">Number of maximum results per page to be included in the response.</param>
		/// <param name="pageToken">The value of the nextToken from the previous page.</param>
		/// <returns>Successful response</returns>
		public void Books_onboarding_listCategoryVolumes(string[] categoryId, string locale, Books_onboarding_listCategoryVolumesMaxAllowedMaturityRating maxAllowedMaturityRating, int pageSize, string pageToken)
		{
			var requestUri = "onboarding/listCategoryVolumes?"+string.Join("&", categoryId.Select(z => $"categoryId={System.Uri.EscapeDataString(z.ToString())}"))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxAllowedMaturityRating=" + maxAllowedMaturityRating+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a stream of personalized book clusters
		/// Books_personalizedstream_get personalizedstream/get
		/// </summary>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'. Used for generating recommendations.</param>
		/// <param name="maxAllowedMaturityRating">The maximum allowed maturity rating of returned recommendations. Books with a higher maturity rating are filtered out.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_personalizedstream_getAsync(string locale, Books_personalizedstream_getMaxAllowedMaturityRating maxAllowedMaturityRating, string source)
		{
			var requestUri = "personalizedstream/get?locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxAllowedMaturityRating=" + maxAllowedMaturityRating+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a stream of personalized book clusters
		/// Books_personalizedstream_get personalizedstream/get
		/// </summary>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'. Used for generating recommendations.</param>
		/// <param name="maxAllowedMaturityRating">The maximum allowed maturity rating of returned recommendations. Books with a higher maturity rating are filtered out.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_personalizedstream_get(string locale, Books_personalizedstream_getMaxAllowedMaturityRating maxAllowedMaturityRating, string source)
		{
			var requestUri = "personalizedstream/get?locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxAllowedMaturityRating=" + maxAllowedMaturityRating+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Books_promooffer_accept promooffer/accept
		/// </summary>
		/// <param name="androidId">device android_id</param>
		/// <param name="device">device device</param>
		/// <param name="manufacturer">device manufacturer</param>
		/// <param name="model">device model</param>
		/// <param name="product">device product</param>
		/// <param name="serial">device serial</param>
		/// <param name="volumeId">Volume id to exercise the offer</param>
		/// <returns>Successful response</returns>
		public async Task Books_promooffer_acceptAsync(string androidId, string device, string manufacturer, string model, string offerId, string product, string serial, string volumeId)
		{
			var requestUri = "promooffer/accept?androidId=" + (androidId==null? "" : System.Uri.EscapeDataString(androidId))+"&device=" + (device==null? "" : System.Uri.EscapeDataString(device))+"&manufacturer=" + (manufacturer==null? "" : System.Uri.EscapeDataString(manufacturer))+"&model=" + (model==null? "" : System.Uri.EscapeDataString(model))+"&offerId=" + (offerId==null? "" : System.Uri.EscapeDataString(offerId))+"&product=" + (product==null? "" : System.Uri.EscapeDataString(product))+"&serial=" + (serial==null? "" : System.Uri.EscapeDataString(serial))+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Books_promooffer_accept promooffer/accept
		/// </summary>
		/// <param name="androidId">device android_id</param>
		/// <param name="device">device device</param>
		/// <param name="manufacturer">device manufacturer</param>
		/// <param name="model">device model</param>
		/// <param name="product">device product</param>
		/// <param name="serial">device serial</param>
		/// <param name="volumeId">Volume id to exercise the offer</param>
		/// <returns>Successful response</returns>
		public void Books_promooffer_accept(string androidId, string device, string manufacturer, string model, string offerId, string product, string serial, string volumeId)
		{
			var requestUri = "promooffer/accept?androidId=" + (androidId==null? "" : System.Uri.EscapeDataString(androidId))+"&device=" + (device==null? "" : System.Uri.EscapeDataString(device))+"&manufacturer=" + (manufacturer==null? "" : System.Uri.EscapeDataString(manufacturer))+"&model=" + (model==null? "" : System.Uri.EscapeDataString(model))+"&offerId=" + (offerId==null? "" : System.Uri.EscapeDataString(offerId))+"&product=" + (product==null? "" : System.Uri.EscapeDataString(product))+"&serial=" + (serial==null? "" : System.Uri.EscapeDataString(serial))+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Books_promooffer_dismiss promooffer/dismiss
		/// </summary>
		/// <param name="androidId">device android_id</param>
		/// <param name="device">device device</param>
		/// <param name="manufacturer">device manufacturer</param>
		/// <param name="model">device model</param>
		/// <param name="offerId">Offer to dimiss</param>
		/// <param name="product">device product</param>
		/// <param name="serial">device serial</param>
		/// <returns>Successful response</returns>
		public async Task Books_promooffer_dismissAsync(string androidId, string device, string manufacturer, string model, string offerId, string product, string serial)
		{
			var requestUri = "promooffer/dismiss?androidId=" + (androidId==null? "" : System.Uri.EscapeDataString(androidId))+"&device=" + (device==null? "" : System.Uri.EscapeDataString(device))+"&manufacturer=" + (manufacturer==null? "" : System.Uri.EscapeDataString(manufacturer))+"&model=" + (model==null? "" : System.Uri.EscapeDataString(model))+"&offerId=" + (offerId==null? "" : System.Uri.EscapeDataString(offerId))+"&product=" + (product==null? "" : System.Uri.EscapeDataString(product))+"&serial=" + (serial==null? "" : System.Uri.EscapeDataString(serial));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Books_promooffer_dismiss promooffer/dismiss
		/// </summary>
		/// <param name="androidId">device android_id</param>
		/// <param name="device">device device</param>
		/// <param name="manufacturer">device manufacturer</param>
		/// <param name="model">device model</param>
		/// <param name="offerId">Offer to dimiss</param>
		/// <param name="product">device product</param>
		/// <param name="serial">device serial</param>
		/// <returns>Successful response</returns>
		public void Books_promooffer_dismiss(string androidId, string device, string manufacturer, string model, string offerId, string product, string serial)
		{
			var requestUri = "promooffer/dismiss?androidId=" + (androidId==null? "" : System.Uri.EscapeDataString(androidId))+"&device=" + (device==null? "" : System.Uri.EscapeDataString(device))+"&manufacturer=" + (manufacturer==null? "" : System.Uri.EscapeDataString(manufacturer))+"&model=" + (model==null? "" : System.Uri.EscapeDataString(model))+"&offerId=" + (offerId==null? "" : System.Uri.EscapeDataString(offerId))+"&product=" + (product==null? "" : System.Uri.EscapeDataString(product))+"&serial=" + (serial==null? "" : System.Uri.EscapeDataString(serial));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of promo offers available to the user
		/// Books_promooffer_get promooffer/get
		/// </summary>
		/// <param name="androidId">device android_id</param>
		/// <param name="device">device device</param>
		/// <param name="manufacturer">device manufacturer</param>
		/// <param name="model">device model</param>
		/// <param name="product">device product</param>
		/// <param name="serial">device serial</param>
		/// <returns>Successful response</returns>
		public async Task Books_promooffer_getAsync(string androidId, string device, string manufacturer, string model, string product, string serial)
		{
			var requestUri = "promooffer/get?androidId=" + (androidId==null? "" : System.Uri.EscapeDataString(androidId))+"&device=" + (device==null? "" : System.Uri.EscapeDataString(device))+"&manufacturer=" + (manufacturer==null? "" : System.Uri.EscapeDataString(manufacturer))+"&model=" + (model==null? "" : System.Uri.EscapeDataString(model))+"&product=" + (product==null? "" : System.Uri.EscapeDataString(product))+"&serial=" + (serial==null? "" : System.Uri.EscapeDataString(serial));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of promo offers available to the user
		/// Books_promooffer_get promooffer/get
		/// </summary>
		/// <param name="androidId">device android_id</param>
		/// <param name="device">device device</param>
		/// <param name="manufacturer">device manufacturer</param>
		/// <param name="model">device model</param>
		/// <param name="product">device product</param>
		/// <param name="serial">device serial</param>
		/// <returns>Successful response</returns>
		public void Books_promooffer_get(string androidId, string device, string manufacturer, string model, string product, string serial)
		{
			var requestUri = "promooffer/get?androidId=" + (androidId==null? "" : System.Uri.EscapeDataString(androidId))+"&device=" + (device==null? "" : System.Uri.EscapeDataString(device))+"&manufacturer=" + (manufacturer==null? "" : System.Uri.EscapeDataString(manufacturer))+"&model=" + (model==null? "" : System.Uri.EscapeDataString(model))+"&product=" + (product==null? "" : System.Uri.EscapeDataString(product))+"&serial=" + (serial==null? "" : System.Uri.EscapeDataString(serial));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns Series metadata for the given series ids.
		/// Books_series_get series/get
		/// </summary>
		/// <param name="series_id">String that identifies the series</param>
		/// <returns>Successful response</returns>
		public async Task Books_series_getAsync(string[] series_id)
		{
			var requestUri = "series/get?"+string.Join("&", series_id.Select(z => $"series_id={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns Series metadata for the given series ids.
		/// Books_series_get series/get
		/// </summary>
		/// <param name="series_id">String that identifies the series</param>
		/// <returns>Successful response</returns>
		public void Books_series_get(string[] series_id)
		{
			var requestUri = "series/get?"+string.Join("&", series_id.Select(z => $"series_id={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns Series membership data given the series id.
		/// Books_series_membership_get series/membership/get
		/// </summary>
		/// <param name="series_id">String that identifies the series</param>
		/// <param name="page_size">Number of maximum results per page to be included in the response.</param>
		/// <param name="page_token">The value of the nextToken from the previous page.</param>
		/// <returns>Successful response</returns>
		public async Task Books_series_membership_getAsync(string series_id, int page_size, string page_token)
		{
			var requestUri = "series/membership/get?series_id=" + (series_id==null? "" : System.Uri.EscapeDataString(series_id))+"&page_size="+page_size+"&page_token=" + (page_token==null? "" : System.Uri.EscapeDataString(page_token));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns Series membership data given the series id.
		/// Books_series_membership_get series/membership/get
		/// </summary>
		/// <param name="series_id">String that identifies the series</param>
		/// <param name="page_size">Number of maximum results per page to be included in the response.</param>
		/// <param name="page_token">The value of the nextToken from the previous page.</param>
		/// <returns>Successful response</returns>
		public void Books_series_membership_get(string series_id, int page_size, string page_token)
		{
			var requestUri = "series/membership/get?series_id=" + (series_id==null? "" : System.Uri.EscapeDataString(series_id))+"&page_size="+page_size+"&page_token=" + (page_token==null? "" : System.Uri.EscapeDataString(page_token));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of public bookshelves for the specified user.
		/// Books_bookshelves_list users/{userId}/bookshelves
		/// </summary>
		/// <param name="userId">ID of user for whom to retrieve bookshelves.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_bookshelves_listAsync(string userId, string source)
		{
			var requestUri = "users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/bookshelves&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of public bookshelves for the specified user.
		/// Books_bookshelves_list users/{userId}/bookshelves
		/// </summary>
		/// <param name="userId">ID of user for whom to retrieve bookshelves.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_bookshelves_list(string userId, string source)
		{
			var requestUri = "users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/bookshelves&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves metadata for a specific bookshelf for the specified user.
		/// Books_bookshelves_get users/{userId}/bookshelves/{shelf}
		/// </summary>
		/// <param name="userId">ID of user for whom to retrieve bookshelves.</param>
		/// <param name="shelf">ID of bookshelf to retrieve.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_bookshelves_getAsync(string userId, string shelf, string source)
		{
			var requestUri = "users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves metadata for a specific bookshelf for the specified user.
		/// Books_bookshelves_get users/{userId}/bookshelves/{shelf}
		/// </summary>
		/// <param name="userId">ID of user for whom to retrieve bookshelves.</param>
		/// <param name="shelf">ID of bookshelf to retrieve.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_bookshelves_get(string userId, string shelf, string source)
		{
			var requestUri = "users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves volumes in a specific bookshelf for the specified user.
		/// Books_bookshelves_volumes_list users/{userId}/bookshelves/{shelf}/volumes
		/// </summary>
		/// <param name="userId">ID of user for whom to retrieve bookshelf volumes.</param>
		/// <param name="shelf">ID of bookshelf to retrieve volumes.</param>
		/// <param name="maxResults">Maximum number of results to return
		/// Minimum: 0
		// </param>
		/// <param name="showPreorders">Set to true to show pre-ordered books. Defaults to false.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="startIndex">Index of the first element to return (starts at 0)
		/// Minimum: 0
		// </param>
		/// <returns>Successful response</returns>
		public async Task Books_bookshelves_volumes_listAsync(string userId, string shelf, int maxResults, bool showPreorders, string source, int startIndex)
		{
			var requestUri = "users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"/volumes&maxResults="+maxResults+"&showPreorders="+showPreorders+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&startIndex="+startIndex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves volumes in a specific bookshelf for the specified user.
		/// Books_bookshelves_volumes_list users/{userId}/bookshelves/{shelf}/volumes
		/// </summary>
		/// <param name="userId">ID of user for whom to retrieve bookshelf volumes.</param>
		/// <param name="shelf">ID of bookshelf to retrieve volumes.</param>
		/// <param name="maxResults">Maximum number of results to return
		/// Minimum: 0
		// </param>
		/// <param name="showPreorders">Set to true to show pre-ordered books. Defaults to false.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="startIndex">Index of the first element to return (starts at 0)
		/// Minimum: 0
		// </param>
		/// <returns>Successful response</returns>
		public void Books_bookshelves_volumes_list(string userId, string shelf, int maxResults, bool showPreorders, string source, int startIndex)
		{
			var requestUri = "users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"/volumes&maxResults="+maxResults+"&showPreorders="+showPreorders+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&startIndex="+startIndex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Performs a book search.
		/// Books_volumes_list volumes
		/// </summary>
		/// <param name="q">Full-text search query string.</param>
		/// <param name="download">Restrict to volumes by download availability.</param>
		/// <param name="filter">Filter search results.</param>
		/// <param name="langRestrict">Restrict results to books with this language code.</param>
		/// <param name="libraryRestrict">Restrict search to this user's library.</param>
		/// <param name="maxAllowedMaturityRating">The maximum allowed maturity rating of returned recommendations. Books with a higher maturity rating are filtered out.</param>
		/// <param name="maxResults">Maximum number of results to return.
		/// Minimum: 0
		/// Maximum: 40
		// </param>
		/// <param name="orderBy">Sort search results.</param>
		/// <param name="partner">Restrict and brand results for partner ID.</param>
		/// <param name="printType">Restrict to books or magazines.</param>
		/// <param name="projection">Restrict information returned to a set of selected fields.</param>
		/// <param name="showPreorders">Set to true to show books available for preorder. Defaults to false.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="startIndex">Index of the first result to return (starts at 0)
		/// Minimum: 0
		// </param>
		/// <returns>Successful response</returns>
		public async Task Books_volumes_listAsync(string q, Books_volumes_listDownload download, Books_volumes_listFilter filter, string langRestrict, Books_volumes_listLibraryRestrict libraryRestrict, Books_volumes_listMaxAllowedMaturityRating maxAllowedMaturityRating, int maxResults, Books_volumes_listOrderBy orderBy, string partner, Books_volumes_listPrintType printType, Books_mylibrary_bookshelves_volumes_listProjection projection, bool showPreorders, string source, int startIndex)
		{
			var requestUri = "volumes?q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&download=" + download+"&filter=" + filter+"&langRestrict=" + (langRestrict==null? "" : System.Uri.EscapeDataString(langRestrict))+"&libraryRestrict=" + libraryRestrict+"&maxAllowedMaturityRating=" + maxAllowedMaturityRating+"&maxResults="+maxResults+"&orderBy=" + orderBy+"&partner=" + (partner==null? "" : System.Uri.EscapeDataString(partner))+"&printType=" + printType+"&projection=" + projection+"&showPreorders="+showPreorders+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&startIndex="+startIndex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Performs a book search.
		/// Books_volumes_list volumes
		/// </summary>
		/// <param name="q">Full-text search query string.</param>
		/// <param name="download">Restrict to volumes by download availability.</param>
		/// <param name="filter">Filter search results.</param>
		/// <param name="langRestrict">Restrict results to books with this language code.</param>
		/// <param name="libraryRestrict">Restrict search to this user's library.</param>
		/// <param name="maxAllowedMaturityRating">The maximum allowed maturity rating of returned recommendations. Books with a higher maturity rating are filtered out.</param>
		/// <param name="maxResults">Maximum number of results to return.
		/// Minimum: 0
		/// Maximum: 40
		// </param>
		/// <param name="orderBy">Sort search results.</param>
		/// <param name="partner">Restrict and brand results for partner ID.</param>
		/// <param name="printType">Restrict to books or magazines.</param>
		/// <param name="projection">Restrict information returned to a set of selected fields.</param>
		/// <param name="showPreorders">Set to true to show books available for preorder. Defaults to false.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="startIndex">Index of the first result to return (starts at 0)
		/// Minimum: 0
		// </param>
		/// <returns>Successful response</returns>
		public void Books_volumes_list(string q, Books_volumes_listDownload download, Books_volumes_listFilter filter, string langRestrict, Books_volumes_listLibraryRestrict libraryRestrict, Books_volumes_listMaxAllowedMaturityRating maxAllowedMaturityRating, int maxResults, Books_volumes_listOrderBy orderBy, string partner, Books_volumes_listPrintType printType, Books_mylibrary_bookshelves_volumes_listProjection projection, bool showPreorders, string source, int startIndex)
		{
			var requestUri = "volumes?q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&download=" + download+"&filter=" + filter+"&langRestrict=" + (langRestrict==null? "" : System.Uri.EscapeDataString(langRestrict))+"&libraryRestrict=" + libraryRestrict+"&maxAllowedMaturityRating=" + maxAllowedMaturityRating+"&maxResults="+maxResults+"&orderBy=" + orderBy+"&partner=" + (partner==null? "" : System.Uri.EscapeDataString(partner))+"&printType=" + printType+"&projection=" + projection+"&showPreorders="+showPreorders+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&startIndex="+startIndex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a list of books in My Library.
		/// Books_volumes_mybooks_list volumes/mybooks
		/// </summary>
		/// <param name="acquireMethod">How the book was acquired</param>
		/// <param name="country">ISO-3166-1 code to override the IP-based location.</param>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex:'en_US'. Used for generating recommendations.</param>
		/// <param name="maxResults">Maximum number of results to return.
		/// Minimum: 0
		/// Maximum: 100
		// </param>
		/// <param name="processingState">The processing state of the user uploaded volumes to be returned. Applicable only if the UPLOADED is specified in the acquireMethod.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="startIndex">Index of the first result to return (starts at 0)
		/// Minimum: 0
		// </param>
		/// <returns>Successful response</returns>
		public async Task Books_volumes_mybooks_listAsync(string[] acquireMethod, string country, string locale, int maxResults, string[] processingState, string source, int startIndex)
		{
			var requestUri = "volumes/mybooks?"+string.Join("&", acquireMethod.Select(z => $"acquireMethod={System.Uri.EscapeDataString(z.ToString())}"))+"&country=" + (country==null? "" : System.Uri.EscapeDataString(country))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxResults="+maxResults+"&"+string.Join("&", processingState.Select(z => $"processingState={System.Uri.EscapeDataString(z.ToString())}"))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&startIndex="+startIndex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a list of books in My Library.
		/// Books_volumes_mybooks_list volumes/mybooks
		/// </summary>
		/// <param name="acquireMethod">How the book was acquired</param>
		/// <param name="country">ISO-3166-1 code to override the IP-based location.</param>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex:'en_US'. Used for generating recommendations.</param>
		/// <param name="maxResults">Maximum number of results to return.
		/// Minimum: 0
		/// Maximum: 100
		// </param>
		/// <param name="processingState">The processing state of the user uploaded volumes to be returned. Applicable only if the UPLOADED is specified in the acquireMethod.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="startIndex">Index of the first result to return (starts at 0)
		/// Minimum: 0
		// </param>
		/// <returns>Successful response</returns>
		public void Books_volumes_mybooks_list(string[] acquireMethod, string country, string locale, int maxResults, string[] processingState, string source, int startIndex)
		{
			var requestUri = "volumes/mybooks?"+string.Join("&", acquireMethod.Select(z => $"acquireMethod={System.Uri.EscapeDataString(z.ToString())}"))+"&country=" + (country==null? "" : System.Uri.EscapeDataString(country))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxResults="+maxResults+"&"+string.Join("&", processingState.Select(z => $"processingState={System.Uri.EscapeDataString(z.ToString())}"))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&startIndex="+startIndex;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a list of recommended books for the current user.
		/// Books_volumes_recommended_list volumes/recommended
		/// </summary>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'. Used for generating recommendations.</param>
		/// <param name="maxAllowedMaturityRating">The maximum allowed maturity rating of returned recommendations. Books with a higher maturity rating are filtered out.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_volumes_recommended_listAsync(string locale, Books_volumes_recommended_listMaxAllowedMaturityRating maxAllowedMaturityRating, string source)
		{
			var requestUri = "volumes/recommended?locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxAllowedMaturityRating=" + maxAllowedMaturityRating+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a list of recommended books for the current user.
		/// Books_volumes_recommended_list volumes/recommended
		/// </summary>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'. Used for generating recommendations.</param>
		/// <param name="maxAllowedMaturityRating">The maximum allowed maturity rating of returned recommendations. Books with a higher maturity rating are filtered out.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_volumes_recommended_list(string locale, Books_volumes_recommended_listMaxAllowedMaturityRating maxAllowedMaturityRating, string source)
		{
			var requestUri = "volumes/recommended?locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxAllowedMaturityRating=" + maxAllowedMaturityRating+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Rate a recommended book for the current user.
		/// Books_volumes_recommended_rate volumes/recommended/rate
		/// </summary>
		/// <param name="rating">Rating to be given to the volume.</param>
		/// <param name="volumeId">ID of the source volume.</param>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'. Used for generating recommendations.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_volumes_recommended_rateAsync(Books_volumes_recommended_rateRating rating, string volumeId, string locale, string source)
		{
			var requestUri = "volumes/recommended/rate?rating=" + rating+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Rate a recommended book for the current user.
		/// Books_volumes_recommended_rate volumes/recommended/rate
		/// </summary>
		/// <param name="rating">Rating to be given to the volume.</param>
		/// <param name="volumeId">ID of the source volume.</param>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'. Used for generating recommendations.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_volumes_recommended_rate(Books_volumes_recommended_rateRating rating, string volumeId, string locale, string source)
		{
			var requestUri = "volumes/recommended/rate?rating=" + rating+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a list of books uploaded by the current user.
		/// Books_volumes_useruploaded_list volumes/useruploaded
		/// </summary>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'. Used for generating recommendations.</param>
		/// <param name="maxResults">Maximum number of results to return.
		/// Minimum: 0
		/// Maximum: 40
		// </param>
		/// <param name="processingState">The processing state of the user uploaded volumes to be returned.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="startIndex">Index of the first result to return (starts at 0)
		/// Minimum: 0
		// </param>
		/// <param name="volumeId">The ids of the volumes to be returned. If not specified all that match the processingState are returned.</param>
		/// <returns>Successful response</returns>
		public async Task Books_volumes_useruploaded_listAsync(string locale, int maxResults, string[] processingState, string source, int startIndex, string[] volumeId)
		{
			var requestUri = "volumes/useruploaded?locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxResults="+maxResults+"&"+string.Join("&", processingState.Select(z => $"processingState={System.Uri.EscapeDataString(z.ToString())}"))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&startIndex="+startIndex+"&"+string.Join("&", volumeId.Select(z => $"volumeId={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a list of books uploaded by the current user.
		/// Books_volumes_useruploaded_list volumes/useruploaded
		/// </summary>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'. Used for generating recommendations.</param>
		/// <param name="maxResults">Maximum number of results to return.
		/// Minimum: 0
		/// Maximum: 40
		// </param>
		/// <param name="processingState">The processing state of the user uploaded volumes to be returned.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="startIndex">Index of the first result to return (starts at 0)
		/// Minimum: 0
		// </param>
		/// <param name="volumeId">The ids of the volumes to be returned. If not specified all that match the processingState are returned.</param>
		/// <returns>Successful response</returns>
		public void Books_volumes_useruploaded_list(string locale, int maxResults, string[] processingState, string source, int startIndex, string[] volumeId)
		{
			var requestUri = "volumes/useruploaded?locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxResults="+maxResults+"&"+string.Join("&", processingState.Select(z => $"processingState={System.Uri.EscapeDataString(z.ToString())}"))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&startIndex="+startIndex+"&"+string.Join("&", volumeId.Select(z => $"volumeId={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets volume information for a single volume.
		/// Books_volumes_get volumes/{volumeId}
		/// </summary>
		/// <param name="volumeId">ID of volume to retrieve.</param>
		/// <param name="country">ISO-3166-1 code to override the IP-based location.</param>
		/// <param name="includeNonComicsSeries">Set to true to include non-comics series. Defaults to false.</param>
		/// <param name="partner">Brand results for partner ID.</param>
		/// <param name="projection">Restrict information returned to a set of selected fields.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_volumes_getAsync(string volumeId, string country, bool includeNonComicsSeries, string partner, Books_mylibrary_bookshelves_volumes_listProjection projection, string source, bool user_library_consistent_read)
		{
			var requestUri = "volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&country=" + (country==null? "" : System.Uri.EscapeDataString(country))+"&includeNonComicsSeries="+includeNonComicsSeries+"&partner=" + (partner==null? "" : System.Uri.EscapeDataString(partner))+"&projection=" + projection+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&user_library_consistent_read="+user_library_consistent_read;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets volume information for a single volume.
		/// Books_volumes_get volumes/{volumeId}
		/// </summary>
		/// <param name="volumeId">ID of volume to retrieve.</param>
		/// <param name="country">ISO-3166-1 code to override the IP-based location.</param>
		/// <param name="includeNonComicsSeries">Set to true to include non-comics series. Defaults to false.</param>
		/// <param name="partner">Brand results for partner ID.</param>
		/// <param name="projection">Restrict information returned to a set of selected fields.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_volumes_get(string volumeId, string country, bool includeNonComicsSeries, string partner, Books_mylibrary_bookshelves_volumes_listProjection projection, string source, bool user_library_consistent_read)
		{
			var requestUri = "volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&country=" + (country==null? "" : System.Uri.EscapeDataString(country))+"&includeNonComicsSeries="+includeNonComicsSeries+"&partner=" + (partner==null? "" : System.Uri.EscapeDataString(partner))+"&projection=" + projection+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&user_library_consistent_read="+user_library_consistent_read;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a list of associated books.
		/// Books_volumes_associated_list volumes/{volumeId}/associated
		/// </summary>
		/// <param name="volumeId">ID of the source volume.</param>
		/// <param name="association">Association type.</param>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'. Used for generating recommendations.</param>
		/// <param name="maxAllowedMaturityRating">The maximum allowed maturity rating of returned recommendations. Books with a higher maturity rating are filtered out.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_volumes_associated_listAsync(string volumeId, Books_volumes_associated_listAssociation association, string locale, Books_volumes_associated_listMaxAllowedMaturityRating maxAllowedMaturityRating, string source)
		{
			var requestUri = "volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/associated&association=" + association+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxAllowedMaturityRating=" + maxAllowedMaturityRating+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a list of associated books.
		/// Books_volumes_associated_list volumes/{volumeId}/associated
		/// </summary>
		/// <param name="volumeId">ID of the source volume.</param>
		/// <param name="association">Association type.</param>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'. Used for generating recommendations.</param>
		/// <param name="maxAllowedMaturityRating">The maximum allowed maturity rating of returned recommendations. Books with a higher maturity rating are filtered out.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_volumes_associated_list(string volumeId, Books_volumes_associated_listAssociation association, string locale, Books_volumes_associated_listMaxAllowedMaturityRating maxAllowedMaturityRating, string source)
		{
			var requestUri = "volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/associated&association=" + association+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxAllowedMaturityRating=" + maxAllowedMaturityRating+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the volume annotations for a volume and layer.
		/// Books_layers_volumeAnnotations_list volumes/{volumeId}/layers/{layerId}
		/// </summary>
		/// <param name="volumeId">The volume to retrieve annotations for.</param>
		/// <param name="layerId">The ID for the layer to get the annotations.</param>
		/// <param name="contentVersion">The content version for the requested volume.</param>
		/// <param name="endOffset">The end offset to end retrieving data from.</param>
		/// <param name="endPosition">The end position to end retrieving data from.</param>
		/// <param name="locale">The locale information for the data. ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'.</param>
		/// <param name="maxResults">Maximum number of results to return
		/// Minimum: 0
		/// Maximum: 200
		// </param>
		/// <param name="pageToken">The value of the nextToken from the previous page.</param>
		/// <param name="showDeleted">Set to true to return deleted annotations. updatedMin must be in the request to use this. Defaults to false.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="startOffset">The start offset to start retrieving data from.</param>
		/// <param name="startPosition">The start position to start retrieving data from.</param>
		/// <param name="updatedMax">RFC 3339 timestamp to restrict to items updated prior to this timestamp (exclusive).</param>
		/// <param name="updatedMin">RFC 3339 timestamp to restrict to items updated since this timestamp (inclusive).</param>
		/// <param name="volumeAnnotationsVersion">The version of the volume annotations that you are requesting.</param>
		/// <returns>Successful response</returns>
		public async Task Books_layers_volumeAnnotations_listAsync(string volumeId, string layerId, string contentVersion, string endOffset, string endPosition, string locale, int maxResults, string pageToken, bool showDeleted, string source, string startOffset, string startPosition, string updatedMax, string updatedMin, string volumeAnnotationsVersion)
		{
			var requestUri = "volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/layers/"+ (layerId==null? "" : System.Uri.EscapeDataString(layerId))+"&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&endOffset=" + (endOffset==null? "" : System.Uri.EscapeDataString(endOffset))+"&endPosition=" + (endPosition==null? "" : System.Uri.EscapeDataString(endPosition))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&showDeleted="+showDeleted+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&startOffset=" + (startOffset==null? "" : System.Uri.EscapeDataString(startOffset))+"&startPosition=" + (startPosition==null? "" : System.Uri.EscapeDataString(startPosition))+"&updatedMax=" + (updatedMax==null? "" : System.Uri.EscapeDataString(updatedMax))+"&updatedMin=" + (updatedMin==null? "" : System.Uri.EscapeDataString(updatedMin))+"&volumeAnnotationsVersion=" + (volumeAnnotationsVersion==null? "" : System.Uri.EscapeDataString(volumeAnnotationsVersion));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the volume annotations for a volume and layer.
		/// Books_layers_volumeAnnotations_list volumes/{volumeId}/layers/{layerId}
		/// </summary>
		/// <param name="volumeId">The volume to retrieve annotations for.</param>
		/// <param name="layerId">The ID for the layer to get the annotations.</param>
		/// <param name="contentVersion">The content version for the requested volume.</param>
		/// <param name="endOffset">The end offset to end retrieving data from.</param>
		/// <param name="endPosition">The end position to end retrieving data from.</param>
		/// <param name="locale">The locale information for the data. ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'.</param>
		/// <param name="maxResults">Maximum number of results to return
		/// Minimum: 0
		/// Maximum: 200
		// </param>
		/// <param name="pageToken">The value of the nextToken from the previous page.</param>
		/// <param name="showDeleted">Set to true to return deleted annotations. updatedMin must be in the request to use this. Defaults to false.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="startOffset">The start offset to start retrieving data from.</param>
		/// <param name="startPosition">The start position to start retrieving data from.</param>
		/// <param name="updatedMax">RFC 3339 timestamp to restrict to items updated prior to this timestamp (exclusive).</param>
		/// <param name="updatedMin">RFC 3339 timestamp to restrict to items updated since this timestamp (inclusive).</param>
		/// <param name="volumeAnnotationsVersion">The version of the volume annotations that you are requesting.</param>
		/// <returns>Successful response</returns>
		public void Books_layers_volumeAnnotations_list(string volumeId, string layerId, string contentVersion, string endOffset, string endPosition, string locale, int maxResults, string pageToken, bool showDeleted, string source, string startOffset, string startPosition, string updatedMax, string updatedMin, string volumeAnnotationsVersion)
		{
			var requestUri = "volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/layers/"+ (layerId==null? "" : System.Uri.EscapeDataString(layerId))+"&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&endOffset=" + (endOffset==null? "" : System.Uri.EscapeDataString(endOffset))+"&endPosition=" + (endPosition==null? "" : System.Uri.EscapeDataString(endPosition))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&showDeleted="+showDeleted+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&startOffset=" + (startOffset==null? "" : System.Uri.EscapeDataString(startOffset))+"&startPosition=" + (startPosition==null? "" : System.Uri.EscapeDataString(startPosition))+"&updatedMax=" + (updatedMax==null? "" : System.Uri.EscapeDataString(updatedMax))+"&updatedMin=" + (updatedMin==null? "" : System.Uri.EscapeDataString(updatedMin))+"&volumeAnnotationsVersion=" + (volumeAnnotationsVersion==null? "" : System.Uri.EscapeDataString(volumeAnnotationsVersion));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the volume annotation.
		/// Books_layers_volumeAnnotations_get volumes/{volumeId}/layers/{layerId}/annotations/{annotationId}
		/// </summary>
		/// <param name="volumeId">The volume to retrieve annotations for.</param>
		/// <param name="layerId">The ID for the layer to get the annotations.</param>
		/// <param name="annotationId">The ID of the volume annotation to retrieve.</param>
		/// <param name="locale">The locale information for the data. ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_layers_volumeAnnotations_getAsync(string volumeId, string layerId, string annotationId, string locale, string source)
		{
			var requestUri = "volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/layers/"+ (layerId==null? "" : System.Uri.EscapeDataString(layerId))+"/annotations/"+ (annotationId==null? "" : System.Uri.EscapeDataString(annotationId))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the volume annotation.
		/// Books_layers_volumeAnnotations_get volumes/{volumeId}/layers/{layerId}/annotations/{annotationId}
		/// </summary>
		/// <param name="volumeId">The volume to retrieve annotations for.</param>
		/// <param name="layerId">The ID for the layer to get the annotations.</param>
		/// <param name="annotationId">The ID of the volume annotation to retrieve.</param>
		/// <param name="locale">The locale information for the data. ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_layers_volumeAnnotations_get(string volumeId, string layerId, string annotationId, string locale, string source)
		{
			var requestUri = "volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/layers/"+ (layerId==null? "" : System.Uri.EscapeDataString(layerId))+"/annotations/"+ (annotationId==null? "" : System.Uri.EscapeDataString(annotationId))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the annotation data for a volume and layer.
		/// Books_layers_annotationData_list volumes/{volumeId}/layers/{layerId}/data
		/// </summary>
		/// <param name="volumeId">The volume to retrieve annotation data for.</param>
		/// <param name="layerId">The ID for the layer to get the annotation data.</param>
		/// <param name="contentVersion">The content version for the requested volume.</param>
		/// <param name="annotationDataId">The list of Annotation Data Ids to retrieve. Pagination is ignored if this is set.</param>
		/// <param name="h">The requested pixel height for any images. If height is provided width must also be provided.</param>
		/// <param name="locale">The locale information for the data. ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'.</param>
		/// <param name="maxResults">Maximum number of results to return
		/// Minimum: 0
		/// Maximum: 200
		// </param>
		/// <param name="pageToken">The value of the nextToken from the previous page.</param>
		/// <param name="scale">The requested scale for the image.
		/// Minimum: 0
		// </param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="updatedMax">RFC 3339 timestamp to restrict to items updated prior to this timestamp (exclusive).</param>
		/// <param name="updatedMin">RFC 3339 timestamp to restrict to items updated since this timestamp (inclusive).</param>
		/// <param name="w">The requested pixel width for any images. If width is provided height must also be provided.</param>
		/// <returns>Successful response</returns>
		public async Task Books_layers_annotationData_listAsync(string volumeId, string layerId, string contentVersion, string[] annotationDataId, int h, string locale, int maxResults, string pageToken, int scale, string source, string updatedMax, string updatedMin, int w)
		{
			var requestUri = "volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/layers/"+ (layerId==null? "" : System.Uri.EscapeDataString(layerId))+"/data&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&"+string.Join("&", annotationDataId.Select(z => $"annotationDataId={System.Uri.EscapeDataString(z.ToString())}"))+"&h="+h+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&scale="+scale+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&updatedMax=" + (updatedMax==null? "" : System.Uri.EscapeDataString(updatedMax))+"&updatedMin=" + (updatedMin==null? "" : System.Uri.EscapeDataString(updatedMin))+"&w="+w;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the annotation data for a volume and layer.
		/// Books_layers_annotationData_list volumes/{volumeId}/layers/{layerId}/data
		/// </summary>
		/// <param name="volumeId">The volume to retrieve annotation data for.</param>
		/// <param name="layerId">The ID for the layer to get the annotation data.</param>
		/// <param name="contentVersion">The content version for the requested volume.</param>
		/// <param name="annotationDataId">The list of Annotation Data Ids to retrieve. Pagination is ignored if this is set.</param>
		/// <param name="h">The requested pixel height for any images. If height is provided width must also be provided.</param>
		/// <param name="locale">The locale information for the data. ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'.</param>
		/// <param name="maxResults">Maximum number of results to return
		/// Minimum: 0
		/// Maximum: 200
		// </param>
		/// <param name="pageToken">The value of the nextToken from the previous page.</param>
		/// <param name="scale">The requested scale for the image.
		/// Minimum: 0
		// </param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="updatedMax">RFC 3339 timestamp to restrict to items updated prior to this timestamp (exclusive).</param>
		/// <param name="updatedMin">RFC 3339 timestamp to restrict to items updated since this timestamp (inclusive).</param>
		/// <param name="w">The requested pixel width for any images. If width is provided height must also be provided.</param>
		/// <returns>Successful response</returns>
		public void Books_layers_annotationData_list(string volumeId, string layerId, string contentVersion, string[] annotationDataId, int h, string locale, int maxResults, string pageToken, int scale, string source, string updatedMax, string updatedMin, int w)
		{
			var requestUri = "volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/layers/"+ (layerId==null? "" : System.Uri.EscapeDataString(layerId))+"/data&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&"+string.Join("&", annotationDataId.Select(z => $"annotationDataId={System.Uri.EscapeDataString(z.ToString())}"))+"&h="+h+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&scale="+scale+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&updatedMax=" + (updatedMax==null? "" : System.Uri.EscapeDataString(updatedMax))+"&updatedMin=" + (updatedMin==null? "" : System.Uri.EscapeDataString(updatedMin))+"&w="+w;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the annotation data.
		/// Books_layers_annotationData_get volumes/{volumeId}/layers/{layerId}/data/{annotationDataId}
		/// </summary>
		/// <param name="volumeId">The volume to retrieve annotations for.</param>
		/// <param name="layerId">The ID for the layer to get the annotations.</param>
		/// <param name="annotationDataId">The ID of the annotation data to retrieve.</param>
		/// <param name="contentVersion">The content version for the volume you are trying to retrieve.</param>
		/// <param name="allowWebDefinitions">For the dictionary layer. Whether or not to allow web definitions.</param>
		/// <param name="h">The requested pixel height for any images. If height is provided width must also be provided.</param>
		/// <param name="locale">The locale information for the data. ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'.</param>
		/// <param name="scale">The requested scale for the image.
		/// Minimum: 0
		// </param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="w">The requested pixel width for any images. If width is provided height must also be provided.</param>
		/// <returns>Successful response</returns>
		public async Task Books_layers_annotationData_getAsync(string volumeId, string layerId, string annotationDataId, string contentVersion, bool allowWebDefinitions, int h, string locale, int scale, string source, int w)
		{
			var requestUri = "volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/layers/"+ (layerId==null? "" : System.Uri.EscapeDataString(layerId))+"/data/"+ (annotationDataId==null? "" : System.Uri.EscapeDataString(annotationDataId))+"&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&allowWebDefinitions="+allowWebDefinitions+"&h="+h+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&scale="+scale+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&w="+w;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the annotation data.
		/// Books_layers_annotationData_get volumes/{volumeId}/layers/{layerId}/data/{annotationDataId}
		/// </summary>
		/// <param name="volumeId">The volume to retrieve annotations for.</param>
		/// <param name="layerId">The ID for the layer to get the annotations.</param>
		/// <param name="annotationDataId">The ID of the annotation data to retrieve.</param>
		/// <param name="contentVersion">The content version for the volume you are trying to retrieve.</param>
		/// <param name="allowWebDefinitions">For the dictionary layer. Whether or not to allow web definitions.</param>
		/// <param name="h">The requested pixel height for any images. If height is provided width must also be provided.</param>
		/// <param name="locale">The locale information for the data. ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'.</param>
		/// <param name="scale">The requested scale for the image.
		/// Minimum: 0
		// </param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="w">The requested pixel width for any images. If width is provided height must also be provided.</param>
		/// <returns>Successful response</returns>
		public void Books_layers_annotationData_get(string volumeId, string layerId, string annotationDataId, string contentVersion, bool allowWebDefinitions, int h, string locale, int scale, string source, int w)
		{
			var requestUri = "volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/layers/"+ (layerId==null? "" : System.Uri.EscapeDataString(layerId))+"/data/"+ (annotationDataId==null? "" : System.Uri.EscapeDataString(annotationDataId))+"&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&allowWebDefinitions="+allowWebDefinitions+"&h="+h+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&scale="+scale+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&w="+w;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the layer summaries for a volume.
		/// Books_layers_list volumes/{volumeId}/layersummary
		/// </summary>
		/// <param name="volumeId">The volume to retrieve layers for.</param>
		/// <param name="contentVersion">The content version for the requested volume.</param>
		/// <param name="maxResults">Maximum number of results to return
		/// Minimum: 0
		/// Maximum: 200
		// </param>
		/// <param name="pageToken">The value of the nextToken from the previous page.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_layers_listAsync(string volumeId, string contentVersion, int maxResults, string pageToken, string source)
		{
			var requestUri = "volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/layersummary&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the layer summaries for a volume.
		/// Books_layers_list volumes/{volumeId}/layersummary
		/// </summary>
		/// <param name="volumeId">The volume to retrieve layers for.</param>
		/// <param name="contentVersion">The content version for the requested volume.</param>
		/// <param name="maxResults">Maximum number of results to return
		/// Minimum: 0
		/// Maximum: 200
		// </param>
		/// <param name="pageToken">The value of the nextToken from the previous page.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_layers_list(string volumeId, string contentVersion, int maxResults, string pageToken, string source)
		{
			var requestUri = "volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/layersummary&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the layer summary for a volume.
		/// Books_layers_get volumes/{volumeId}/layersummary/{summaryId}
		/// </summary>
		/// <param name="volumeId">The volume to retrieve layers for.</param>
		/// <param name="summaryId">The ID for the layer to get the summary for.</param>
		/// <param name="contentVersion">The content version for the requested volume.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task Books_layers_getAsync(string volumeId, string summaryId, string contentVersion, string source)
		{
			var requestUri = "volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/layersummary/"+ (summaryId==null? "" : System.Uri.EscapeDataString(summaryId))+"&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the layer summary for a volume.
		/// Books_layers_get volumes/{volumeId}/layersummary/{summaryId}
		/// </summary>
		/// <param name="volumeId">The volume to retrieve layers for.</param>
		/// <param name="summaryId">The ID for the layer to get the summary for.</param>
		/// <param name="contentVersion">The content version for the requested volume.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public void Books_layers_get(string volumeId, string summaryId, string contentVersion, string source)
		{
			var requestUri = "volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/layersummary/"+ (summaryId==null? "" : System.Uri.EscapeDataString(summaryId))+"&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.Send(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum Books_myconfig_requestAccessLicenseTypes
	{
		
		BOTH = 0,
		
		CONCURRENT = 1,
		
		DOWNLOAD = 2,
	}
	
	public enum Books_mylibrary_bookshelves_addVolumeReason
	{
		
		IOS_PREX = 0,
		
		IOS_SEARCH = 1,
		
		ONBOARDING = 2,
	}
	
	public enum Books_mylibrary_bookshelves_removeVolumeReason
	{
		
		ONBOARDING = 0,
	}
	
	public enum Books_mylibrary_bookshelves_volumes_listProjection
	{
		
		full = 0,
		
		lite = 1,
	}
	
	public enum Books_mylibrary_readingpositions_setPositionAction
	{
		
		bookmark = 0,
		
		chapter = 1,
		
		nextMinuspage = 2,
		
		prevMinuspage = 3,
		
		scroll = 4,
		
		search = 5,
	}
	
	public enum Books_onboarding_listCategoryVolumesMaxAllowedMaturityRating
	{
		
		mature = 0,
		
		notMinusmature = 1,
	}
	
	public enum Books_personalizedstream_getMaxAllowedMaturityRating
	{
		
		mature = 0,
		
		notMinusmature = 1,
	}
	
	public enum Books_volumes_listDownload
	{
		
		epub = 0,
	}
	
	public enum Books_volumes_listFilter
	{
		
		ebooks = 0,
		
		freeMinusebooks = 1,
		
		full = 2,
		
		paidMinusebooks = 3,
		
		@partial = 4,
	}
	
	public enum Books_volumes_listLibraryRestrict
	{
		
		myMinuslibrary = 0,
		
		noMinusrestrict = 1,
	}
	
	public enum Books_volumes_listMaxAllowedMaturityRating
	{
		
		mature = 0,
		
		notMinusmature = 1,
	}
	
	public enum Books_volumes_listOrderBy
	{
		
		newest = 0,
		
		relevance = 1,
	}
	
	public enum Books_volumes_listPrintType
	{
		
		all = 0,
		
		books = 1,
		
		magazines = 2,
	}
	
	public enum Books_volumes_recommended_listMaxAllowedMaturityRating
	{
		
		mature = 0,
		
		notMinusmature = 1,
	}
	
	public enum Books_volumes_recommended_rateRating
	{
		
		HAVE_IT = 0,
		
		NOT_INTERESTED = 1,
	}
	
	public enum Books_volumes_associated_listAssociation
	{
		
		endMinusofMinussample = 0,
		
		endMinusofMinusvolume = 1,
		
		relatedMinusforMinusplay = 2,
	}
	
	public enum Books_volumes_associated_listMaxAllowedMaturityRating
	{
		
		mature = 0,
		
		notMinusmature = 1,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
