//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	public class AssociatedWorkItem
	{
		
		public string AssignedTo { get; set; }
		
		/// <summary>
		/// Id of associated the work item.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		public string State { get; set; }
		
		public string Title { get; set; }
		
		/// <summary>
		/// REST Url of the work item.
		/// </summary>
		public string Url { get; set; }
		
		public string WebUrl { get; set; }
		
		public string WorkItemType { get; set; }
	}
	
	public class AsyncGitOperationNotification
	{
		
		public System.Nullable<System.Int32> OperationId { get; set; }
	}
	
	public class AsyncRefOperationCommitLevelEventNotification
	{
		
		public string CommitId { get; set; }
	}
	
	public class AsyncRefOperationCompletedNotification
	{
		
		public string NewRefName { get; set; }
	}
	
	public class AsyncRefOperationConflictNotification
	{
	}
	
	public class AsyncRefOperationGeneralFailureNotification
	{
	}
	
	public class AsyncRefOperationProgressNotification
	{
		
		public System.Nullable<System.Double> Progress { get; set; }
	}
	
	public class AsyncRefOperationTimeoutNotification
	{
	}
	
	/// <summary>
	/// Meta data for a file attached to an artifact.
	/// </summary>
	public class Attachment
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		public IdentityRef Author { get; set; }
		
		/// <summary>
		/// Content hash of on-disk representation of file content. Its calculated by the server by using SHA1 hash function.
		/// </summary>
		public string ContentHash { get; set; }
		
		/// <summary>
		/// The time the attachment was uploaded.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedDate { get; set; }
		
		/// <summary>
		/// The description of the attachment.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// The display name of the attachment. Can't be null or empty.
		/// </summary>
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Id of the attachment.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The class represents a property bag as a collection of key-value pairs. Values of all primitive types (any type with a `TypeCode != TypeCode.Object`) except for `DBNull` are accepted. Values of type Byte[], Int32, Double, DateType and String preserve their type, other primitives are retuned as a String. Byte[] expected as base64 encoded string.
		/// </summary>
		public PropertiesCollection Properties { get; set; }
		
		/// <summary>
		/// The url to download the content of the attachment.
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// The class to represent a collection of REST reference links.
	/// </summary>
	public class ReferenceLinks
	{
		
		/// <summary>
		/// The readonly view of the links.  Because Reference links are readonly, we only want to expose them as read only.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, object> Links { get; set; }
	}
	
	public class IdentityRef
	{
		
		/// <summary>
		/// Deprecated - Can be retrieved by querying the Graph user referenced in the "self" entry of the IdentityRef "_links" dictionary
		/// </summary>
		public string DirectoryAlias { get; set; }
		
		public string Id { get; set; }
		
		/// <summary>
		/// Deprecated - Available in the "avatar" entry of the IdentityRef "_links" dictionary
		/// </summary>
		public string ImageUrl { get; set; }
		
		/// <summary>
		/// Deprecated - Can be retrieved by querying the Graph membership state referenced in the "membershipState" entry of the GraphUser "_links" dictionary
		/// </summary>
		public System.Nullable<System.Boolean> Inactive { get; set; }
		
		/// <summary>
		/// Deprecated - Can be inferred from the subject type of the descriptor (Descriptor.IsAadUserType/Descriptor.IsAadGroupType)
		/// </summary>
		public System.Nullable<System.Boolean> IsAadIdentity { get; set; }
		
		/// <summary>
		/// Deprecated - Can be inferred from the subject type of the descriptor (Descriptor.IsGroupType)
		/// </summary>
		public System.Nullable<System.Boolean> IsContainer { get; set; }
		
		public System.Nullable<System.Boolean> IsDeletedInOrigin { get; set; }
		
		/// <summary>
		/// Deprecated - not in use in most preexisting implementations of ToIdentityRef
		/// </summary>
		public string ProfileUrl { get; set; }
		
		/// <summary>
		/// Deprecated - use Domain+PrincipalName instead
		/// </summary>
		public string UniqueName { get; set; }
	}
	
	/// <summary>
	/// The class represents a property bag as a collection of key-value pairs. Values of all primitive types (any type with a `TypeCode != TypeCode.Object`) except for `DBNull` are accepted. Values of type Byte[], Int32, Double, DateType and String preserve their type, other primitives are retuned as a String. Byte[] expected as base64 encoded string.
	/// </summary>
	public class PropertiesCollection
	{
		
		/// <summary>
		/// The count of properties in the collection.
		/// </summary>
		public System.Nullable<System.Int32> Count { get; set; }
		
		public string Item { get; set; }
		
		/// <summary>
		/// The set of keys in the collection.
		/// </summary>
		public string[] Keys { get; set; }
		
		/// <summary>
		/// The set of values in the collection.
		/// </summary>
		public string[] Values { get; set; }
	}
	
	/// <summary>
	/// Real time event (SignalR) for an auto-complete update on a pull request
	/// </summary>
	public class AutoCompleteUpdatedEvent
	{
	}
	
	/// <summary>
	/// Real time event (SignalR) for a source/target branch update on a pull request
	/// </summary>
	public class BranchUpdatedEvent
	{
		
		/// <summary>
		/// If true, the source branch of the pull request was updated
		/// </summary>
		public System.Nullable<System.Boolean> IsSourceUpdate { get; set; }
	}
	
	public class Change
	{
		
		/// <summary>
		/// The type of change that was made to the item.
		/// </summary>
		public System.Nullable<ChangeChangeType> ChangeType { get; set; }
		
		/// <summary>
		/// Current version.
		/// </summary>
		public string Item { get; set; }
		
		public ItemContent NewContent { get; set; }
		
		/// <summary>
		/// Path of the item on the server.
		/// </summary>
		public string SourceServerItem { get; set; }
		
		/// <summary>
		/// URL to retrieve the item.
		/// </summary>
		public string Url { get; set; }
	}
	
	public enum ChangeChangeType
	{
		
		none = 0,
		
		add = 1,
		
		edit = 2,
		
		encoding = 3,
		
		rename = 4,
		
		_delete = 5,
		
		undelete = 6,
		
		branch = 7,
		
		merge = 8,
		
		_lock = 9,
		
		rollback = 10,
		
		sourceRename = 11,
		
		targetRename = 12,
		
		property = 13,
		
		all = 14,
	}
	
	public class ItemContent
	{
		
		public string Content { get; set; }
		
		public System.Nullable<ItemContentContentType> ContentType { get; set; }
	}
	
	public enum ItemContentContentType
	{
		
		rawText = 0,
		
		base64Encoded = 1,
	}
	
	public class ChangeCountDictionary
	{
	}
	
	public class ChangeList
	{
		
		public System.Nullable<System.Boolean> AllChangesIncluded { get; set; }
		
		public System.Collections.Generic.Dictionary<string, int> ChangeCounts { get; set; }
		
		public Change[] Changes { get; set; }
		
		public string Comment { get; set; }
		
		public System.Nullable<System.Boolean> CommentTruncated { get; set; }
		
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		public CheckinNote[] Notes { get; set; }
		
		public string Owner { get; set; }
		
		public string OwnerDisplayName { get; set; }
		
		public string OwnerId { get; set; }
		
		public System.Nullable<System.DateTimeOffset> SortDate { get; set; }
		
		public string Version { get; set; }
	}
	
	public class CheckinNote
	{
		
		public string Name { get; set; }
		
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Criteria used in a search for change lists
	/// </summary>
	public class ChangeListSearchCriteria
	{
		
		/// <summary>
		/// If provided, a version descriptor to compare against base
		/// </summary>
		public string CompareVersion { get; set; }
		
		/// <summary>
		/// If true, don't include delete history entries
		/// </summary>
		public System.Nullable<System.Boolean> ExcludeDeletes { get; set; }
		
		/// <summary>
		/// Whether or not to follow renames for the given item being queried
		/// </summary>
		public System.Nullable<System.Boolean> FollowRenames { get; set; }
		
		/// <summary>
		/// If provided, only include history entries created after this date (string)
		/// </summary>
		public string FromDate { get; set; }
		
		/// <summary>
		/// If provided, a version descriptor for the earliest change list to include
		/// </summary>
		public string FromVersion { get; set; }
		
		/// <summary>
		/// Path of item to search under. If the itemPaths memebr is used then it will take precedence over this.
		/// </summary>
		public string ItemPath { get; set; }
		
		/// <summary>
		/// List of item paths to search under. If this member is used then itemPath will be ignored.
		/// </summary>
		public string[] ItemPaths { get; set; }
		
		/// <summary>
		/// Version of the items to search
		/// </summary>
		public string ItemVersion { get; set; }
		
		/// <summary>
		/// Number of results to skip (used when clicking more...)
		/// </summary>
		public System.Nullable<System.Int32> Skip { get; set; }
		
		/// <summary>
		/// If provided, only include history entries created before this date (string)
		/// </summary>
		public string ToDate { get; set; }
		
		/// <summary>
		/// If provided, the maximum number of history entries to return
		/// </summary>
		public System.Nullable<System.Int32> Top { get; set; }
		
		/// <summary>
		/// If provided, a version descriptor for the latest change list to include
		/// </summary>
		public string ToVersion { get; set; }
		
		/// <summary>
		/// Alias or display name of user who made the changes
		/// </summary>
		public string User { get; set; }
	}
	
	/// <summary>
	/// Represents a comment which is one of potentially many in a comment thread.
	/// </summary>
	public class Comment
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		public IdentityRef Author { get; set; }
		
		/// <summary>
		/// The comment type at the time of creation.
		/// </summary>
		public System.Nullable<CommentCommentType> CommentType { get; set; }
		
		/// <summary>
		/// The comment content.
		/// </summary>
		public string Content { get; set; }
		
		/// <summary>
		/// The comment ID. IDs start at 1 and are unique to a pull request.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Whether or not this comment was soft-deleted.
		/// </summary>
		public System.Nullable<System.Boolean> IsDeleted { get; set; }
		
		/// <summary>
		/// The date the comment's content was last updated.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastContentUpdatedDate { get; set; }
		
		/// <summary>
		/// The date the comment was last updated.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastUpdatedDate { get; set; }
		
		/// <summary>
		/// The ID of the parent comment. This is used for replies.
		/// </summary>
		public string ParentCommentId { get; set; }
		
		/// <summary>
		/// The date the comment was first published.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> PublishedDate { get; set; }
		
		/// <summary>
		/// A list of the users who have liked this comment.
		/// </summary>
		public IdentityRef[] UsersLiked { get; set; }
	}
	
	public enum CommentCommentType
	{
		
		unknown = 0,
		
		text = 1,
		
		codeChange = 2,
		
		system = 3,
	}
	
	/// <summary>
	/// Comment iteration context is used to identify which diff was being viewed when the thread was created.
	/// </summary>
	public class CommentIterationContext
	{
		
		/// <summary>
		/// The iteration of the file on the left side of the diff when the thread was created. If this value is equal to SecondComparingIteration, then this version is the common commit between the source and target branches of the pull request.
		/// </summary>
		public string FirstComparingIteration { get; set; }
		
		/// <summary>
		/// The iteration of the file on the right side of the diff when the thread was created.
		/// </summary>
		public string SecondComparingIteration { get; set; }
	}
	
	public class CommentPosition
	{
		
		/// <summary>
		/// The line number of a thread's position. Starts at 1.
		/// </summary>
		public System.Nullable<System.Int32> Line { get; set; }
		
		/// <summary>
		/// The character offset of a thread's position inside of a line. Starts at 0.
		/// </summary>
		public System.Nullable<System.Int32> Offset { get; set; }
	}
	
	/// <summary>
	/// Represents a comment thread of a pull request. A thread contains meta data about the file it was left on along with one or more comments (an initial comment and the subsequent replies).
	/// </summary>
	public class CommentThread
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// A list of the comments.
		/// </summary>
		public Comment[] Comments { get; set; }
		
		/// <summary>
		/// The comment thread id.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Set of identities related to this thread
		/// </summary>
		public System.Collections.Generic.Dictionary<string, IdentityRef> Identities { get; set; }
		
		/// <summary>
		/// Specify if the thread is deleted which happens when all comments are deleted.
		/// </summary>
		public System.Nullable<System.Boolean> IsDeleted { get; set; }
		
		/// <summary>
		/// The time this thread was last updated.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastUpdatedDate { get; set; }
		
		/// <summary>
		/// The class represents a property bag as a collection of key-value pairs. Values of all primitive types (any type with a `TypeCode != TypeCode.Object`) except for `DBNull` are accepted. Values of type Byte[], Int32, Double, DateType and String preserve their type, other primitives are retuned as a String. Byte[] expected as base64 encoded string.
		/// </summary>
		public PropertiesCollection Properties { get; set; }
		
		/// <summary>
		/// The time this thread was published.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> PublishedDate { get; set; }
		
		/// <summary>
		/// The status of the comment thread.
		/// </summary>
		public System.Nullable<CommentThreadStatus> Status { get; set; }
		
		public CommentThreadContext ThreadContext { get; set; }
	}
	
	public enum CommentThreadStatus
	{
		
		unknown = 0,
		
		active = 1,
		
		_fixed = 2,
		
		wontFix = 3,
		
		closed = 4,
		
		byDesign = 5,
		
		pending = 6,
	}
	
	public class CommentThreadContext
	{
		
		/// <summary>
		/// File path relative to the root of the repository. It's up to the client to use any path format.
		/// </summary>
		public string FilePath { get; set; }
		
		public CommentPosition LeftFileEnd { get; set; }
		
		public CommentPosition LeftFileStart { get; set; }
		
		public CommentPosition RightFileEnd { get; set; }
		
		public CommentPosition RightFileStart { get; set; }
	}
	
	/// <summary>
	/// Comment tracking criteria is used to identify which iteration context the thread has been tracked to (if any) along with some detail about the original position and filename.
	/// </summary>
	public class CommentTrackingCriteria
	{
		
		/// <summary>
		/// The iteration of the file on the left side of the diff that the thread will be tracked to. Threads were tracked if this is greater than 0.
		/// </summary>
		public System.Nullable<System.Int32> FirstComparingIteration { get; set; }
		
		/// <summary>
		/// Original filepath the thread was created on before tracking. This will be different than the current thread filepath if the file in question was renamed in a later iteration.
		/// </summary>
		public string OrigFilePath { get; set; }
		
		public CommentPosition OrigLeftFileEnd { get; set; }
		
		public CommentPosition OrigLeftFileStart { get; set; }
		
		public CommentPosition OrigRightFileEnd { get; set; }
		
		public CommentPosition OrigRightFileStart { get; set; }
		
		/// <summary>
		/// The iteration of the file on the right side of the diff that the thread will be tracked to. Threads were tracked if this is greater than 0.
		/// </summary>
		public System.Nullable<System.Int32> SecondComparingIteration { get; set; }
	}
	
	/// <summary>
	/// Real time event (SignalR) for a completion errors on a pull request
	/// </summary>
	public class CompletionErrorsEvent
	{
		
		/// <summary>
		/// The error message associated with the completion error
		/// </summary>
		public string ErrorMessage { get; set; }
	}
	
	/// <summary>
	/// Real time event (SignalR) for a discussions update on a pull request
	/// </summary>
	public class DiscussionsUpdatedEvent
	{
	}
	
	public class FileContentMetadata
	{
		
		public string ContentType { get; set; }
		
		public System.Nullable<System.Int32> Encoding { get; set; }
		
		public string Extension { get; set; }
		
		public string FileName { get; set; }
		
		public System.Nullable<System.Boolean> IsBinary { get; set; }
		
		public System.Nullable<System.Boolean> IsImage { get; set; }
		
		public string VsLink { get; set; }
	}
	
	/// <summary>
	/// Provides properties that describe file differences
	/// </summary>
	public class FileDiff
	{
		
		/// <summary>
		/// The collection of line diff blocks
		/// </summary>
		public LineDiffBlock[] LineDiffBlocks { get; set; }
		
		/// <summary>
		/// Original path of item if different from current path.
		/// </summary>
		public string OriginalPath { get; set; }
		
		/// <summary>
		/// Current path of item
		/// </summary>
		public string Path { get; set; }
	}
	
	/// <summary>
	/// The class to represent the line diff block
	/// </summary>
	public class LineDiffBlock
	{
		
		/// <summary>
		/// Type of change that was made to the block.
		/// </summary>
		public System.Nullable<LineDiffBlockChangeType> ChangeType { get; set; }
		
		/// <summary>
		/// Line number where this block starts in modified file.
		/// </summary>
		public System.Nullable<System.Int32> ModifiedLineNumberStart { get; set; }
		
		/// <summary>
		/// Count of lines in this block in modified file.
		/// </summary>
		public System.Nullable<System.Int32> ModifiedLinesCount { get; set; }
		
		/// <summary>
		/// Line number where this block starts in original file.
		/// </summary>
		public System.Nullable<System.Int32> OriginalLineNumberStart { get; set; }
		
		/// <summary>
		/// Count of lines in this block in original file.
		/// </summary>
		public System.Nullable<System.Int32> OriginalLinesCount { get; set; }
	}
	
	public enum LineDiffBlockChangeType
	{
		
		none = 0,
		
		add = 1,
		
		_delete = 2,
		
		edit = 3,
	}
	
	/// <summary>
	/// Provides parameters that describe inputs for the file diff
	/// </summary>
	public class FileDiffParams
	{
		
		/// <summary>
		/// Original path of the file
		/// </summary>
		public string OriginalPath { get; set; }
		
		/// <summary>
		/// Current path of the file
		/// </summary>
		public string Path { get; set; }
	}
	
	/// <summary>
	/// Provides properties that describe inputs for the file diffs
	/// </summary>
	public class FileDiffsCriteria
	{
		
		/// <summary>
		/// Commit ID of the base version
		/// </summary>
		public string BaseVersionCommit { get; set; }
		
		/// <summary>
		/// List of parameters for each of the files for which we need to get the file diff
		/// </summary>
		public FileDiffParams[] FileDiffParams { get; set; }
		
		/// <summary>
		/// Commit ID of the target version
		/// </summary>
		public string TargetVersionCommit { get; set; }
	}
	
	/// <summary>
	/// A Git annotated tag.
	/// </summary>
	public class GitAnnotatedTag
	{
		
		/// <summary>
		/// The tagging Message
		/// </summary>
		public string Message { get; set; }
		
		/// <summary>
		/// The name of the annotated tag.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// The objectId (Sha1Id) of the tag.
		/// </summary>
		public string ObjectId { get; set; }
		
		/// <summary>
		/// User info and date for Git operations.
		/// </summary>
		public GitUserDate TaggedBy { get; set; }
		
		/// <summary>
		/// Git object identifier and type information.
		/// </summary>
		public GitObject TaggedObject { get; set; }
		
		public string Url { get; set; }
	}
	
	/// <summary>
	/// User info and date for Git operations.
	/// </summary>
	public class GitUserDate
	{
		
		/// <summary>
		/// Date of the Git operation.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> Date { get; set; }
		
		/// <summary>
		/// Email address of the user performing the Git operation.
		/// </summary>
		public string Email { get; set; }
		
		/// <summary>
		/// Url for the user's avatar.
		/// </summary>
		public string ImageUrl { get; set; }
		
		/// <summary>
		/// Name of the user performing the Git operation.
		/// </summary>
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Git object identifier and type information.
	/// </summary>
	public class GitObject
	{
		
		/// <summary>
		/// Object Id (Sha1Id).
		/// </summary>
		public string ObjectId { get; set; }
		
		/// <summary>
		/// Type of object (Commit, Tree, Blob, Tag)
		/// </summary>
		public System.Nullable<GitObjectObjectType> ObjectType { get; set; }
	}
	
	public enum GitObjectObjectType
	{
		
		bad = 0,
		
		commit = 1,
		
		tree = 2,
		
		blob = 3,
		
		tag = 4,
		
		ext2 = 5,
		
		ofsDelta = 6,
		
		refDelta = 7,
	}
	
	public class GitAsyncRefOperation
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// Information about the progress of a cherry pick or revert operation.
		/// </summary>
		public GitAsyncRefOperationDetail DetailedStatus { get; set; }
		
		/// <summary>
		/// Parameters that are provided in the request body when requesting to cherry pick or revert.
		/// </summary>
		public GitAsyncRefOperationParameters Parameters { get; set; }
		
		public System.Nullable<GitAsyncRefOperationStatus> Status { get; set; }
		
		/// <summary>
		/// A URL that can be used to make further requests for status about the operation
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Information about the progress of a cherry pick or revert operation.
	/// </summary>
	public class GitAsyncRefOperationDetail
	{
		
		/// <summary>
		/// Indicates if there was a conflict generated when trying to cherry pick or revert the changes.
		/// </summary>
		public System.Nullable<System.Boolean> Conflict { get; set; }
		
		/// <summary>
		/// The current commit from the list of commits that are being cherry picked or reverted.
		/// </summary>
		public string CurrentCommitId { get; set; }
		
		/// <summary>
		/// Detailed information about why the cherry pick or revert failed to complete.
		/// </summary>
		public string FailureMessage { get; set; }
		
		/// <summary>
		/// A number between 0 and 1 indicating the percent complete of the operation.
		/// </summary>
		public System.Nullable<System.Double> Progress { get; set; }
		
		/// <summary>
		/// Provides a status code that indicates the reason the cherry pick or revert failed.
		/// </summary>
		public System.Nullable<GitAsyncRefOperationDetailStatus> Status { get; set; }
		
		/// <summary>
		/// Indicates if the operation went beyond the maximum time allowed for a cherry pick or revert operation.
		/// </summary>
		public System.Nullable<System.Boolean> Timedout { get; set; }
	}
	
	public enum GitAsyncRefOperationDetailStatus
	{
		
		none = 0,
		
		invalidRefName = 1,
		
		refNameConflict = 2,
		
		createBranchPermissionRequired = 3,
		
		writePermissionRequired = 4,
		
		targetBranchDeleted = 5,
		
		gitObjectTooLarge = 6,
		
		operationIndentityNotFound = 7,
		
		asyncOperationNotFound = 8,
		
		other = 9,
		
		emptyCommitterSignature = 10,
	}
	
	/// <summary>
	/// Parameters that are provided in the request body when requesting to cherry pick or revert.
	/// </summary>
	public class GitAsyncRefOperationParameters
	{
		
		/// <summary>
		/// Proposed target branch name for the cherry pick or revert operation.
		/// </summary>
		public string GeneratedRefName { get; set; }
		
		/// <summary>
		/// The target branch for the cherry pick or revert operation.
		/// </summary>
		public string OntoRefName { get; set; }
		
		public GitRepository Repository { get; set; }
		
		/// <summary>
		/// GitAsyncRefOperationSource specifies the pull request or list of commits to use when making a cherry pick and revert operation request. Only one should be provided.
		/// </summary>
		public GitAsyncRefOperationSource Source { get; set; }
	}
	
	public class GitRepository
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		public string DefaultBranch { get; set; }
		
		public string Id { get; set; }
		
		/// <summary>
		/// True if the repository was created as a fork
		/// </summary>
		public System.Nullable<System.Boolean> IsFork { get; set; }
		
		public string Name { get; set; }
		
		public GitRepositoryRef ParentRepository { get; set; }
		
		/// <summary>
		/// Represents a shallow reference to a TeamProject.
		/// </summary>
		public TeamProjectReference Project { get; set; }
		
		public string RemoteUrl { get; set; }
		
		/// <summary>
		/// Compressed size (bytes) of the repository.
		/// </summary>
		public System.Nullable<System.Int64> Size { get; set; }
		
		public string SshUrl { get; set; }
		
		public string Url { get; set; }
		
		public string[] ValidRemoteUrls { get; set; }
		
		public string WebUrl { get; set; }
	}
	
	public class GitRepositoryRef
	{
		
		/// <summary>
		/// Reference object for a TeamProjectCollection.
		/// </summary>
		public TeamProjectCollectionReference Collection { get; set; }
		
		public string Id { get; set; }
		
		/// <summary>
		/// True if the repository was created as a fork
		/// </summary>
		public System.Nullable<System.Boolean> IsFork { get; set; }
		
		public string Name { get; set; }
		
		/// <summary>
		/// Represents a shallow reference to a TeamProject.
		/// </summary>
		public TeamProjectReference Project { get; set; }
		
		public string RemoteUrl { get; set; }
		
		public string SshUrl { get; set; }
		
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Reference object for a TeamProjectCollection.
	/// </summary>
	public class TeamProjectCollectionReference
	{
		
		/// <summary>
		/// Collection Id.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Collection Name.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Collection REST Url.
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Represents a shallow reference to a TeamProject.
	/// </summary>
	public class TeamProjectReference
	{
		
		/// <summary>
		/// Project abbreviation.
		/// </summary>
		public string Abbreviation { get; set; }
		
		/// <summary>
		/// Url to default team identity image.
		/// </summary>
		public string DefaultTeamImageUrl { get; set; }
		
		/// <summary>
		/// The project's description (if any).
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Project identifier.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Project last update time.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastUpdateTime { get; set; }
		
		/// <summary>
		/// Project name.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Project revision.
		/// </summary>
		public System.Nullable<System.Int64> Revision { get; set; }
		
		/// <summary>
		/// Project state.
		/// </summary>
		public System.Nullable<TeamProjectReferenceState> State { get; set; }
		
		/// <summary>
		/// Url to the full version of the object.
		/// </summary>
		public string Url { get; set; }
		
		/// <summary>
		/// Project visibility.
		/// </summary>
		public System.Nullable<TeamProjectReferenceVisibility> Visibility { get; set; }
	}
	
	public enum TeamProjectReferenceState
	{
		
		deleting = 0,
		
		_new = 1,
		
		wellFormed = 2,
		
		createPending = 3,
		
		all = 4,
		
		unchanged = 5,
		
		deleted = 6,
	}
	
	public enum TeamProjectReferenceVisibility
	{
		
		_private = 0,
		
		_public = 1,
	}
	
	/// <summary>
	/// GitAsyncRefOperationSource specifies the pull request or list of commits to use when making a cherry pick and revert operation request. Only one should be provided.
	/// </summary>
	public class GitAsyncRefOperationSource
	{
		
		/// <summary>
		/// A list of commits to cherry pick or revert
		/// </summary>
		public GitCommitRef[] CommitList { get; set; }
		
		/// <summary>
		/// Id of the pull request to cherry pick or revert
		/// </summary>
		public System.Nullable<System.Int32> PullRequestId { get; set; }
	}
	
	/// <summary>
	/// Provides properties that describe a Git commit and associated metadata.
	/// </summary>
	public class GitCommitRef
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// User info and date for Git operations.
		/// </summary>
		public GitUserDate Author { get; set; }
		
		public ChangeCountDictionary ChangeCounts { get; set; }
		
		/// <summary>
		/// An enumeration of the changes included with the commit.
		/// </summary>
		public GitChange[] Changes { get; set; }
		
		/// <summary>
		/// Comment or message of the commit.
		/// </summary>
		public string Comment { get; set; }
		
		/// <summary>
		/// Indicates if the comment is truncated from the full Git commit comment message.
		/// </summary>
		public System.Nullable<System.Boolean> CommentTruncated { get; set; }
		
		/// <summary>
		/// ID (SHA-1) of the commit.
		/// </summary>
		public string CommitId { get; set; }
		
		/// <summary>
		/// User info and date for Git operations.
		/// </summary>
		public GitUserDate Committer { get; set; }
		
		/// <summary>
		/// An enumeration of the parent commit IDs for this commit.
		/// </summary>
		public string[] Parents { get; set; }
		
		public GitPushRef Push { get; set; }
		
		/// <summary>
		/// Remote URL path to the commit.
		/// </summary>
		public string RemoteUrl { get; set; }
		
		/// <summary>
		/// A list of status metadata from services and extensions that may associate additional information to the commit.
		/// </summary>
		public GitStatus[] Statuses { get; set; }
		
		/// <summary>
		/// REST URL for this resource.
		/// </summary>
		public string Url { get; set; }
		
		/// <summary>
		/// A list of workitems associated with this commit.
		/// </summary>
		public ResourceRef[] WorkItems { get; set; }
	}
	
	public class GitChange
	{
		
		/// <summary>
		/// ID of the change within the group of changes.
		/// </summary>
		public System.Nullable<System.Int32> ChangeId { get; set; }
		
		public GitTemplate NewContentTemplate { get; set; }
		
		/// <summary>
		/// Original path of item if different from current path.
		/// </summary>
		public string OriginalPath { get; set; }
	}
	
	public class GitTemplate
	{
		
		/// <summary>
		/// Name of the Template
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Type of the Template
		/// </summary>
		public string Type { get; set; }
	}
	
	public class GitPushRef
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		public System.Nullable<System.DateTimeOffset> Date { get; set; }
		
		public IdentityRef PushedBy { get; set; }
		
		public System.Nullable<System.Int32> PushId { get; set; }
		
		public string Url { get; set; }
	}
	
	/// <summary>
	/// This class contains the metadata of a service/extension posting a status.
	/// </summary>
	public class GitStatus
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// Status context that uniquely identifies the status.
		/// </summary>
		public GitStatusContext Context { get; set; }
		
		public IdentityRef CreatedBy { get; set; }
		
		/// <summary>
		/// Creation date and time of the status.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		/// <summary>
		/// Status description. Typically describes current state of the status.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Status identifier.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// State of the status.
		/// </summary>
		public System.Nullable<GitStatusState> State { get; set; }
		
		/// <summary>
		/// URL with status details.
		/// </summary>
		public string TargetUrl { get; set; }
		
		/// <summary>
		/// Last update date and time of the status.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> UpdatedDate { get; set; }
	}
	
	/// <summary>
	/// Status context that uniquely identifies the status.
	/// </summary>
	public class GitStatusContext
	{
		
		/// <summary>
		/// Genre of the status. Typically name of the service/tool generating the status, can be empty.
		/// </summary>
		public string Genre { get; set; }
		
		/// <summary>
		/// Name identifier of the status, cannot be null or empty.
		/// </summary>
		public string Name { get; set; }
	}
	
	public enum GitStatusState
	{
		
		notSet = 0,
		
		pending = 1,
		
		succeeded = 2,
		
		failed = 3,
		
		error = 4,
		
		notApplicable = 5,
	}
	
	public class ResourceRef
	{
		
		public string Id { get; set; }
		
		public string Url { get; set; }
	}
	
	public enum GitAsyncRefOperationStatus
	{
		
		queued = 0,
		
		inProgress = 1,
		
		completed = 2,
		
		failed = 3,
		
		abandoned = 4,
	}
	
	public class GitBaseVersionDescriptor
	{
		
		/// <summary>
		/// Version string identifier (name of tag/branch, SHA1 of commit)
		/// </summary>
		public string BaseVersion { get; set; }
		
		/// <summary>
		/// Version options - Specify additional modifiers to version (e.g Previous)
		/// </summary>
		public System.Nullable<GitBaseVersionDescriptorBaseVersionOptions> BaseVersionOptions { get; set; }
		
		/// <summary>
		/// Version type (branch, tag, or commit). Determines how Id is interpreted
		/// </summary>
		public System.Nullable<GitBaseVersionDescriptorBaseVersionType> BaseVersionType { get; set; }
	}
	
	public enum GitBaseVersionDescriptorBaseVersionOptions
	{
		
		none = 0,
		
		previousChange = 1,
		
		firstParent = 2,
	}
	
	public enum GitBaseVersionDescriptorBaseVersionType
	{
		
		branch = 0,
		
		tag = 1,
		
		commit = 2,
	}
	
	public class GitBlobRef
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// SHA1 hash of git object
		/// </summary>
		public string ObjectId { get; set; }
		
		/// <summary>
		/// Size of blob content (in bytes)
		/// </summary>
		public System.Nullable<System.Int64> Size { get; set; }
		
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Ahead and behind counts for a particular ref.
	/// </summary>
	public class GitBranchStats
	{
		
		/// <summary>
		/// Number of commits ahead.
		/// </summary>
		public System.Nullable<System.Int32> AheadCount { get; set; }
		
		/// <summary>
		/// Number of commits behind.
		/// </summary>
		public System.Nullable<System.Int32> BehindCount { get; set; }
		
		/// <summary>
		/// Provides properties that describe a Git commit and associated metadata.
		/// </summary>
		public GitCommitRef Commit { get; set; }
		
		/// <summary>
		/// True if this is the result for the base version.
		/// </summary>
		public System.Nullable<System.Boolean> IsBaseVersion { get; set; }
		
		/// <summary>
		/// Name of the ref.
		/// </summary>
		public string Name { get; set; }
	}
	
	/// <summary>
	/// This object is returned from Cherry Pick operations and provides the id and status of the operation
	/// </summary>
	public class GitCherryPick
	{
		
		public System.Nullable<System.Int32> CherryPickId { get; set; }
	}
	
	public class GitCommit
	{
		
		public string TreeId { get; set; }
	}
	
	public class GitCommitChanges
	{
		
		public ChangeCountDictionary ChangeCounts { get; set; }
		
		public GitChange[] Changes { get; set; }
	}
	
	public class GitCommitDiffs
	{
		
		public System.Nullable<System.Int32> AheadCount { get; set; }
		
		public System.Nullable<System.Boolean> AllChangesIncluded { get; set; }
		
		public string BaseCommit { get; set; }
		
		public System.Nullable<System.Int32> BehindCount { get; set; }
		
		public System.Collections.Generic.Dictionary<string, int> ChangeCounts { get; set; }
		
		public GitChange[] Changes { get; set; }
		
		public string CommonCommit { get; set; }
		
		public string TargetCommit { get; set; }
	}
	
	public class GitCommitToCreate
	{
		
		public GitRef BaseRef { get; set; }
		
		public string Comment { get; set; }
		
		public GitPathAction[] PathActions { get; set; }
	}
	
	public class GitRef
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		public IdentityRef Creator { get; set; }
		
		public System.Nullable<System.Boolean> IsLocked { get; set; }
		
		public IdentityRef IsLockedBy { get; set; }
		
		public string Name { get; set; }
		
		public string ObjectId { get; set; }
		
		public string PeeledObjectId { get; set; }
		
		public GitStatus[] Statuses { get; set; }
		
		public string Url { get; set; }
	}
	
	public class GitPathAction
	{
		
		public System.Nullable<GitPathActionAction> Action { get; set; }
		
		public string Base64Content { get; set; }
		
		public string Path { get; set; }
		
		public string RawTextContent { get; set; }
		
		public string TargetPath { get; set; }
	}
	
	public enum GitPathActionAction
	{
		
		none = 0,
		
		edit = 1,
		
		_delete = 2,
		
		add = 3,
		
		rename = 4,
	}
	
	public class GitConflict
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		public System.Nullable<System.Int32> ConflictId { get; set; }
		
		public string ConflictPath { get; set; }
		
		public System.Nullable<GitConflictConflictType> ConflictType { get; set; }
		
		/// <summary>
		/// Provides properties that describe a Git commit and associated metadata.
		/// </summary>
		public GitCommitRef MergeBaseCommit { get; set; }
		
		public GitMergeOriginRef MergeOrigin { get; set; }
		
		/// <summary>
		/// Provides properties that describe a Git commit and associated metadata.
		/// </summary>
		public GitCommitRef MergeSourceCommit { get; set; }
		
		/// <summary>
		/// Provides properties that describe a Git commit and associated metadata.
		/// </summary>
		public GitCommitRef MergeTargetCommit { get; set; }
		
		public System.Nullable<GitConflictResolutionError> ResolutionError { get; set; }
		
		public System.Nullable<GitConflictResolutionStatus> ResolutionStatus { get; set; }
		
		public IdentityRef ResolvedBy { get; set; }
		
		public System.Nullable<System.DateTimeOffset> ResolvedDate { get; set; }
		
		public string Url { get; set; }
	}
	
	public enum GitConflictConflictType
	{
		
		none = 0,
		
		addAdd = 1,
		
		addRename = 2,
		
		deleteEdit = 3,
		
		deleteRename = 4,
		
		directoryFile = 5,
		
		directoryChild = 6,
		
		editDelete = 7,
		
		editEdit = 8,
		
		fileDirectory = 9,
		
		rename1to2 = 10,
		
		rename2to1 = 11,
		
		renameAdd = 12,
		
		renameDelete = 13,
		
		renameRename = 14,
	}
	
	public class GitMergeOriginRef
	{
		
		public System.Nullable<System.Int32> CherryPickId { get; set; }
		
		public System.Nullable<System.Int32> PullRequestId { get; set; }
		
		public System.Nullable<System.Int32> RevertId { get; set; }
	}
	
	public enum GitConflictResolutionError
	{
		
		none = 0,
		
		mergeContentNotFound = 1,
		
		pathInUse = 2,
		
		invalidPath = 3,
		
		unknownAction = 4,
		
		unknownMergeType = 5,
		
		otherError = 6,
	}
	
	public enum GitConflictResolutionStatus
	{
		
		unresolved = 0,
		
		partiallyResolved = 1,
		
		resolved = 2,
	}
	
	/// <summary>
	/// Data object for AddAdd conflict
	/// </summary>
	public class GitConflictAddAdd
	{
		
		public GitResolutionMergeContent Resolution { get; set; }
		
		public GitBlobRef SourceBlob { get; set; }
		
		public GitBlobRef TargetBlob { get; set; }
	}
	
	public class GitResolutionMergeContent
	{
		
		public System.Nullable<GitResolutionMergeContentMergeType> MergeType { get; set; }
		
		public GitBlobRef UserMergedBlob { get; set; }
		
		public string[] UserMergedContent { get; set; }
	}
	
	public enum GitResolutionMergeContentMergeType
	{
		
		undecided = 0,
		
		takeSourceContent = 1,
		
		takeTargetContent = 2,
		
		autoMerged = 3,
		
		userMerged = 4,
	}
	
	/// <summary>
	/// Data object for RenameAdd conflict
	/// </summary>
	public class GitConflictAddRename
	{
		
		public GitBlobRef BaseBlob { get; set; }
		
		public GitResolutionPathConflict Resolution { get; set; }
		
		public GitBlobRef SourceBlob { get; set; }
		
		public GitBlobRef TargetBlob { get; set; }
		
		public string TargetOriginalPath { get; set; }
	}
	
	public class GitResolutionPathConflict
	{
		
		public System.Nullable<GitResolutionPathConflictAction> Action { get; set; }
		
		public string RenamePath { get; set; }
	}
	
	public enum GitResolutionPathConflictAction
	{
		
		undecided = 0,
		
		keepSourceRenameTarget = 1,
		
		keepSourceDeleteTarget = 2,
		
		keepTargetRenameSource = 3,
		
		keepTargetDeleteSource = 4,
	}
	
	/// <summary>
	/// Data object for EditDelete conflict
	/// </summary>
	public class GitConflictDeleteEdit
	{
		
		public GitBlobRef BaseBlob { get; set; }
		
		public GitResolutionPickOneAction Resolution { get; set; }
		
		public GitBlobRef TargetBlob { get; set; }
	}
	
	public class GitResolutionPickOneAction
	{
		
		public System.Nullable<GitResolutionPickOneActionAction> Action { get; set; }
	}
	
	public enum GitResolutionPickOneActionAction
	{
		
		undecided = 0,
		
		pickSourceAction = 1,
		
		pickTargetAction = 2,
	}
	
	/// <summary>
	/// Data object for RenameDelete conflict
	/// </summary>
	public class GitConflictDeleteRename
	{
		
		public GitBlobRef BaseBlob { get; set; }
		
		public GitResolutionPickOneAction Resolution { get; set; }
		
		public GitBlobRef TargetBlob { get; set; }
		
		public string TargetNewPath { get; set; }
	}
	
	/// <summary>
	/// Data object for FileDirectory conflict
	/// </summary>
	public class GitConflictDirectoryFile
	{
		
		public GitResolutionPathConflict Resolution { get; set; }
		
		public GitTreeRef SourceTree { get; set; }
		
		public GitBlobRef TargetBlob { get; set; }
	}
	
	public class GitTreeRef
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// SHA1 hash of git object
		/// </summary>
		public string ObjectId { get; set; }
		
		/// <summary>
		/// Sum of sizes of all children
		/// </summary>
		public System.Nullable<System.Int64> Size { get; set; }
		
		/// <summary>
		/// Blobs and trees under this tree
		/// </summary>
		public GitTreeEntryRef[] TreeEntries { get; set; }
		
		/// <summary>
		/// Url to tree
		/// </summary>
		public string Url { get; set; }
	}
	
	public class GitTreeEntryRef
	{
		
		/// <summary>
		/// Blob or tree
		/// </summary>
		public System.Nullable<GitTreeEntryRefGitObjectType> GitObjectType { get; set; }
		
		/// <summary>
		/// Mode represented as octal string
		/// </summary>
		public string Mode { get; set; }
		
		/// <summary>
		/// SHA1 hash of git object
		/// </summary>
		public string ObjectId { get; set; }
		
		/// <summary>
		/// Path relative to parent tree object
		/// </summary>
		public string RelativePath { get; set; }
		
		/// <summary>
		/// Size of content
		/// </summary>
		public System.Nullable<System.Int64> Size { get; set; }
		
		/// <summary>
		/// url to retrieve tree or blob
		/// </summary>
		public string Url { get; set; }
	}
	
	public enum GitTreeEntryRefGitObjectType
	{
		
		bad = 0,
		
		commit = 1,
		
		tree = 2,
		
		blob = 3,
		
		tag = 4,
		
		ext2 = 5,
		
		ofsDelta = 6,
		
		refDelta = 7,
	}
	
	/// <summary>
	/// Data object for DeleteEdit conflict
	/// </summary>
	public class GitConflictEditDelete
	{
		
		public GitBlobRef BaseBlob { get; set; }
		
		public GitResolutionPickOneAction Resolution { get; set; }
		
		public GitBlobRef SourceBlob { get; set; }
	}
	
	/// <summary>
	/// Data object for EditEdit conflict
	/// </summary>
	public class GitConflictEditEdit
	{
		
		public GitBlobRef BaseBlob { get; set; }
		
		public GitResolutionMergeContent Resolution { get; set; }
		
		public GitBlobRef SourceBlob { get; set; }
		
		public GitBlobRef TargetBlob { get; set; }
	}
	
	/// <summary>
	/// Data object for DirectoryFile conflict
	/// </summary>
	public class GitConflictFileDirectory
	{
		
		public GitResolutionPathConflict Resolution { get; set; }
		
		public GitBlobRef SourceBlob { get; set; }
		
		public GitTreeRef TargetTree { get; set; }
	}
	
	/// <summary>
	/// Data object for Rename1to2 conflict
	/// </summary>
	public class GitConflictRename1to2
	{
		
		public GitBlobRef BaseBlob { get; set; }
		
		public GitResolutionRename1to2 Resolution { get; set; }
		
		public GitBlobRef SourceBlob { get; set; }
		
		public string SourceNewPath { get; set; }
		
		public GitBlobRef TargetBlob { get; set; }
		
		public string TargetNewPath { get; set; }
	}
	
	public class GitResolutionRename1to2
	{
		
		public System.Nullable<GitResolutionRename1to2Action> Action { get; set; }
	}
	
	public enum GitResolutionRename1to2Action
	{
		
		undecided = 0,
		
		keepSourcePath = 1,
		
		keepTargetPath = 2,
		
		keepBothFiles = 3,
	}
	
	/// <summary>
	/// Data object for Rename2to1 conflict
	/// </summary>
	public class GitConflictRename2to1
	{
		
		public GitResolutionPathConflict Resolution { get; set; }
		
		public GitBlobRef SourceNewBlob { get; set; }
		
		public GitBlobRef SourceOriginalBlob { get; set; }
		
		public string SourceOriginalPath { get; set; }
		
		public GitBlobRef TargetNewBlob { get; set; }
		
		public GitBlobRef TargetOriginalBlob { get; set; }
		
		public string TargetOriginalPath { get; set; }
	}
	
	/// <summary>
	/// Data object for AddRename conflict
	/// </summary>
	public class GitConflictRenameAdd
	{
		
		public GitBlobRef BaseBlob { get; set; }
		
		public GitResolutionPathConflict Resolution { get; set; }
		
		public GitBlobRef SourceBlob { get; set; }
		
		public string SourceOriginalPath { get; set; }
		
		public GitBlobRef TargetBlob { get; set; }
	}
	
	/// <summary>
	/// Data object for DeleteRename conflict
	/// </summary>
	public class GitConflictRenameDelete
	{
		
		public GitBlobRef BaseBlob { get; set; }
		
		public GitResolutionPickOneAction Resolution { get; set; }
		
		public GitBlobRef SourceBlob { get; set; }
		
		public string SourceNewPath { get; set; }
	}
	
	/// <summary>
	/// Data object for RenameRename conflict
	/// </summary>
	public class GitConflictRenameRename
	{
		
		public GitBlobRef BaseBlob { get; set; }
		
		public string OriginalPath { get; set; }
		
		public GitResolutionMergeContent Resolution { get; set; }
		
		public GitBlobRef SourceBlob { get; set; }
		
		public GitBlobRef TargetBlob { get; set; }
	}
	
	public class GitConflictUpdateResult
	{
		
		/// <summary>
		/// Conflict ID that was provided by input
		/// </summary>
		public System.Nullable<System.Int32> ConflictId { get; set; }
		
		/// <summary>
		/// Reason for failing
		/// </summary>
		public string CustomMessage { get; set; }
		
		public GitConflict UpdatedConflict { get; set; }
		
		/// <summary>
		/// Status of the update on the server
		/// </summary>
		public System.Nullable<GitConflictUpdateResultUpdateStatus> UpdateStatus { get; set; }
	}
	
	public enum GitConflictUpdateResultUpdateStatus
	{
		
		succeeded = 0,
		
		badRequest = 1,
		
		invalidResolution = 2,
		
		unsupportedConflictType = 3,
		
		notFound = 4,
	}
	
	public class GitDeletedRepository
	{
		
		public System.Nullable<System.DateTimeOffset> CreatedDate { get; set; }
		
		public IdentityRef DeletedBy { get; set; }
		
		public System.Nullable<System.DateTimeOffset> DeletedDate { get; set; }
		
		public string Id { get; set; }
		
		public string Name { get; set; }
		
		/// <summary>
		/// Represents a shallow reference to a TeamProject.
		/// </summary>
		public TeamProjectReference Project { get; set; }
	}
	
	public class GitFilePathsCollection
	{
		
		public string CommitId { get; set; }
		
		public string[] Paths { get; set; }
		
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Status information about a requested fork operation.
	/// </summary>
	public class GitForkOperationStatusDetail
	{
		
		/// <summary>
		/// All valid steps for the forking process
		/// </summary>
		public string[] AllSteps { get; set; }
		
		/// <summary>
		/// Index into AllSteps for the current step
		/// </summary>
		public System.Nullable<System.Int32> CurrentStep { get; set; }
		
		/// <summary>
		/// Error message if the operation failed.
		/// </summary>
		public string ErrorMessage { get; set; }
	}
	
	/// <summary>
	/// Information about a fork ref.
	/// </summary>
	public class GitForkRef
	{
		
		public GitRepository Repository { get; set; }
	}
	
	/// <summary>
	/// Request to sync data between two forks.
	/// </summary>
	public class GitForkSyncRequest
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// Status information about a requested fork operation.
		/// </summary>
		public GitForkOperationStatusDetail DetailedStatus { get; set; }
		
		/// <summary>
		/// Unique identifier for the operation.
		/// </summary>
		public System.Nullable<System.Int32> OperationId { get; set; }
		
		/// <summary>
		/// Globally unique key for a repository.
		/// </summary>
		public GlobalGitRepositoryKey Source { get; set; }
		
		/// <summary>
		/// If supplied, the set of ref mappings to use when performing a "sync" or create. If missing, all refs will be synchronized.
		/// </summary>
		public SourceToTargetRef[] SourceToTargetRefs { get; set; }
		
		public System.Nullable<GitForkSyncRequestStatus> Status { get; set; }
	}
	
	/// <summary>
	/// Globally unique key for a repository.
	/// </summary>
	public class GlobalGitRepositoryKey
	{
		
		/// <summary>
		/// Team Project Collection ID of the collection for the repository.
		/// </summary>
		public string CollectionId { get; set; }
		
		/// <summary>
		/// Team Project ID of the project for the repository.
		/// </summary>
		public string ProjectId { get; set; }
		
		/// <summary>
		/// ID of the repository.
		/// </summary>
		public string RepositoryId { get; set; }
	}
	
	public class SourceToTargetRef
	{
		
		/// <summary>
		/// The source ref to copy. For example, refs/heads/master.
		/// </summary>
		public string SourceRef { get; set; }
		
		/// <summary>
		/// The target ref to update. For example, refs/heads/master.
		/// </summary>
		public string TargetRef { get; set; }
	}
	
	public enum GitForkSyncRequestStatus
	{
		
		queued = 0,
		
		inProgress = 1,
		
		completed = 2,
		
		failed = 3,
		
		abandoned = 4,
	}
	
	/// <summary>
	/// Parameters for creating a fork request
	/// </summary>
	public class GitForkSyncRequestParameters
	{
		
		/// <summary>
		/// Globally unique key for a repository.
		/// </summary>
		public GlobalGitRepositoryKey Source { get; set; }
		
		/// <summary>
		/// If supplied, the set of ref mappings to use when performing a "sync" or create. If missing, all refs will be synchronized.
		/// </summary>
		public SourceToTargetRef[] SourceToTargetRefs { get; set; }
	}
	
	public class GitForkTeamProjectReference
	{
	}
	
	public class GitImportFailedEvent
	{
		
		public string SourceRepositoryName { get; set; }
		
		public GitRepository TargetRepository { get; set; }
	}
	
	/// <summary>
	/// Parameter for creating a git import request when source is Git version control
	/// </summary>
	public class GitImportGitSource
	{
		
		/// <summary>
		/// Tells if this is a sync request or not
		/// </summary>
		public System.Nullable<System.Boolean> Overwrite { get; set; }
		
		/// <summary>
		/// Url for the source repo
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// A request to import data from a remote source control system.
	/// </summary>
	public class GitImportRequest
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// Additional status information about an import request.
		/// </summary>
		public GitImportStatusDetail DetailedStatus { get; set; }
		
		/// <summary>
		/// The unique identifier for this import request.
		/// </summary>
		public System.Nullable<System.Int32> ImportRequestId { get; set; }
		
		/// <summary>
		/// Parameters for creating an import request
		/// </summary>
		public GitImportRequestParameters Parameters { get; set; }
		
		public GitRepository Repository { get; set; }
		
		/// <summary>
		/// Current status of the import.
		/// </summary>
		public System.Nullable<GitImportRequestStatus> Status { get; set; }
		
		/// <summary>
		/// A link back to this import request resource.
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Additional status information about an import request.
	/// </summary>
	public class GitImportStatusDetail
	{
		
		/// <summary>
		/// All valid steps for the import process
		/// </summary>
		public string[] AllSteps { get; set; }
		
		/// <summary>
		/// Index into AllSteps for the current step
		/// </summary>
		public System.Nullable<System.Int32> CurrentStep { get; set; }
		
		/// <summary>
		/// Error message if the operation failed.
		/// </summary>
		public string ErrorMessage { get; set; }
	}
	
	/// <summary>
	/// Parameters for creating an import request
	/// </summary>
	public class GitImportRequestParameters
	{
		
		/// <summary>
		/// Option to delete service endpoint when import is done
		/// </summary>
		public System.Nullable<System.Boolean> DeleteServiceEndpointAfterImportIsDone { get; set; }
		
		/// <summary>
		/// Parameter for creating a git import request when source is Git version control
		/// </summary>
		public GitImportGitSource GitSource { get; set; }
		
		/// <summary>
		/// Service Endpoint for connection to external endpoint
		/// </summary>
		public string ServiceEndpointId { get; set; }
		
		/// <summary>
		/// Parameter for creating a git import request when source is tfvc version control
		/// </summary>
		public GitImportTfvcSource TfvcSource { get; set; }
	}
	
	/// <summary>
	/// Parameter for creating a git import request when source is tfvc version control
	/// </summary>
	public class GitImportTfvcSource
	{
		
		/// <summary>
		/// Set true to import History, false otherwise
		/// </summary>
		public System.Nullable<System.Boolean> ImportHistory { get; set; }
		
		/// <summary>
		/// Get history for last n days (max allowed value is 180 days)
		/// </summary>
		public System.Nullable<System.Int32> ImportHistoryDurationInDays { get; set; }
		
		/// <summary>
		/// Path which we want to import (this can be copied from Path Control in Explorer)
		/// </summary>
		public string Path { get; set; }
	}
	
	public enum GitImportRequestStatus
	{
		
		queued = 0,
		
		inProgress = 1,
		
		completed = 2,
		
		failed = 3,
		
		abandoned = 4,
	}
	
	public class GitImportSucceededEvent
	{
		
		public string SourceRepositoryName { get; set; }
		
		public GitRepository TargetRepository { get; set; }
	}
	
	public class GitItem
	{
		
		/// <summary>
		/// SHA1 of commit item was fetched at
		/// </summary>
		public string CommitId { get; set; }
		
		/// <summary>
		/// Type of object (Commit, Tree, Blob, Tag, ...)
		/// </summary>
		public System.Nullable<GitItemGitObjectType> GitObjectType { get; set; }
		
		/// <summary>
		/// Provides properties that describe a Git commit and associated metadata.
		/// </summary>
		public GitCommitRef LatestProcessedChange { get; set; }
		
		/// <summary>
		/// Git object id
		/// </summary>
		public string ObjectId { get; set; }
		
		/// <summary>
		/// Git object id
		/// </summary>
		public string OriginalObjectId { get; set; }
	}
	
	public enum GitItemGitObjectType
	{
		
		bad = 0,
		
		commit = 1,
		
		tree = 2,
		
		blob = 3,
		
		tag = 4,
		
		ext2 = 5,
		
		ofsDelta = 6,
		
		refDelta = 7,
	}
	
	public class GitItemDescriptor
	{
		
		/// <summary>
		/// Path to item
		/// </summary>
		public string Path { get; set; }
		
		/// <summary>
		/// Specifies whether to include children (OneLevel), all descendants (Full), or None
		/// </summary>
		public System.Nullable<GitItemDescriptorRecursionLevel> RecursionLevel { get; set; }
		
		/// <summary>
		/// Version string (interpretation based on VersionType defined in subclass
		/// </summary>
		public string Version { get; set; }
		
		/// <summary>
		/// Version modifiers (e.g. previous)
		/// </summary>
		public System.Nullable<GitItemDescriptorVersionOptions> VersionOptions { get; set; }
		
		/// <summary>
		/// How to interpret version (branch,tag,commit)
		/// </summary>
		public System.Nullable<GitItemDescriptorVersionType> VersionType { get; set; }
	}
	
	public enum GitItemDescriptorRecursionLevel
	{
		
		none = 0,
		
		oneLevel = 1,
		
		oneLevelPlusNestedEmptyFolders = 2,
		
		full = 3,
	}
	
	public enum GitItemDescriptorVersionOptions
	{
		
		none = 0,
		
		previousChange = 1,
		
		firstParent = 2,
	}
	
	public enum GitItemDescriptorVersionType
	{
		
		branch = 0,
		
		tag = 1,
		
		commit = 2,
	}
	
	public class GitItemRequestData
	{
		
		/// <summary>
		/// Whether to include metadata for all items
		/// </summary>
		public System.Nullable<System.Boolean> IncludeContentMetadata { get; set; }
		
		/// <summary>
		/// Whether to include the _links field on the shallow references
		/// </summary>
		public System.Nullable<System.Boolean> IncludeLinks { get; set; }
		
		/// <summary>
		/// Collection of items to fetch, including path, version, and recursion level
		/// </summary>
		public GitItemDescriptor[] ItemDescriptors { get; set; }
		
		/// <summary>
		/// Whether to include shallow ref to commit that last changed each item
		/// </summary>
		public System.Nullable<System.Boolean> LatestProcessedChange { get; set; }
	}
	
	public class GitLastChangeItem
	{
		
		/// <summary>
		/// Gets or sets the commit Id this item was modified most recently for the provided version.
		/// </summary>
		public string CommitId { get; set; }
		
		/// <summary>
		/// Gets or sets the path of the item.
		/// </summary>
		public string Path { get; set; }
	}
	
	public class GitLastChangeTreeItems
	{
		
		/// <summary>
		/// The list of commits referenced by Items, if they were requested.
		/// </summary>
		public GitCommitRef[] Commits { get; set; }
		
		/// <summary>
		/// The last change of items.
		/// </summary>
		public GitLastChangeItem[] Items { get; set; }
		
		/// <summary>
		/// The last explored time, in case the result is not comprehensive. Null otherwise.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastExploredTime { get; set; }
	}
	
	public class GitMerge
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// Status information about a requested merge operation.
		/// </summary>
		public GitMergeOperationStatusDetail DetailedStatus { get; set; }
		
		/// <summary>
		/// Unique identifier for the merge operation.
		/// </summary>
		public System.Nullable<System.Int32> MergeOperationId { get; set; }
		
		/// <summary>
		/// Status of the merge operation.
		/// </summary>
		public System.Nullable<GitMergeStatus> Status { get; set; }
	}
	
	/// <summary>
	/// Status information about a requested merge operation.
	/// </summary>
	public class GitMergeOperationStatusDetail
	{
		
		/// <summary>
		/// Error message if the operation failed.
		/// </summary>
		public string FailureMessage { get; set; }
		
		/// <summary>
		/// The commitId of the resultant merge commit.
		/// </summary>
		public string MergeCommitId { get; set; }
	}
	
	public enum GitMergeStatus
	{
		
		queued = 0,
		
		inProgress = 1,
		
		completed = 2,
		
		failed = 3,
		
		abandoned = 4,
	}
	
	/// <summary>
	/// Parameters required for performing git merge.
	/// </summary>
	public class GitMergeParameters
	{
		
		/// <summary>
		/// Comment or message of the commit.
		/// </summary>
		public string Comment { get; set; }
		
		/// <summary>
		/// An enumeration of the parent commit IDs for the merge  commit.
		/// </summary>
		public string[] Parents { get; set; }
	}
	
	public class GitPathToItemsCollection
	{
		
		public System.Collections.Generic.Dictionary<string, GitItem[]> Items { get; set; }
	}
	
	public class GitPolicyConfigurationResponse
	{
		
		/// <summary>
		/// The HTTP client methods find the continuation token header in the response and populate this field.
		/// </summary>
		public string ContinuationToken { get; set; }
		
		public PolicyConfiguration[] PolicyConfigurations { get; set; }
	}
	
	/// <summary>
	/// The full policy configuration with settings.
	/// </summary>
	public class PolicyConfiguration
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		public IdentityRef CreatedBy { get; set; }
		
		/// <summary>
		/// The date and time when the policy was created.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedDate { get; set; }
		
		/// <summary>
		/// Indicates whether the policy is blocking.
		/// </summary>
		public System.Nullable<System.Boolean> IsBlocking { get; set; }
		
		/// <summary>
		/// Indicates whether the policy has been (soft) deleted.
		/// </summary>
		public System.Nullable<System.Boolean> IsDeleted { get; set; }
		
		/// <summary>
		/// Indicates whether the policy is enabled.
		/// </summary>
		public System.Nullable<System.Boolean> IsEnabled { get; set; }
		
		/// <summary>
		/// If set, this policy requires "Manage Enterprise Policies" permission to create, edit, or delete.
		/// </summary>
		public System.Nullable<System.Boolean> IsEnterpriseManaged { get; set; }
		
		/// <summary>
		/// The policy configuration settings.
		/// </summary>
		public string Settings { get; set; }
	}
	
	/// <summary>
	/// Represents all the data associated with a pull request.
	/// </summary>
	public class GitPullRequest
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// A string which uniquely identifies this pull request. To generate an artifact ID for a pull request, use this template: ```vstfs:///Git/PullRequestId/{projectId}/{repositoryId}/{pullRequestId}```
		/// </summary>
		public string ArtifactId { get; set; }
		
		public IdentityRef AutoCompleteSetBy { get; set; }
		
		public IdentityRef ClosedBy { get; set; }
		
		/// <summary>
		/// The date when the pull request was closed (completed, abandoned, or merged externally).
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ClosedDate { get; set; }
		
		/// <summary>
		/// The code review ID of the pull request. Used internally.
		/// </summary>
		public System.Nullable<System.Int32> CodeReviewId { get; set; }
		
		/// <summary>
		/// The commits contained in the pull request.
		/// </summary>
		public GitCommitRef[] Commits { get; set; }
		
		/// <summary>
		/// Preferences about how the pull request should be completed.
		/// </summary>
		public GitPullRequestCompletionOptions CompletionOptions { get; set; }
		
		/// <summary>
		/// The most recent date at which the pull request entered the queue to be completed. Used internally.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CompletionQueueTime { get; set; }
		
		public IdentityRef CreatedBy { get; set; }
		
		/// <summary>
		/// The date when the pull request was created.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		/// <summary>
		/// The description of the pull request.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Information about a fork ref.
		/// </summary>
		public GitForkRef ForkSource { get; set; }
		
		/// <summary>
		/// Draft / WIP pull request.
		/// </summary>
		public System.Nullable<System.Boolean> IsDraft { get; set; }
		
		/// <summary>
		/// The labels associated with the pull request.
		/// </summary>
		public WebApiTagDefinition[] Labels { get; set; }
		
		/// <summary>
		/// Provides properties that describe a Git commit and associated metadata.
		/// </summary>
		public GitCommitRef LastMergeCommit { get; set; }
		
		/// <summary>
		/// Provides properties that describe a Git commit and associated metadata.
		/// </summary>
		public GitCommitRef LastMergeSourceCommit { get; set; }
		
		/// <summary>
		/// Provides properties that describe a Git commit and associated metadata.
		/// </summary>
		public GitCommitRef LastMergeTargetCommit { get; set; }
		
		/// <summary>
		/// If set, pull request merge failed for this reason.
		/// </summary>
		public string MergeFailureMessage { get; set; }
		
		/// <summary>
		/// The type of failure (if any) of the pull request merge.
		/// </summary>
		public System.Nullable<GitPullRequestMergeFailureType> MergeFailureType { get; set; }
		
		/// <summary>
		/// The ID of the job used to run the pull request merge. Used internally.
		/// </summary>
		public string MergeId { get; set; }
		
		/// <summary>
		/// The options which are used when a pull request merge is created.
		/// </summary>
		public GitPullRequestMergeOptions MergeOptions { get; set; }
		
		/// <summary>
		/// The current status of the pull request merge.
		/// </summary>
		public System.Nullable<GitPullRequestMergeStatus> MergeStatus { get; set; }
		
		/// <summary>
		/// The ID of the pull request.
		/// </summary>
		public System.Nullable<System.Int32> PullRequestId { get; set; }
		
		/// <summary>
		/// Used internally.
		/// </summary>
		public string RemoteUrl { get; set; }
		
		public GitRepository Repository { get; set; }
		
		/// <summary>
		/// A list of reviewers on the pull request along with the state of their votes.
		/// </summary>
		public IdentityRefWithVote[] Reviewers { get; set; }
		
		/// <summary>
		/// The name of the source branch of the pull request.
		/// </summary>
		public string SourceRefName { get; set; }
		
		/// <summary>
		/// The status of the pull request.
		/// </summary>
		public System.Nullable<GitPullRequestStatus> Status { get; set; }
		
		/// <summary>
		/// If true, this pull request supports multiple iterations. Iteration support means individual pushes to the source branch of the pull request can be reviewed and comments left in one iteration will be tracked across future iterations.
		/// </summary>
		public System.Nullable<System.Boolean> SupportsIterations { get; set; }
		
		/// <summary>
		/// The name of the target branch of the pull request.
		/// </summary>
		public string TargetRefName { get; set; }
		
		/// <summary>
		/// The title of the pull request.
		/// </summary>
		public string Title { get; set; }
		
		/// <summary>
		/// Used internally.
		/// </summary>
		public string Url { get; set; }
		
		/// <summary>
		/// Any work item references associated with this pull request.
		/// </summary>
		public ResourceRef[] WorkItemRefs { get; set; }
	}
	
	/// <summary>
	/// Preferences about how the pull request should be completed.
	/// </summary>
	public class GitPullRequestCompletionOptions
	{
		
		/// <summary>
		/// List of any policy configuration Id's which auto-complete should not wait for. Only applies to optional policies (isBlocking == false). Auto-complete always waits for required policies (isBlocking == true).
		/// </summary>
		public int[] AutoCompleteIgnoreConfigIds { get; set; }
		
		/// <summary>
		/// If true, policies will be explicitly bypassed while the pull request is completed.
		/// </summary>
		public System.Nullable<System.Boolean> BypassPolicy { get; set; }
		
		/// <summary>
		/// If policies are bypassed, this reason is stored as to why bypass was used.
		/// </summary>
		public string BypassReason { get; set; }
		
		/// <summary>
		/// If true, the source branch of the pull request will be deleted after completion.
		/// </summary>
		public System.Nullable<System.Boolean> DeleteSourceBranch { get; set; }
		
		/// <summary>
		/// If set, this will be used as the commit message of the merge commit.
		/// </summary>
		public string MergeCommitMessage { get; set; }
		
		/// <summary>
		/// Specify the strategy used to merge the pull request during completion. If MergeStrategy is not set to any value, a no-FF merge will be created if SquashMerge == false. If MergeStrategy is not set to any value, the pull request commits will be squashed if SquashMerge == true. The SquashMerge property is deprecated. It is recommended that you explicitly set MergeStrategy in all cases. If an explicit value is provided for MergeStrategy, the SquashMerge property will be ignored.
		/// </summary>
		public System.Nullable<GitPullRequestCompletionOptionsMergeStrategy> MergeStrategy { get; set; }
		
		/// <summary>
		/// SquashMerge is deprecated. You should explicitly set the value of MergeStrategy. If MergeStrategy is set to any value, the SquashMerge value will be ignored. If MergeStrategy is not set, the merge strategy will be no-fast-forward if this flag is false, or squash if true.
		/// </summary>
		public System.Nullable<System.Boolean> SquashMerge { get; set; }
		
		/// <summary>
		/// If true, we will attempt to transition any work items linked to the pull request into the next logical state (i.e. Active -> Resolved)
		/// </summary>
		public System.Nullable<System.Boolean> TransitionWorkItems { get; set; }
		
		/// <summary>
		/// If true, the current completion attempt was triggered via auto-complete. Used internally.
		/// </summary>
		public System.Nullable<System.Boolean> TriggeredByAutoComplete { get; set; }
	}
	
	public enum GitPullRequestCompletionOptionsMergeStrategy
	{
		
		noFastForward = 0,
		
		squash = 1,
		
		rebase = 2,
		
		rebaseMerge = 3,
	}
	
	/// <summary>
	/// The representation of a tag definition which is sent across the wire.
	/// </summary>
	public class WebApiTagDefinition
	{
		
		/// <summary>
		/// Whether or not the tag definition is active.
		/// </summary>
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// ID of the tag definition.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the tag definition.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Resource URL for the Tag Definition.
		/// </summary>
		public string Url { get; set; }
	}
	
	public enum GitPullRequestMergeFailureType
	{
		
		none = 0,
		
		unknown = 1,
		
		caseSensitive = 2,
		
		objectTooLarge = 3,
	}
	
	/// <summary>
	/// The options which are used when a pull request merge is created.
	/// </summary>
	public class GitPullRequestMergeOptions
	{
		
		/// <summary>
		/// If true, conflict resolutions applied during the merge will be put in separate commits to preserve authorship info for git blame, etc.
		/// </summary>
		public System.Nullable<System.Boolean> ConflictAuthorshipCommits { get; set; }
		
		public System.Nullable<System.Boolean> DetectRenameFalsePositives { get; set; }
		
		/// <summary>
		/// If true, rename detection will not be performed during the merge.
		/// </summary>
		public System.Nullable<System.Boolean> DisableRenames { get; set; }
	}
	
	public enum GitPullRequestMergeStatus
	{
		
		notSet = 0,
		
		queued = 1,
		
		conflicts = 2,
		
		succeeded = 3,
		
		rejectedByPolicy = 4,
		
		failure = 5,
	}
	
	/// <summary>
	/// Identity information including a vote on a pull request.
	/// </summary>
	public class IdentityRefWithVote
	{
		
		/// <summary>
		/// Indicates if this reviewer is flagged for attention on this pull request.
		/// </summary>
		public System.Nullable<System.Boolean> IsFlagged { get; set; }
		
		/// <summary>
		/// Indicates if this is a required reviewer for this pull request. <br /> Branches can have policies that require particular reviewers are required for pull requests.
		/// </summary>
		public System.Nullable<System.Boolean> IsRequired { get; set; }
		
		/// <summary>
		/// URL to retrieve information about this identity
		/// </summary>
		public string ReviewerUrl { get; set; }
		
		/// <summary>
		/// Vote on a pull request:<br /> 10 - approved 5 - approved with suggestions 0 - no vote -5 - waiting for author -10 - rejected
		/// </summary>
		public string Vote { get; set; }
		
		/// <summary>
		/// Groups or teams that that this reviewer contributed to. <br /> Groups and teams can be reviewers on pull requests but can not vote directly.  When a member of the group or team votes, that vote is rolled up into the group or team vote.  VotedFor is a list of such votes.
		/// </summary>
		public IdentityRefWithVote[] VotedFor { get; set; }
	}
	
	public enum GitPullRequestStatus
	{
		
		notSet = 0,
		
		active = 1,
		
		abandoned = 2,
		
		completed = 3,
		
		all = 4,
	}
	
	/// <summary>
	/// Change made in a pull request.
	/// </summary>
	public class GitPullRequestChange
	{
		
		/// <summary>
		/// ID used to track files through multiple changes.
		/// </summary>
		public System.Nullable<System.Int32> ChangeTrackingId { get; set; }
	}
	
	/// <summary>
	/// Represents a comment thread of a pull request. A thread contains meta data about the file it was left on (if any) along with one or more comments (an initial comment and the subsequent replies).
	/// </summary>
	public class GitPullRequestCommentThread
	{
		
		/// <summary>
		/// Comment thread context contains details about what diffs were being viewed at the time of thread creation and whether or not the thread has been tracked from that original diff.
		/// </summary>
		public GitPullRequestCommentThreadContext PullRequestThreadContext { get; set; }
	}
	
	/// <summary>
	/// Comment thread context contains details about what diffs were being viewed at the time of thread creation and whether or not the thread has been tracked from that original diff.
	/// </summary>
	public class GitPullRequestCommentThreadContext
	{
		
		/// <summary>
		/// Used to track a comment across iterations. This value can be found by looking at the iteration's changes list. Must be set for pull requests with iteration support. Otherwise, it's not required for 'legacy' pull requests.
		/// </summary>
		public System.Nullable<System.Int32> ChangeTrackingId { get; set; }
		
		/// <summary>
		/// Comment iteration context is used to identify which diff was being viewed when the thread was created.
		/// </summary>
		public CommentIterationContext IterationContext { get; set; }
		
		/// <summary>
		/// Comment tracking criteria is used to identify which iteration context the thread has been tracked to (if any) along with some detail about the original position and filename.
		/// </summary>
		public CommentTrackingCriteria TrackingCriteria { get; set; }
	}
	
	/// <summary>
	/// Provides properties that describe a Git pull request iteration. Iterations are created as a result of creating and pushing updates to a pull request.
	/// </summary>
	public class GitPullRequestIteration
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		public IdentityRef Author { get; set; }
		
		/// <summary>
		/// Changes included with the pull request iteration.
		/// </summary>
		public GitPullRequestChange[] ChangeList { get; set; }
		
		/// <summary>
		/// The commits included with the pull request iteration.
		/// </summary>
		public GitCommitRef[] Commits { get; set; }
		
		/// <summary>
		/// Provides properties that describe a Git commit and associated metadata.
		/// </summary>
		public GitCommitRef CommonRefCommit { get; set; }
		
		/// <summary>
		/// The creation date of the pull request iteration.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedDate { get; set; }
		
		/// <summary>
		/// Description of the pull request iteration.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Indicates if the Commits property contains a truncated list of commits in this pull request iteration.
		/// </summary>
		public System.Nullable<System.Boolean> HasMoreCommits { get; set; }
		
		/// <summary>
		/// ID of the pull request iteration. Iterations are created as a result of creating and pushing updates to a pull request.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// If the iteration reason is Retarget, this is the refName of the new target
		/// </summary>
		public string NewTargetRefName { get; set; }
		
		/// <summary>
		/// If the iteration reason is Retarget, this is the original target refName
		/// </summary>
		public string OldTargetRefName { get; set; }
		
		public GitPushRef Push { get; set; }
		
		/// <summary>
		/// The reason for which the pull request iteration was created.
		/// </summary>
		public System.Nullable<GitPullRequestIterationReason> Reason { get; set; }
		
		/// <summary>
		/// Provides properties that describe a Git commit and associated metadata.
		/// </summary>
		public GitCommitRef SourceRefCommit { get; set; }
		
		/// <summary>
		/// Provides properties that describe a Git commit and associated metadata.
		/// </summary>
		public GitCommitRef TargetRefCommit { get; set; }
		
		/// <summary>
		/// The updated date of the pull request iteration.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> UpdatedDate { get; set; }
	}
	
	public enum GitPullRequestIterationReason
	{
		
		push = 0,
		
		forcePush = 1,
		
		create = 2,
		
		rebase = 3,
		
		unknown = 4,
		
		retarget = 5,
	}
	
	/// <summary>
	/// Collection of changes made in a pull request.
	/// </summary>
	public class GitPullRequestIterationChanges
	{
		
		/// <summary>
		/// Changes made in the iteration.
		/// </summary>
		public GitPullRequestChange[] ChangeEntries { get; set; }
		
		/// <summary>
		/// Value to specify as skip to get the next page of changes.  This will be zero if there are no more changes.
		/// </summary>
		public System.Nullable<System.Int32> NextSkip { get; set; }
		
		/// <summary>
		/// Value to specify as top to get the next page of changes.  This will be zero if there are no more changes.
		/// </summary>
		public System.Nullable<System.Int32> NextTop { get; set; }
	}
	
	/// <summary>
	/// A set of pull request queries and their results.
	/// </summary>
	public class GitPullRequestQuery
	{
		
		/// <summary>
		/// The queries to perform.
		/// </summary>
		public GitPullRequestQueryInput[] Queries { get; set; }
		
		/// <summary>
		/// The results of the queries. This matches the QueryInputs list so Results[n] are the results of QueryInputs[n]. Each entry in the list is a dictionary of commit->pull requests.
		/// </summary>
		public string[] Results { get; set; }
	}
	
	/// <summary>
	/// Pull request query input parameters.
	/// </summary>
	public class GitPullRequestQueryInput
	{
		
		/// <summary>
		/// The list of commit IDs to search for.
		/// </summary>
		public string[] Items { get; set; }
		
		/// <summary>
		/// The type of query to perform.
		/// </summary>
		public System.Nullable<GitPullRequestQueryInputType> Type { get; set; }
	}
	
	public enum GitPullRequestQueryInputType
	{
		
		notSet = 0,
		
		lastMergeCommit = 1,
		
		commit = 2,
	}
	
	public class GitPullRequestReviewFileContentInfo
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// The file change path.
		/// </summary>
		public string Path { get; set; }
		
		/// <summary>
		/// Content hash of on-disk representation of file content. Its calculated by the client by using SHA1 hash function. Ensure that uploaded file has same encoding as in source control.
		/// </summary>
		public string ShA1Hash { get; set; }
	}
	
	/// <summary>
	/// Pull requests can be searched for matching this criteria.
	/// </summary>
	public class GitPullRequestSearchCriteria
	{
		
		/// <summary>
		/// If set, search for pull requests that were created by this identity.
		/// </summary>
		public string CreatorId { get; set; }
		
		/// <summary>
		/// Whether to include the _links field on the shallow references
		/// </summary>
		public System.Nullable<System.Boolean> IncludeLinks { get; set; }
		
		/// <summary>
		/// If set, search for pull requests whose target branch is in this repository.
		/// </summary>
		public string RepositoryId { get; set; }
		
		/// <summary>
		/// If set, search for pull requests that have this identity as a reviewer.
		/// </summary>
		public string ReviewerId { get; set; }
		
		/// <summary>
		/// If set, search for pull requests from this branch.
		/// </summary>
		public string SourceRefName { get; set; }
		
		/// <summary>
		/// If set, search for pull requests whose source branch is in this repository.
		/// </summary>
		public string SourceRepositoryId { get; set; }
		
		/// <summary>
		/// If set, search for pull requests that are in this state. Defaults to Active if unset.
		/// </summary>
		public System.Nullable<GitPullRequestSearchCriteriaStatus> Status { get; set; }
		
		/// <summary>
		/// If set, search for pull requests into this branch.
		/// </summary>
		public string TargetRefName { get; set; }
	}
	
	public enum GitPullRequestSearchCriteriaStatus
	{
		
		notSet = 0,
		
		active = 1,
		
		abandoned = 2,
		
		completed = 3,
		
		all = 4,
	}
	
	public class GitPush
	{
		
		public GitCommitRef[] Commits { get; set; }
		
		public GitRefUpdate[] RefUpdates { get; set; }
		
		public GitRepository Repository { get; set; }
	}
	
	public class GitRefUpdate
	{
		
		public System.Nullable<System.Boolean> IsLocked { get; set; }
		
		public string Name { get; set; }
		
		public string NewObjectId { get; set; }
		
		public string OldObjectId { get; set; }
		
		public string RepositoryId { get; set; }
	}
	
	public class GitPushEventData
	{
		
		public string AfterId { get; set; }
		
		public string BeforeId { get; set; }
		
		public string Branch { get; set; }
		
		public GitCommit[] Commits { get; set; }
		
		public GitRepository Repository { get; set; }
	}
	
	public class GitPushSearchCriteria
	{
		
		public System.Nullable<System.DateTimeOffset> FromDate { get; set; }
		
		/// <summary>
		/// Whether to include the _links field on the shallow references
		/// </summary>
		public System.Nullable<System.Boolean> IncludeLinks { get; set; }
		
		public System.Nullable<System.Boolean> IncludeRefUpdates { get; set; }
		
		public string PusherId { get; set; }
		
		public string RefName { get; set; }
		
		public System.Nullable<System.DateTimeOffset> ToDate { get; set; }
	}
	
	public class GitQueryBranchStatsCriteria
	{
		
		public GitVersionDescriptor BaseCommit { get; set; }
		
		public GitVersionDescriptor[] TargetCommits { get; set; }
	}
	
	public class GitVersionDescriptor
	{
		
		/// <summary>
		/// Version string identifier (name of tag/branch, SHA1 of commit)
		/// </summary>
		public string Version { get; set; }
		
		/// <summary>
		/// Version options - Specify additional modifiers to version (e.g Previous)
		/// </summary>
		public System.Nullable<GitVersionDescriptorVersionOptions> VersionOptions { get; set; }
		
		/// <summary>
		/// Version type (branch, tag, or commit). Determines how Id is interpreted
		/// </summary>
		public System.Nullable<GitVersionDescriptorVersionType> VersionType { get; set; }
	}
	
	public enum GitVersionDescriptorVersionOptions
	{
		
		none = 0,
		
		previousChange = 1,
		
		firstParent = 2,
	}
	
	public enum GitVersionDescriptorVersionType
	{
		
		branch = 0,
		
		tag = 1,
		
		commit = 2,
	}
	
	public class GitQueryCommitsCriteria
	{
		
		/// <summary>
		/// Number of entries to skip
		/// </summary>
		public System.Nullable<System.Int32> Skip { get; set; }
		
		/// <summary>
		/// Maximum number of entries to retrieve
		/// </summary>
		public System.Nullable<System.Int32> Top { get; set; }
		
		/// <summary>
		/// Alias or display name of the author
		/// </summary>
		public string Author { get; set; }
		
		public GitVersionDescriptor CompareVersion { get; set; }
		
		/// <summary>
		/// Only applies when an itemPath is specified. This determines whether to exclude delete entries of the specified path.
		/// </summary>
		public System.Nullable<System.Boolean> ExcludeDeletes { get; set; }
		
		/// <summary>
		/// If provided, a lower bound for filtering commits alphabetically
		/// </summary>
		public string FromCommitId { get; set; }
		
		/// <summary>
		/// If provided, only include history entries created after this date (string)
		/// </summary>
		public string FromDate { get; set; }
		
		/// <summary>
		/// What Git history mode should be used. This only applies to the search criteria when Ids = null and an itemPath is specified.
		/// </summary>
		public System.Nullable<GitQueryCommitsCriteriaHistoryMode> HistoryMode { get; set; }
		
		/// <summary>
		/// If provided, specifies the exact commit ids of the commits to fetch. May not be combined with other parameters.
		/// </summary>
		public string[] Ids { get; set; }
		
		/// <summary>
		/// Whether to include the _links field on the shallow references
		/// </summary>
		public System.Nullable<System.Boolean> IncludeLinks { get; set; }
		
		/// <summary>
		/// Whether to include the push information
		/// </summary>
		public System.Nullable<System.Boolean> IncludePushData { get; set; }
		
		/// <summary>
		/// Whether to include the image Url for committers and authors
		/// </summary>
		public System.Nullable<System.Boolean> IncludeUserImageUrl { get; set; }
		
		/// <summary>
		/// Whether to include linked work items
		/// </summary>
		public System.Nullable<System.Boolean> IncludeWorkItems { get; set; }
		
		/// <summary>
		/// Path of item to search under
		/// </summary>
		public string ItemPath { get; set; }
		
		public GitVersionDescriptor ItemVersion { get; set; }
		
		/// <summary>
		/// If enabled, this option will ignore the itemVersion and compareVersion parameters
		/// </summary>
		public System.Nullable<System.Boolean> ShowOldestCommitsFirst { get; set; }
		
		/// <summary>
		/// If provided, an upper bound for filtering commits alphabetically
		/// </summary>
		public string ToCommitId { get; set; }
		
		/// <summary>
		/// If provided, only include history entries created before this date (string)
		/// </summary>
		public string ToDate { get; set; }
		
		/// <summary>
		/// Alias or display name of the committer
		/// </summary>
		public string User { get; set; }
	}
	
	public enum GitQueryCommitsCriteriaHistoryMode
	{
		
		simplifiedHistory = 0,
		
		firstParent = 1,
		
		fullHistory = 2,
		
		fullHistorySimplifyMerges = 3,
	}
	
	public class GitQueryRefsCriteria
	{
		
		/// <summary>
		/// List of commit Ids to be searched
		/// </summary>
		public string[] CommitIds { get; set; }
		
		/// <summary>
		/// List of complete or partial names for refs to be searched
		/// </summary>
		public string[] RefNames { get; set; }
		
		/// <summary>
		/// Type of search on refNames, if provided
		/// </summary>
		public System.Nullable<GitQueryRefsCriteriaSearchType> SearchType { get; set; }
	}
	
	public enum GitQueryRefsCriteriaSearchType
	{
		
		exact = 0,
		
		startsWith = 1,
		
		contains = 2,
	}
	
	public class GitRecycleBinRepositoryDetails
	{
		
		/// <summary>
		/// Setting to false will undo earlier deletion and restore the repository.
		/// </summary>
		public System.Nullable<System.Boolean> Deleted { get; set; }
	}
	
	public class GitRefFavorite
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		public System.Nullable<System.Int32> Id { get; set; }
		
		public string IdentityId { get; set; }
		
		public string Name { get; set; }
		
		public string RepositoryId { get; set; }
		
		public System.Nullable<GitRefFavoriteType> Type { get; set; }
		
		public string Url { get; set; }
	}
	
	public enum GitRefFavoriteType
	{
		
		invalid = 0,
		
		folder = 1,
		
		_ref = 2,
	}
	
	public class GitRefUpdateResult
	{
		
		/// <summary>
		/// Custom message for the result object For instance, Reason for failing.
		/// </summary>
		public string CustomMessage { get; set; }
		
		/// <summary>
		/// Whether the ref is locked or not
		/// </summary>
		public System.Nullable<System.Boolean> IsLocked { get; set; }
		
		/// <summary>
		/// Ref name
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// New object ID
		/// </summary>
		public string NewObjectId { get; set; }
		
		/// <summary>
		/// Old object ID
		/// </summary>
		public string OldObjectId { get; set; }
		
		/// <summary>
		/// Name of the plugin that rejected the updated.
		/// </summary>
		public string RejectedBy { get; set; }
		
		/// <summary>
		/// Repository ID
		/// </summary>
		public string RepositoryId { get; set; }
		
		/// <summary>
		/// True if the ref update succeeded, false otherwise
		/// </summary>
		public System.Nullable<System.Boolean> Success { get; set; }
		
		/// <summary>
		/// Status of the update from the TFS server.
		/// </summary>
		public System.Nullable<GitRefUpdateResultUpdateStatus> UpdateStatus { get; set; }
	}
	
	public enum GitRefUpdateResultUpdateStatus
	{
		
		succeeded = 0,
		
		forcePushRequired = 1,
		
		staleOldObjectId = 2,
		
		invalidRefName = 3,
		
		unprocessed = 4,
		
		unresolvableToCommit = 5,
		
		writePermissionRequired = 6,
		
		manageNotePermissionRequired = 7,
		
		createBranchPermissionRequired = 8,
		
		createTagPermissionRequired = 9,
		
		rejectedByPlugin = 10,
		
		locked = 11,
		
		refNameConflict = 12,
		
		rejectedByPolicy = 13,
		
		succeededNonExistentRef = 14,
		
		succeededCorruptRef = 15,
	}
	
	public class GitRepositoryCreateOptions
	{
		
		public string Name { get; set; }
		
		public GitRepositoryRef ParentRepository { get; set; }
		
		/// <summary>
		/// Represents a shallow reference to a TeamProject.
		/// </summary>
		public TeamProjectReference Project { get; set; }
	}
	
	public class GitRepositoryStats
	{
		
		public System.Nullable<System.Int32> ActivePullRequestsCount { get; set; }
		
		public System.Nullable<System.Int32> BranchesCount { get; set; }
		
		public System.Nullable<System.Int32> CommitsCount { get; set; }
		
		public string RepositoryId { get; set; }
	}
	
	public class GitResolution
	{
		
		public IdentityRef Author { get; set; }
	}
	
	public class GitRevert
	{
		
		public System.Nullable<System.Int32> RevertId { get; set; }
	}
	
	/// <summary>
	/// An object describing the git suggestion.  Git suggestions are currently limited to suggested pull requests.
	/// </summary>
	public class GitSuggestion
	{
		
		/// <summary>
		/// Specific properties describing the suggestion.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, object> Properties { get; set; }
		
		/// <summary>
		/// The type of suggestion (e.g. pull request).
		/// </summary>
		public string Type { get; set; }
	}
	
	public class GitTargetVersionDescriptor
	{
		
		/// <summary>
		/// Version string identifier (name of tag/branch, SHA1 of commit)
		/// </summary>
		public string TargetVersion { get; set; }
		
		/// <summary>
		/// Version options - Specify additional modifiers to version (e.g Previous)
		/// </summary>
		public System.Nullable<GitTargetVersionDescriptorTargetVersionOptions> TargetVersionOptions { get; set; }
		
		/// <summary>
		/// Version type (branch, tag, or commit). Determines how Id is interpreted
		/// </summary>
		public System.Nullable<GitTargetVersionDescriptorTargetVersionType> TargetVersionType { get; set; }
	}
	
	public enum GitTargetVersionDescriptorTargetVersionOptions
	{
		
		none = 0,
		
		previousChange = 1,
		
		firstParent = 2,
	}
	
	public enum GitTargetVersionDescriptorTargetVersionType
	{
		
		branch = 0,
		
		tag = 1,
		
		commit = 2,
	}
	
	public class GitTreeDiff
	{
		
		/// <summary>
		/// ObjectId of the base tree of this diff.
		/// </summary>
		public string BaseTreeId { get; set; }
		
		/// <summary>
		/// List of tree entries that differ between the base and target tree.  Renames and object type changes are returned as a delete for the old object and add for the new object.  If a continuation token is returned in the response header, some tree entries are yet to be processed and may yield more diff entries. If the continuation token is not returned all the diff entries have been included in this response.
		/// </summary>
		public GitTreeDiffEntry[] DiffEntries { get; set; }
		
		/// <summary>
		/// ObjectId of the target tree of this diff.
		/// </summary>
		public string TargetTreeId { get; set; }
		
		/// <summary>
		/// REST Url to this resource.
		/// </summary>
		public string Url { get; set; }
	}
	
	public class GitTreeDiffEntry
	{
		
		/// <summary>
		/// SHA1 hash of the object in the base tree, if it exists. Will be null in case of adds.
		/// </summary>
		public string BaseObjectId { get; set; }
		
		/// <summary>
		/// Type of change that affected this entry.
		/// </summary>
		public System.Nullable<GitTreeDiffEntryChangeType> ChangeType { get; set; }
		
		/// <summary>
		/// Object type of the tree entry. Blob, Tree or Commit("submodule")
		/// </summary>
		public System.Nullable<GitTreeDiffEntryObjectType> ObjectType { get; set; }
		
		/// <summary>
		/// Relative path in base and target trees.
		/// </summary>
		public string Path { get; set; }
		
		/// <summary>
		/// SHA1 hash of the object in the target tree, if it exists. Will be null in case of deletes.
		/// </summary>
		public string TargetObjectId { get; set; }
	}
	
	public enum GitTreeDiffEntryChangeType
	{
		
		none = 0,
		
		add = 1,
		
		edit = 2,
		
		encoding = 3,
		
		rename = 4,
		
		_delete = 5,
		
		undelete = 6,
		
		branch = 7,
		
		merge = 8,
		
		_lock = 9,
		
		rollback = 10,
		
		sourceRename = 11,
		
		targetRename = 12,
		
		property = 13,
		
		all = 14,
	}
	
	public enum GitTreeDiffEntryObjectType
	{
		
		bad = 0,
		
		commit = 1,
		
		tree = 2,
		
		blob = 3,
		
		tag = 4,
		
		ext2 = 5,
		
		ofsDelta = 6,
		
		refDelta = 7,
	}
	
	public class GitTreeDiffResponse
	{
		
		/// <summary>
		/// The HTTP client methods find the continuation token header in the response and populate this field.
		/// </summary>
		public string[] ContinuationToken { get; set; }
		
		public GitTreeDiff TreeDiff { get; set; }
	}
	
	public class GraphSubjectBase
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
		/// </summary>
		public string Descriptor { get; set; }
		
		/// <summary>
		/// This is the non-unique display name of the graph subject. To change this field, you must alter its value in the source provider.
		/// </summary>
		public string DisplayName { get; set; }
		
		/// <summary>
		/// This url is the full route to the source resource of this graph subject.
		/// </summary>
		public string Url { get; set; }
	}
	
	public class HistoryEntry
	{
		
		public ChangeList ChangeList { get; set; }
		
		/// <summary>
		/// The change made to the item from this change list (only relevant for File history, not folders)
		/// </summary>
		public System.Nullable<HistoryEntryItemChangeType> ItemChangeType { get; set; }
		
		/// <summary>
		/// The path of the item at this point in history (only relevant for File history, not folders)
		/// </summary>
		public string ServerItem { get; set; }
	}
	
	public enum HistoryEntryItemChangeType
	{
		
		none = 0,
		
		add = 1,
		
		edit = 2,
		
		encoding = 3,
		
		rename = 4,
		
		_delete = 5,
		
		undelete = 6,
		
		branch = 7,
		
		merge = 8,
		
		_lock = 9,
		
		rollback = 10,
		
		sourceRename = 11,
		
		targetRename = 12,
		
		property = 13,
		
		all = 14,
	}
	
	public class ImportRepositoryValidation
	{
		
		/// <summary>
		/// Parameter for creating a git import request when source is Git version control
		/// </summary>
		public GitImportGitSource GitSource { get; set; }
		
		public string Password { get; set; }
		
		/// <summary>
		/// Parameter for creating a git import request when source is tfvc version control
		/// </summary>
		public GitImportTfvcSource TfvcSource { get; set; }
		
		public string Username { get; set; }
	}
	
	public class IncludedGitCommit
	{
		
		public string CommitId { get; set; }
		
		public System.Nullable<System.DateTimeOffset> CommitTime { get; set; }
		
		public string[] ParentCommitIds { get; set; }
		
		public string RepositoryId { get; set; }
	}
	
	/// <summary>
	/// Real time event (SignalR) for IsDraft update on a pull request
	/// </summary>
	public class IsDraftUpdatedEvent
	{
	}
	
	/// <summary>
	/// Optional details to include when returning an item model
	/// </summary>
	public class ItemDetailsOptions
	{
		
		/// <summary>
		/// If true, include metadata about the file type
		/// </summary>
		public System.Nullable<System.Boolean> IncludeContentMetadata { get; set; }
		
		/// <summary>
		/// Specifies whether to include children (OneLevel), all descendants (Full) or None for folder items
		/// </summary>
		public System.Nullable<ItemDetailsOptionsRecursionLevel> RecursionLevel { get; set; }
	}
	
	public enum ItemDetailsOptionsRecursionLevel
	{
		
		none = 0,
		
		oneLevel = 1,
		
		oneLevelPlusNestedEmptyFolders = 2,
		
		full = 3,
	}
	
	public class ItemModel
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		public string Content { get; set; }
		
		public FileContentMetadata ContentMetadata { get; set; }
		
		public System.Nullable<System.Boolean> IsFolder { get; set; }
		
		public System.Nullable<System.Boolean> IsSymLink { get; set; }
		
		public string Path { get; set; }
		
		public string Url { get; set; }
	}
	
	/// <summary>
	/// The JSON model for JSON Patch Operations
	/// </summary>
	public class JsonPatchDocument
	{
	}
	
	/// <summary>
	/// The JSON model for a JSON Patch operation
	/// </summary>
	public class JsonPatchOperation
	{
		
		/// <summary>
		/// The path to copy from for the Move/Copy operation.
		/// </summary>
		public string From { get; set; }
		
		/// <summary>
		/// The patch operation
		/// </summary>
		public System.Nullable<JsonPatchOperationOp> Op { get; set; }
		
		/// <summary>
		/// The path for the operation. In the case of an array, a zero based index can be used to specify the position in the array (e.g. /biscuits/0/name). The "-" character can be used instead of an index to insert at the end of the array (e.g. /biscuits/-).
		/// </summary>
		public string Path { get; set; }
		
		/// <summary>
		/// The value for the operation. This is either a primitive or a JToken.
		/// </summary>
		public string Value { get; set; }
	}
	
	public enum JsonPatchOperationOp
	{
		
		add = 0,
		
		remove = 1,
		
		replace = 2,
		
		move = 3,
		
		copy = 4,
		
		test = 5,
	}
	
	/// <summary>
	/// Real time event (SignalR) for updated labels on a pull request
	/// </summary>
	public class LabelsUpdatedEvent
	{
	}
	
	/// <summary>
	/// Real time event (SignalR) for a merge completed on a pull request
	/// </summary>
	public class MergeCompletedEvent
	{
	}
	
	/// <summary>
	/// Policy configuration reference.
	/// </summary>
	public class PolicyConfigurationRef
	{
		
		/// <summary>
		/// The policy configuration ID.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Policy type reference.
		/// </summary>
		public PolicyTypeRef Type { get; set; }
		
		/// <summary>
		/// The URL where the policy configuration can be retrieved.
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Policy type reference.
	/// </summary>
	public class PolicyTypeRef
	{
		
		/// <summary>
		/// Display name of the policy type.
		/// </summary>
		public string DisplayName { get; set; }
		
		/// <summary>
		/// The policy type ID.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// The URL where the policy type can be retrieved.
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Real time event (SignalR) for a policy evaluation update on a pull request
	/// </summary>
	public class PolicyEvaluationUpdatedEvent
	{
	}
	
	/// <summary>
	/// Real time event (SignalR) for pull request creation
	/// </summary>
	public class PullRequestCreatedEvent
	{
	}
	
	/// <summary>
	/// Initial config contract sent to extensions creating tabs on the pull request page
	/// </summary>
	public class PullRequestTabExtensionConfig
	{
		
		public System.Nullable<System.Int32> PullRequestId { get; set; }
		
		public string RepositoryId { get; set; }
	}
	
	/// <summary>
	/// Base contract for a real time pull request event (SignalR)
	/// </summary>
	public class RealTimePullRequestEvent
	{
		
		/// <summary>
		/// The id of this event. Can be used to track send/receive state between client and server.
		/// </summary>
		public string EventId { get; set; }
		
		/// <summary>
		/// The id of the pull request this event was generated for.
		/// </summary>
		public System.Nullable<System.Int32> PullRequestId { get; set; }
	}
	
	/// <summary>
	/// Real time event (SignalR) for when the target branch of a pull request is changed
	/// </summary>
	public class RetargetEvent
	{
	}
	
	/// <summary>
	/// Real time event (SignalR) for an update to reviewers on a pull request
	/// </summary>
	public class ReviewersUpdatedEvent
	{
	}
	
	/// <summary>
	/// Real time event (SignalR) for reviewer votes being reset on a pull request
	/// </summary>
	public class ReviewersVotesResetEvent
	{
	}
	
	/// <summary>
	/// Real time event (SignalR) for a reviewer vote update on a pull request
	/// </summary>
	public class ReviewerVoteUpdatedEvent
	{
	}
	
	/// <summary>
	/// Context used while sharing a pull request.
	/// </summary>
	public class ShareNotificationContext
	{
		
		/// <summary>
		/// Optional user note or message.
		/// </summary>
		public string Message { get; set; }
		
		/// <summary>
		/// Identities of users who will receive a share notification.
		/// </summary>
		public IdentityRef[] Receivers { get; set; }
	}
	
	/// <summary>
	/// Real time event (SignalR) for an added status on a pull request
	/// </summary>
	public class StatusAddedEvent
	{
	}
	
	/// <summary>
	/// Real time event (SignalR) for deleted statuses on a pull request
	/// </summary>
	public class StatusesDeletedEvent
	{
	}
	
	/// <summary>
	/// Real time event (SignalR) for a status update on a pull request
	/// </summary>
	public class StatusUpdatedEvent
	{
	}
	
	/// <summary>
	/// Represents a Supported IDE entity.
	/// </summary>
	public class SupportedIde
	{
		
		/// <summary>
		/// The download URL for the IDE.
		/// </summary>
		public string DownloadUrl { get; set; }
		
		/// <summary>
		/// The type of the IDE.
		/// </summary>
		public System.Nullable<SupportedIdeIdeType> IdeType { get; set; }
		
		/// <summary>
		/// The name of the IDE.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// The URL to open the protocol handler for the IDE.
		/// </summary>
		public string ProtocolHandlerUrl { get; set; }
		
		/// <summary>
		/// A list of SupportedPlatforms.
		/// </summary>
		public string[] SupportedPlatforms { get; set; }
	}
	
	public enum SupportedIdeIdeType
	{
		
		unknown = 0,
		
		androidStudio = 1,
		
		appCode = 2,
		
		cLion = 3,
		
		dataGrip = 4,
		
		eclipse = 5,
		
		intelliJ = 6,
		
		mps = 7,
		
		phpStorm = 8,
		
		pyCharm = 9,
		
		rubyMine = 10,
		
		tower = 11,
		
		visualStudio = 12,
		
		vsCode = 13,
		
		webStorm = 14,
	}
	
	/// <summary>
	/// Class representing a branch object.
	/// </summary>
	public class TfvcBranch
	{
		
		/// <summary>
		/// List of children for the branch.
		/// </summary>
		public TfvcBranch[] Children { get; set; }
		
		/// <summary>
		/// List of branch mappings.
		/// </summary>
		public TfvcBranchMapping[] Mappings { get; set; }
		
		/// <summary>
		/// This is the shallow branchref class.
		/// </summary>
		public TfvcShallowBranchRef Parent { get; set; }
		
		/// <summary>
		/// List of paths of the related branches.
		/// </summary>
		public TfvcShallowBranchRef[] RelatedBranches { get; set; }
	}
	
	/// <summary>
	/// A branch mapping.
	/// </summary>
	public class TfvcBranchMapping
	{
		
		/// <summary>
		/// Depth of the branch.
		/// </summary>
		public string Depth { get; set; }
		
		/// <summary>
		/// Server item for the branch.
		/// </summary>
		public string ServerItem { get; set; }
		
		/// <summary>
		/// Type of the branch.
		/// </summary>
		public string Type { get; set; }
	}
	
	/// <summary>
	/// This is the shallow branchref class.
	/// </summary>
	public class TfvcShallowBranchRef
	{
		
		/// <summary>
		/// Path for the branch.
		/// </summary>
		public string Path { get; set; }
	}
	
	/// <summary>
	/// Metadata for a branchref.
	/// </summary>
	public class TfvcBranchRef
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// Creation date of the branch.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedDate { get; set; }
		
		/// <summary>
		/// Branch description.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Is the branch deleted?
		/// </summary>
		public System.Nullable<System.Boolean> IsDeleted { get; set; }
		
		public IdentityRef Owner { get; set; }
		
		/// <summary>
		/// URL to retrieve the item.
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// A change.
	/// </summary>
	public class TfvcChange
	{
		
		/// <summary>
		/// List of merge sources in case of rename or branch creation.
		/// </summary>
		public TfvcMergeSource[] MergeSources { get; set; }
		
		/// <summary>
		/// Version at which a (shelved) change was pended against
		/// </summary>
		public System.Nullable<System.Int32> PendingVersion { get; set; }
	}
	
	public class TfvcMergeSource
	{
		
		/// <summary>
		/// Indicates if this a rename source. If false, it is a merge source.
		/// </summary>
		public System.Nullable<System.Boolean> IsRename { get; set; }
		
		/// <summary>
		/// The server item of the merge source.
		/// </summary>
		public string ServerItem { get; set; }
		
		/// <summary>
		/// Start of the version range.
		/// </summary>
		public System.Nullable<System.Int32> VersionFrom { get; set; }
		
		/// <summary>
		/// End of the version range.
		/// </summary>
		public System.Nullable<System.Int32> VersionTo { get; set; }
	}
	
	/// <summary>
	/// A collection of changes.
	/// </summary>
	public class TfvcChangeset
	{
		
		/// <summary>
		/// Changeset Account Id also known as Organization Id.
		/// </summary>
		public string AccountId { get; set; }
		
		/// <summary>
		/// List of associated changes.
		/// </summary>
		public TfvcChange[] Changes { get; set; }
		
		/// <summary>
		/// List of Checkin Notes for the changeset.
		/// </summary>
		public CheckinNote[] CheckinNotes { get; set; }
		
		/// <summary>
		/// Changeset collection Id.
		/// </summary>
		public string CollectionId { get; set; }
		
		/// <summary>
		/// True if more changes are available.
		/// </summary>
		public System.Nullable<System.Boolean> HasMoreChanges { get; set; }
		
		/// <summary>
		/// Information on the policy override.
		/// </summary>
		public TfvcPolicyOverrideInfo PolicyOverride { get; set; }
		
		/// <summary>
		/// Team Project Ids for the changeset.
		/// </summary>
		public string[] TeamProjectIds { get; set; }
		
		/// <summary>
		/// List of work items associated with the changeset.
		/// </summary>
		public AssociatedWorkItem[] WorkItems { get; set; }
	}
	
	/// <summary>
	/// Information on the policy override.
	/// </summary>
	public class TfvcPolicyOverrideInfo
	{
		
		/// <summary>
		/// Overidden policy comment.
		/// </summary>
		public string Comment { get; set; }
		
		/// <summary>
		/// Information on the failed policy that was overridden.
		/// </summary>
		public TfvcPolicyFailureInfo[] PolicyFailures { get; set; }
	}
	
	/// <summary>
	/// Policy failure information.
	/// </summary>
	public class TfvcPolicyFailureInfo
	{
		
		/// <summary>
		/// Policy failure message.
		/// </summary>
		public string Message { get; set; }
		
		/// <summary>
		/// Name of the policy that failed.
		/// </summary>
		public string PolicyName { get; set; }
	}
	
	/// <summary>
	/// Metadata for a changeset.
	/// </summary>
	public class TfvcChangesetRef
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		public IdentityRef Author { get; set; }
		
		/// <summary>
		/// Changeset Id.
		/// </summary>
		public System.Nullable<System.Int32> ChangesetId { get; set; }
		
		public IdentityRef CheckedInBy { get; set; }
		
		/// <summary>
		/// Comment for the changeset.
		/// </summary>
		public string Comment { get; set; }
		
		/// <summary>
		/// Was the Comment result truncated?
		/// </summary>
		public System.Nullable<System.Boolean> CommentTruncated { get; set; }
		
		/// <summary>
		/// Creation date of the changeset.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedDate { get; set; }
		
		/// <summary>
		/// URL to retrieve the item.
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Criteria used in a search for change lists.
	/// </summary>
	public class TfvcChangesetSearchCriteria
	{
		
		/// <summary>
		/// Alias or display name of user who made the changes.
		/// </summary>
		public string Author { get; set; }
		
		/// <summary>
		/// Whether or not to follow renames for the given item being queried.
		/// </summary>
		public System.Nullable<System.Boolean> FollowRenames { get; set; }
		
		/// <summary>
		/// If provided, only include changesets created after this date (string).
		/// </summary>
		public string FromDate { get; set; }
		
		/// <summary>
		/// If provided, only include changesets after this changesetID.
		/// </summary>
		public System.Nullable<System.Int32> FromId { get; set; }
		
		/// <summary>
		/// Whether to include the _links field on the shallow references.
		/// </summary>
		public System.Nullable<System.Boolean> IncludeLinks { get; set; }
		
		/// <summary>
		/// Path of item to search under.
		/// </summary>
		public string ItemPath { get; set; }
		
		public TfvcMappingFilter[] Mappings { get; set; }
		
		/// <summary>
		/// If provided, only include changesets created before this date (string).
		/// </summary>
		public string ToDate { get; set; }
		
		/// <summary>
		/// If provided, a version descriptor for the latest change list to include.
		/// </summary>
		public System.Nullable<System.Int32> ToId { get; set; }
	}
	
	/// <summary>
	/// MappingFilter can be used to include or exclude specific paths.
	/// </summary>
	public class TfvcMappingFilter
	{
		
		/// <summary>
		/// True if ServerPath should be excluded.
		/// </summary>
		public System.Nullable<System.Boolean> Exclude { get; set; }
		
		/// <summary>
		/// Path to be included or excluded.
		/// </summary>
		public string ServerPath { get; set; }
	}
	
	/// <summary>
	/// Request body for Get batched changesets.
	/// </summary>
	public class TfvcChangesetsRequestData
	{
		
		/// <summary>
		/// List of changeset Ids.
		/// </summary>
		public int[] ChangesetIds { get; set; }
		
		/// <summary>
		/// Max length of the comment.
		/// </summary>
		public System.Nullable<System.Int32> CommentLength { get; set; }
		
		/// <summary>
		/// Whether to include the _links field on the shallow references
		/// </summary>
		public System.Nullable<System.Boolean> IncludeLinks { get; set; }
	}
	
	public class TfvcCheckinEventData
	{
		
		/// <summary>
		/// A collection of changes.
		/// </summary>
		public TfvcChangeset Changeset { get; set; }
		
		/// <summary>
		/// Represents a shallow reference to a TeamProject.
		/// </summary>
		public TeamProjectReference Project { get; set; }
	}
	
	public class TfvcHistoryEntry
	{
		
		/// <summary>
		/// The encoding of the item at this point in history (only relevant for File history, not folders)
		/// </summary>
		public System.Nullable<System.Int32> Encoding { get; set; }
		
		/// <summary>
		/// The file id of the item at this point in history (only relevant for File history, not folders)
		/// </summary>
		public System.Nullable<System.Int32> FileId { get; set; }
	}
	
	/// <summary>
	/// Metadata for an item.
	/// </summary>
	public class TfvcItem
	{
		
		/// <summary>
		/// Item changed datetime.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ChangeDate { get; set; }
		
		/// <summary>
		/// Greater than 0 if item is deleted.
		/// </summary>
		public System.Nullable<System.Int32> DeletionId { get; set; }
		
		/// <summary>
		/// File encoding from database, -1 represents binary.
		/// </summary>
		public System.Nullable<System.Int32> Encoding { get; set; }
		
		/// <summary>
		/// MD5 hash as a base 64 string, applies to files only.
		/// </summary>
		public string HashValue { get; set; }
		
		/// <summary>
		/// True if item is a branch.
		/// </summary>
		public System.Nullable<System.Boolean> IsBranch { get; set; }
		
		/// <summary>
		/// True if there is a change pending.
		/// </summary>
		public System.Nullable<System.Boolean> IsPendingChange { get; set; }
		
		/// <summary>
		/// The size of the file, if applicable.
		/// </summary>
		public System.Nullable<System.Int64> Size { get; set; }
		
		/// <summary>
		/// Changeset version Id.
		/// </summary>
		public System.Nullable<System.Int32> Version { get; set; }
	}
	
	/// <summary>
	/// Item path and Version descriptor properties
	/// </summary>
	public class TfvcItemDescriptor
	{
		
		/// <summary>
		/// Item path.
		/// </summary>
		public string Path { get; set; }
		
		/// <summary>
		/// Defaults to OneLevel.
		/// </summary>
		public System.Nullable<TfvcItemDescriptorRecursionLevel> RecursionLevel { get; set; }
		
		/// <summary>
		/// Specify the desired version, can be null or empty string only if VersionType is latest or tip.
		/// </summary>
		public string Version { get; set; }
		
		/// <summary>
		/// Defaults to None.
		/// </summary>
		public System.Nullable<TfvcItemDescriptorVersionOption> VersionOption { get; set; }
		
		/// <summary>
		/// Defaults to Latest.
		/// </summary>
		public System.Nullable<TfvcItemDescriptorVersionType> VersionType { get; set; }
	}
	
	public enum TfvcItemDescriptorRecursionLevel
	{
		
		none = 0,
		
		oneLevel = 1,
		
		oneLevelPlusNestedEmptyFolders = 2,
		
		full = 3,
	}
	
	public enum TfvcItemDescriptorVersionOption
	{
		
		none = 0,
		
		previous = 1,
		
		useRename = 2,
	}
	
	public enum TfvcItemDescriptorVersionType
	{
		
		none = 0,
		
		changeset = 1,
		
		shelveset = 2,
		
		change = 3,
		
		date = 4,
		
		latest = 5,
		
		tip = 6,
		
		mergeSource = 7,
	}
	
	/// <summary>
	/// Metadata for an item including the previous hash value for files.
	/// </summary>
	public class TfvcItemPreviousHash
	{
		
		/// <summary>
		/// MD5 hash as a base 64 string, applies to files only.
		/// </summary>
		public string PreviousHashValue { get; set; }
	}
	
	/// <summary>
	/// Request body used by Get Items Batch
	/// </summary>
	public class TfvcItemRequestData
	{
		
		/// <summary>
		/// If true, include metadata about the file type
		/// </summary>
		public System.Nullable<System.Boolean> IncludeContentMetadata { get; set; }
		
		/// <summary>
		/// Whether to include the _links field on the shallow references
		/// </summary>
		public System.Nullable<System.Boolean> IncludeLinks { get; set; }
		
		public TfvcItemDescriptor[] ItemDescriptors { get; set; }
	}
	
	/// <summary>
	/// Metadata for a label.
	/// </summary>
	public class TfvcLabel
	{
		
		/// <summary>
		/// List of items.
		/// </summary>
		public TfvcItem[] Items { get; set; }
	}
	
	/// <summary>
	/// Metadata for a Label.
	/// </summary>
	public class TfvcLabelRef
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// Label description.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Label Id.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Label scope.
		/// </summary>
		public string LabelScope { get; set; }
		
		/// <summary>
		/// Last modified datetime for the label.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ModifiedDate { get; set; }
		
		/// <summary>
		/// Label name.
		/// </summary>
		public string Name { get; set; }
		
		public IdentityRef Owner { get; set; }
		
		/// <summary>
		/// Label Url.
		/// </summary>
		public string Url { get; set; }
	}
	
	public class TfvcLabelRequestData
	{
		
		/// <summary>
		/// Whether to include the _links field on the shallow references
		/// </summary>
		public System.Nullable<System.Boolean> IncludeLinks { get; set; }
		
		public string ItemLabelFilter { get; set; }
		
		public string LabelScope { get; set; }
		
		public System.Nullable<System.Int32> MaxItemCount { get; set; }
		
		public string Name { get; set; }
		
		public string Owner { get; set; }
	}
	
	/// <summary>
	/// Metadata for a shelveset.
	/// </summary>
	public class TfvcShelveset
	{
		
		/// <summary>
		/// List of changes.
		/// </summary>
		public TfvcChange[] Changes { get; set; }
		
		/// <summary>
		/// List of checkin notes.
		/// </summary>
		public CheckinNote[] Notes { get; set; }
		
		/// <summary>
		/// Information on the policy override.
		/// </summary>
		public TfvcPolicyOverrideInfo PolicyOverride { get; set; }
		
		/// <summary>
		/// List of associated workitems.
		/// </summary>
		public AssociatedWorkItem[] WorkItems { get; set; }
	}
	
	/// <summary>
	/// Metadata for a shallow shelveset.
	/// </summary>
	public class TfvcShelvesetRef
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// Shelveset comment.
		/// </summary>
		public string Comment { get; set; }
		
		/// <summary>
		/// Shelveset comment truncated as applicable.
		/// </summary>
		public System.Nullable<System.Boolean> CommentTruncated { get; set; }
		
		/// <summary>
		/// Shelveset create date.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedDate { get; set; }
		
		/// <summary>
		/// Shelveset Id.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Shelveset name.
		/// </summary>
		public string Name { get; set; }
		
		public IdentityRef Owner { get; set; }
		
		/// <summary>
		/// Shelveset Url.
		/// </summary>
		public string Url { get; set; }
	}
	
	public class TfvcShelvesetRequestData
	{
		
		/// <summary>
		/// Whether to include policyOverride and notes Only applies when requesting a single deep shelveset
		/// </summary>
		public System.Nullable<System.Boolean> IncludeDetails { get; set; }
		
		/// <summary>
		/// Whether to include the _links field on the shallow references. Does not apply when requesting a single deep shelveset object. Links will always be included in the deep shelveset.
		/// </summary>
		public System.Nullable<System.Boolean> IncludeLinks { get; set; }
		
		/// <summary>
		/// Whether to include workItems
		/// </summary>
		public System.Nullable<System.Boolean> IncludeWorkItems { get; set; }
		
		/// <summary>
		/// Max number of changes to include
		/// </summary>
		public System.Nullable<System.Int32> MaxChangeCount { get; set; }
		
		/// <summary>
		/// Max length of comment
		/// </summary>
		public System.Nullable<System.Int32> MaxCommentLength { get; set; }
		
		/// <summary>
		/// Shelveset name
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Owner's ID. Could be a name or a guid.
		/// </summary>
		public string Owner { get; set; }
	}
	
	public class TfvcStatistics
	{
		
		/// <summary>
		/// Id of the last changeset the stats are based on.
		/// </summary>
		public System.Nullable<System.Int32> ChangesetId { get; set; }
		
		/// <summary>
		/// Count of files at the requested scope.
		/// </summary>
		public System.Nullable<System.Int64> FileCountTotal { get; set; }
	}
	
	/// <summary>
	/// Version descriptor properties.
	/// </summary>
	public class TfvcVersionDescriptor
	{
		
		/// <summary>
		/// Version object.
		/// </summary>
		public string Version { get; set; }
		
		public System.Nullable<TfvcVersionDescriptorVersionOption> VersionOption { get; set; }
		
		public System.Nullable<TfvcVersionDescriptorVersionType> VersionType { get; set; }
	}
	
	public enum TfvcVersionDescriptorVersionOption
	{
		
		none = 0,
		
		previous = 1,
		
		useRename = 2,
	}
	
	public enum TfvcVersionDescriptorVersionType
	{
		
		none = 0,
		
		changeset = 1,
		
		shelveset = 2,
		
		change = 3,
		
		date = 4,
		
		latest = 5,
		
		tip = 6,
		
		mergeSource = 7,
	}
	
	/// <summary>
	/// Real time event (SignalR) for a title/description update on a pull request
	/// </summary>
	public class TitleDescriptionUpdatedEvent
	{
	}
	
	public class UpdateRefsRequest
	{
		
		public GitRefUpdate[] RefUpdateRequests { get; set; }
		
		public System.Nullable<UpdateRefsRequestUpdateMode> UpdateMode { get; set; }
	}
	
	public enum UpdateRefsRequestUpdateMode
	{
		
		bestEffort = 0,
		
		allOrNone = 1,
	}
	
	public class VersionControlProjectInfo
	{
		
		public System.Nullable<VersionControlProjectInfoDefaultSourceControlType> DefaultSourceControlType { get; set; }
		
		/// <summary>
		/// Represents a shallow reference to a TeamProject.
		/// </summary>
		public TeamProjectReference Project { get; set; }
		
		public System.Nullable<System.Boolean> SupportsGit { get; set; }
		
		public System.Nullable<System.Boolean> SupportsTFVC { get; set; }
	}
	
	public enum VersionControlProjectInfoDefaultSourceControlType
	{
		
		tfvc = 0,
		
		git = 1,
	}
	
	/// <summary>
	/// A particular revision for a policy configuration.
	/// </summary>
	public class VersionedPolicyConfigurationRef
	{
		
		/// <summary>
		/// The policy configuration revision ID.
		/// </summary>
		public System.Nullable<System.Int32> Revision { get; set; }
	}
	
	/// <summary>
	/// This class is used to serialized collections as a single JSON object on the wire, to avoid serializing JSON arrays directly to the client, which can be a security hole
	/// </summary>
	public class VssJsonCollectionWrapper
	{
		
		public string Value { get; set; }
	}
	
	public class VssJsonCollectionWrapperBase
	{
		
		public System.Nullable<System.Int32> Count { get; set; }
	}
	
	/// <summary>
	/// The representation of data needed to create a tag definition which is sent across the wire.
	/// </summary>
	public class WebApiCreateTagRequestData
	{
		
		/// <summary>
		/// Name of the tag definition that will be created.
		/// </summary>
		public string Name { get; set; }
	}
	
	public partial class MyClient
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public MyClient(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Retrieve deleted git repositories.
		/// Repositories_Get_Deleted_Repositories {organization}/{project}/_apis/git/deletedrepositories
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitDeletedRepository[]> Repositories_Get_Deleted_RepositoriesAsync(string organization, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/deletedrepositories&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitDeletedRepository[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve deleted git repositories.
		/// Repositories_Get_Deleted_Repositories {organization}/{project}/_apis/git/deletedrepositories
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitDeletedRepository[] Repositories_Get_Deleted_Repositories(string organization, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/deletedrepositories&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitDeletedRepository[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the refs favorites for a repo and an identity.
		/// Refs_Favorites_List {organization}/{project}/_apis/git/favorites/refs
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">The id of the repository.</param>
		/// <param name="identityId">The id of the identity whose favorites are to be retrieved. If null, the requesting identity is used.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitRefFavorite[]> Refs_Favorites_ListAsync(string organization, string project, string repositoryId, string identityId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/favorites/refs&repositoryId=" + (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"&identityId=" + (identityId==null? "" : System.Uri.EscapeDataString(identityId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRefFavorite[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the refs favorites for a repo and an identity.
		/// Refs_Favorites_List {organization}/{project}/_apis/git/favorites/refs
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">The id of the repository.</param>
		/// <param name="identityId">The id of the identity whose favorites are to be retrieved. If null, the requesting identity is used.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitRefFavorite[] Refs_Favorites_List(string organization, string project, string repositoryId, string identityId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/favorites/refs&repositoryId=" + (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"&identityId=" + (identityId==null? "" : System.Uri.EscapeDataString(identityId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRefFavorite[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a ref favorite
		/// Refs_Favorites_Create {organization}/{project}/_apis/git/favorites/refs
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The ref favorite to create.</param>
		/// <returns>successful operation</returns>
		public async Task<GitRefFavorite> Refs_Favorites_CreateAsync(string organization, string project, string api_version, GitRefFavorite requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/favorites/refs&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRefFavorite>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a ref favorite
		/// Refs_Favorites_Create {organization}/{project}/_apis/git/favorites/refs
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The ref favorite to create.</param>
		/// <returns>successful operation</returns>
		public GitRefFavorite Refs_Favorites_Create(string organization, string project, string api_version, GitRefFavorite requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/favorites/refs&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRefFavorite>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the refs favorite for a favorite Id.
		/// Refs_Favorites_Get {organization}/{project}/_apis/git/favorites/refs/{favoriteId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="favoriteId">The Id of the requested ref favorite.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitRefFavorite> Refs_Favorites_GetAsync(string organization, string project, int favoriteId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/favorites/refs/"+favoriteId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRefFavorite>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the refs favorite for a favorite Id.
		/// Refs_Favorites_Get {organization}/{project}/_apis/git/favorites/refs/{favoriteId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="favoriteId">The Id of the requested ref favorite.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitRefFavorite Refs_Favorites_Get(string organization, string project, int favoriteId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/favorites/refs/"+favoriteId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRefFavorite>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the refs favorite specified
		/// Refs_Favorites_Delete {organization}/{project}/_apis/git/favorites/refs/{favoriteId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="favoriteId">The Id of the ref favorite to delete.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Refs_Favorites_DeleteAsync(string organization, string project, int favoriteId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/favorites/refs/"+favoriteId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the refs favorite specified
		/// Refs_Favorites_Delete {organization}/{project}/_apis/git/favorites/refs/{favoriteId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="favoriteId">The Id of the ref favorite to delete.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Refs_Favorites_Delete(string organization, string project, int favoriteId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/favorites/refs/"+favoriteId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a list of policy configurations by a given set of scope/filtering criteria.
		/// 
		/// Below is a short description of how all of the query parameters interact with each other:
		/// - repositoryId set, refName set: returns all policy configurations that *apply* to a particular branch in a repository
		/// - repositoryId set, refName unset: returns all policy configurations that *apply* to a particular repository
		/// - repositoryId unset, refName unset: returns all policy configurations that are *defined* at the project level
		/// - repositoryId unset, refName set: returns all project-level branch policies, plus the project level configurations
		/// For all of the examples above, when policyType is set, it'll restrict results to the given policy type
		/// Policy_Configurations_Get {organization}/{project}/_apis/git/policy/configurations
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">The repository id.</param>
		/// <param name="refName">The fully-qualified Git ref name (e.g. refs/heads/master).</param>
		/// <param name="policyType">The policy type filter.</param>
		/// <param name="top">Maximum number of policies to return.</param>
		/// <param name="continuationToken">Pass a policy configuration ID to fetch the next page of results, up to top number of results, for this endpoint.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<PolicyConfiguration[]> Policy_Configurations_GetAsync(string organization, string project, string repositoryId, string refName, string policyType, int top, string continuationToken, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/policy/configurations&repositoryId=" + (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"&refName=" + (refName==null? "" : System.Uri.EscapeDataString(refName))+"&policyType=" + (policyType==null? "" : System.Uri.EscapeDataString(policyType))+"&$top="+top+"&continuationToken=" + (continuationToken==null? "" : System.Uri.EscapeDataString(continuationToken))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PolicyConfiguration[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a list of policy configurations by a given set of scope/filtering criteria.
		/// 
		/// Below is a short description of how all of the query parameters interact with each other:
		/// - repositoryId set, refName set: returns all policy configurations that *apply* to a particular branch in a repository
		/// - repositoryId set, refName unset: returns all policy configurations that *apply* to a particular repository
		/// - repositoryId unset, refName unset: returns all policy configurations that are *defined* at the project level
		/// - repositoryId unset, refName set: returns all project-level branch policies, plus the project level configurations
		/// For all of the examples above, when policyType is set, it'll restrict results to the given policy type
		/// Policy_Configurations_Get {organization}/{project}/_apis/git/policy/configurations
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">The repository id.</param>
		/// <param name="refName">The fully-qualified Git ref name (e.g. refs/heads/master).</param>
		/// <param name="policyType">The policy type filter.</param>
		/// <param name="top">Maximum number of policies to return.</param>
		/// <param name="continuationToken">Pass a policy configuration ID to fetch the next page of results, up to top number of results, for this endpoint.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public PolicyConfiguration[] Policy_Configurations_Get(string organization, string project, string repositoryId, string refName, string policyType, int top, string continuationToken, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/policy/configurations&repositoryId=" + (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"&refName=" + (refName==null? "" : System.Uri.EscapeDataString(refName))+"&policyType=" + (policyType==null? "" : System.Uri.EscapeDataString(policyType))+"&$top="+top+"&continuationToken=" + (continuationToken==null? "" : System.Uri.EscapeDataString(continuationToken))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PolicyConfiguration[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all pull requests matching a specified criteria.
		/// Pull_Requests_Get_Pull_Requests_By_Project {organization}/{project}/_apis/git/pullrequests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="searchCriteria_creatorId">If set, search for pull requests that were created by this identity.</param>
		/// <param name="searchCriteria_includeLinks">Whether to include the _links field on the shallow references</param>
		/// <param name="searchCriteria_repositoryId">If set, search for pull requests whose target branch is in this repository.</param>
		/// <param name="searchCriteria_reviewerId">If set, search for pull requests that have this identity as a reviewer.</param>
		/// <param name="searchCriteria_sourceRefName">If set, search for pull requests from this branch.</param>
		/// <param name="searchCriteria_sourceRepositoryId">If set, search for pull requests whose source branch is in this repository.</param>
		/// <param name="searchCriteria_status">If set, search for pull requests that are in this state. Defaults to Active if unset.</param>
		/// <param name="searchCriteria_targetRefName">If set, search for pull requests into this branch.</param>
		/// <param name="maxCommentLength">Not used.</param>
		/// <param name="skip">The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100.</param>
		/// <param name="top">The number of pull requests to retrieve.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequest[]> Pull_Requests_Get_Pull_Requests_By_ProjectAsync(string organization, string project, string searchCriteria_creatorId, bool searchCriteria_includeLinks, string searchCriteria_repositoryId, string searchCriteria_reviewerId, string searchCriteria_sourceRefName, string searchCriteria_sourceRepositoryId, GitPullRequestStatus searchCriteria_status, string searchCriteria_targetRefName, int maxCommentLength, int skip, int top, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/pullrequests&searchCriteria.creatorId=" + (searchCriteria_creatorId==null? "" : System.Uri.EscapeDataString(searchCriteria_creatorId))+"&searchCriteria.includeLinks="+searchCriteria_includeLinks+"&searchCriteria.repositoryId=" + (searchCriteria_repositoryId==null? "" : System.Uri.EscapeDataString(searchCriteria_repositoryId))+"&searchCriteria.reviewerId=" + (searchCriteria_reviewerId==null? "" : System.Uri.EscapeDataString(searchCriteria_reviewerId))+"&searchCriteria.sourceRefName=" + (searchCriteria_sourceRefName==null? "" : System.Uri.EscapeDataString(searchCriteria_sourceRefName))+"&searchCriteria.sourceRepositoryId=" + (searchCriteria_sourceRepositoryId==null? "" : System.Uri.EscapeDataString(searchCriteria_sourceRepositoryId))+"&searchCriteria.status=" + searchCriteria_status+"&searchCriteria.targetRefName=" + (searchCriteria_targetRefName==null? "" : System.Uri.EscapeDataString(searchCriteria_targetRefName))+"&maxCommentLength="+maxCommentLength+"&$skip="+skip+"&$top="+top+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequest[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all pull requests matching a specified criteria.
		/// Pull_Requests_Get_Pull_Requests_By_Project {organization}/{project}/_apis/git/pullrequests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="searchCriteria_creatorId">If set, search for pull requests that were created by this identity.</param>
		/// <param name="searchCriteria_includeLinks">Whether to include the _links field on the shallow references</param>
		/// <param name="searchCriteria_repositoryId">If set, search for pull requests whose target branch is in this repository.</param>
		/// <param name="searchCriteria_reviewerId">If set, search for pull requests that have this identity as a reviewer.</param>
		/// <param name="searchCriteria_sourceRefName">If set, search for pull requests from this branch.</param>
		/// <param name="searchCriteria_sourceRepositoryId">If set, search for pull requests whose source branch is in this repository.</param>
		/// <param name="searchCriteria_status">If set, search for pull requests that are in this state. Defaults to Active if unset.</param>
		/// <param name="searchCriteria_targetRefName">If set, search for pull requests into this branch.</param>
		/// <param name="maxCommentLength">Not used.</param>
		/// <param name="skip">The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100.</param>
		/// <param name="top">The number of pull requests to retrieve.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitPullRequest[] Pull_Requests_Get_Pull_Requests_By_Project(string organization, string project, string searchCriteria_creatorId, bool searchCriteria_includeLinks, string searchCriteria_repositoryId, string searchCriteria_reviewerId, string searchCriteria_sourceRefName, string searchCriteria_sourceRepositoryId, GitPullRequestStatus searchCriteria_status, string searchCriteria_targetRefName, int maxCommentLength, int skip, int top, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/pullrequests&searchCriteria.creatorId=" + (searchCriteria_creatorId==null? "" : System.Uri.EscapeDataString(searchCriteria_creatorId))+"&searchCriteria.includeLinks="+searchCriteria_includeLinks+"&searchCriteria.repositoryId=" + (searchCriteria_repositoryId==null? "" : System.Uri.EscapeDataString(searchCriteria_repositoryId))+"&searchCriteria.reviewerId=" + (searchCriteria_reviewerId==null? "" : System.Uri.EscapeDataString(searchCriteria_reviewerId))+"&searchCriteria.sourceRefName=" + (searchCriteria_sourceRefName==null? "" : System.Uri.EscapeDataString(searchCriteria_sourceRefName))+"&searchCriteria.sourceRepositoryId=" + (searchCriteria_sourceRepositoryId==null? "" : System.Uri.EscapeDataString(searchCriteria_sourceRepositoryId))+"&searchCriteria.status=" + searchCriteria_status+"&searchCriteria.targetRefName=" + (searchCriteria_targetRefName==null? "" : System.Uri.EscapeDataString(searchCriteria_targetRefName))+"&maxCommentLength="+maxCommentLength+"&$skip="+skip+"&$top="+top+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequest[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a pull request.
		/// Pull_Requests_Get_Pull_Request_By_Id {organization}/{project}/_apis/git/pullrequests/{pullRequestId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="pullRequestId">The ID of the pull request to retrieve.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequest> Pull_Requests_Get_Pull_Request_By_IdAsync(string organization, int pullRequestId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/pullrequests/"+pullRequestId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a pull request.
		/// Pull_Requests_Get_Pull_Request_By_Id {organization}/{project}/_apis/git/pullrequests/{pullRequestId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="pullRequestId">The ID of the pull request to retrieve.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitPullRequest Pull_Requests_Get_Pull_Request_By_Id(string organization, int pullRequestId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/pullrequests/"+pullRequestId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve soft-deleted git repositories from the recycle bin.
		/// Repositories_Get_Recycle_Bin_Repositories {organization}/{project}/_apis/git/recycleBin/repositories
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitDeletedRepository[]> Repositories_Get_Recycle_Bin_RepositoriesAsync(string organization, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/recycleBin/repositories&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitDeletedRepository[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve soft-deleted git repositories from the recycle bin.
		/// Repositories_Get_Recycle_Bin_Repositories {organization}/{project}/_apis/git/recycleBin/repositories
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitDeletedRepository[] Repositories_Get_Recycle_Bin_Repositories(string organization, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/recycleBin/repositories&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitDeletedRepository[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Destroy (hard delete) a soft-deleted Git repository.
		/// Repositories_Delete_Repository_From_Recycle_Bin {organization}/{project}/_apis/git/recycleBin/repositories/{repositoryId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">The ID of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Repositories_Delete_Repository_From_Recycle_BinAsync(string organization, string project, string repositoryId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/recycleBin/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Destroy (hard delete) a soft-deleted Git repository.
		/// Repositories_Delete_Repository_From_Recycle_Bin {organization}/{project}/_apis/git/recycleBin/repositories/{repositoryId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">The ID of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Repositories_Delete_Repository_From_Recycle_Bin(string organization, string project, string repositoryId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/recycleBin/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Recover a soft-deleted Git repository. Recently deleted repositories go into a soft-delete state for a period of time before they are hard deleted and become unrecoverable.
		/// Repositories_Restore_Repository_From_Recycle_Bin {organization}/{project}/_apis/git/recycleBin/repositories/{repositoryId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">The ID of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitRepository> Repositories_Restore_Repository_From_Recycle_BinAsync(string organization, string project, string repositoryId, string api_version, GitRecycleBinRepositoryDetails requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/recycleBin/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRepository>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Recover a soft-deleted Git repository. Recently deleted repositories go into a soft-delete state for a period of time before they are hard deleted and become unrecoverable.
		/// Repositories_Restore_Repository_From_Recycle_Bin {organization}/{project}/_apis/git/recycleBin/repositories/{repositoryId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">The ID of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitRepository Repositories_Restore_Repository_From_Recycle_Bin(string organization, string project, string repositoryId, string api_version, GitRecycleBinRepositoryDetails requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/recycleBin/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRepository>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve git repositories.
		/// Repositories_List {organization}/{project}/_apis/git/repositories
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="includeLinks">[optional] True to include reference links. The default value is false.</param>
		/// <param name="includeAllUrls">[optional] True to include all remote URLs. The default value is false.</param>
		/// <param name="includeHidden">[optional] True to include hidden repositories. The default value is false.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitRepository[]> Repositories_ListAsync(string organization, string project, bool includeLinks, bool includeAllUrls, bool includeHidden, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories&includeLinks="+includeLinks+"&includeAllUrls="+includeAllUrls+"&includeHidden="+includeHidden+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRepository[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve git repositories.
		/// Repositories_List {organization}/{project}/_apis/git/repositories
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="includeLinks">[optional] True to include reference links. The default value is false.</param>
		/// <param name="includeAllUrls">[optional] True to include all remote URLs. The default value is false.</param>
		/// <param name="includeHidden">[optional] True to include hidden repositories. The default value is false.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitRepository[] Repositories_List(string organization, string project, bool includeLinks, bool includeAllUrls, bool includeHidden, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories&includeLinks="+includeLinks+"&includeAllUrls="+includeAllUrls+"&includeHidden="+includeHidden+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRepository[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a git repository in a team project.
		/// Repositories_Create {organization}/{project}/_apis/git/repositories
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="sourceRef">[optional] Specify the source refs to use while creating a fork repo</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Specify the repo name, team project and/or parent repository. Team project information can be omitted from gitRepositoryToCreate if the request is project-scoped (i.e., includes project Id).</param>
		public async Task Repositories_CreateAsync(string organization, string project, string sourceRef, string api_version, GitRepositoryCreateOptions requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories&sourceRef=" + (sourceRef==null? "" : System.Uri.EscapeDataString(sourceRef))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a git repository in a team project.
		/// Repositories_Create {organization}/{project}/_apis/git/repositories
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="sourceRef">[optional] Specify the source refs to use while creating a fork repo</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Specify the repo name, team project and/or parent repository. Team project information can be omitted from gitRepositoryToCreate if the request is project-scoped (i.e., includes project Id).</param>
		public void Repositories_Create(string organization, string project, string sourceRef, string api_version, GitRepositoryCreateOptions requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories&sourceRef=" + (sourceRef==null? "" : System.Uri.EscapeDataString(sourceRef))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve a git repository.
		/// Repositories_Get_Repository {organization}/{project}/_apis/git/repositories/{repositoryId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitRepository> Repositories_Get_RepositoryAsync(string organization, string repositoryId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRepository>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a git repository.
		/// Repositories_Get_Repository {organization}/{project}/_apis/git/repositories/{repositoryId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitRepository Repositories_Get_Repository(string organization, string repositoryId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRepository>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a git repository
		/// Repositories_Delete {organization}/{project}/_apis/git/repositories/{repositoryId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Repositories_DeleteAsync(string organization, string repositoryId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a git repository
		/// Repositories_Delete {organization}/{project}/_apis/git/repositories/{repositoryId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Repositories_Delete(string organization, string repositoryId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the Git repository with either a new repo name or a new default branch.
		/// Repositories_Update {organization}/{project}/_apis/git/repositories/{repositoryId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Specify a new repo name or a new default branch of the repository</param>
		/// <returns>successful operation</returns>
		public async Task<GitRepository> Repositories_UpdateAsync(string organization, string repositoryId, string project, string api_version, GitRepository requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRepository>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the Git repository with either a new repo name or a new default branch.
		/// Repositories_Update {organization}/{project}/_apis/git/repositories/{repositoryId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Specify a new repo name or a new default branch of the repository</param>
		/// <returns>successful operation</returns>
		public GitRepository Repositories_Update(string organization, string repositoryId, string project, string api_version, GitRepository requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRepository>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create an annotated tag.
		/// 
		/// Repositories have both a name and an identifier. Identifiers are globally unique, but several projects
		/// may contain a repository of the same name. You don't need to include the project if you specify a
		/// repository by ID. However, if you specify a repository by name, you must also specify the project (by name or ID).
		/// Annotated_Tags_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/annotatedtags
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">ID or name of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Object containing details of tag to be created.</param>
		/// <returns>successful operation</returns>
		public async Task<GitAnnotatedTag> Annotated_Tags_CreateAsync(string organization, string project, string repositoryId, string api_version, GitAnnotatedTag requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/annotatedtags&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitAnnotatedTag>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create an annotated tag.
		/// 
		/// Repositories have both a name and an identifier. Identifiers are globally unique, but several projects
		/// may contain a repository of the same name. You don't need to include the project if you specify a
		/// repository by ID. However, if you specify a repository by name, you must also specify the project (by name or ID).
		/// Annotated_Tags_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/annotatedtags
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">ID or name of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Object containing details of tag to be created.</param>
		/// <returns>successful operation</returns>
		public GitAnnotatedTag Annotated_Tags_Create(string organization, string project, string repositoryId, string api_version, GitAnnotatedTag requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/annotatedtags&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitAnnotatedTag>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get an annotated tag.
		/// 
		/// Repositories have both a name and an identifier. Identifiers are globally unique, but several projects
		/// may contain a repository of the same name. You don't need to include the project if you specify a
		/// repository by ID. However, if you specify a repository by name, you must also specify the project (by name or ID).
		/// Annotated_Tags_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/annotatedtags/{objectId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">ID or name of the repository.</param>
		/// <param name="objectId">ObjectId (Sha1Id) of tag to get.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitAnnotatedTag> Annotated_Tags_GetAsync(string organization, string project, string repositoryId, string objectId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/annotatedtags/"+ (objectId==null? "" : System.Uri.EscapeDataString(objectId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitAnnotatedTag>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an annotated tag.
		/// 
		/// Repositories have both a name and an identifier. Identifiers are globally unique, but several projects
		/// may contain a repository of the same name. You don't need to include the project if you specify a
		/// repository by ID. However, if you specify a repository by name, you must also specify the project (by name or ID).
		/// Annotated_Tags_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/annotatedtags/{objectId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">ID or name of the repository.</param>
		/// <param name="objectId">ObjectId (Sha1Id) of tag to get.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitAnnotatedTag Annotated_Tags_Get(string organization, string project, string repositoryId, string objectId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/annotatedtags/"+ (objectId==null? "" : System.Uri.EscapeDataString(objectId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitAnnotatedTag>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets one or more blobs in a zip file download.
		/// Blobs_Get_Blobs_Zip {organization}/{project}/_apis/git/repositories/{repositoryId}/blobs
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Blob IDs (SHA1 hashes) to be returned in the zip file.</param>
		/// <returns>successful operation</returns>
		public async Task Blobs_Get_Blobs_ZipAsync(string organization, string repositoryId, string project, string filename, string api_version, string[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/blobs&filename=" + (filename==null? "" : System.Uri.EscapeDataString(filename))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets one or more blobs in a zip file download.
		/// Blobs_Get_Blobs_Zip {organization}/{project}/_apis/git/repositories/{repositoryId}/blobs
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Blob IDs (SHA1 hashes) to be returned in the zip file.</param>
		/// <returns>successful operation</returns>
		public void Blobs_Get_Blobs_Zip(string organization, string repositoryId, string project, string filename, string api_version, string[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/blobs&filename=" + (filename==null? "" : System.Uri.EscapeDataString(filename))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a single blob.
		/// 
		/// Repositories have both a name and an identifier. Identifiers are globally unique,
		/// but several projects may contain a repository of the same name. You don't need to include
		/// the project if you specify a repository by ID. However, if you specify a repository by name,
		/// you must also specify the project (by name or ID).
		/// Blobs_Get_Blob {organization}/{project}/_apis/git/repositories/{repositoryId}/blobs/{sha1}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="sha1">SHA1 hash of the file. You can get the SHA1 of a file using the "Git/Items/Get Item" endpoint.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="download">If true, prompt for a download rather than rendering in a browser. Note: this value defaults to true if $format is zip</param>
		/// <param name="fileName">Provide a fileName to use for a download.</param>
		/// <param name="format">Options: json, zip, text, octetstream. If not set, defaults to the MIME type set in the Accept header.</param>
		/// <param name="resolveLfs">If true, try to resolve a blob to its LFS contents, if it's an LFS pointer file. Only compatible with octet-stream Accept headers or $format types</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitBlobRef> Blobs_Get_BlobAsync(string organization, string repositoryId, string sha1, string project, bool download, string fileName, string format, bool resolveLfs, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/blobs/"+ (sha1==null? "" : System.Uri.EscapeDataString(sha1))+"&download="+download+"&fileName=" + (fileName==null? "" : System.Uri.EscapeDataString(fileName))+"&$format=" + (format==null? "" : System.Uri.EscapeDataString(format))+"&resolveLfs="+resolveLfs+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitBlobRef>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a single blob.
		/// 
		/// Repositories have both a name and an identifier. Identifiers are globally unique,
		/// but several projects may contain a repository of the same name. You don't need to include
		/// the project if you specify a repository by ID. However, if you specify a repository by name,
		/// you must also specify the project (by name or ID).
		/// Blobs_Get_Blob {organization}/{project}/_apis/git/repositories/{repositoryId}/blobs/{sha1}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="sha1">SHA1 hash of the file. You can get the SHA1 of a file using the "Git/Items/Get Item" endpoint.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="download">If true, prompt for a download rather than rendering in a browser. Note: this value defaults to true if $format is zip</param>
		/// <param name="fileName">Provide a fileName to use for a download.</param>
		/// <param name="format">Options: json, zip, text, octetstream. If not set, defaults to the MIME type set in the Accept header.</param>
		/// <param name="resolveLfs">If true, try to resolve a blob to its LFS contents, if it's an LFS pointer file. Only compatible with octet-stream Accept headers or $format types</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitBlobRef Blobs_Get_Blob(string organization, string repositoryId, string sha1, string project, bool download, string fileName, string format, bool resolveLfs, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/blobs/"+ (sha1==null? "" : System.Uri.EscapeDataString(sha1))+"&download="+download+"&fileName=" + (fileName==null? "" : System.Uri.EscapeDataString(fileName))+"&$format=" + (format==null? "" : System.Uri.EscapeDataString(format))+"&resolveLfs="+resolveLfs+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitBlobRef>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve information about a cherry pick for a specific branch.
		/// Cherry_Picks_Get_Cherry_Pick_For_Ref_Name {organization}/{project}/_apis/git/repositories/{repositoryId}/cherryPicks
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">ID of the repository.</param>
		/// <param name="refName">The GitAsyncRefOperationParameters generatedRefName used for the cherry pick operation.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitCherryPick> Cherry_Picks_Get_Cherry_Pick_For_Ref_NameAsync(string organization, string project, string repositoryId, string refName, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/cherryPicks&refName=" + (refName==null? "" : System.Uri.EscapeDataString(refName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCherryPick>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve information about a cherry pick for a specific branch.
		/// Cherry_Picks_Get_Cherry_Pick_For_Ref_Name {organization}/{project}/_apis/git/repositories/{repositoryId}/cherryPicks
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">ID of the repository.</param>
		/// <param name="refName">The GitAsyncRefOperationParameters generatedRefName used for the cherry pick operation.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitCherryPick Cherry_Picks_Get_Cherry_Pick_For_Ref_Name(string organization, string project, string repositoryId, string refName, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/cherryPicks&refName=" + (refName==null? "" : System.Uri.EscapeDataString(refName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCherryPick>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Cherry pick a specific commit or commits that are associated to a pull request into a new branch.
		/// Cherry_Picks_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/cherryPicks
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">ID of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitCherryPick> Cherry_Picks_CreateAsync(string organization, string project, string repositoryId, string api_version, GitAsyncRefOperationParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/cherryPicks&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCherryPick>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Cherry pick a specific commit or commits that are associated to a pull request into a new branch.
		/// Cherry_Picks_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/cherryPicks
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">ID of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitCherryPick Cherry_Picks_Create(string organization, string project, string repositoryId, string api_version, GitAsyncRefOperationParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/cherryPicks&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCherryPick>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve information about a cherry pick by cherry pick Id.
		/// Cherry_Picks_Get_Cherry_Pick {organization}/{project}/_apis/git/repositories/{repositoryId}/cherryPicks/{cherryPickId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="cherryPickId">ID of the cherry pick.</param>
		/// <param name="repositoryId">ID of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitCherryPick> Cherry_Picks_Get_Cherry_PickAsync(string organization, string project, int cherryPickId, string repositoryId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/cherryPicks/"+cherryPickId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCherryPick>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve information about a cherry pick by cherry pick Id.
		/// Cherry_Picks_Get_Cherry_Pick {organization}/{project}/_apis/git/repositories/{repositoryId}/cherryPicks/{cherryPickId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="cherryPickId">ID of the cherry pick.</param>
		/// <param name="repositoryId">ID of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitCherryPick Cherry_Picks_Get_Cherry_Pick(string organization, string project, int cherryPickId, string repositoryId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/cherryPicks/"+cherryPickId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCherryPick>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a list of commits associated with a particular push.
		/// Commits_Get_Push_Commits {organization}/{project}/_apis/git/repositories/{repositoryId}/commits
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The id or friendly name of the repository. To use the friendly name, projectId must also be specified.</param>
		/// <param name="pushId">The id of the push.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="top">The maximum number of commits to return ("get the top x commits").</param>
		/// <param name="skip">The number of commits to skip.</param>
		/// <param name="includeLinks">Set to false to avoid including REST Url links for resources. Defaults to true.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitCommitRef[]> Commits_Get_Push_CommitsAsync(string organization, string repositoryId, int pushId, string project, int top, int skip, bool includeLinks, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/commits&pushId="+pushId+"&top="+top+"&skip="+skip+"&includeLinks="+includeLinks+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCommitRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a list of commits associated with a particular push.
		/// Commits_Get_Push_Commits {organization}/{project}/_apis/git/repositories/{repositoryId}/commits
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The id or friendly name of the repository. To use the friendly name, projectId must also be specified.</param>
		/// <param name="pushId">The id of the push.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="top">The maximum number of commits to return ("get the top x commits").</param>
		/// <param name="skip">The number of commits to skip.</param>
		/// <param name="includeLinks">Set to false to avoid including REST Url links for resources. Defaults to true.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitCommitRef[] Commits_Get_Push_Commits(string organization, string repositoryId, int pushId, string project, int top, int skip, bool includeLinks, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/commits&pushId="+pushId+"&top="+top+"&skip="+skip+"&includeLinks="+includeLinks+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCommitRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a particular commit.
		/// Commits_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/commits/{commitId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="commitId">The id of the commit.</param>
		/// <param name="repositoryId">The id or friendly name of the repository. To use the friendly name, projectId must also be specified.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="changeCount">The number of changes to include in the result.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitCommit> Commits_GetAsync(string organization, string commitId, string repositoryId, string project, int changeCount, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/commits/"+ (commitId==null? "" : System.Uri.EscapeDataString(commitId))+"&changeCount="+changeCount+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCommit>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a particular commit.
		/// Commits_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/commits/{commitId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="commitId">The id of the commit.</param>
		/// <param name="repositoryId">The id or friendly name of the repository. To use the friendly name, projectId must also be specified.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="changeCount">The number of changes to include in the result.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitCommit Commits_Get(string organization, string commitId, string repositoryId, string project, int changeCount, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/commits/"+ (commitId==null? "" : System.Uri.EscapeDataString(commitId))+"&changeCount="+changeCount+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCommit>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve changes for a particular commit.
		/// Commits_Get_Changes {organization}/{project}/_apis/git/repositories/{repositoryId}/commits/{commitId}/changes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="commitId">The id of the commit.</param>
		/// <param name="repositoryId">The id or friendly name of the repository. To use the friendly name, projectId must also be specified.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="top">The maximum number of changes to return.</param>
		/// <param name="skip">The number of changes to skip.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitCommitChanges> Commits_Get_ChangesAsync(string organization, string commitId, string repositoryId, string project, int top, int skip, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/commits/"+ (commitId==null? "" : System.Uri.EscapeDataString(commitId))+"/changes&top="+top+"&skip="+skip+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCommitChanges>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve changes for a particular commit.
		/// Commits_Get_Changes {organization}/{project}/_apis/git/repositories/{repositoryId}/commits/{commitId}/changes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="commitId">The id of the commit.</param>
		/// <param name="repositoryId">The id or friendly name of the repository. To use the friendly name, projectId must also be specified.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="top">The maximum number of changes to return.</param>
		/// <param name="skip">The number of changes to skip.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitCommitChanges Commits_Get_Changes(string organization, string commitId, string repositoryId, string project, int top, int skip, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/commits/"+ (commitId==null? "" : System.Uri.EscapeDataString(commitId))+"/changes&top="+top+"&skip="+skip+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCommitChanges>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get statuses associated with the Git commit.
		/// Statuses_List {organization}/{project}/_apis/git/repositories/{repositoryId}/commits/{commitId}/statuses
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="commitId">ID of the Git commit.</param>
		/// <param name="repositoryId">ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="top">Optional. The number of statuses to retrieve. Default is 1000.</param>
		/// <param name="skip">Optional. The number of statuses to ignore. Default is 0. For example, to retrieve results 101-150, set top to 50 and skip to 100.</param>
		/// <param name="latestOnly">The flag indicates whether to get only latest statuses grouped by `Context.Name` and `Context.Genre`.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitStatus[]> Statuses_ListAsync(string organization, string commitId, string repositoryId, string project, int top, int skip, bool latestOnly, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/commits/"+ (commitId==null? "" : System.Uri.EscapeDataString(commitId))+"/statuses&top="+top+"&skip="+skip+"&latestOnly="+latestOnly+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitStatus[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get statuses associated with the Git commit.
		/// Statuses_List {organization}/{project}/_apis/git/repositories/{repositoryId}/commits/{commitId}/statuses
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="commitId">ID of the Git commit.</param>
		/// <param name="repositoryId">ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="top">Optional. The number of statuses to retrieve. Default is 1000.</param>
		/// <param name="skip">Optional. The number of statuses to ignore. Default is 0. For example, to retrieve results 101-150, set top to 50 and skip to 100.</param>
		/// <param name="latestOnly">The flag indicates whether to get only latest statuses grouped by `Context.Name` and `Context.Genre`.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitStatus[] Statuses_List(string organization, string commitId, string repositoryId, string project, int top, int skip, bool latestOnly, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/commits/"+ (commitId==null? "" : System.Uri.EscapeDataString(commitId))+"/statuses&top="+top+"&skip="+skip+"&latestOnly="+latestOnly+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitStatus[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create Git commit status.
		/// Statuses_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/commits/{commitId}/statuses
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="commitId">ID of the Git commit.</param>
		/// <param name="repositoryId">ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Git commit status object to create.</param>
		/// <returns>successful operation</returns>
		public async Task<GitStatus> Statuses_CreateAsync(string organization, string commitId, string repositoryId, string project, string api_version, GitStatus requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/commits/"+ (commitId==null? "" : System.Uri.EscapeDataString(commitId))+"/statuses&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create Git commit status.
		/// Statuses_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/commits/{commitId}/statuses
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="commitId">ID of the Git commit.</param>
		/// <param name="repositoryId">ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Git commit status object to create.</param>
		/// <returns>successful operation</returns>
		public GitStatus Statuses_Create(string organization, string commitId, string repositoryId, string project, string api_version, GitStatus requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/commits/"+ (commitId==null? "" : System.Uri.EscapeDataString(commitId))+"/statuses&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve git commits for a project matching the search criteria
		/// Commits_Get_Commits_Batch {organization}/{project}/_apis/git/repositories/{repositoryId}/commitsbatch
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="skip">Number of commits to skip.</param>
		/// <param name="top">Maximum number of commits to return.</param>
		/// <param name="includeStatuses">True to include additional commit status information.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Search options</param>
		/// <returns>successful operation</returns>
		public async Task<GitCommitRef[]> Commits_Get_Commits_BatchAsync(string organization, string repositoryId, string project, int skip, int top, bool includeStatuses, string api_version, GitQueryCommitsCriteria requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/commitsbatch&$skip="+skip+"&$top="+top+"&includeStatuses="+includeStatuses+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCommitRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve git commits for a project matching the search criteria
		/// Commits_Get_Commits_Batch {organization}/{project}/_apis/git/repositories/{repositoryId}/commitsbatch
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="skip">Number of commits to skip.</param>
		/// <param name="top">Maximum number of commits to return.</param>
		/// <param name="includeStatuses">True to include additional commit status information.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Search options</param>
		/// <returns>successful operation</returns>
		public GitCommitRef[] Commits_Get_Commits_Batch(string organization, string repositoryId, string project, int skip, int top, bool includeStatuses, string api_version, GitQueryCommitsCriteria requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/commitsbatch&$skip="+skip+"&$top="+top+"&includeStatuses="+includeStatuses+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCommitRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Find the closest common commit (the merge base) between base and target commits, and get the diff between either the base and target commits or common and target commits.
		/// Diffs_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/diffs/commits
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="diffCommonCommit">If true, diff between common and target commits. If false, diff between base and target commits.</param>
		/// <param name="top">Maximum number of changes to return. Defaults to 100.</param>
		/// <param name="skip">Number of changes to skip</param>
		/// <param name="baseVersion">Version string identifier (name of tag/branch, SHA1 of commit)</param>
		/// <param name="baseVersionOptions">Version options - Specify additional modifiers to version (e.g Previous)</param>
		/// <param name="baseVersionType">Version type (branch, tag, or commit). Determines how Id is interpreted</param>
		/// <param name="targetVersion">Version string identifier (name of tag/branch, SHA1 of commit)</param>
		/// <param name="targetVersionOptions">Version options - Specify additional modifiers to version (e.g Previous)</param>
		/// <param name="targetVersionType">Version type (branch, tag, or commit). Determines how Id is interpreted</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitCommitDiffs> Diffs_GetAsync(string organization, string repositoryId, string project, bool diffCommonCommit, int top, int skip, string baseVersion, GitBaseVersionDescriptorBaseVersionOptions baseVersionOptions, GitBaseVersionDescriptorBaseVersionType baseVersionType, string targetVersion, GitBaseVersionDescriptorBaseVersionOptions targetVersionOptions, GitBaseVersionDescriptorBaseVersionType targetVersionType, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/diffs/commits&diffCommonCommit="+diffCommonCommit+"&$top="+top+"&$skip="+skip+"&baseVersion=" + (baseVersion==null? "" : System.Uri.EscapeDataString(baseVersion))+"&baseVersionOptions=" + baseVersionOptions+"&baseVersionType=" + baseVersionType+"&targetVersion=" + (targetVersion==null? "" : System.Uri.EscapeDataString(targetVersion))+"&targetVersionOptions=" + targetVersionOptions+"&targetVersionType=" + targetVersionType+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCommitDiffs>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Find the closest common commit (the merge base) between base and target commits, and get the diff between either the base and target commits or common and target commits.
		/// Diffs_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/diffs/commits
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="diffCommonCommit">If true, diff between common and target commits. If false, diff between base and target commits.</param>
		/// <param name="top">Maximum number of changes to return. Defaults to 100.</param>
		/// <param name="skip">Number of changes to skip</param>
		/// <param name="baseVersion">Version string identifier (name of tag/branch, SHA1 of commit)</param>
		/// <param name="baseVersionOptions">Version options - Specify additional modifiers to version (e.g Previous)</param>
		/// <param name="baseVersionType">Version type (branch, tag, or commit). Determines how Id is interpreted</param>
		/// <param name="targetVersion">Version string identifier (name of tag/branch, SHA1 of commit)</param>
		/// <param name="targetVersionOptions">Version options - Specify additional modifiers to version (e.g Previous)</param>
		/// <param name="targetVersionType">Version type (branch, tag, or commit). Determines how Id is interpreted</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitCommitDiffs Diffs_Get(string organization, string repositoryId, string project, bool diffCommonCommit, int top, int skip, string baseVersion, GitBaseVersionDescriptorBaseVersionOptions baseVersionOptions, GitBaseVersionDescriptorBaseVersionType baseVersionType, string targetVersion, GitBaseVersionDescriptorBaseVersionOptions targetVersionOptions, GitBaseVersionDescriptorBaseVersionType targetVersionType, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/diffs/commits&diffCommonCommit="+diffCommonCommit+"&$top="+top+"&$skip="+skip+"&baseVersion=" + (baseVersion==null? "" : System.Uri.EscapeDataString(baseVersion))+"&baseVersionOptions=" + baseVersionOptions+"&baseVersionType=" + baseVersionType+"&targetVersion=" + (targetVersion==null? "" : System.Uri.EscapeDataString(targetVersion))+"&targetVersionOptions=" + targetVersionOptions+"&targetVersionType=" + targetVersionType+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCommitDiffs>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve import requests for a repository.
		/// Import_Requests_Query {organization}/{project}/_apis/git/repositories/{repositoryId}/importRequests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="includeAbandoned">True to include abandoned import requests in the results.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitImportRequest[]> Import_Requests_QueryAsync(string organization, string project, string repositoryId, bool includeAbandoned, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/importRequests&includeAbandoned="+includeAbandoned+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitImportRequest[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve import requests for a repository.
		/// Import_Requests_Query {organization}/{project}/_apis/git/repositories/{repositoryId}/importRequests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="includeAbandoned">True to include abandoned import requests in the results.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitImportRequest[] Import_Requests_Query(string organization, string project, string repositoryId, bool includeAbandoned, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/importRequests&includeAbandoned="+includeAbandoned+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitImportRequest[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an import request.
		/// Import_Requests_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/importRequests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The import request to create.</param>
		/// <returns>successful operation</returns>
		public async Task<GitImportRequest> Import_Requests_CreateAsync(string organization, string project, string repositoryId, string api_version, GitImportRequest requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/importRequests&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitImportRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create an import request.
		/// Import_Requests_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/importRequests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The import request to create.</param>
		/// <returns>successful operation</returns>
		public GitImportRequest Import_Requests_Create(string organization, string project, string repositoryId, string api_version, GitImportRequest requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/importRequests&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitImportRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve a particular import request.
		/// Import_Requests_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/importRequests/{importRequestId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="importRequestId">The unique identifier for the import request.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitImportRequest> Import_Requests_GetAsync(string organization, string project, string repositoryId, int importRequestId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/importRequests/"+importRequestId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitImportRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a particular import request.
		/// Import_Requests_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/importRequests/{importRequestId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="importRequestId">The unique identifier for the import request.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitImportRequest Import_Requests_Get(string organization, string project, string repositoryId, int importRequestId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/importRequests/"+importRequestId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitImportRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retry or abandon a failed import request.
		/// 
		/// There can only be one active import request associated with a repository. Marking a failed import request abandoned makes it inactive.
		/// Import_Requests_Update {organization}/{project}/_apis/git/repositories/{repositoryId}/importRequests/{importRequestId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="importRequestId">The unique identifier for the import request to update.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The updated version of the import request. Currently, the only change allowed is setting the Status to Queued or Abandoned.</param>
		/// <returns>successful operation</returns>
		public async Task<GitImportRequest> Import_Requests_UpdateAsync(string organization, string project, string repositoryId, int importRequestId, string api_version, GitImportRequest requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/importRequests/"+importRequestId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitImportRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retry or abandon a failed import request.
		/// 
		/// There can only be one active import request associated with a repository. Marking a failed import request abandoned makes it inactive.
		/// Import_Requests_Update {organization}/{project}/_apis/git/repositories/{repositoryId}/importRequests/{importRequestId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="importRequestId">The unique identifier for the import request to update.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The updated version of the import request. Currently, the only change allowed is setting the Status to Queued or Abandoned.</param>
		/// <returns>successful operation</returns>
		public GitImportRequest Import_Requests_Update(string organization, string project, string repositoryId, int importRequestId, string api_version, GitImportRequest requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/importRequests/"+importRequestId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitImportRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get Item Metadata and/or Content for a collection of items. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
		/// Items_List {organization}/{project}/_apis/git/repositories/{repositoryId}/items
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="scopePath">The path scope.  The default is null.</param>
		/// <param name="recursionLevel">The recursion level of this request. The default is 'none', no recursion.</param>
		/// <param name="includeContentMetadata">Set to true to include content metadata.  Default is false.</param>
		/// <param name="latestProcessedChange">Set to true to include the latest changes.  Default is false.</param>
		/// <param name="download">Set to true to download the response as a file.  Default is false.</param>
		/// <param name="includeLinks">Set to true to include links to items.  Default is false.</param>
		/// <param name="format">If specified, this overrides the HTTP Accept request header to return either 'json' or 'zip'. If $format is specified, then api-version should also be specified as a query parameter.</param>
		/// <param name="versionDescriptor_version">Version string identifier (name of tag/branch, SHA1 of commit)</param>
		/// <param name="versionDescriptor_versionOptions">Version options - Specify additional modifiers to version (e.g Previous)</param>
		/// <param name="versionDescriptor_versionType">Version type (branch, tag, or commit). Determines how Id is interpreted</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitItem[]> Items_ListAsync(string organization, string repositoryId, string project, string scopePath, GitItemDescriptorRecursionLevel recursionLevel, bool includeContentMetadata, bool latestProcessedChange, bool download, bool includeLinks, string format, string versionDescriptor_version, GitBaseVersionDescriptorBaseVersionOptions versionDescriptor_versionOptions, GitBaseVersionDescriptorBaseVersionType versionDescriptor_versionType, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/items&scopePath=" + (scopePath==null? "" : System.Uri.EscapeDataString(scopePath))+"&recursionLevel=" + recursionLevel+"&includeContentMetadata="+includeContentMetadata+"&latestProcessedChange="+latestProcessedChange+"&download="+download+"&includeLinks="+includeLinks+"&$format=" + (format==null? "" : System.Uri.EscapeDataString(format))+"&versionDescriptor.version=" + (versionDescriptor_version==null? "" : System.Uri.EscapeDataString(versionDescriptor_version))+"&versionDescriptor.versionOptions=" + versionDescriptor_versionOptions+"&versionDescriptor.versionType=" + versionDescriptor_versionType+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitItem[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Item Metadata and/or Content for a collection of items. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
		/// Items_List {organization}/{project}/_apis/git/repositories/{repositoryId}/items
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="scopePath">The path scope.  The default is null.</param>
		/// <param name="recursionLevel">The recursion level of this request. The default is 'none', no recursion.</param>
		/// <param name="includeContentMetadata">Set to true to include content metadata.  Default is false.</param>
		/// <param name="latestProcessedChange">Set to true to include the latest changes.  Default is false.</param>
		/// <param name="download">Set to true to download the response as a file.  Default is false.</param>
		/// <param name="includeLinks">Set to true to include links to items.  Default is false.</param>
		/// <param name="format">If specified, this overrides the HTTP Accept request header to return either 'json' or 'zip'. If $format is specified, then api-version should also be specified as a query parameter.</param>
		/// <param name="versionDescriptor_version">Version string identifier (name of tag/branch, SHA1 of commit)</param>
		/// <param name="versionDescriptor_versionOptions">Version options - Specify additional modifiers to version (e.g Previous)</param>
		/// <param name="versionDescriptor_versionType">Version type (branch, tag, or commit). Determines how Id is interpreted</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitItem[] Items_List(string organization, string repositoryId, string project, string scopePath, GitItemDescriptorRecursionLevel recursionLevel, bool includeContentMetadata, bool latestProcessedChange, bool download, bool includeLinks, string format, string versionDescriptor_version, GitBaseVersionDescriptorBaseVersionOptions versionDescriptor_versionOptions, GitBaseVersionDescriptorBaseVersionType versionDescriptor_versionType, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/items&scopePath=" + (scopePath==null? "" : System.Uri.EscapeDataString(scopePath))+"&recursionLevel=" + recursionLevel+"&includeContentMetadata="+includeContentMetadata+"&latestProcessedChange="+latestProcessedChange+"&download="+download+"&includeLinks="+includeLinks+"&$format=" + (format==null? "" : System.Uri.EscapeDataString(format))+"&versionDescriptor.version=" + (versionDescriptor_version==null? "" : System.Uri.EscapeDataString(versionDescriptor_version))+"&versionDescriptor.versionOptions=" + versionDescriptor_versionOptions+"&versionDescriptor.versionType=" + versionDescriptor_versionType+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitItem[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Post for retrieving a creating a batch out of a set of items in a repo / project given a list of paths or a long path
		/// Items_Get_Items_Batch {organization}/{project}/_apis/git/repositories/{repositoryId}/itemsbatch
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Request data attributes: ItemDescriptors, IncludeContentMetadata, LatestProcessedChange, IncludeLinks. ItemDescriptors: Collection of items to fetch, including path, version, and recursion level. IncludeContentMetadata: Whether to include metadata for all items LatestProcessedChange: Whether to include shallow ref to commit that last changed each item. IncludeLinks: Whether to include the _links field on the shallow references.</param>
		/// <returns>successful operation</returns>
		public async Task<string[]> Items_Get_Items_BatchAsync(string organization, string repositoryId, string project, string api_version, GitItemRequestData requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/itemsbatch&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Post for retrieving a creating a batch out of a set of items in a repo / project given a list of paths or a long path
		/// Items_Get_Items_Batch {organization}/{project}/_apis/git/repositories/{repositoryId}/itemsbatch
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Request data attributes: ItemDescriptors, IncludeContentMetadata, LatestProcessedChange, IncludeLinks. ItemDescriptors: Collection of items to fetch, including path, version, and recursion level. IncludeContentMetadata: Whether to include metadata for all items LatestProcessedChange: Whether to include shallow ref to commit that last changed each item. IncludeLinks: Whether to include the _links field on the shallow references.</param>
		/// <returns>successful operation</returns>
		public string[] Items_Get_Items_Batch(string organization, string repositoryId, string project, string api_version, GitItemRequestData requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/itemsbatch&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// This API is used to find what pull requests are related to a given commit.  It can be used to either find the pull request that created a particular merge commit or it can be used to find all pull requests that have ever merged a particular commit.  The input is a list of queries which each contain a list of commits. For each commit that you search against, you will get back a dictionary of commit -> pull requests.
		/// Pull_Request_Query_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullrequestquery
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The list of queries to perform.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequestQuery> Pull_Request_Query_GetAsync(string organization, string repositoryId, string project, string api_version, GitPullRequestQuery requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullrequestquery&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestQuery>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// This API is used to find what pull requests are related to a given commit.  It can be used to either find the pull request that created a particular merge commit or it can be used to find all pull requests that have ever merged a particular commit.  The input is a list of queries which each contain a list of commits. For each commit that you search against, you will get back a dictionary of commit -> pull requests.
		/// Pull_Request_Query_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullrequestquery
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The list of queries to perform.</param>
		/// <returns>successful operation</returns>
		public GitPullRequestQuery Pull_Request_Query_Get(string organization, string repositoryId, string project, string api_version, GitPullRequestQuery requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullrequestquery&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestQuery>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve all pull requests matching a specified criteria.
		/// Pull_Requests_Get_Pull_Requests {organization}/{project}/_apis/git/repositories/{repositoryId}/pullrequests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="searchCriteria_creatorId">If set, search for pull requests that were created by this identity.</param>
		/// <param name="searchCriteria_includeLinks">Whether to include the _links field on the shallow references</param>
		/// <param name="searchCriteria_repositoryId">If set, search for pull requests whose target branch is in this repository.</param>
		/// <param name="searchCriteria_reviewerId">If set, search for pull requests that have this identity as a reviewer.</param>
		/// <param name="searchCriteria_sourceRefName">If set, search for pull requests from this branch.</param>
		/// <param name="searchCriteria_sourceRepositoryId">If set, search for pull requests whose source branch is in this repository.</param>
		/// <param name="searchCriteria_status">If set, search for pull requests that are in this state. Defaults to Active if unset.</param>
		/// <param name="searchCriteria_targetRefName">If set, search for pull requests into this branch.</param>
		/// <param name="maxCommentLength">Not used.</param>
		/// <param name="skip">The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100.</param>
		/// <param name="top">The number of pull requests to retrieve.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequest[]> Pull_Requests_Get_Pull_RequestsAsync(string organization, string repositoryId, string project, string searchCriteria_creatorId, bool searchCriteria_includeLinks, string searchCriteria_repositoryId, string searchCriteria_reviewerId, string searchCriteria_sourceRefName, string searchCriteria_sourceRepositoryId, GitPullRequestStatus searchCriteria_status, string searchCriteria_targetRefName, int maxCommentLength, int skip, int top, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullrequests&searchCriteria.creatorId=" + (searchCriteria_creatorId==null? "" : System.Uri.EscapeDataString(searchCriteria_creatorId))+"&searchCriteria.includeLinks="+searchCriteria_includeLinks+"&searchCriteria.repositoryId=" + (searchCriteria_repositoryId==null? "" : System.Uri.EscapeDataString(searchCriteria_repositoryId))+"&searchCriteria.reviewerId=" + (searchCriteria_reviewerId==null? "" : System.Uri.EscapeDataString(searchCriteria_reviewerId))+"&searchCriteria.sourceRefName=" + (searchCriteria_sourceRefName==null? "" : System.Uri.EscapeDataString(searchCriteria_sourceRefName))+"&searchCriteria.sourceRepositoryId=" + (searchCriteria_sourceRepositoryId==null? "" : System.Uri.EscapeDataString(searchCriteria_sourceRepositoryId))+"&searchCriteria.status=" + searchCriteria_status+"&searchCriteria.targetRefName=" + (searchCriteria_targetRefName==null? "" : System.Uri.EscapeDataString(searchCriteria_targetRefName))+"&maxCommentLength="+maxCommentLength+"&$skip="+skip+"&$top="+top+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequest[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all pull requests matching a specified criteria.
		/// Pull_Requests_Get_Pull_Requests {organization}/{project}/_apis/git/repositories/{repositoryId}/pullrequests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="searchCriteria_creatorId">If set, search for pull requests that were created by this identity.</param>
		/// <param name="searchCriteria_includeLinks">Whether to include the _links field on the shallow references</param>
		/// <param name="searchCriteria_repositoryId">If set, search for pull requests whose target branch is in this repository.</param>
		/// <param name="searchCriteria_reviewerId">If set, search for pull requests that have this identity as a reviewer.</param>
		/// <param name="searchCriteria_sourceRefName">If set, search for pull requests from this branch.</param>
		/// <param name="searchCriteria_sourceRepositoryId">If set, search for pull requests whose source branch is in this repository.</param>
		/// <param name="searchCriteria_status">If set, search for pull requests that are in this state. Defaults to Active if unset.</param>
		/// <param name="searchCriteria_targetRefName">If set, search for pull requests into this branch.</param>
		/// <param name="maxCommentLength">Not used.</param>
		/// <param name="skip">The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100.</param>
		/// <param name="top">The number of pull requests to retrieve.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitPullRequest[] Pull_Requests_Get_Pull_Requests(string organization, string repositoryId, string project, string searchCriteria_creatorId, bool searchCriteria_includeLinks, string searchCriteria_repositoryId, string searchCriteria_reviewerId, string searchCriteria_sourceRefName, string searchCriteria_sourceRepositoryId, GitPullRequestStatus searchCriteria_status, string searchCriteria_targetRefName, int maxCommentLength, int skip, int top, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullrequests&searchCriteria.creatorId=" + (searchCriteria_creatorId==null? "" : System.Uri.EscapeDataString(searchCriteria_creatorId))+"&searchCriteria.includeLinks="+searchCriteria_includeLinks+"&searchCriteria.repositoryId=" + (searchCriteria_repositoryId==null? "" : System.Uri.EscapeDataString(searchCriteria_repositoryId))+"&searchCriteria.reviewerId=" + (searchCriteria_reviewerId==null? "" : System.Uri.EscapeDataString(searchCriteria_reviewerId))+"&searchCriteria.sourceRefName=" + (searchCriteria_sourceRefName==null? "" : System.Uri.EscapeDataString(searchCriteria_sourceRefName))+"&searchCriteria.sourceRepositoryId=" + (searchCriteria_sourceRepositoryId==null? "" : System.Uri.EscapeDataString(searchCriteria_sourceRepositoryId))+"&searchCriteria.status=" + searchCriteria_status+"&searchCriteria.targetRefName=" + (searchCriteria_targetRefName==null? "" : System.Uri.EscapeDataString(searchCriteria_targetRefName))+"&maxCommentLength="+maxCommentLength+"&$skip="+skip+"&$top="+top+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequest[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a pull request.
		/// Pull_Requests_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/pullrequests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="supportsIterations">If true, subsequent pushes to the pull request will be individually reviewable. Set this to false for large pull requests for performance reasons if this functionality is not needed.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The pull request to create.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequest> Pull_Requests_CreateAsync(string organization, string repositoryId, string project, bool supportsIterations, string api_version, GitPullRequest requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullrequests&supportsIterations="+supportsIterations+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a pull request.
		/// Pull_Requests_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/pullrequests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="supportsIterations">If true, subsequent pushes to the pull request will be individually reviewable. Set this to false for large pull requests for performance reasons if this functionality is not needed.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The pull request to create.</param>
		/// <returns>successful operation</returns>
		public GitPullRequest Pull_Requests_Create(string organization, string repositoryId, string project, bool supportsIterations, string api_version, GitPullRequest requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullrequests&supportsIterations="+supportsIterations+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve a pull request.
		/// Pull_Requests_Get_Pull_Request {organization}/{project}/_apis/git/repositories/{repositoryId}/pullrequests/{pullRequestId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">The ID of the pull request to retrieve.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="maxCommentLength">Not used.</param>
		/// <param name="skip">Not used.</param>
		/// <param name="top">Not used.</param>
		/// <param name="includeCommits">If true, the pull request will be returned with the associated commits.</param>
		/// <param name="includeWorkItemRefs">If true, the pull request will be returned with the associated work item references.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequest> Pull_Requests_Get_Pull_RequestAsync(string organization, string repositoryId, int pullRequestId, string project, int maxCommentLength, int skip, int top, bool includeCommits, bool includeWorkItemRefs, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullrequests/"+pullRequestId+"&maxCommentLength="+maxCommentLength+"&$skip="+skip+"&$top="+top+"&includeCommits="+includeCommits+"&includeWorkItemRefs="+includeWorkItemRefs+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a pull request.
		/// Pull_Requests_Get_Pull_Request {organization}/{project}/_apis/git/repositories/{repositoryId}/pullrequests/{pullRequestId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">The ID of the pull request to retrieve.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="maxCommentLength">Not used.</param>
		/// <param name="skip">Not used.</param>
		/// <param name="top">Not used.</param>
		/// <param name="includeCommits">If true, the pull request will be returned with the associated commits.</param>
		/// <param name="includeWorkItemRefs">If true, the pull request will be returned with the associated work item references.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitPullRequest Pull_Requests_Get_Pull_Request(string organization, string repositoryId, int pullRequestId, string project, int maxCommentLength, int skip, int top, bool includeCommits, bool includeWorkItemRefs, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullrequests/"+pullRequestId+"&maxCommentLength="+maxCommentLength+"&$skip="+skip+"&$top="+top+"&includeCommits="+includeCommits+"&includeWorkItemRefs="+includeWorkItemRefs+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a pull request
		/// 
		/// These are the properties that can be updated with the API:
		/// - Status
		/// - Title
		/// - Description (up to 4000 characters)
		/// - CompletionOptions
		/// - MergeOptions
		/// - AutoCompleteSetBy.Id
		/// - TargetRefName (when the PR retargeting feature is enabled)
		/// Attempting to update other properties outside of this list will either cause the server to throw an `InvalidArgumentValueException`,
		/// or to silently ignore the update.
		/// Pull_Requests_Update {organization}/{project}/_apis/git/repositories/{repositoryId}/pullrequests/{pullRequestId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request to update.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The pull request content that should be updated.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequest> Pull_Requests_UpdateAsync(string organization, string repositoryId, int pullRequestId, string project, string api_version, GitPullRequest requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullrequests/"+pullRequestId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update a pull request
		/// 
		/// These are the properties that can be updated with the API:
		/// - Status
		/// - Title
		/// - Description (up to 4000 characters)
		/// - CompletionOptions
		/// - MergeOptions
		/// - AutoCompleteSetBy.Id
		/// - TargetRefName (when the PR retargeting feature is enabled)
		/// Attempting to update other properties outside of this list will either cause the server to throw an `InvalidArgumentValueException`,
		/// or to silently ignore the update.
		/// Pull_Requests_Update {organization}/{project}/_apis/git/repositories/{repositoryId}/pullrequests/{pullRequestId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request to update.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The pull request content that should be updated.</param>
		/// <returns>successful operation</returns>
		public GitPullRequest Pull_Requests_Update(string organization, string repositoryId, int pullRequestId, string project, string api_version, GitPullRequest requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullrequests/"+pullRequestId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a list of files attached to a given pull request.
		/// Pull_Request_Attachments_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/attachments
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<Attachment[]> Pull_Request_Attachments_ListAsync(string organization, string repositoryId, int pullRequestId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/attachments&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Attachment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a list of files attached to a given pull request.
		/// Pull_Request_Attachments_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/attachments
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public Attachment[] Pull_Request_Attachments_List(string organization, string repositoryId, int pullRequestId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/attachments&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Attachment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the file content of a pull request attachment.
		/// Pull_Request_Attachments_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/attachments/{fileName}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="fileName">The name of the attachment.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Pull_Request_Attachments_GetAsync(string organization, string fileName, string repositoryId, int pullRequestId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/attachments/"+ (fileName==null? "" : System.Uri.EscapeDataString(fileName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the file content of a pull request attachment.
		/// Pull_Request_Attachments_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/attachments/{fileName}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="fileName">The name of the attachment.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Pull_Request_Attachments_Get(string organization, string fileName, string repositoryId, int pullRequestId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/attachments/"+ (fileName==null? "" : System.Uri.EscapeDataString(fileName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a pull request attachment.
		/// Pull_Request_Attachments_Delete {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/attachments/{fileName}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="fileName">The name of the attachment to delete.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Pull_Request_Attachments_DeleteAsync(string organization, string fileName, string repositoryId, int pullRequestId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/attachments/"+ (fileName==null? "" : System.Uri.EscapeDataString(fileName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a pull request attachment.
		/// Pull_Request_Attachments_Delete {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/attachments/{fileName}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="fileName">The name of the attachment to delete.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Pull_Request_Attachments_Delete(string organization, string fileName, string repositoryId, int pullRequestId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/attachments/"+ (fileName==null? "" : System.Uri.EscapeDataString(fileName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the commits for the specified pull request.
		/// Pull_Request_Commits_Get_Pull_Request_Commits {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/commits
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">ID or name of the repository.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="top">Maximum number of commits to return.</param>
		/// <param name="continuationToken">The continuation token used for pagination.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitCommitRef[]> Pull_Request_Commits_Get_Pull_Request_CommitsAsync(string organization, string repositoryId, int pullRequestId, string project, int top, string continuationToken, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/commits&$top="+top+"&continuationToken=" + (continuationToken==null? "" : System.Uri.EscapeDataString(continuationToken))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCommitRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the commits for the specified pull request.
		/// Pull_Request_Commits_Get_Pull_Request_Commits {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/commits
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">ID or name of the repository.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="top">Maximum number of commits to return.</param>
		/// <param name="continuationToken">The continuation token used for pagination.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitCommitRef[] Pull_Request_Commits_Get_Pull_Request_Commits(string organization, string repositoryId, int pullRequestId, string project, int top, string continuationToken, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/commits&$top="+top+"&continuationToken=" + (continuationToken==null? "" : System.Uri.EscapeDataString(continuationToken))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCommitRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the list of iterations for the specified pull request.
		/// Pull_Request_Iterations_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">ID or name of the repository.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="includeCommits">If true, include the commits associated with each iteration in the response.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequestIteration[]> Pull_Request_Iterations_ListAsync(string organization, string repositoryId, int pullRequestId, string project, bool includeCommits, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/iterations&includeCommits="+includeCommits+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestIteration[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the list of iterations for the specified pull request.
		/// Pull_Request_Iterations_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">ID or name of the repository.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="includeCommits">If true, include the commits associated with each iteration in the response.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitPullRequestIteration[] Pull_Request_Iterations_List(string organization, string repositoryId, int pullRequestId, string project, bool includeCommits, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/iterations&includeCommits="+includeCommits+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestIteration[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the specified iteration for a pull request.
		/// Pull_Request_Iterations_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">ID or name of the repository.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="iterationId">ID of the pull request iteration to return.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequestIteration> Pull_Request_Iterations_GetAsync(string organization, string repositoryId, int pullRequestId, int iterationId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/iterations/"+iterationId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestIteration>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the specified iteration for a pull request.
		/// Pull_Request_Iterations_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">ID or name of the repository.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="iterationId">ID of the pull request iteration to return.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitPullRequestIteration Pull_Request_Iterations_Get(string organization, string repositoryId, int pullRequestId, int iterationId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/iterations/"+iterationId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestIteration>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the changes made in a pull request between two iterations.
		/// Pull_Request_Iteration_Changes_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}/changes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="iterationId">ID of the pull request iteration. <br /> Iteration IDs are zero-based with zero indicating the common commit between the source and target branches. Iteration one is the head of the source branch at the time the pull request is created and subsequent iterations are created when there are pushes to the source branch.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="top">Optional. The number of changes to retrieve.  The default value is 100 and the maximum value is 2000.</param>
		/// <param name="skip">Optional. The number of changes to ignore.  For example, to retrieve changes 101-150, set top 50 and skip to 100.</param>
		/// <param name="compareTo">ID of the pull request iteration to compare against.  The default value is zero which indicates the comparison is made against the common commit between the source and target branches</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequestIterationChanges> Pull_Request_Iteration_Changes_GetAsync(string organization, string repositoryId, int pullRequestId, int iterationId, string project, int top, int skip, int compareTo, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/iterations/"+iterationId+"/changes&$top="+top+"&$skip="+skip+"&$compareTo="+compareTo+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestIterationChanges>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the changes made in a pull request between two iterations.
		/// Pull_Request_Iteration_Changes_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}/changes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="iterationId">ID of the pull request iteration. <br /> Iteration IDs are zero-based with zero indicating the common commit between the source and target branches. Iteration one is the head of the source branch at the time the pull request is created and subsequent iterations are created when there are pushes to the source branch.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="top">Optional. The number of changes to retrieve.  The default value is 100 and the maximum value is 2000.</param>
		/// <param name="skip">Optional. The number of changes to ignore.  For example, to retrieve changes 101-150, set top 50 and skip to 100.</param>
		/// <param name="compareTo">ID of the pull request iteration to compare against.  The default value is zero which indicates the comparison is made against the common commit between the source and target branches</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitPullRequestIterationChanges Pull_Request_Iteration_Changes_Get(string organization, string repositoryId, int pullRequestId, int iterationId, string project, int top, int skip, int compareTo, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/iterations/"+iterationId+"/changes&$top="+top+"&$skip="+skip+"&$compareTo="+compareTo+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestIterationChanges>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the commits for the specified iteration of a pull request.
		/// Pull_Request_Commits_Get_Pull_Request_Iteration_Commits {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}/commits
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">ID or name of the repository.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="iterationId">ID of the iteration from which to get the commits.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="top">Maximum number of commits to return. The maximum number of commits that can be returned per batch is 500.</param>
		/// <param name="skip">Number of commits to skip.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitCommitRef[]> Pull_Request_Commits_Get_Pull_Request_Iteration_CommitsAsync(string organization, string repositoryId, int pullRequestId, int iterationId, string project, int top, int skip, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/iterations/"+iterationId+"/commits&top="+top+"&skip="+skip+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCommitRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the commits for the specified iteration of a pull request.
		/// Pull_Request_Commits_Get_Pull_Request_Iteration_Commits {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}/commits
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">ID or name of the repository.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="iterationId">ID of the iteration from which to get the commits.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="top">Maximum number of commits to return. The maximum number of commits that can be returned per batch is 500.</param>
		/// <param name="skip">Number of commits to skip.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitCommitRef[] Pull_Request_Commits_Get_Pull_Request_Iteration_Commits(string organization, string repositoryId, int pullRequestId, int iterationId, string project, int top, int skip, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/iterations/"+iterationId+"/commits&top="+top+"&skip="+skip+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCommitRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all the statuses associated with a pull request iteration.
		/// Pull_Request_Iteration_Statuses_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}/statuses
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="iterationId">ID of the pull request iteration.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequestStatus[]> Pull_Request_Iteration_Statuses_ListAsync(string organization, string repositoryId, int pullRequestId, int iterationId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/iterations/"+iterationId+"/statuses&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestStatus[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all the statuses associated with a pull request iteration.
		/// Pull_Request_Iteration_Statuses_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}/statuses
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="iterationId">ID of the pull request iteration.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitPullRequestStatus[] Pull_Request_Iteration_Statuses_List(string organization, string repositoryId, int pullRequestId, int iterationId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/iterations/"+iterationId+"/statuses&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestStatus[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a pull request status on the iteration. This operation will have the same result as Create status on pull request with specified iteration ID in the request body.
		/// 
		/// The only required field for the status is `Context.Name` that uniquely identifies the status.
		/// Note that `iterationId` in the request body is optional since `iterationId` can be specified in the URL.
		/// A conflict between `iterationId` in the URL and `iterationId` in the request body will result in status code 400.
		/// Pull_Request_Iteration_Statuses_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}/statuses
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="iterationId">ID of the pull request iteration.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Pull request status to create.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequestStatus> Pull_Request_Iteration_Statuses_CreateAsync(string organization, string repositoryId, int pullRequestId, int iterationId, string project, string api_version, GitPullRequestStatus requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/iterations/"+iterationId+"/statuses&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a pull request status on the iteration. This operation will have the same result as Create status on pull request with specified iteration ID in the request body.
		/// 
		/// The only required field for the status is `Context.Name` that uniquely identifies the status.
		/// Note that `iterationId` in the request body is optional since `iterationId` can be specified in the URL.
		/// A conflict between `iterationId` in the URL and `iterationId` in the request body will result in status code 400.
		/// Pull_Request_Iteration_Statuses_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}/statuses
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="iterationId">ID of the pull request iteration.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Pull request status to create.</param>
		/// <returns>successful operation</returns>
		public GitPullRequestStatus Pull_Request_Iteration_Statuses_Create(string organization, string repositoryId, int pullRequestId, int iterationId, string project, string api_version, GitPullRequestStatus requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/iterations/"+iterationId+"/statuses&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the specific pull request iteration status by ID. The status ID is unique within the pull request across all iterations.
		/// Pull_Request_Iteration_Statuses_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}/statuses/{statusId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="iterationId">ID of the pull request iteration.</param>
		/// <param name="statusId">ID of the pull request status.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequestStatus> Pull_Request_Iteration_Statuses_GetAsync(string organization, string repositoryId, int pullRequestId, int iterationId, int statusId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/iterations/"+iterationId+"/statuses/"+statusId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the specific pull request iteration status by ID. The status ID is unique within the pull request across all iterations.
		/// Pull_Request_Iteration_Statuses_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}/statuses/{statusId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="iterationId">ID of the pull request iteration.</param>
		/// <param name="statusId">ID of the pull request status.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitPullRequestStatus Pull_Request_Iteration_Statuses_Get(string organization, string repositoryId, int pullRequestId, int iterationId, int statusId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/iterations/"+iterationId+"/statuses/"+statusId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete pull request iteration status.
		/// 
		/// You can remove multiple statuses in one call by using Update operation.
		/// Pull_Request_Iteration_Statuses_Delete {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}/statuses/{statusId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="iterationId">ID of the pull request iteration.</param>
		/// <param name="statusId">ID of the pull request status.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Pull_Request_Iteration_Statuses_DeleteAsync(string organization, string repositoryId, int pullRequestId, int iterationId, int statusId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/iterations/"+iterationId+"/statuses/"+statusId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete pull request iteration status.
		/// 
		/// You can remove multiple statuses in one call by using Update operation.
		/// Pull_Request_Iteration_Statuses_Delete {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}/statuses/{statusId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="iterationId">ID of the pull request iteration.</param>
		/// <param name="statusId">ID of the pull request status.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Pull_Request_Iteration_Statuses_Delete(string organization, string repositoryId, int pullRequestId, int iterationId, int statusId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/iterations/"+iterationId+"/statuses/"+statusId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all the labels assigned to a pull request.
		/// Pull_Request_Labels_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/labels
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="projectId">Project ID or project name.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<WebApiTagDefinition[]> Pull_Request_Labels_ListAsync(string organization, string repositoryId, int pullRequestId, string project, string projectId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/labels&projectId=" + (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<WebApiTagDefinition[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all the labels assigned to a pull request.
		/// Pull_Request_Labels_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/labels
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="projectId">Project ID or project name.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public WebApiTagDefinition[] Pull_Request_Labels_List(string organization, string repositoryId, int pullRequestId, string project, string projectId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/labels&projectId=" + (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<WebApiTagDefinition[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a label for a specified pull request. The only required field is the name of the new label.
		/// Pull_Request_Labels_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/labels
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="projectId">Project ID or project name.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Label to assign to the pull request.</param>
		/// <returns>successful operation</returns>
		public async Task<WebApiTagDefinition> Pull_Request_Labels_CreateAsync(string organization, string repositoryId, int pullRequestId, string project, string projectId, string api_version, WebApiCreateTagRequestData requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/labels&projectId=" + (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<WebApiTagDefinition>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a label for a specified pull request. The only required field is the name of the new label.
		/// Pull_Request_Labels_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/labels
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="projectId">Project ID or project name.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Label to assign to the pull request.</param>
		/// <returns>successful operation</returns>
		public WebApiTagDefinition Pull_Request_Labels_Create(string organization, string repositoryId, int pullRequestId, string project, string projectId, string api_version, WebApiCreateTagRequestData requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/labels&projectId=" + (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<WebApiTagDefinition>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a single label that has been assigned to a pull request.
		/// Pull_Request_Labels_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/labels/{labelIdOrName}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="labelIdOrName">The name or ID of the label requested.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="projectId">Project ID or project name.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<WebApiTagDefinition> Pull_Request_Labels_GetAsync(string organization, string repositoryId, int pullRequestId, string labelIdOrName, string project, string projectId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/labels/"+ (labelIdOrName==null? "" : System.Uri.EscapeDataString(labelIdOrName))+"&projectId=" + (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<WebApiTagDefinition>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a single label that has been assigned to a pull request.
		/// Pull_Request_Labels_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/labels/{labelIdOrName}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="labelIdOrName">The name or ID of the label requested.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="projectId">Project ID or project name.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public WebApiTagDefinition Pull_Request_Labels_Get(string organization, string repositoryId, int pullRequestId, string labelIdOrName, string project, string projectId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/labels/"+ (labelIdOrName==null? "" : System.Uri.EscapeDataString(labelIdOrName))+"&projectId=" + (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<WebApiTagDefinition>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes a label from the set of those assigned to the pull request.
		/// Pull_Request_Labels_Delete {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/labels/{labelIdOrName}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="labelIdOrName">The name or ID of the label requested.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="projectId">Project ID or project name.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Pull_Request_Labels_DeleteAsync(string organization, string repositoryId, int pullRequestId, string labelIdOrName, string project, string projectId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/labels/"+ (labelIdOrName==null? "" : System.Uri.EscapeDataString(labelIdOrName))+"&projectId=" + (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes a label from the set of those assigned to the pull request.
		/// Pull_Request_Labels_Delete {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/labels/{labelIdOrName}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="labelIdOrName">The name or ID of the label requested.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="projectId">Project ID or project name.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Pull_Request_Labels_Delete(string organization, string repositoryId, int pullRequestId, string labelIdOrName, string project, string projectId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/labels/"+ (labelIdOrName==null? "" : System.Uri.EscapeDataString(labelIdOrName))+"&projectId=" + (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get external properties of the pull request.
		/// Pull_Request_Properties_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/properties
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<PropertiesCollection> Pull_Request_Properties_ListAsync(string organization, string repositoryId, int pullRequestId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/properties&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PropertiesCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get external properties of the pull request.
		/// Pull_Request_Properties_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/properties
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public PropertiesCollection Pull_Request_Properties_List(string organization, string repositoryId, int pullRequestId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/properties&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PropertiesCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the reviewers for a pull request
		/// Pull_Request_Reviewers_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<IdentityRefWithVote[]> Pull_Request_Reviewers_ListAsync(string organization, string repositoryId, int pullRequestId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/reviewers&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdentityRefWithVote[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the reviewers for a pull request
		/// Pull_Request_Reviewers_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public IdentityRefWithVote[] Pull_Request_Reviewers_List(string organization, string repositoryId, int pullRequestId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/reviewers&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdentityRefWithVote[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add an unmaterialized identity to the reviewers of a pull request.
		/// Pull_Request_Reviewers_Create_Unmaterialized_Pull_Request_Reviewer {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Reviewer to add to the pull request.</param>
		/// <returns>successful operation</returns>
		public async Task<IdentityRefWithVote> Pull_Request_Reviewers_Create_Unmaterialized_Pull_Request_ReviewerAsync(string organization, string repositoryId, int pullRequestId, string project, string api_version, IdentityRefWithVote requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/reviewers&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdentityRefWithVote>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Add an unmaterialized identity to the reviewers of a pull request.
		/// Pull_Request_Reviewers_Create_Unmaterialized_Pull_Request_Reviewer {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Reviewer to add to the pull request.</param>
		/// <returns>successful operation</returns>
		public IdentityRefWithVote Pull_Request_Reviewers_Create_Unmaterialized_Pull_Request_Reviewer(string organization, string repositoryId, int pullRequestId, string project, string api_version, IdentityRefWithVote requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/reviewers&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdentityRefWithVote>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Add reviewers to a pull request.
		/// Pull_Request_Reviewers_Create_Pull_Request_Reviewers {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Reviewers to add to the pull request.</param>
		/// <returns>successful operation</returns>
		public async Task<IdentityRefWithVote[]> Pull_Request_Reviewers_Create_Pull_Request_ReviewersAsync(string organization, string repositoryId, int pullRequestId, string project, string api_version, IdentityRef[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/reviewers&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdentityRefWithVote[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Add reviewers to a pull request.
		/// Pull_Request_Reviewers_Create_Pull_Request_Reviewers {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Reviewers to add to the pull request.</param>
		/// <returns>successful operation</returns>
		public IdentityRefWithVote[] Pull_Request_Reviewers_Create_Pull_Request_Reviewers(string organization, string repositoryId, int pullRequestId, string project, string api_version, IdentityRef[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/reviewers&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdentityRefWithVote[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Reset the votes of multiple reviewers on a pull request.  NOTE: This endpoint only supports updating votes, but does not support updating required reviewers (use policy) or display names.
		/// Pull_Request_Reviewers_Update_Pull_Request_Reviewers {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">IDs of the reviewers whose votes will be reset to zero</param>
		/// <returns>successful operation</returns>
		public async Task Pull_Request_Reviewers_Update_Pull_Request_ReviewersAsync(string organization, string repositoryId, int pullRequestId, string project, string api_version, IdentityRefWithVote[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/reviewers&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Reset the votes of multiple reviewers on a pull request.  NOTE: This endpoint only supports updating votes, but does not support updating required reviewers (use policy) or display names.
		/// Pull_Request_Reviewers_Update_Pull_Request_Reviewers {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">IDs of the reviewers whose votes will be reset to zero</param>
		/// <returns>successful operation</returns>
		public void Pull_Request_Reviewers_Update_Pull_Request_Reviewers(string organization, string repositoryId, int pullRequestId, string project, string api_version, IdentityRefWithVote[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/reviewers&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve information about a particular reviewer on a pull request
		/// Pull_Request_Reviewers_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers/{reviewerId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="reviewerId">ID of the reviewer.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<IdentityRefWithVote> Pull_Request_Reviewers_GetAsync(string organization, string repositoryId, int pullRequestId, string reviewerId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/reviewers/"+ (reviewerId==null? "" : System.Uri.EscapeDataString(reviewerId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdentityRefWithVote>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve information about a particular reviewer on a pull request
		/// Pull_Request_Reviewers_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers/{reviewerId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="reviewerId">ID of the reviewer.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public IdentityRefWithVote Pull_Request_Reviewers_Get(string organization, string repositoryId, int pullRequestId, string reviewerId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/reviewers/"+ (reviewerId==null? "" : System.Uri.EscapeDataString(reviewerId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdentityRefWithVote>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a reviewer to a pull request or cast a vote.
		/// Pull_Request_Reviewers_Create_Pull_Request_Reviewer {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers/{reviewerId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="reviewerId">ID of the reviewer.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Reviewer's vote.<br />If the reviewer's ID is included here, it must match the reviewerID parameter.<br />Reviewers can set their own vote with this method.  When adding other reviewers, vote must be set to zero.</param>
		/// <returns>successful operation</returns>
		public async Task<IdentityRefWithVote> Pull_Request_Reviewers_Create_Pull_Request_ReviewerAsync(string organization, string repositoryId, int pullRequestId, string reviewerId, string project, string api_version, IdentityRefWithVote requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/reviewers/"+ (reviewerId==null? "" : System.Uri.EscapeDataString(reviewerId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdentityRefWithVote>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Add a reviewer to a pull request or cast a vote.
		/// Pull_Request_Reviewers_Create_Pull_Request_Reviewer {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers/{reviewerId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="reviewerId">ID of the reviewer.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Reviewer's vote.<br />If the reviewer's ID is included here, it must match the reviewerID parameter.<br />Reviewers can set their own vote with this method.  When adding other reviewers, vote must be set to zero.</param>
		/// <returns>successful operation</returns>
		public IdentityRefWithVote Pull_Request_Reviewers_Create_Pull_Request_Reviewer(string organization, string repositoryId, int pullRequestId, string reviewerId, string project, string api_version, IdentityRefWithVote requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/reviewers/"+ (reviewerId==null? "" : System.Uri.EscapeDataString(reviewerId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdentityRefWithVote>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove a reviewer from a pull request.
		/// Pull_Request_Reviewers_Delete {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers/{reviewerId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="reviewerId">ID of the reviewer to remove.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Pull_Request_Reviewers_DeleteAsync(string organization, string repositoryId, int pullRequestId, string reviewerId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/reviewers/"+ (reviewerId==null? "" : System.Uri.EscapeDataString(reviewerId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove a reviewer from a pull request.
		/// Pull_Request_Reviewers_Delete {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers/{reviewerId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="reviewerId">ID of the reviewer to remove.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Pull_Request_Reviewers_Delete(string organization, string repositoryId, int pullRequestId, string reviewerId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/reviewers/"+ (reviewerId==null? "" : System.Uri.EscapeDataString(reviewerId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Edit a reviewer entry. These fields are patchable: isFlagged
		/// Pull_Request_Reviewers_Update_Pull_Request_Reviewer {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers/{reviewerId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="reviewerId">ID of the reviewer.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Reviewer data.<br />If the reviewer's ID is included here, it must match the reviewerID parameter.</param>
		/// <returns>successful operation</returns>
		public async Task<IdentityRefWithVote> Pull_Request_Reviewers_Update_Pull_Request_ReviewerAsync(string organization, string repositoryId, int pullRequestId, string reviewerId, string project, string api_version, IdentityRefWithVote requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/reviewers/"+ (reviewerId==null? "" : System.Uri.EscapeDataString(reviewerId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdentityRefWithVote>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Edit a reviewer entry. These fields are patchable: isFlagged
		/// Pull_Request_Reviewers_Update_Pull_Request_Reviewer {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers/{reviewerId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="reviewerId">ID of the reviewer.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Reviewer data.<br />If the reviewer's ID is included here, it must match the reviewerID parameter.</param>
		/// <returns>successful operation</returns>
		public IdentityRefWithVote Pull_Request_Reviewers_Update_Pull_Request_Reviewer(string organization, string repositoryId, int pullRequestId, string reviewerId, string project, string api_version, IdentityRefWithVote requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/reviewers/"+ (reviewerId==null? "" : System.Uri.EscapeDataString(reviewerId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdentityRefWithVote>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sends an e-mail notification about a specific pull request to a set of recipients
		/// Pull_Request_Share_Share_Pull_Request {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/share
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">ID of the git repository.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Pull_Request_Share_Share_Pull_RequestAsync(string organization, string repositoryId, int pullRequestId, string project, string api_version, ShareNotificationContext requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/share&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sends an e-mail notification about a specific pull request to a set of recipients
		/// Pull_Request_Share_Share_Pull_Request {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/share
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">ID of the git repository.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Pull_Request_Share_Share_Pull_Request(string organization, string repositoryId, int pullRequestId, string project, string api_version, ShareNotificationContext requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/share&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get all the statuses associated with a pull request.
		/// Pull_Request_Statuses_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/statuses
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequestStatus[]> Pull_Request_Statuses_ListAsync(string organization, string repositoryId, int pullRequestId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/statuses&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestStatus[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all the statuses associated with a pull request.
		/// Pull_Request_Statuses_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/statuses
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitPullRequestStatus[] Pull_Request_Statuses_List(string organization, string repositoryId, int pullRequestId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/statuses&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestStatus[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a pull request status.
		/// 
		/// The only required field for the status is `Context.Name` that uniquely identifies the status.
		/// Note that you can specify iterationId in the request body to post the status on the iteration.
		/// Pull_Request_Statuses_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/statuses
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Pull request status to create.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequestStatus> Pull_Request_Statuses_CreateAsync(string organization, string repositoryId, int pullRequestId, string project, string api_version, GitPullRequestStatus requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/statuses&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a pull request status.
		/// 
		/// The only required field for the status is `Context.Name` that uniquely identifies the status.
		/// Note that you can specify iterationId in the request body to post the status on the iteration.
		/// Pull_Request_Statuses_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/statuses
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Pull request status to create.</param>
		/// <returns>successful operation</returns>
		public GitPullRequestStatus Pull_Request_Statuses_Create(string organization, string repositoryId, int pullRequestId, string project, string api_version, GitPullRequestStatus requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/statuses&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the specific pull request status by ID. The status ID is unique within the pull request across all iterations.
		/// Pull_Request_Statuses_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/statuses/{statusId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="statusId">ID of the pull request status.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequestStatus> Pull_Request_Statuses_GetAsync(string organization, string repositoryId, int pullRequestId, int statusId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/statuses/"+statusId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the specific pull request status by ID. The status ID is unique within the pull request across all iterations.
		/// Pull_Request_Statuses_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/statuses/{statusId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="statusId">ID of the pull request status.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitPullRequestStatus Pull_Request_Statuses_Get(string organization, string repositoryId, int pullRequestId, int statusId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/statuses/"+statusId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete pull request status.
		/// 
		/// You can remove multiple statuses in one call by using Update operation.
		/// Pull_Request_Statuses_Delete {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/statuses/{statusId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="statusId">ID of the pull request status.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Pull_Request_Statuses_DeleteAsync(string organization, string repositoryId, int pullRequestId, int statusId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/statuses/"+statusId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete pull request status.
		/// 
		/// You can remove multiple statuses in one call by using Update operation.
		/// Pull_Request_Statuses_Delete {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/statuses/{statusId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request’s target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="statusId">ID of the pull request status.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Pull_Request_Statuses_Delete(string organization, string repositoryId, int pullRequestId, int statusId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/statuses/"+statusId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all threads in a pull request.
		/// Pull_Request_Threads_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="iteration">If specified, thread positions will be tracked using this iteration as the right side of the diff.</param>
		/// <param name="baseIteration">If specified, thread positions will be tracked using this iteration as the left side of the diff.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequestCommentThread[]> Pull_Request_Threads_ListAsync(string organization, string repositoryId, int pullRequestId, string project, int iteration, int baseIteration, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads&$iteration="+iteration+"&$baseIteration="+baseIteration+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestCommentThread[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all threads in a pull request.
		/// Pull_Request_Threads_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="iteration">If specified, thread positions will be tracked using this iteration as the right side of the diff.</param>
		/// <param name="baseIteration">If specified, thread positions will be tracked using this iteration as the left side of the diff.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitPullRequestCommentThread[] Pull_Request_Threads_List(string organization, string repositoryId, int pullRequestId, string project, int iteration, int baseIteration, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads&$iteration="+iteration+"&$baseIteration="+baseIteration+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestCommentThread[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a thread in a pull request.
		/// Pull_Request_Threads_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">Repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The thread to create. Thread must contain at least one comment.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequestCommentThread> Pull_Request_Threads_CreateAsync(string organization, string repositoryId, int pullRequestId, string project, string api_version, GitPullRequestCommentThread requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestCommentThread>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a thread in a pull request.
		/// Pull_Request_Threads_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">Repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The thread to create. Thread must contain at least one comment.</param>
		/// <returns>successful operation</returns>
		public GitPullRequestCommentThread Pull_Request_Threads_Create(string organization, string repositoryId, int pullRequestId, string project, string api_version, GitPullRequestCommentThread requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestCommentThread>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve a thread in a pull request.
		/// Pull_Request_Threads_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">ID of the thread.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="iteration">If specified, thread position will be tracked using this iteration as the right side of the diff.</param>
		/// <param name="baseIteration">If specified, thread position will be tracked using this iteration as the left side of the diff.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequestCommentThread> Pull_Request_Threads_GetAsync(string organization, string repositoryId, int pullRequestId, int threadId, string project, int iteration, int baseIteration, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"&$iteration="+iteration+"&$baseIteration="+baseIteration+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestCommentThread>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a thread in a pull request.
		/// Pull_Request_Threads_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">ID of the thread.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="iteration">If specified, thread position will be tracked using this iteration as the right side of the diff.</param>
		/// <param name="baseIteration">If specified, thread position will be tracked using this iteration as the left side of the diff.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitPullRequestCommentThread Pull_Request_Threads_Get(string organization, string repositoryId, int pullRequestId, int threadId, string project, int iteration, int baseIteration, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"&$iteration="+iteration+"&$baseIteration="+baseIteration+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestCommentThread>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a thread in a pull request.
		/// Pull_Request_Threads_Update {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">ID of the thread to update.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The thread content that should be updated.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPullRequestCommentThread> Pull_Request_Threads_UpdateAsync(string organization, string repositoryId, int pullRequestId, int threadId, string project, string api_version, GitPullRequestCommentThread requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestCommentThread>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update a thread in a pull request.
		/// Pull_Request_Threads_Update {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">ID of the thread to update.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The thread content that should be updated.</param>
		/// <returns>successful operation</returns>
		public GitPullRequestCommentThread Pull_Request_Threads_Update(string organization, string repositoryId, int pullRequestId, int threadId, string project, string api_version, GitPullRequestCommentThread requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPullRequestCommentThread>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve all comments associated with a specific thread in a pull request.
		/// Pull_Request_Thread_Comments_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">ID of the thread.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<Comment[]> Pull_Request_Thread_Comments_ListAsync(string organization, string repositoryId, int pullRequestId, int threadId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"/comments&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Comment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all comments associated with a specific thread in a pull request.
		/// Pull_Request_Thread_Comments_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">ID of the thread.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public Comment[] Pull_Request_Thread_Comments_List(string organization, string repositoryId, int pullRequestId, int threadId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"/comments&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Comment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a comment on a specific thread in a pull request (up to 500 comments can be created per thread).
		/// Pull_Request_Thread_Comments_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">ID of the thread that the desired comment is in.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The comment to create. Comments can be up to 150,000 characters.</param>
		/// <returns>successful operation</returns>
		public async Task<Comment> Pull_Request_Thread_Comments_CreateAsync(string organization, string repositoryId, int pullRequestId, int threadId, string project, string api_version, Comment requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"/comments&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Comment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a comment on a specific thread in a pull request (up to 500 comments can be created per thread).
		/// Pull_Request_Thread_Comments_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">ID of the thread that the desired comment is in.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The comment to create. Comments can be up to 150,000 characters.</param>
		/// <returns>successful operation</returns>
		public Comment Pull_Request_Thread_Comments_Create(string organization, string repositoryId, int pullRequestId, int threadId, string project, string api_version, Comment requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"/comments&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Comment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve a comment associated with a specific thread in a pull request.
		/// Pull_Request_Thread_Comments_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments/{commentId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">ID of the thread that the desired comment is in.</param>
		/// <param name="commentId">ID of the comment.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<Comment> Pull_Request_Thread_Comments_GetAsync(string organization, string repositoryId, int pullRequestId, int threadId, int commentId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"/comments/"+commentId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Comment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a comment associated with a specific thread in a pull request.
		/// Pull_Request_Thread_Comments_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments/{commentId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">ID of the thread that the desired comment is in.</param>
		/// <param name="commentId">ID of the comment.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public Comment Pull_Request_Thread_Comments_Get(string organization, string repositoryId, int pullRequestId, int threadId, int commentId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"/comments/"+commentId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Comment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a comment associated with a specific thread in a pull request.
		/// Pull_Request_Thread_Comments_Delete {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments/{commentId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">ID of the thread that the desired comment is in.</param>
		/// <param name="commentId">ID of the comment.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Pull_Request_Thread_Comments_DeleteAsync(string organization, string repositoryId, int pullRequestId, int threadId, int commentId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"/comments/"+commentId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a comment associated with a specific thread in a pull request.
		/// Pull_Request_Thread_Comments_Delete {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments/{commentId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">ID of the thread that the desired comment is in.</param>
		/// <param name="commentId">ID of the comment.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Pull_Request_Thread_Comments_Delete(string organization, string repositoryId, int pullRequestId, int threadId, int commentId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"/comments/"+commentId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a comment associated with a specific thread in a pull request.
		/// Pull_Request_Thread_Comments_Update {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments/{commentId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">ID of the thread that the desired comment is in.</param>
		/// <param name="commentId">ID of the comment to update.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The comment content that should be updated. Comments can be up to 150,000 characters.</param>
		/// <returns>successful operation</returns>
		public async Task<Comment> Pull_Request_Thread_Comments_UpdateAsync(string organization, string repositoryId, int pullRequestId, int threadId, int commentId, string project, string api_version, Comment requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"/comments/"+commentId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Comment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update a comment associated with a specific thread in a pull request.
		/// Pull_Request_Thread_Comments_Update {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments/{commentId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">ID of the thread that the desired comment is in.</param>
		/// <param name="commentId">ID of the comment to update.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The comment content that should be updated. Comments can be up to 150,000 characters.</param>
		/// <returns>successful operation</returns>
		public Comment Pull_Request_Thread_Comments_Update(string organization, string repositoryId, int pullRequestId, int threadId, int commentId, string project, string api_version, Comment requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"/comments/"+commentId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Comment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get likes for a comment.
		/// Pull_Request_Comment_Likes_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments/{commentId}/likes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">The ID of the thread that contains the comment.</param>
		/// <param name="commentId">The ID of the comment.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<IdentityRef[]> Pull_Request_Comment_Likes_ListAsync(string organization, string repositoryId, int pullRequestId, int threadId, int commentId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"/comments/"+commentId+"/likes&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdentityRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get likes for a comment.
		/// Pull_Request_Comment_Likes_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments/{commentId}/likes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">The ID of the thread that contains the comment.</param>
		/// <param name="commentId">The ID of the comment.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public IdentityRef[] Pull_Request_Comment_Likes_List(string organization, string repositoryId, int pullRequestId, int threadId, int commentId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"/comments/"+commentId+"/likes&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdentityRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a like on a comment.
		/// Pull_Request_Comment_Likes_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments/{commentId}/likes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">The ID of the thread that contains the comment.</param>
		/// <param name="commentId">The ID of the comment.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Pull_Request_Comment_Likes_CreateAsync(string organization, string repositoryId, int pullRequestId, int threadId, int commentId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"/comments/"+commentId+"/likes&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a like on a comment.
		/// Pull_Request_Comment_Likes_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments/{commentId}/likes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">The ID of the thread that contains the comment.</param>
		/// <param name="commentId">The ID of the comment.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Pull_Request_Comment_Likes_Create(string organization, string repositoryId, int pullRequestId, int threadId, int commentId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"/comments/"+commentId+"/likes&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a like on a comment.
		/// Pull_Request_Comment_Likes_Delete {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments/{commentId}/likes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">The ID of the thread that contains the comment.</param>
		/// <param name="commentId">The ID of the comment.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Pull_Request_Comment_Likes_DeleteAsync(string organization, string repositoryId, int pullRequestId, int threadId, int commentId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"/comments/"+commentId+"/likes&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a like on a comment.
		/// Pull_Request_Comment_Likes_Delete {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments/{commentId}/likes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The repository ID of the pull request's target branch.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="threadId">The ID of the thread that contains the comment.</param>
		/// <param name="commentId">The ID of the comment.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Pull_Request_Comment_Likes_Delete(string organization, string repositoryId, int pullRequestId, int threadId, int commentId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/threads/"+threadId+"/comments/"+commentId+"/likes&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a list of work items associated with a pull request.
		/// Pull_Request_Work_Items_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/workitems
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">ID or name of the repository.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<ResourceRef[]> Pull_Request_Work_Items_ListAsync(string organization, string repositoryId, int pullRequestId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/workitems&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ResourceRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a list of work items associated with a pull request.
		/// Pull_Request_Work_Items_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/workitems
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">ID or name of the repository.</param>
		/// <param name="pullRequestId">ID of the pull request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public ResourceRef[] Pull_Request_Work_Items_List(string organization, string repositoryId, int pullRequestId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pullRequests/"+pullRequestId+"/workitems&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ResourceRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves pushes associated with the specified repository.
		/// Pushes_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pushes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="skip">Number of pushes to skip.</param>
		/// <param name="top">Number of pushes to return.</param>
		/// <param name="searchCriteria_fromDate">Search criteria attributes: fromDate, toDate, pusherId, refName, includeRefUpdates or includeLinks. fromDate: Start date to search from. toDate: End date to search to. pusherId: Identity of the person who submitted the push. refName: Branch name to consider. includeRefUpdates: If true, include the list of refs that were updated by the push. includeLinks: Whether to include the _links field on the shallow references.</param>
		/// <param name="searchCriteria_includeLinks">Whether to include the _links field on the shallow references</param>
		/// <param name="searchCriteria_includeRefUpdates">Search criteria attributes: fromDate, toDate, pusherId, refName, includeRefUpdates or includeLinks. fromDate: Start date to search from. toDate: End date to search to. pusherId: Identity of the person who submitted the push. refName: Branch name to consider. includeRefUpdates: If true, include the list of refs that were updated by the push. includeLinks: Whether to include the _links field on the shallow references.</param>
		/// <param name="searchCriteria_pusherId">Search criteria attributes: fromDate, toDate, pusherId, refName, includeRefUpdates or includeLinks. fromDate: Start date to search from. toDate: End date to search to. pusherId: Identity of the person who submitted the push. refName: Branch name to consider. includeRefUpdates: If true, include the list of refs that were updated by the push. includeLinks: Whether to include the _links field on the shallow references.</param>
		/// <param name="searchCriteria_refName">Search criteria attributes: fromDate, toDate, pusherId, refName, includeRefUpdates or includeLinks. fromDate: Start date to search from. toDate: End date to search to. pusherId: Identity of the person who submitted the push. refName: Branch name to consider. includeRefUpdates: If true, include the list of refs that were updated by the push. includeLinks: Whether to include the _links field on the shallow references.</param>
		/// <param name="searchCriteria_toDate">Search criteria attributes: fromDate, toDate, pusherId, refName, includeRefUpdates or includeLinks. fromDate: Start date to search from. toDate: End date to search to. pusherId: Identity of the person who submitted the push. refName: Branch name to consider. includeRefUpdates: If true, include the list of refs that were updated by the push. includeLinks: Whether to include the _links field on the shallow references.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPush[]> Pushes_ListAsync(string organization, string repositoryId, string project, int skip, int top, System.DateTimeOffset searchCriteria_fromDate, bool searchCriteria_includeLinks, bool searchCriteria_includeRefUpdates, string searchCriteria_pusherId, string searchCriteria_refName, System.DateTimeOffset searchCriteria_toDate, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pushes&$skip="+skip+"&$top="+top+"&searchCriteria.fromDate=" + searchCriteria_fromDate.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&searchCriteria.includeLinks="+searchCriteria_includeLinks+"&searchCriteria.includeRefUpdates="+searchCriteria_includeRefUpdates+"&searchCriteria.pusherId=" + (searchCriteria_pusherId==null? "" : System.Uri.EscapeDataString(searchCriteria_pusherId))+"&searchCriteria.refName=" + (searchCriteria_refName==null? "" : System.Uri.EscapeDataString(searchCriteria_refName))+"&searchCriteria.toDate=" + searchCriteria_toDate.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPush[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves pushes associated with the specified repository.
		/// Pushes_List {organization}/{project}/_apis/git/repositories/{repositoryId}/pushes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="skip">Number of pushes to skip.</param>
		/// <param name="top">Number of pushes to return.</param>
		/// <param name="searchCriteria_fromDate">Search criteria attributes: fromDate, toDate, pusherId, refName, includeRefUpdates or includeLinks. fromDate: Start date to search from. toDate: End date to search to. pusherId: Identity of the person who submitted the push. refName: Branch name to consider. includeRefUpdates: If true, include the list of refs that were updated by the push. includeLinks: Whether to include the _links field on the shallow references.</param>
		/// <param name="searchCriteria_includeLinks">Whether to include the _links field on the shallow references</param>
		/// <param name="searchCriteria_includeRefUpdates">Search criteria attributes: fromDate, toDate, pusherId, refName, includeRefUpdates or includeLinks. fromDate: Start date to search from. toDate: End date to search to. pusherId: Identity of the person who submitted the push. refName: Branch name to consider. includeRefUpdates: If true, include the list of refs that were updated by the push. includeLinks: Whether to include the _links field on the shallow references.</param>
		/// <param name="searchCriteria_pusherId">Search criteria attributes: fromDate, toDate, pusherId, refName, includeRefUpdates or includeLinks. fromDate: Start date to search from. toDate: End date to search to. pusherId: Identity of the person who submitted the push. refName: Branch name to consider. includeRefUpdates: If true, include the list of refs that were updated by the push. includeLinks: Whether to include the _links field on the shallow references.</param>
		/// <param name="searchCriteria_refName">Search criteria attributes: fromDate, toDate, pusherId, refName, includeRefUpdates or includeLinks. fromDate: Start date to search from. toDate: End date to search to. pusherId: Identity of the person who submitted the push. refName: Branch name to consider. includeRefUpdates: If true, include the list of refs that were updated by the push. includeLinks: Whether to include the _links field on the shallow references.</param>
		/// <param name="searchCriteria_toDate">Search criteria attributes: fromDate, toDate, pusherId, refName, includeRefUpdates or includeLinks. fromDate: Start date to search from. toDate: End date to search to. pusherId: Identity of the person who submitted the push. refName: Branch name to consider. includeRefUpdates: If true, include the list of refs that were updated by the push. includeLinks: Whether to include the _links field on the shallow references.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitPush[] Pushes_List(string organization, string repositoryId, string project, int skip, int top, System.DateTimeOffset searchCriteria_fromDate, bool searchCriteria_includeLinks, bool searchCriteria_includeRefUpdates, string searchCriteria_pusherId, string searchCriteria_refName, System.DateTimeOffset searchCriteria_toDate, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pushes&$skip="+skip+"&$top="+top+"&searchCriteria.fromDate=" + searchCriteria_fromDate.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&searchCriteria.includeLinks="+searchCriteria_includeLinks+"&searchCriteria.includeRefUpdates="+searchCriteria_includeRefUpdates+"&searchCriteria.pusherId=" + (searchCriteria_pusherId==null? "" : System.Uri.EscapeDataString(searchCriteria_pusherId))+"&searchCriteria.refName=" + (searchCriteria_refName==null? "" : System.Uri.EscapeDataString(searchCriteria_refName))+"&searchCriteria.toDate=" + searchCriteria_toDate.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPush[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Push changes to the repository.
		/// Pushes_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/pushes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPush> Pushes_CreateAsync(string organization, string repositoryId, string project, string api_version, GitPush requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pushes&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPush>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Push changes to the repository.
		/// Pushes_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/pushes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitPush Pushes_Create(string organization, string repositoryId, string project, string api_version, GitPush requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pushes&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPush>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a particular push.
		/// Pushes_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pushes/{pushId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="pushId">ID of the push.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="includeCommits">The number of commits to include in the result.</param>
		/// <param name="includeRefUpdates">If true, include the list of refs that were updated by the push.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitPush> Pushes_GetAsync(string organization, string repositoryId, int pushId, string project, int includeCommits, bool includeRefUpdates, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pushes/"+pushId+"&includeCommits="+includeCommits+"&includeRefUpdates="+includeRefUpdates+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPush>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a particular push.
		/// Pushes_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/pushes/{pushId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="pushId">ID of the push.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="includeCommits">The number of commits to include in the result.</param>
		/// <param name="includeRefUpdates">If true, include the list of refs that were updated by the push.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitPush Pushes_Get(string organization, string repositoryId, int pushId, string project, int includeCommits, bool includeRefUpdates, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/pushes/"+pushId+"&includeCommits="+includeCommits+"&includeRefUpdates="+includeRefUpdates+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitPush>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Queries the provided repository for its refs and returns them.
		/// Refs_List {organization}/{project}/_apis/git/repositories/{repositoryId}/refs
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="filter">[optional] A filter to apply to the refs (starts with).</param>
		/// <param name="includeLinks">[optional] Specifies if referenceLinks should be included in the result. default is false.</param>
		/// <param name="includeStatuses">[optional] Includes up to the first 1000 commit statuses for each ref. The default value is false.</param>
		/// <param name="includeMyBranches">[optional] Includes only branches that the user owns, the branches the user favorites, and the default branch. The default value is false. Cannot be combined with the filter parameter.</param>
		/// <param name="latestStatusesOnly">[optional] True to include only the tip commit status for each ref. This option requires `includeStatuses` to be true. The default value is false.</param>
		/// <param name="peelTags">[optional] Annotated tags will populate the PeeledObjectId property. default is false.</param>
		/// <param name="filterContains">[optional] A filter to apply to the refs (contains).</param>
		/// <param name="top">[optional] Maximum number of refs to return. It cannot be bigger than 1000. If it is not provided but continuationToken is, top will default to 100.</param>
		/// <param name="continuationToken">The continuation token used for pagination.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitRef[]> Refs_ListAsync(string organization, string repositoryId, string project, string filter, bool includeLinks, bool includeStatuses, bool includeMyBranches, bool latestStatusesOnly, bool peelTags, string filterContains, int top, string continuationToken, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/refs&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeLinks="+includeLinks+"&includeStatuses="+includeStatuses+"&includeMyBranches="+includeMyBranches+"&latestStatusesOnly="+latestStatusesOnly+"&peelTags="+peelTags+"&filterContains=" + (filterContains==null? "" : System.Uri.EscapeDataString(filterContains))+"&$top="+top+"&continuationToken=" + (continuationToken==null? "" : System.Uri.EscapeDataString(continuationToken))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Queries the provided repository for its refs and returns them.
		/// Refs_List {organization}/{project}/_apis/git/repositories/{repositoryId}/refs
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="filter">[optional] A filter to apply to the refs (starts with).</param>
		/// <param name="includeLinks">[optional] Specifies if referenceLinks should be included in the result. default is false.</param>
		/// <param name="includeStatuses">[optional] Includes up to the first 1000 commit statuses for each ref. The default value is false.</param>
		/// <param name="includeMyBranches">[optional] Includes only branches that the user owns, the branches the user favorites, and the default branch. The default value is false. Cannot be combined with the filter parameter.</param>
		/// <param name="latestStatusesOnly">[optional] True to include only the tip commit status for each ref. This option requires `includeStatuses` to be true. The default value is false.</param>
		/// <param name="peelTags">[optional] Annotated tags will populate the PeeledObjectId property. default is false.</param>
		/// <param name="filterContains">[optional] A filter to apply to the refs (contains).</param>
		/// <param name="top">[optional] Maximum number of refs to return. It cannot be bigger than 1000. If it is not provided but continuationToken is, top will default to 100.</param>
		/// <param name="continuationToken">The continuation token used for pagination.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitRef[] Refs_List(string organization, string repositoryId, string project, string filter, bool includeLinks, bool includeStatuses, bool includeMyBranches, bool latestStatusesOnly, bool peelTags, string filterContains, int top, string continuationToken, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/refs&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeLinks="+includeLinks+"&includeStatuses="+includeStatuses+"&includeMyBranches="+includeMyBranches+"&latestStatusesOnly="+latestStatusesOnly+"&peelTags="+peelTags+"&filterContains=" + (filterContains==null? "" : System.Uri.EscapeDataString(filterContains))+"&$top="+top+"&continuationToken=" + (continuationToken==null? "" : System.Uri.EscapeDataString(continuationToken))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creating, updating, or deleting refs(branches).
		/// 
		/// Updating a ref means making it point at a different commit than it used to. You must specify both the old and new commit to avoid race conditions.
		/// Refs_Update_Refs {organization}/{project}/_apis/git/repositories/{repositoryId}/refs
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="projectId">ID or name of the team project. Optional if specifying an ID for repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">List of ref updates to attempt to perform</param>
		/// <returns>successful operation</returns>
		public async Task<GitRefUpdateResult[]> Refs_Update_RefsAsync(string organization, string repositoryId, string project, string projectId, string api_version, GitRefUpdate[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/refs&projectId=" + (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRefUpdateResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creating, updating, or deleting refs(branches).
		/// 
		/// Updating a ref means making it point at a different commit than it used to. You must specify both the old and new commit to avoid race conditions.
		/// Refs_Update_Refs {organization}/{project}/_apis/git/repositories/{repositoryId}/refs
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="projectId">ID or name of the team project. Optional if specifying an ID for repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">List of ref updates to attempt to perform</param>
		/// <returns>successful operation</returns>
		public GitRefUpdateResult[] Refs_Update_Refs(string organization, string repositoryId, string project, string projectId, string api_version, GitRefUpdate[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/refs&projectId=" + (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRefUpdateResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lock or Unlock a branch.
		/// Refs_Update_Ref {organization}/{project}/_apis/git/repositories/{repositoryId}/refs
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="filter">The name of the branch to lock/unlock</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="projectId">ID or name of the team project. Optional if specifying an ID for repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The ref update action (lock/unlock) to perform</param>
		/// <returns>successful operation</returns>
		public async Task<GitRef> Refs_Update_RefAsync(string organization, string repositoryId, string filter, string project, string projectId, string api_version, GitRefUpdate requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/refs&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&projectId=" + (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRef>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lock or Unlock a branch.
		/// Refs_Update_Ref {organization}/{project}/_apis/git/repositories/{repositoryId}/refs
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="filter">The name of the branch to lock/unlock</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="projectId">ID or name of the team project. Optional if specifying an ID for repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The ref update action (lock/unlock) to perform</param>
		/// <returns>successful operation</returns>
		public GitRef Refs_Update_Ref(string organization, string repositoryId, string filter, string project, string projectId, string api_version, GitRefUpdate requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/refs&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&projectId=" + (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRef>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve information about a revert operation for a specific branch.
		/// Reverts_Get_Revert_For_Ref_Name {organization}/{project}/_apis/git/repositories/{repositoryId}/reverts
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">ID of the repository.</param>
		/// <param name="refName">The GitAsyncRefOperationParameters generatedRefName used for the revert operation.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitRevert> Reverts_Get_Revert_For_Ref_NameAsync(string organization, string project, string repositoryId, string refName, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/reverts&refName=" + (refName==null? "" : System.Uri.EscapeDataString(refName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRevert>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve information about a revert operation for a specific branch.
		/// Reverts_Get_Revert_For_Ref_Name {organization}/{project}/_apis/git/repositories/{repositoryId}/reverts
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">ID of the repository.</param>
		/// <param name="refName">The GitAsyncRefOperationParameters generatedRefName used for the revert operation.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitRevert Reverts_Get_Revert_For_Ref_Name(string organization, string project, string repositoryId, string refName, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/reverts&refName=" + (refName==null? "" : System.Uri.EscapeDataString(refName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRevert>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Starts the operation to create a new branch which reverts changes introduced by either a specific commit or commits that are associated to a pull request.
		/// Reverts_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/reverts
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">ID of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitRevert> Reverts_CreateAsync(string organization, string project, string repositoryId, string api_version, GitAsyncRefOperationParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/reverts&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRevert>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Starts the operation to create a new branch which reverts changes introduced by either a specific commit or commits that are associated to a pull request.
		/// Reverts_Create {organization}/{project}/_apis/git/repositories/{repositoryId}/reverts
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryId">ID of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitRevert Reverts_Create(string organization, string project, string repositoryId, string api_version, GitAsyncRefOperationParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/reverts&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRevert>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve information about a revert operation by revert Id.
		/// Reverts_Get_Revert {organization}/{project}/_apis/git/repositories/{repositoryId}/reverts/{revertId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="revertId">ID of the revert operation.</param>
		/// <param name="repositoryId">ID of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitRevert> Reverts_Get_RevertAsync(string organization, string project, int revertId, string repositoryId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/reverts/"+revertId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRevert>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve information about a revert operation by revert Id.
		/// Reverts_Get_Revert {organization}/{project}/_apis/git/repositories/{repositoryId}/reverts/{revertId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="revertId">ID of the revert operation.</param>
		/// <param name="repositoryId">ID of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitRevert Reverts_Get_Revert(string organization, string project, int revertId, string repositoryId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/reverts/"+revertId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRevert>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve statistics about all branches within a repository.
		/// Stats_List {organization}/{project}/_apis/git/repositories/{repositoryId}/stats/branches
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="baseVersionDescriptor_version">Version string identifier (name of tag/branch, SHA1 of commit)</param>
		/// <param name="baseVersionDescriptor_versionOptions">Version options - Specify additional modifiers to version (e.g Previous)</param>
		/// <param name="baseVersionDescriptor_versionType">Version type (branch, tag, or commit). Determines how Id is interpreted</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitBranchStats[]> Stats_ListAsync(string organization, string repositoryId, string project, string baseVersionDescriptor_version, GitBaseVersionDescriptorBaseVersionOptions baseVersionDescriptor_versionOptions, GitBaseVersionDescriptorBaseVersionType baseVersionDescriptor_versionType, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/stats/branches&baseVersionDescriptor.version=" + (baseVersionDescriptor_version==null? "" : System.Uri.EscapeDataString(baseVersionDescriptor_version))+"&baseVersionDescriptor.versionOptions=" + baseVersionDescriptor_versionOptions+"&baseVersionDescriptor.versionType=" + baseVersionDescriptor_versionType+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitBranchStats[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve statistics about all branches within a repository.
		/// Stats_List {organization}/{project}/_apis/git/repositories/{repositoryId}/stats/branches
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="baseVersionDescriptor_version">Version string identifier (name of tag/branch, SHA1 of commit)</param>
		/// <param name="baseVersionDescriptor_versionOptions">Version options - Specify additional modifiers to version (e.g Previous)</param>
		/// <param name="baseVersionDescriptor_versionType">Version type (branch, tag, or commit). Determines how Id is interpreted</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitBranchStats[] Stats_List(string organization, string repositoryId, string project, string baseVersionDescriptor_version, GitBaseVersionDescriptorBaseVersionOptions baseVersionDescriptor_versionOptions, GitBaseVersionDescriptorBaseVersionType baseVersionDescriptor_versionType, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/stats/branches&baseVersionDescriptor.version=" + (baseVersionDescriptor_version==null? "" : System.Uri.EscapeDataString(baseVersionDescriptor_version))+"&baseVersionDescriptor.versionOptions=" + baseVersionDescriptor_versionOptions+"&baseVersionDescriptor.versionType=" + baseVersionDescriptor_versionType+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitBranchStats[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a pull request suggestion for a particular repository or team project.
		/// Suggestions_List {organization}/{project}/_apis/git/repositories/{repositoryId}/suggestions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">ID of the git repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitSuggestion[]> Suggestions_ListAsync(string organization, string repositoryId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/suggestions&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitSuggestion[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a pull request suggestion for a particular repository or team project.
		/// Suggestions_List {organization}/{project}/_apis/git/repositories/{repositoryId}/suggestions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">ID of the git repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitSuggestion[] Suggestions_List(string organization, string repositoryId, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/suggestions&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitSuggestion[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The Tree endpoint returns the collection of objects underneath the specified tree. Trees are folders in a Git repository.
		/// 
		/// Repositories have both a name and an identifier. Identifiers are globally unique, but several projects may contain a repository of the same name. You don't need to include the project if you specify a repository by ID. However, if you specify a repository by name, you must also specify the project (by name or ID.
		/// Trees_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/trees/{sha1}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">Repository Id.</param>
		/// <param name="sha1">SHA1 hash of the tree object.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="projectId">Project Id.</param>
		/// <param name="recursive">Search recursively. Include trees underneath this tree. Default is false.</param>
		/// <param name="fileName">Name to use if a .zip file is returned. Default is the object ID.</param>
		/// <param name="format">Use "zip". Defaults to the MIME type set in the Accept header.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitTreeRef> Trees_GetAsync(string organization, string repositoryId, string sha1, string project, string projectId, bool recursive, string fileName, string format, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/trees/"+ (sha1==null? "" : System.Uri.EscapeDataString(sha1))+"&projectId=" + (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"&recursive="+recursive+"&fileName=" + (fileName==null? "" : System.Uri.EscapeDataString(fileName))+"&$format=" + (format==null? "" : System.Uri.EscapeDataString(format))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitTreeRef>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The Tree endpoint returns the collection of objects underneath the specified tree. Trees are folders in a Git repository.
		/// 
		/// Repositories have both a name and an identifier. Identifiers are globally unique, but several projects may contain a repository of the same name. You don't need to include the project if you specify a repository by ID. However, if you specify a repository by name, you must also specify the project (by name or ID.
		/// Trees_Get {organization}/{project}/_apis/git/repositories/{repositoryId}/trees/{sha1}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryId">Repository Id.</param>
		/// <param name="sha1">SHA1 hash of the tree object.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="projectId">Project Id.</param>
		/// <param name="recursive">Search recursively. Include trees underneath this tree. Default is false.</param>
		/// <param name="fileName">Name to use if a .zip file is returned. Default is the object ID.</param>
		/// <param name="format">Use "zip". Defaults to the MIME type set in the Accept header.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitTreeRef Trees_Get(string organization, string repositoryId, string sha1, string project, string projectId, bool recursive, string fileName, string format, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId))+"/trees/"+ (sha1==null? "" : System.Uri.EscapeDataString(sha1))+"&projectId=" + (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"&recursive="+recursive+"&fileName=" + (fileName==null? "" : System.Uri.EscapeDataString(fileName))+"&$format=" + (format==null? "" : System.Uri.EscapeDataString(format))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitTreeRef>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Find the merge bases of two commits, optionally across forks. If otherRepositoryId is not specified, the merge bases will only be calculated within the context of the local repositoryNameOrId.
		/// Merge_Bases_List {organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/commits/{commitId}/mergebases
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryNameOrId">ID or name of the local repository.</param>
		/// <param name="commitId">First commit, usually the tip of the target branch of the potential merge.</param>
		/// <param name="otherCommitId">Other commit, usually the tip of the source branch of the potential merge.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="otherCollectionId">The collection ID where otherCommitId lives.</param>
		/// <param name="otherRepositoryId">The repository ID where otherCommitId lives.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitCommitRef[]> Merge_Bases_ListAsync(string organization, string repositoryNameOrId, string commitId, string otherCommitId, string project, string otherCollectionId, string otherRepositoryId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryNameOrId==null? "" : System.Uri.EscapeDataString(repositoryNameOrId))+"/commits/"+ (commitId==null? "" : System.Uri.EscapeDataString(commitId))+"/mergebases&otherCommitId=" + (otherCommitId==null? "" : System.Uri.EscapeDataString(otherCommitId))+"&otherCollectionId=" + (otherCollectionId==null? "" : System.Uri.EscapeDataString(otherCollectionId))+"&otherRepositoryId=" + (otherRepositoryId==null? "" : System.Uri.EscapeDataString(otherRepositoryId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCommitRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Find the merge bases of two commits, optionally across forks. If otherRepositoryId is not specified, the merge bases will only be calculated within the context of the local repositoryNameOrId.
		/// Merge_Bases_List {organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/commits/{commitId}/mergebases
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryNameOrId">ID or name of the local repository.</param>
		/// <param name="commitId">First commit, usually the tip of the target branch of the potential merge.</param>
		/// <param name="otherCommitId">Other commit, usually the tip of the source branch of the potential merge.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="otherCollectionId">The collection ID where otherCommitId lives.</param>
		/// <param name="otherRepositoryId">The repository ID where otherCommitId lives.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitCommitRef[] Merge_Bases_List(string organization, string repositoryNameOrId, string commitId, string otherCommitId, string project, string otherCollectionId, string otherRepositoryId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryNameOrId==null? "" : System.Uri.EscapeDataString(repositoryNameOrId))+"/commits/"+ (commitId==null? "" : System.Uri.EscapeDataString(commitId))+"/mergebases&otherCommitId=" + (otherCommitId==null? "" : System.Uri.EscapeDataString(otherCommitId))+"&otherCollectionId=" + (otherCollectionId==null? "" : System.Uri.EscapeDataString(otherCollectionId))+"&otherRepositoryId=" + (otherRepositoryId==null? "" : System.Uri.EscapeDataString(otherRepositoryId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitCommitRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all forks of a repository in the collection.
		/// Forks_List {organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/forks/{collectionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryNameOrId">The name or ID of the repository.</param>
		/// <param name="collectionId">Team project collection ID.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="includeLinks">True to include links.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitRepositoryRef[]> Forks_ListAsync(string organization, string repositoryNameOrId, string collectionId, string project, bool includeLinks, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryNameOrId==null? "" : System.Uri.EscapeDataString(repositoryNameOrId))+"/forks/"+ (collectionId==null? "" : System.Uri.EscapeDataString(collectionId))+"&includeLinks="+includeLinks+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRepositoryRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all forks of a repository in the collection.
		/// Forks_List {organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/forks/{collectionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryNameOrId">The name or ID of the repository.</param>
		/// <param name="collectionId">Team project collection ID.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="includeLinks">True to include links.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitRepositoryRef[] Forks_List(string organization, string repositoryNameOrId, string collectionId, string project, bool includeLinks, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryNameOrId==null? "" : System.Uri.EscapeDataString(repositoryNameOrId))+"/forks/"+ (collectionId==null? "" : System.Uri.EscapeDataString(collectionId))+"&includeLinks="+includeLinks+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitRepositoryRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all requested fork sync operations on this repository.
		/// Forks_Get_Fork_Sync_Requests {organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/forkSyncRequests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryNameOrId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="includeAbandoned">True to include abandoned requests.</param>
		/// <param name="includeLinks">True to include links.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitForkSyncRequest[]> Forks_Get_Fork_Sync_RequestsAsync(string organization, string repositoryNameOrId, string project, bool includeAbandoned, bool includeLinks, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryNameOrId==null? "" : System.Uri.EscapeDataString(repositoryNameOrId))+"/forkSyncRequests&includeAbandoned="+includeAbandoned+"&includeLinks="+includeLinks+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitForkSyncRequest[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all requested fork sync operations on this repository.
		/// Forks_Get_Fork_Sync_Requests {organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/forkSyncRequests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryNameOrId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="includeAbandoned">True to include abandoned requests.</param>
		/// <param name="includeLinks">True to include links.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitForkSyncRequest[] Forks_Get_Fork_Sync_Requests(string organization, string repositoryNameOrId, string project, bool includeAbandoned, bool includeLinks, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryNameOrId==null? "" : System.Uri.EscapeDataString(repositoryNameOrId))+"/forkSyncRequests&includeAbandoned="+includeAbandoned+"&includeLinks="+includeLinks+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitForkSyncRequest[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Request that another repository's refs be fetched into this one. It syncs two existing forks. To create a fork, please see the <a href="https://docs.microsoft.com/en-us/rest/api/vsts/git/repositories/create?view=azure-devops-rest-5.1"> repositories endpoint</a>
		/// Forks_Create_fork_sync_request {organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/forkSyncRequests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryNameOrId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="includeLinks">True to include links</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Source repository and ref mapping.</param>
		/// <returns>successful operation</returns>
		public async Task<GitForkSyncRequest> Forks_Create_fork_sync_requestAsync(string organization, string repositoryNameOrId, string project, bool includeLinks, string api_version, GitForkSyncRequestParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryNameOrId==null? "" : System.Uri.EscapeDataString(repositoryNameOrId))+"/forkSyncRequests&includeLinks="+includeLinks+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitForkSyncRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Request that another repository's refs be fetched into this one. It syncs two existing forks. To create a fork, please see the <a href="https://docs.microsoft.com/en-us/rest/api/vsts/git/repositories/create?view=azure-devops-rest-5.1"> repositories endpoint</a>
		/// Forks_Create_fork_sync_request {organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/forkSyncRequests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryNameOrId">The name or ID of the repository.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="includeLinks">True to include links</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Source repository and ref mapping.</param>
		/// <returns>successful operation</returns>
		public GitForkSyncRequest Forks_Create_fork_sync_request(string organization, string repositoryNameOrId, string project, bool includeLinks, string api_version, GitForkSyncRequestParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryNameOrId==null? "" : System.Uri.EscapeDataString(repositoryNameOrId))+"/forkSyncRequests&includeLinks="+includeLinks+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitForkSyncRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a specific fork sync operation's details.
		/// Forks_Get_fork_sync_request {organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/forkSyncRequests/{forkSyncOperationId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryNameOrId">The name or ID of the repository.</param>
		/// <param name="forkSyncOperationId">OperationId of the sync request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="includeLinks">True to include links.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitForkSyncRequest> Forks_Get_fork_sync_requestAsync(string organization, string repositoryNameOrId, int forkSyncOperationId, string project, bool includeLinks, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryNameOrId==null? "" : System.Uri.EscapeDataString(repositoryNameOrId))+"/forkSyncRequests/"+forkSyncOperationId+"&includeLinks="+includeLinks+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitForkSyncRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a specific fork sync operation's details.
		/// Forks_Get_fork_sync_request {organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/forkSyncRequests/{forkSyncOperationId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="repositoryNameOrId">The name or ID of the repository.</param>
		/// <param name="forkSyncOperationId">OperationId of the sync request.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="includeLinks">True to include links.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitForkSyncRequest Forks_Get_fork_sync_request(string organization, string repositoryNameOrId, int forkSyncOperationId, string project, bool includeLinks, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryNameOrId==null? "" : System.Uri.EscapeDataString(repositoryNameOrId))+"/forkSyncRequests/"+forkSyncOperationId+"&includeLinks="+includeLinks+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitForkSyncRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Request a git merge operation. Currently we support merging only 2 commits.
		/// Merges_Create {organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/merges
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryNameOrId">The name or ID of the repository.</param>
		/// <param name="includeLinks">True to include links</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Parents commitIds and merge commit messsage.</param>
		/// <returns>successful operation</returns>
		public async Task<GitMerge> Merges_CreateAsync(string organization, string project, string repositoryNameOrId, bool includeLinks, string api_version, GitMergeParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryNameOrId==null? "" : System.Uri.EscapeDataString(repositoryNameOrId))+"/merges&includeLinks="+includeLinks+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitMerge>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Request a git merge operation. Currently we support merging only 2 commits.
		/// Merges_Create {organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/merges
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryNameOrId">The name or ID of the repository.</param>
		/// <param name="includeLinks">True to include links</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Parents commitIds and merge commit messsage.</param>
		/// <returns>successful operation</returns>
		public GitMerge Merges_Create(string organization, string project, string repositoryNameOrId, bool includeLinks, string api_version, GitMergeParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryNameOrId==null? "" : System.Uri.EscapeDataString(repositoryNameOrId))+"/merges&includeLinks="+includeLinks+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitMerge>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a specific merge operation's details.
		/// Merges_Get {organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/merges/{mergeOperationId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryNameOrId">The name or ID of the repository.</param>
		/// <param name="mergeOperationId">OperationId of the merge request.</param>
		/// <param name="includeLinks">True to include links</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<GitMerge> Merges_GetAsync(string organization, string project, string repositoryNameOrId, int mergeOperationId, bool includeLinks, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryNameOrId==null? "" : System.Uri.EscapeDataString(repositoryNameOrId))+"/merges/"+mergeOperationId+"&includeLinks="+includeLinks+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitMerge>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a specific merge operation's details.
		/// Merges_Get {organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/merges/{mergeOperationId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repositoryNameOrId">The name or ID of the repository.</param>
		/// <param name="mergeOperationId">OperationId of the merge request.</param>
		/// <param name="includeLinks">True to include links</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public GitMerge Merges_Get(string organization, string project, string repositoryNameOrId, int mergeOperationId, bool includeLinks, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/git/repositories/"+ (repositoryNameOrId==null? "" : System.Uri.EscapeDataString(repositoryNameOrId))+"/merges/"+mergeOperationId+"&includeLinks="+includeLinks+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GitMerge>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
