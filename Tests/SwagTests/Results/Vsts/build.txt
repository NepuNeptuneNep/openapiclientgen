//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Net.Http;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Represents a queue for running builds.
	/// </summary>
	public class AgentPoolQueue
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// The ID of the queue.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The name of the queue.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Represents a reference to an agent pool.
		/// </summary>
		public TaskAgentPoolReference Pool { get; set; }
		
		/// <summary>
		/// The full http link to the resource.
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// The class to represent a collection of REST reference links.
	/// </summary>
	public class ReferenceLinks
	{
		
		/// <summary>
		/// The readonly view of the links.  Because Reference links are readonly, we only want to expose them as read only.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, object> Links { get; set; }
	}
	
	/// <summary>
	/// Represents a reference to an agent pool.
	/// </summary>
	public class TaskAgentPoolReference
	{
		
		/// <summary>
		/// The pool ID.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// A value indicating whether or not this pool is managed by the service.
		/// </summary>
		public System.Nullable<System.Boolean> IsHosted { get; set; }
		
		/// <summary>
		/// The pool name.
		/// </summary>
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Represents a reference to an agent queue.
	/// </summary>
	public class AgentPoolQueueReference
	{
		
		/// <summary>
		/// The ID of the queue.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
	}
	
	/// <summary>
	/// Describes how a phase should run against an agent queue.
	/// </summary>
	public class AgentPoolQueueTarget
	{
		
		/// <summary>
		/// Specification of the agent defined by the pool provider.
		/// </summary>
		public AgentSpecification AgentSpecification { get; set; }
		
		/// <summary>
		/// Enables scripts and other processes launched while executing phase to access the OAuth token
		/// </summary>
		public System.Nullable<System.Boolean> AllowScriptsAuthAccessOption { get; set; }
		
		public Demand[] Demands { get; set; }
		
		/// <summary>
		/// Additional options for running phases against an agent queue.
		/// </summary>
		public AgentTargetExecutionOptions ExecutionOptions { get; set; }
		
		/// <summary>
		/// Represents a queue for running builds.
		/// </summary>
		public AgentPoolQueue Queue { get; set; }
	}
	
	/// <summary>
	/// Specification of the agent defined by the pool provider.
	/// </summary>
	public class AgentSpecification
	{
		
		/// <summary>
		/// Agent specification unique identifier.
		/// </summary>
		public string Identifier { get; set; }
	}
	
	/// <summary>
	/// Represents a demand used by a definition or build.
	/// </summary>
	public class Demand
	{
		
		/// <summary>
		/// The name of the capability referenced by the demand.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// The demanded value.
		/// </summary>
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Additional options for running phases against an agent queue.
	/// </summary>
	public class AgentTargetExecutionOptions
	{
		
		/// <summary>
		/// Indicates the type of execution options.
		/// </summary>
		public System.Nullable<System.Int32> Type { get; set; }
	}
	
	public class AggregatedResultsAnalysis
	{
		
		public string Duration { get; set; }
		
		public System.Collections.Generic.Dictionary<string, AggregatedResultsByOutcome> NotReportedResultsByOutcome { get; set; }
		
		public TestResultsContext PreviousContext { get; set; }
		
		public System.Collections.Generic.Dictionary<string, AggregatedResultsByOutcome> ResultsByOutcome { get; set; }
		
		public AggregatedResultsDifference ResultsDifference { get; set; }
		
		public System.Collections.Generic.Dictionary<string, AggregatedRunsByOutcome> RunSummaryByOutcome { get; set; }
		
		public System.Collections.Generic.Dictionary<string, AggregatedRunsByState> RunSummaryByState { get; set; }
		
		public System.Nullable<System.Int32> TotalTests { get; set; }
	}
	
	public class AggregatedResultsByOutcome
	{
		
		public System.Nullable<System.Int32> Count { get; set; }
		
		public string Duration { get; set; }
		
		public string GroupByField { get; set; }
		
		public string GroupByValue { get; set; }
		
		public System.Nullable<AggregatedResultsByOutcomeOutcome> Outcome { get; set; }
		
		public System.Nullable<System.Int32> RerunResultCount { get; set; }
	}
	
	public enum AggregatedResultsByOutcomeOutcome
	{
		
		unspecified = 0,
		
		none = 1,
		
		passed = 2,
		
		failed = 3,
		
		inconclusive = 4,
		
		timeout = 5,
		
		aborted = 6,
		
		blocked = 7,
		
		notExecuted = 8,
		
		warning = 9,
		
		error = 10,
		
		notApplicable = 11,
		
		paused = 12,
		
		inProgress = 13,
		
		notImpacted = 14,
	}
	
	public class TestResultsContext
	{
		
		/// <summary>
		/// Represents a reference to a build.
		/// </summary>
		public BuildReference Build { get; set; }
		
		public System.Nullable<TestResultsContextContextType> ContextType { get; set; }
		
		/// <summary>
		/// Pipeline reference
		/// </summary>
		public PipelineReference PipelineReference { get; set; }
		
		/// <summary>
		/// Reference to a release.
		/// </summary>
		public ReleaseReference Release { get; set; }
	}
	
	/// <summary>
	/// Represents a reference to a build.
	/// </summary>
	public class BuildReference
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// The build number.
		/// </summary>
		public string BuildNumber { get; set; }
		
		/// <summary>
		/// Indicates whether the build has been deleted.
		/// </summary>
		public System.Nullable<System.Boolean> Deleted { get; set; }
		
		/// <summary>
		/// The time that the build was completed.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> FinishTime { get; set; }
		
		/// <summary>
		/// The ID of the build.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The time that the build was queued.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> QueueTime { get; set; }
		
		public IdentityRef RequestedFor { get; set; }
		
		/// <summary>
		/// The build result.
		/// </summary>
		public System.Nullable<BuildReferenceResult> Result { get; set; }
		
		/// <summary>
		/// The time that the build was started.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> StartTime { get; set; }
		
		/// <summary>
		/// The build status.
		/// </summary>
		public System.Nullable<BuildReferenceStatus> Status { get; set; }
	}
	
	public class IdentityRef
	{
		
		/// <summary>
		/// Deprecated - Can be retrieved by querying the Graph user referenced in the "self" entry of the IdentityRef "_links" dictionary
		/// </summary>
		public string DirectoryAlias { get; set; }
		
		public string Id { get; set; }
		
		/// <summary>
		/// Deprecated - Available in the "avatar" entry of the IdentityRef "_links" dictionary
		/// </summary>
		public string ImageUrl { get; set; }
		
		/// <summary>
		/// Deprecated - Can be retrieved by querying the Graph membership state referenced in the "membershipState" entry of the GraphUser "_links" dictionary
		/// </summary>
		public System.Nullable<System.Boolean> Inactive { get; set; }
		
		/// <summary>
		/// Deprecated - Can be inferred from the subject type of the descriptor (Descriptor.IsAadUserType/Descriptor.IsAadGroupType)
		/// </summary>
		public System.Nullable<System.Boolean> IsAadIdentity { get; set; }
		
		/// <summary>
		/// Deprecated - Can be inferred from the subject type of the descriptor (Descriptor.IsGroupType)
		/// </summary>
		public System.Nullable<System.Boolean> IsContainer { get; set; }
		
		public System.Nullable<System.Boolean> IsDeletedInOrigin { get; set; }
		
		/// <summary>
		/// Deprecated - not in use in most preexisting implementations of ToIdentityRef
		/// </summary>
		public string ProfileUrl { get; set; }
		
		/// <summary>
		/// Deprecated - use Domain+PrincipalName instead
		/// </summary>
		public string UniqueName { get; set; }
	}
	
	public enum BuildReferenceResult
	{
		
		none = 0,
		
		succeeded = 1,
		
		partiallySucceeded = 2,
		
		failed = 3,
		
		canceled = 4,
	}
	
	public enum BuildReferenceStatus
	{
		
		none = 0,
		
		inProgress = 1,
		
		completed = 2,
		
		cancelling = 3,
		
		postponed = 4,
		
		notStarted = 5,
		
		all = 6,
	}
	
	public enum TestResultsContextContextType
	{
		
		build = 0,
		
		release = 1,
		
		pipeline = 2,
	}
	
	/// <summary>
	/// Pipeline reference
	/// </summary>
	public class PipelineReference
	{
		
		/// <summary>
		/// Job in pipeline. This is related to matrixing in YAML.
		/// </summary>
		public JobReference JobReference { get; set; }
		
		/// <summary>
		/// Phase in pipeline
		/// </summary>
		public PhaseReference PhaseReference { get; set; }
		
		/// <summary>
		/// Reference of the pipeline with which this pipeline instance is related.
		/// </summary>
		public System.Nullable<System.Int32> PipelineId { get; set; }
		
		/// <summary>
		/// Stage in pipeline
		/// </summary>
		public StageReference StageReference { get; set; }
	}
	
	/// <summary>
	/// Job in pipeline. This is related to matrixing in YAML.
	/// </summary>
	public class JobReference
	{
		
		/// <summary>
		/// Attempt number of the job
		/// </summary>
		public System.Nullable<System.Int32> Attempt { get; set; }
		
		/// <summary>
		/// Matrixing in YAML generates copies of a job with different inputs in matrix. JobName is the name of those input. Maximum supported length for name is 256 character.
		/// </summary>
		public string JobName { get; set; }
	}
	
	/// <summary>
	/// Phase in pipeline
	/// </summary>
	public class PhaseReference
	{
		
		/// <summary>
		/// Attempt number of the phase
		/// </summary>
		public System.Nullable<System.Int32> Attempt { get; set; }
		
		/// <summary>
		/// Name of the phase. Maximum supported length for name is 256 character.
		/// </summary>
		public string PhaseName { get; set; }
	}
	
	/// <summary>
	/// Stage in pipeline
	/// </summary>
	public class StageReference
	{
		
		/// <summary>
		/// Attempt number of stage
		/// </summary>
		public System.Nullable<System.Int32> Attempt { get; set; }
		
		/// <summary>
		/// Name of the stage. Maximum supported length for name is 256 character.
		/// </summary>
		public string StageName { get; set; }
	}
	
	/// <summary>
	/// Reference to a release.
	/// </summary>
	public class ReleaseReference
	{
		
		/// <summary>
		/// Number of Release Attempt.
		/// </summary>
		public System.Nullable<System.Int32> Attempt { get; set; }
		
		/// <summary>
		/// Release Creation Date.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreationDate { get; set; }
		
		/// <summary>
		/// Release definition ID.
		/// </summary>
		public System.Nullable<System.Int32> DefinitionId { get; set; }
		
		/// <summary>
		/// Environment creation Date.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> EnvironmentCreationDate { get; set; }
		
		/// <summary>
		/// Release environment definition ID.
		/// </summary>
		public System.Nullable<System.Int32> EnvironmentDefinitionId { get; set; }
		
		/// <summary>
		/// Release environment definition name.
		/// </summary>
		public string EnvironmentDefinitionName { get; set; }
		
		/// <summary>
		/// Release environment ID.
		/// </summary>
		public System.Nullable<System.Int32> EnvironmentId { get; set; }
		
		/// <summary>
		/// Release environment name.
		/// </summary>
		public string EnvironmentName { get; set; }
		
		/// <summary>
		/// Release ID.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Release name.
		/// </summary>
		public string Name { get; set; }
	}
	
	public class AggregatedResultsDifference
	{
		
		public string IncreaseInDuration { get; set; }
		
		public System.Nullable<System.Int32> IncreaseInFailures { get; set; }
		
		public System.Nullable<System.Int32> IncreaseInNonImpactedTests { get; set; }
		
		public System.Nullable<System.Int32> IncreaseInOtherTests { get; set; }
		
		public System.Nullable<System.Int32> IncreaseInPassedTests { get; set; }
		
		public System.Nullable<System.Int32> IncreaseInTotalTests { get; set; }
	}
	
	public class AggregatedRunsByOutcome
	{
		
		public System.Nullable<AggregatedRunsByOutcomeOutcome> Outcome { get; set; }
		
		public System.Nullable<System.Int32> RunsCount { get; set; }
	}
	
	public enum AggregatedRunsByOutcomeOutcome
	{
		
		passed = 0,
		
		failed = 1,
		
		notImpacted = 2,
		
		others = 3,
	}
	
	public class AggregatedRunsByState
	{
		
		public System.Collections.Generic.Dictionary<string, AggregatedResultsByOutcome> ResultsByOutcome { get; set; }
		
		public System.Nullable<System.Int32> RunsCount { get; set; }
		
		public System.Nullable<AggregatedRunsByStateState> State { get; set; }
	}
	
	public enum AggregatedRunsByStateState
	{
		
		unspecified = 0,
		
		notStarted = 1,
		
		inProgress = 2,
		
		completed = 3,
		
		aborted = 4,
		
		waiting = 5,
		
		needsInvestigation = 6,
	}
	
	public class ArtifactResource
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// Type-specific data about the artifact.
		/// </summary>
		public string Data { get; set; }
		
		/// <summary>
		/// A link to download the resource.
		/// </summary>
		public string DownloadUrl { get; set; }
		
		/// <summary>
		/// Type-specific properties of the artifact.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, string> Properties { get; set; }
		
		/// <summary>
		/// The type of the resource: File container, version control folder, UNC path, etc.
		/// </summary>
		public string Type { get; set; }
		
		/// <summary>
		/// The full http link to the resource.
		/// </summary>
		public string Url { get; set; }
	}
	
	public class AssociatedWorkItem
	{
		
		public string AssignedTo { get; set; }
		
		/// <summary>
		/// Id of associated the work item.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		public string State { get; set; }
		
		public string Title { get; set; }
		
		/// <summary>
		/// REST Url of the work item.
		/// </summary>
		public string Url { get; set; }
		
		public string WebUrl { get; set; }
		
		public string WorkItemType { get; set; }
	}
	
	/// <summary>
	/// Represents an attachment to a build.
	/// </summary>
	public class Attachment
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// The name of the attachment.
		/// </summary>
		public string Name { get; set; }
	}
	
	public class AuthorizationHeader
	{
		
		public string Name { get; set; }
		
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Data representation of a build.
	/// </summary>
	public class Build
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// Specification of the agent defined by the pool provider.
		/// </summary>
		public AgentSpecification AgentSpecification { get; set; }
		
		/// <summary>
		/// The build number/name of the build.
		/// </summary>
		public string BuildNumber { get; set; }
		
		/// <summary>
		/// The build number revision.
		/// </summary>
		public System.Nullable<System.Int32> BuildNumberRevision { get; set; }
		
		public BuildController Controller { get; set; }
		
		/// <summary>
		/// Represents a reference to a definition.
		/// </summary>
		public DefinitionReference Definition { get; set; }
		
		/// <summary>
		/// Indicates whether the build has been deleted.
		/// </summary>
		public System.Nullable<System.Boolean> Deleted { get; set; }
		
		public IdentityRef DeletedBy { get; set; }
		
		/// <summary>
		/// The date the build was deleted.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> DeletedDate { get; set; }
		
		/// <summary>
		/// The description of how the build was deleted.
		/// </summary>
		public string DeletedReason { get; set; }
		
		/// <summary>
		/// A list of demands that represents the agent capabilities required by this build.
		/// </summary>
		public Demand[] Demands { get; set; }
		
		/// <summary>
		/// The time that the build was completed.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> FinishTime { get; set; }
		
		/// <summary>
		/// The ID of the build.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Indicates whether the build should be skipped by retention policies.
		/// </summary>
		public System.Nullable<System.Boolean> KeepForever { get; set; }
		
		public IdentityRef LastChangedBy { get; set; }
		
		/// <summary>
		/// The date the build was last changed.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastChangedDate { get; set; }
		
		/// <summary>
		/// Represents a reference to a build log.
		/// </summary>
		public BuildLogReference Logs { get; set; }
		
		/// <summary>
		/// Represents a reference to an orchestration plan.
		/// </summary>
		public TaskOrchestrationPlanReference OrchestrationPlan { get; set; }
		
		/// <summary>
		/// The parameters for the build.
		/// </summary>
		public string Parameters { get; set; }
		
		/// <summary>
		/// Orchestration plans associated with the build (build, cleanup)
		/// </summary>
		public TaskOrchestrationPlanReference[] Plans { get; set; }
		
		/// <summary>
		/// The build's priority.
		/// </summary>
		public System.Nullable<BuildPriority> Priority { get; set; }
		
		/// <summary>
		/// Represents a shallow reference to a TeamProject.
		/// </summary>
		public TeamProjectReference Project { get; set; }
		
		/// <summary>
		/// The class represents a property bag as a collection of key-value pairs. Values of all primitive types (any type with a `TypeCode != TypeCode.Object`) except for `DBNull` are accepted. Values of type Byte[], Int32, Double, DateType and String preserve their type, other primitives are retuned as a String. Byte[] expected as base64 encoded string.
		/// </summary>
		public PropertiesCollection Properties { get; set; }
		
		/// <summary>
		/// The quality of the xaml build (good, bad, etc.)
		/// </summary>
		public string Quality { get; set; }
		
		/// <summary>
		/// Represents a queue for running builds.
		/// </summary>
		public AgentPoolQueue Queue { get; set; }
		
		/// <summary>
		/// Additional options for queueing the build.
		/// </summary>
		public System.Nullable<BuildQueueOptions> QueueOptions { get; set; }
		
		/// <summary>
		/// The current position of the build in the queue.
		/// </summary>
		public System.Nullable<System.Int32> QueuePosition { get; set; }
		
		/// <summary>
		/// The time that the build was queued.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> QueueTime { get; set; }
		
		/// <summary>
		/// The reason that the build was created.
		/// </summary>
		public System.Nullable<BuildReason> Reason { get; set; }
		
		/// <summary>
		/// Represents a repository used by a build definition.
		/// </summary>
		public BuildRepository Repository { get; set; }
		
		public IdentityRef RequestedBy { get; set; }
		
		public IdentityRef RequestedFor { get; set; }
		
		/// <summary>
		/// The build result.
		/// </summary>
		public System.Nullable<BuildResult> Result { get; set; }
		
		/// <summary>
		/// Indicates whether the build is retained by a release.
		/// </summary>
		public System.Nullable<System.Boolean> RetainedByRelease { get; set; }
		
		/// <summary>
		/// The source branch.
		/// </summary>
		public string SourceBranch { get; set; }
		
		/// <summary>
		/// The source version.
		/// </summary>
		public string SourceVersion { get; set; }
		
		/// <summary>
		/// The time that the build was started.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> StartTime { get; set; }
		
		/// <summary>
		/// The status of the build.
		/// </summary>
		public System.Nullable<BuildStatus> Status { get; set; }
		
		public string[] Tags { get; set; }
		
		/// <summary>
		/// Data representation of a build.
		/// </summary>
		public Build TriggeredByBuild { get; set; }
		
		/// <summary>
		/// Sourceprovider-specific information about what triggered the build
		/// </summary>
		public System.Collections.Generic.Dictionary<string, string> TriggerInfo { get; set; }
		
		/// <summary>
		/// The URI of the build.
		/// </summary>
		public string Uri { get; set; }
		
		/// <summary>
		/// The REST URL of the build.
		/// </summary>
		public string Url { get; set; }
		
		public BuildRequestValidationResult[] ValidationResults { get; set; }
	}
	
	public class BuildController
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// The date the controller was created.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedDate { get; set; }
		
		/// <summary>
		/// The description of the controller.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Indicates whether the controller is enabled.
		/// </summary>
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The status of the controller.
		/// </summary>
		public System.Nullable<BuildControllerStatus> Status { get; set; }
		
		/// <summary>
		/// The date the controller was last updated.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> UpdatedDate { get; set; }
		
		/// <summary>
		/// The controller's URI.
		/// </summary>
		public string Uri { get; set; }
	}
	
	public enum BuildControllerStatus
	{
		
		unavailable = 0,
		
		available = 1,
		
		offline = 2,
	}
	
	/// <summary>
	/// Represents a reference to a definition.
	/// </summary>
	public class DefinitionReference
	{
		
		/// <summary>
		/// The date this version of the definition was created.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedDate { get; set; }
		
		/// <summary>
		/// The ID of the referenced definition.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The name of the referenced definition.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// The folder path of the definition.
		/// </summary>
		public string Path { get; set; }
		
		/// <summary>
		/// Represents a shallow reference to a TeamProject.
		/// </summary>
		public TeamProjectReference Project { get; set; }
		
		/// <summary>
		/// A value that indicates whether builds can be queued against this definition.
		/// </summary>
		public System.Nullable<DefinitionReferenceQueueStatus> QueueStatus { get; set; }
		
		/// <summary>
		/// The definition revision number.
		/// </summary>
		public System.Nullable<System.Int32> Revision { get; set; }
		
		/// <summary>
		/// The type of the definition.
		/// </summary>
		public System.Nullable<DefinitionReferenceType> Type { get; set; }
		
		/// <summary>
		/// The definition's URI.
		/// </summary>
		public string Uri { get; set; }
		
		/// <summary>
		/// The REST URL of the definition.
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Represents a shallow reference to a TeamProject.
	/// </summary>
	public class TeamProjectReference
	{
		
		/// <summary>
		/// Project abbreviation.
		/// </summary>
		public string Abbreviation { get; set; }
		
		/// <summary>
		/// Url to default team identity image.
		/// </summary>
		public string DefaultTeamImageUrl { get; set; }
		
		/// <summary>
		/// The project's description (if any).
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Project identifier.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Project last update time.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastUpdateTime { get; set; }
		
		/// <summary>
		/// Project name.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Project revision.
		/// </summary>
		public System.Nullable<System.Int64> Revision { get; set; }
		
		/// <summary>
		/// Project state.
		/// </summary>
		public System.Nullable<TeamProjectReferenceState> State { get; set; }
		
		/// <summary>
		/// Url to the full version of the object.
		/// </summary>
		public string Url { get; set; }
		
		/// <summary>
		/// Project visibility.
		/// </summary>
		public System.Nullable<TeamProjectReferenceVisibility> Visibility { get; set; }
	}
	
	public enum TeamProjectReferenceState
	{
		
		deleting = 0,
		
		_new = 1,
		
		wellFormed = 2,
		
		createPending = 3,
		
		all = 4,
		
		unchanged = 5,
		
		deleted = 6,
	}
	
	public enum TeamProjectReferenceVisibility
	{
		
		_private = 0,
		
		_public = 1,
	}
	
	public enum DefinitionReferenceQueueStatus
	{
		
		enabled = 0,
		
		paused = 1,
		
		disabled = 2,
	}
	
	public enum DefinitionReferenceType
	{
		
		xaml = 0,
		
		build = 1,
	}
	
	/// <summary>
	/// Represents a reference to a build log.
	/// </summary>
	public class BuildLogReference
	{
		
		/// <summary>
		/// The ID of the log.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The type of the log location.
		/// </summary>
		public string Type { get; set; }
		
		/// <summary>
		/// A full link to the log resource.
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Represents a reference to an orchestration plan.
	/// </summary>
	public class TaskOrchestrationPlanReference
	{
		
		/// <summary>
		/// The type of the plan.
		/// </summary>
		public System.Nullable<System.Int32> OrchestrationType { get; set; }
		
		/// <summary>
		/// The ID of the plan.
		/// </summary>
		public string PlanId { get; set; }
	}
	
	public enum BuildPriority
	{
		
		low = 0,
		
		belowNormal = 1,
		
		normal = 2,
		
		aboveNormal = 3,
		
		high = 4,
	}
	
	/// <summary>
	/// The class represents a property bag as a collection of key-value pairs. Values of all primitive types (any type with a `TypeCode != TypeCode.Object`) except for `DBNull` are accepted. Values of type Byte[], Int32, Double, DateType and String preserve their type, other primitives are retuned as a String. Byte[] expected as base64 encoded string.
	/// </summary>
	public class PropertiesCollection
	{
		
		/// <summary>
		/// The count of properties in the collection.
		/// </summary>
		public System.Nullable<System.Int32> Count { get; set; }
		
		public string Item { get; set; }
		
		/// <summary>
		/// The set of keys in the collection.
		/// </summary>
		public string[] Keys { get; set; }
		
		/// <summary>
		/// The set of values in the collection.
		/// </summary>
		public string[] Values { get; set; }
	}
	
	public enum BuildQueueOptions
	{
		
		none = 0,
		
		doNotRun = 1,
	}
	
	public enum BuildReason
	{
		
		none = 0,
		
		manual = 1,
		
		individualCI = 2,
		
		batchedCI = 3,
		
		schedule = 4,
		
		scheduleForced = 5,
		
		userCreated = 6,
		
		validateShelveset = 7,
		
		checkInShelveset = 8,
		
		pullRequest = 9,
		
		buildCompletion = 10,
		
		resourceTrigger = 11,
		
		triggered = 12,
		
		all = 13,
	}
	
	/// <summary>
	/// Represents a repository used by a build definition.
	/// </summary>
	public class BuildRepository
	{
		
		/// <summary>
		/// Indicates whether to checkout submodules.
		/// </summary>
		public System.Nullable<System.Boolean> CheckoutSubmodules { get; set; }
		
		/// <summary>
		/// Indicates whether to clean the target folder when getting code from the repository.
		/// </summary>
		public string Clean { get; set; }
		
		/// <summary>
		/// The name of the default branch.
		/// </summary>
		public string DefaultBranch { get; set; }
		
		/// <summary>
		/// The ID of the repository.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// The friendly name of the repository.
		/// </summary>
		public string Name { get; set; }
		
		public System.Collections.Generic.Dictionary<string, string> Properties { get; set; }
		
		/// <summary>
		/// The root folder.
		/// </summary>
		public string RootFolder { get; set; }
		
		/// <summary>
		/// The type of the repository.
		/// </summary>
		public string Type { get; set; }
		
		/// <summary>
		/// The URL of the repository.
		/// </summary>
		public string Url { get; set; }
	}
	
	public enum BuildResult
	{
		
		none = 0,
		
		succeeded = 1,
		
		partiallySucceeded = 2,
		
		failed = 3,
		
		canceled = 4,
	}
	
	public enum BuildStatus
	{
		
		none = 0,
		
		inProgress = 1,
		
		completed = 2,
		
		cancelling = 3,
		
		postponed = 4,
		
		notStarted = 5,
		
		all = 6,
	}
	
	/// <summary>
	/// Represents the result of validating a build request.
	/// </summary>
	public class BuildRequestValidationResult
	{
		
		/// <summary>
		/// The message associated with the result.
		/// </summary>
		public string Message { get; set; }
		
		/// <summary>
		/// The result.
		/// </summary>
		public System.Nullable<BuildRequestValidationResultResult> Result { get; set; }
	}
	
	public enum BuildRequestValidationResultResult
	{
		
		ok = 0,
		
		warning = 1,
		
		error = 2,
	}
	
	public class BuildAgent
	{
		
		public string BuildDirectory { get; set; }
		
		public XamlBuildControllerReference Controller { get; set; }
		
		public System.Nullable<System.DateTimeOffset> CreatedDate { get; set; }
		
		public string Description { get; set; }
		
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		public System.Nullable<System.Int32> Id { get; set; }
		
		public string MessageQueueUrl { get; set; }
		
		public string Name { get; set; }
		
		public string ReservedForBuild { get; set; }
		
		public XamlBuildServerReference Server { get; set; }
		
		public System.Nullable<BuildAgentStatus> Status { get; set; }
		
		public string StatusMessage { get; set; }
		
		public System.Nullable<System.DateTimeOffset> UpdatedDate { get; set; }
		
		public string Uri { get; set; }
		
		public string Url { get; set; }
	}
	
	public class XamlBuildControllerReference
	{
		
		/// <summary>
		/// Id of the resource
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Name of the linked resource (definition name, controller name, etc.)
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Full http link to the resource
		/// </summary>
		public string Url { get; set; }
	}
	
	public class XamlBuildServerReference
	{
		
		/// <summary>
		/// Id of the resource
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Name of the linked resource (definition name, controller name, etc.)
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Full http link to the resource
		/// </summary>
		public string Url { get; set; }
	}
	
	public enum BuildAgentStatus
	{
		
		unavailable = 0,
		
		available = 1,
		
		offline = 2,
	}
	
	public class BuildAgentReference
	{
		
		/// <summary>
		/// Id of the resource
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Name of the linked resource (definition name, controller name, etc.)
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Full http link to the resource
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Represents an artifact produced by a build.
	/// </summary>
	public class BuildArtifact
	{
		
		/// <summary>
		/// The artifact ID.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The name of the artifact.
		/// </summary>
		public string Name { get; set; }
		
		public ArtifactResource Resource { get; set; }
		
		/// <summary>
		/// The artifact source, which will be the ID of the job that produced this artifact. If an artifact is associated with multiple sources, this points to the first source.
		/// </summary>
		public string Source { get; set; }
	}
	
	/// <summary>
	/// Represents a build badge.
	/// </summary>
	public class BuildBadge
	{
		
		/// <summary>
		/// The ID of the build represented by this badge.
		/// </summary>
		public System.Nullable<System.Int32> BuildId { get; set; }
		
		/// <summary>
		/// A link to the SVG resource.
		/// </summary>
		public string ImageUrl { get; set; }
	}
	
	public class BuildCompletedEvent
	{
		
		/// <summary>
		/// Changes associated with a build used for build notifications
		/// </summary>
		public Change[] Changes { get; set; }
		
		/// <summary>
		/// Represents a pull request object.  These are retrieved from Source Providers.
		/// </summary>
		public PullRequest PullRequest { get; set; }
		
		public AggregatedResultsAnalysis TestResults { get; set; }
		
		/// <summary>
		/// Timeline records associated with a build used for build notifications
		/// </summary>
		public TimelineRecord[] TimelineRecords { get; set; }
		
		/// <summary>
		/// Work items associated with a build used for build notifications
		/// </summary>
		public AssociatedWorkItem[] WorkItems { get; set; }
	}
	
	/// <summary>
	/// Represents a change associated with a build.
	/// </summary>
	public class Change
	{
		
		public IdentityRef Author { get; set; }
		
		/// <summary>
		/// The location of a user-friendly representation of the resource.
		/// </summary>
		public string DisplayUri { get; set; }
		
		/// <summary>
		/// The identifier for the change. For a commit, this would be the SHA1. For a TFVC changeset, this would be the changeset ID.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// The location of the full representation of the resource.
		/// </summary>
		public string Location { get; set; }
		
		/// <summary>
		/// The description of the change. This might be a commit message or changeset description.
		/// </summary>
		public string Message { get; set; }
		
		/// <summary>
		/// Indicates whether the message was truncated.
		/// </summary>
		public System.Nullable<System.Boolean> MessageTruncated { get; set; }
		
		/// <summary>
		/// The person or process that pushed the change.
		/// </summary>
		public string Pusher { get; set; }
		
		/// <summary>
		/// The timestamp for the change.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> Timestamp { get; set; }
		
		/// <summary>
		/// The type of change. "commit", "changeset", etc.
		/// </summary>
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Represents a pull request object.  These are retrieved from Source Providers.
	/// </summary>
	public class PullRequest
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		public IdentityRef Author { get; set; }
		
		/// <summary>
		/// Current state of the pull request, e.g. open, merged, closed, conflicts, etc.
		/// </summary>
		public string CurrentState { get; set; }
		
		/// <summary>
		/// Description for the pull request.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Unique identifier for the pull request
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the provider this pull request is associated with.
		/// </summary>
		public string ProviderName { get; set; }
		
		/// <summary>
		/// Source branch ref of this pull request
		/// </summary>
		public string SourceBranchRef { get; set; }
		
		/// <summary>
		/// Owner of the source repository of this pull request
		/// </summary>
		public string SourceRepositoryOwner { get; set; }
		
		/// <summary>
		/// Target branch ref of this pull request
		/// </summary>
		public string TargetBranchRef { get; set; }
		
		/// <summary>
		/// Owner of the target repository of this pull request
		/// </summary>
		public string TargetRepositoryOwner { get; set; }
		
		/// <summary>
		/// Title of the pull request.
		/// </summary>
		public string Title { get; set; }
	}
	
	/// <summary>
	/// Represents an entry in a build's timeline.
	/// </summary>
	public class TimelineRecord
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// Attempt number of record.
		/// </summary>
		public System.Nullable<System.Int32> Attempt { get; set; }
		
		/// <summary>
		/// The change ID.
		/// </summary>
		public System.Nullable<System.Int32> ChangeId { get; set; }
		
		/// <summary>
		/// A string that indicates the current operation.
		/// </summary>
		public string CurrentOperation { get; set; }
		
		/// <summary>
		/// Represents a reference to a timeline.
		/// </summary>
		public TimelineReference Details { get; set; }
		
		/// <summary>
		/// The number of errors produced by this operation.
		/// </summary>
		public System.Nullable<System.Int32> ErrorCount { get; set; }
		
		/// <summary>
		/// The finish time.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> FinishTime { get; set; }
		
		/// <summary>
		/// The ID of the record.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// String identifier that is consistent across attempts.
		/// </summary>
		public string Identifier { get; set; }
		
		public Issue[] Issues { get; set; }
		
		/// <summary>
		/// The time the record was last modified.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastModified { get; set; }
		
		/// <summary>
		/// Represents a reference to a build log.
		/// </summary>
		public BuildLogReference Log { get; set; }
		
		/// <summary>
		/// The name.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// An ordinal value relative to other records.
		/// </summary>
		public System.Nullable<System.Int32> Order { get; set; }
		
		/// <summary>
		/// The ID of the record's parent.
		/// </summary>
		public string ParentId { get; set; }
		
		/// <summary>
		/// The current completion percentage.
		/// </summary>
		public System.Nullable<System.Int32> PercentComplete { get; set; }
		
		public TimelineAttempt[] PreviousAttempts { get; set; }
		
		/// <summary>
		/// The queue ID of the queue that the operation ran on.
		/// </summary>
		public System.Nullable<System.Int32> QueueId { get; set; }
		
		/// <summary>
		/// The result.
		/// </summary>
		public System.Nullable<TimelineRecordResult> Result { get; set; }
		
		/// <summary>
		/// The result code.
		/// </summary>
		public string ResultCode { get; set; }
		
		/// <summary>
		/// The start time.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> StartTime { get; set; }
		
		/// <summary>
		/// The state of the record.
		/// </summary>
		public System.Nullable<TimelineRecordState> State { get; set; }
		
		/// <summary>
		/// Represents a reference to a task.
		/// </summary>
		public TaskReference Task { get; set; }
		
		/// <summary>
		/// The type of the record.
		/// </summary>
		public string Type { get; set; }
		
		/// <summary>
		/// The REST URL of the timeline record.
		/// </summary>
		public string Url { get; set; }
		
		/// <summary>
		/// The number of warnings produced by this operation.
		/// </summary>
		public System.Nullable<System.Int32> WarningCount { get; set; }
		
		/// <summary>
		/// The name of the agent running the operation.
		/// </summary>
		public string WorkerName { get; set; }
	}
	
	/// <summary>
	/// Represents a reference to a timeline.
	/// </summary>
	public class TimelineReference
	{
		
		/// <summary>
		/// The change ID.
		/// </summary>
		public System.Nullable<System.Int32> ChangeId { get; set; }
		
		/// <summary>
		/// The ID of the timeline.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// The REST URL of the timeline.
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Represents an issue (error, warning) associated with a build.
	/// </summary>
	public class Issue
	{
		
		/// <summary>
		/// The category.
		/// </summary>
		public string Category { get; set; }
		
		public System.Collections.Generic.Dictionary<string, string> Data { get; set; }
		
		/// <summary>
		/// A description of the issue.
		/// </summary>
		public string Message { get; set; }
		
		/// <summary>
		/// The type (error, warning) of the issue.
		/// </summary>
		public System.Nullable<IssueType> Type { get; set; }
	}
	
	public enum IssueType
	{
		
		error = 0,
		
		warning = 1,
	}
	
	public class TimelineAttempt
	{
		
		/// <summary>
		/// Gets or sets the attempt of the record.
		/// </summary>
		public System.Nullable<System.Int32> Attempt { get; set; }
		
		/// <summary>
		/// Gets or sets the record identifier located within the specified timeline.
		/// </summary>
		public string RecordId { get; set; }
		
		/// <summary>
		/// Gets or sets the timeline identifier which owns the record representing this attempt.
		/// </summary>
		public string TimelineId { get; set; }
	}
	
	public enum TimelineRecordResult
	{
		
		succeeded = 0,
		
		succeededWithIssues = 1,
		
		failed = 2,
		
		canceled = 3,
		
		skipped = 4,
		
		abandoned = 5,
	}
	
	public enum TimelineRecordState
	{
		
		pending = 0,
		
		inProgress = 1,
		
		completed = 2,
	}
	
	/// <summary>
	/// Represents a reference to a task.
	/// </summary>
	public class TaskReference
	{
		
		/// <summary>
		/// The ID of the task definition.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the task definition.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// The version of the task definition.
		/// </summary>
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Represents a build completion trigger.
	/// </summary>
	public class BuildCompletionTrigger
	{
		
		public string[] BranchFilters { get; set; }
		
		/// <summary>
		/// Represents a reference to a definition.
		/// </summary>
		public DefinitionReference Definition { get; set; }
		
		public System.Nullable<System.Boolean> RequiresSuccessfulBuild { get; set; }
	}
	
	/// <summary>
	/// Represents a build definition.
	/// </summary>
	public class BuildDefinition
	{
		
		/// <summary>
		/// Indicates whether badges are enabled for this definition.
		/// </summary>
		public System.Nullable<System.Boolean> BadgeEnabled { get; set; }
		
		/// <summary>
		/// The build number format.
		/// </summary>
		public string BuildNumberFormat { get; set; }
		
		/// <summary>
		/// A save-time comment for the definition.
		/// </summary>
		public string Comment { get; set; }
		
		public Demand[] Demands { get; set; }
		
		/// <summary>
		/// The description.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// The drop location for the definition.
		/// </summary>
		public string DropLocation { get; set; }
		
		/// <summary>
		/// The job authorization scope for builds queued against this definition.
		/// </summary>
		public System.Nullable<BuildDefinitionJobAuthorizationScope> JobAuthorizationScope { get; set; }
		
		/// <summary>
		/// The job cancel timeout (in minutes) for builds cancelled by user for this definition.
		/// </summary>
		public System.Nullable<System.Int32> JobCancelTimeoutInMinutes { get; set; }
		
		/// <summary>
		/// The job execution timeout (in minutes) for builds queued against this definition.
		/// </summary>
		public System.Nullable<System.Int32> JobTimeoutInMinutes { get; set; }
		
		public BuildOption[] Options { get; set; }
		
		/// <summary>
		/// Represents a build process.
		/// </summary>
		public BuildProcess Process { get; set; }
		
		public ProcessParameters ProcessParameters { get; set; }
		
		/// <summary>
		/// The class represents a property bag as a collection of key-value pairs. Values of all primitive types (any type with a `TypeCode != TypeCode.Object`) except for `DBNull` are accepted. Values of type Byte[], Int32, Double, DateType and String preserve their type, other primitives are retuned as a String. Byte[] expected as base64 encoded string.
		/// </summary>
		public PropertiesCollection Properties { get; set; }
		
		/// <summary>
		/// Represents a repository used by a build definition.
		/// </summary>
		public BuildRepository Repository { get; set; }
		
		public RetentionPolicy[] RetentionRules { get; set; }
		
		public string[] Tags { get; set; }
		
		public BuildTrigger[] Triggers { get; set; }
		
		public VariableGroup[] VariableGroups { get; set; }
		
		public System.Collections.Generic.Dictionary<string, BuildDefinitionVariable> Variables { get; set; }
	}
	
	public enum BuildDefinitionJobAuthorizationScope
	{
		
		projectCollection = 0,
		
		project = 1,
	}
	
	/// <summary>
	/// Represents the application of an optional behavior to a build definition.
	/// </summary>
	public class BuildOption
	{
		
		/// <summary>
		/// Represents a reference to a build option definition.
		/// </summary>
		public BuildOptionDefinitionReference Definition { get; set; }
		
		/// <summary>
		/// Indicates whether the behavior is enabled.
		/// </summary>
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		public System.Collections.Generic.Dictionary<string, string> Inputs { get; set; }
	}
	
	/// <summary>
	/// Represents a reference to a build option definition.
	/// </summary>
	public class BuildOptionDefinitionReference
	{
		
		/// <summary>
		/// The ID of the referenced build option.
		/// </summary>
		public string Id { get; set; }
	}
	
	/// <summary>
	/// Represents a build process.
	/// </summary>
	public class BuildProcess
	{
		
		/// <summary>
		/// The type of the process.
		/// </summary>
		public System.Nullable<System.Int32> Type { get; set; }
	}
	
	public class ProcessParameters
	{
		
		public DataSourceBindingBase[] DataSourceBindings { get; set; }
		
		public TaskInputDefinitionBase[] Inputs { get; set; }
		
		public TaskSourceDefinitionBase[] SourceDefinitions { get; set; }
	}
	
	/// <summary>
	/// Represents binding of data source for the service endpoint request.
	/// </summary>
	public class DataSourceBindingBase
	{
		
		/// <summary>
		/// Pagination format supported by this data source(ContinuationToken/SkipTop).
		/// </summary>
		public string CallbackContextTemplate { get; set; }
		
		/// <summary>
		/// Subsequent calls needed?
		/// </summary>
		public string CallbackRequiredTemplate { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the data source.
		/// </summary>
		public string DataSourceName { get; set; }
		
		/// <summary>
		/// Gets or sets the endpoint Id.
		/// </summary>
		public string EndpointId { get; set; }
		
		/// <summary>
		/// Gets or sets the url of the service endpoint.
		/// </summary>
		public string EndpointUrl { get; set; }
		
		/// <summary>
		/// Gets or sets the authorization headers.
		/// </summary>
		public AuthorizationHeader[] Headers { get; set; }
		
		/// <summary>
		/// Defines the initial value of the query params
		/// </summary>
		public string InitialContextTemplate { get; set; }
		
		/// <summary>
		/// Gets or sets the parameters for the data source.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, string> Parameters { get; set; }
		
		/// <summary>
		/// Gets or sets http request body
		/// </summary>
		public string RequestContent { get; set; }
		
		/// <summary>
		/// Gets or sets http request verb
		/// </summary>
		public string RequestVerb { get; set; }
		
		/// <summary>
		/// Gets or sets the result selector.
		/// </summary>
		public string ResultSelector { get; set; }
		
		/// <summary>
		/// Gets or sets the result template.
		/// </summary>
		public string ResultTemplate { get; set; }
		
		/// <summary>
		/// Gets or sets the target of the data source.
		/// </summary>
		public string Target { get; set; }
	}
	
	public class TaskInputDefinitionBase
	{
		
		public string[] Aliases { get; set; }
		
		public string DefaultValue { get; set; }
		
		public string GroupName { get; set; }
		
		public string HelpMarkDown { get; set; }
		
		public string Label { get; set; }
		
		public string Name { get; set; }
		
		public System.Collections.Generic.Dictionary<string, string> Options { get; set; }
		
		public System.Collections.Generic.Dictionary<string, string> Properties { get; set; }
		
		public System.Nullable<System.Boolean> Required { get; set; }
		
		public string Type { get; set; }
		
		public TaskInputValidation Validation { get; set; }
		
		public string VisibleRule { get; set; }
	}
	
	public class TaskInputValidation
	{
		
		/// <summary>
		/// Conditional expression
		/// </summary>
		public string Expression { get; set; }
		
		/// <summary>
		/// Message explaining how user can correct if validation fails
		/// </summary>
		public string Message { get; set; }
	}
	
	public class TaskSourceDefinitionBase
	{
		
		public string AuthKey { get; set; }
		
		public string Endpoint { get; set; }
		
		public string KeySelector { get; set; }
		
		public string Selector { get; set; }
		
		public string Target { get; set; }
	}
	
	/// <summary>
	/// Represents a retention policy for a build definition.
	/// </summary>
	public class RetentionPolicy
	{
		
		public string[] Artifacts { get; set; }
		
		public string[] ArtifactTypesToDelete { get; set; }
		
		public string[] Branches { get; set; }
		
		/// <summary>
		/// The number of days to keep builds.
		/// </summary>
		public System.Nullable<System.Int32> DaysToKeep { get; set; }
		
		/// <summary>
		/// Indicates whether the build record itself should be deleted.
		/// </summary>
		public System.Nullable<System.Boolean> DeleteBuildRecord { get; set; }
		
		/// <summary>
		/// Indicates whether to delete test results associated with the build.
		/// </summary>
		public System.Nullable<System.Boolean> DeleteTestResults { get; set; }
		
		/// <summary>
		/// The minimum number of builds to keep.
		/// </summary>
		public System.Nullable<System.Int32> MinimumToKeep { get; set; }
	}
	
	/// <summary>
	/// Represents a trigger for a buld definition.
	/// </summary>
	public class BuildTrigger
	{
		
		/// <summary>
		/// The type of the trigger.
		/// </summary>
		public System.Nullable<BuildTriggerTriggerType> TriggerType { get; set; }
	}
	
	public enum BuildTriggerTriggerType
	{
		
		none = 0,
		
		continuousIntegration = 1,
		
		batchedContinuousIntegration = 2,
		
		schedule = 3,
		
		gatedCheckIn = 4,
		
		batchedGatedCheckIn = 5,
		
		pullRequest = 6,
		
		buildCompletion = 7,
		
		all = 8,
	}
	
	/// <summary>
	/// Represents a variable group.
	/// </summary>
	public class VariableGroup
	{
		
		/// <summary>
		/// The description.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the variable group.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// The type of the variable group.
		/// </summary>
		public string Type { get; set; }
		
		public System.Collections.Generic.Dictionary<string, BuildDefinitionVariable> Variables { get; set; }
	}
	
	/// <summary>
	/// Represents a variable used by a build definition.
	/// </summary>
	public class BuildDefinitionVariable
	{
		
		/// <summary>
		/// Indicates whether the value can be set at queue time.
		/// </summary>
		public System.Nullable<System.Boolean> AllowOverride { get; set; }
		
		/// <summary>
		/// Indicates whether the variable's value is a secret.
		/// </summary>
		public System.Nullable<System.Boolean> IsSecret { get; set; }
		
		/// <summary>
		/// The value of the variable.
		/// </summary>
		public string Value { get; set; }
	}
	
	/// <summary>
	/// For back-compat with extensions that use the old Steps format instead of Process and Phases
	/// </summary>
	public class BuildDefinition3_2
	{
		
		/// <summary>
		/// Indicates whether badges are enabled for this definition
		/// </summary>
		public System.Nullable<System.Boolean> BadgeEnabled { get; set; }
		
		public BuildDefinitionStep[] Build { get; set; }
		
		/// <summary>
		/// The build number format
		/// </summary>
		public string BuildNumberFormat { get; set; }
		
		/// <summary>
		/// The comment entered when saving the definition
		/// </summary>
		public string Comment { get; set; }
		
		public Demand[] Demands { get; set; }
		
		/// <summary>
		/// The description
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// The drop location for the definition
		/// </summary>
		public string DropLocation { get; set; }
		
		/// <summary>
		/// The job authorization scope for builds which are queued against this definition
		/// </summary>
		public System.Nullable<BuildDefinition3_2JobAuthorizationScope> JobAuthorizationScope { get; set; }
		
		/// <summary>
		/// The job cancel timeout in minutes for builds which are cancelled by user for this definition
		/// </summary>
		public System.Nullable<System.Int32> JobCancelTimeoutInMinutes { get; set; }
		
		/// <summary>
		/// The job execution timeout in minutes for builds which are queued against this definition
		/// </summary>
		public System.Nullable<System.Int32> JobTimeoutInMinutes { get; set; }
		
		/// <summary>
		/// Data representation of a build.
		/// </summary>
		public Build LatestBuild { get; set; }
		
		/// <summary>
		/// Data representation of a build.
		/// </summary>
		public Build LatestCompletedBuild { get; set; }
		
		public BuildOption[] Options { get; set; }
		
		public ProcessParameters ProcessParameters { get; set; }
		
		/// <summary>
		/// The class represents a property bag as a collection of key-value pairs. Values of all primitive types (any type with a `TypeCode != TypeCode.Object`) except for `DBNull` are accepted. Values of type Byte[], Int32, Double, DateType and String preserve their type, other primitives are retuned as a String. Byte[] expected as base64 encoded string.
		/// </summary>
		public PropertiesCollection Properties { get; set; }
		
		/// <summary>
		/// Represents a repository used by a build definition.
		/// </summary>
		public BuildRepository Repository { get; set; }
		
		public RetentionPolicy[] RetentionRules { get; set; }
		
		public string[] Tags { get; set; }
		
		public BuildTrigger[] Triggers { get; set; }
		
		public System.Collections.Generic.Dictionary<string, BuildDefinitionVariable> Variables { get; set; }
	}
	
	/// <summary>
	/// Represents a step in a build phase.
	/// </summary>
	public class BuildDefinitionStep
	{
		
		/// <summary>
		/// Indicates whether this step should run even if a previous step fails.
		/// </summary>
		public System.Nullable<System.Boolean> AlwaysRun { get; set; }
		
		/// <summary>
		/// A condition that determines whether this step should run.
		/// </summary>
		public string Condition { get; set; }
		
		/// <summary>
		/// Indicates whether the phase should continue even if this step fails.
		/// </summary>
		public System.Nullable<System.Boolean> ContinueOnError { get; set; }
		
		/// <summary>
		/// The display name for this step.
		/// </summary>
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Indicates whether the step is enabled.
		/// </summary>
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		public System.Collections.Generic.Dictionary<string, string> Environment { get; set; }
		
		public System.Collections.Generic.Dictionary<string, string> Inputs { get; set; }
		
		/// <summary>
		/// The reference name for this step.
		/// </summary>
		public string RefName { get; set; }
		
		/// <summary>
		/// A reference to a task definition.
		/// </summary>
		public TaskDefinitionReference Task { get; set; }
		
		/// <summary>
		/// The time, in minutes, that this step is allowed to run.
		/// </summary>
		public System.Nullable<System.Int32> TimeoutInMinutes { get; set; }
	}
	
	/// <summary>
	/// A reference to a task definition.
	/// </summary>
	public class TaskDefinitionReference
	{
		
		/// <summary>
		/// The type of task (task or task group).
		/// </summary>
		public string DefinitionType { get; set; }
		
		/// <summary>
		/// The ID of the task.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// The version of the task.
		/// </summary>
		public string VersionSpec { get; set; }
	}
	
	public enum BuildDefinition3_2JobAuthorizationScope
	{
		
		projectCollection = 0,
		
		project = 1,
	}
	
	/// <summary>
	/// Represents a reference to a build definition.
	/// </summary>
	public class BuildDefinitionReference
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		public IdentityRef AuthoredBy { get; set; }
		
		/// <summary>
		/// Represents a reference to a definition.
		/// </summary>
		public DefinitionReference DraftOf { get; set; }
		
		/// <summary>
		/// The list of drafts associated with this definition, if this is not a draft definition.
		/// </summary>
		public DefinitionReference[] Drafts { get; set; }
		
		/// <summary>
		/// Data representation of a build.
		/// </summary>
		public Build LatestBuild { get; set; }
		
		/// <summary>
		/// Data representation of a build.
		/// </summary>
		public Build LatestCompletedBuild { get; set; }
		
		public BuildMetric[] Metrics { get; set; }
		
		/// <summary>
		/// The quality of the definition document (draft, etc.)
		/// </summary>
		public System.Nullable<BuildDefinitionReferenceQuality> Quality { get; set; }
		
		/// <summary>
		/// Represents a queue for running builds.
		/// </summary>
		public AgentPoolQueue Queue { get; set; }
	}
	
	/// <summary>
	/// Represents metadata about builds in the system.
	/// </summary>
	public class BuildMetric
	{
		
		/// <summary>
		/// The date for the scope.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> Date { get; set; }
		
		/// <summary>
		/// The value.
		/// </summary>
		public System.Nullable<System.Int32> IntValue { get; set; }
		
		/// <summary>
		/// The name of the metric.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// The scope.
		/// </summary>
		public string Scope { get; set; }
	}
	
	public enum BuildDefinitionReferenceQuality
	{
		
		definition = 0,
		
		draft = 1,
	}
	
	/// <summary>
	/// For back-compat with extensions that use the old Steps format instead of Process and Phases
	/// </summary>
	public class BuildDefinitionReference3_2
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		public IdentityRef AuthoredBy { get; set; }
		
		/// <summary>
		/// Represents a reference to a definition.
		/// </summary>
		public DefinitionReference DraftOf { get; set; }
		
		/// <summary>
		/// The list of drafts associated with this definition, if this is not a draft definition.
		/// </summary>
		public DefinitionReference[] Drafts { get; set; }
		
		public BuildMetric[] Metrics { get; set; }
		
		/// <summary>
		/// The quality of the definition document (draft, etc.)
		/// </summary>
		public System.Nullable<BuildDefinitionReference3_2Quality> Quality { get; set; }
		
		/// <summary>
		/// Represents a queue for running builds.
		/// </summary>
		public AgentPoolQueue Queue { get; set; }
	}
	
	public enum BuildDefinitionReference3_2Quality
	{
		
		definition = 0,
		
		draft = 1,
	}
	
	/// <summary>
	/// Represents a revision of a build definition.
	/// </summary>
	public class BuildDefinitionRevision
	{
		
		public IdentityRef ChangedBy { get; set; }
		
		/// <summary>
		/// The date and time that the definition was changed.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ChangedDate { get; set; }
		
		/// <summary>
		/// The change type (add, edit, delete).
		/// </summary>
		public System.Nullable<BuildDefinitionRevisionChangeType> ChangeType { get; set; }
		
		/// <summary>
		/// The comment associated with the change.
		/// </summary>
		public string Comment { get; set; }
		
		/// <summary>
		/// A link to the definition at this revision.
		/// </summary>
		public string DefinitionUrl { get; set; }
		
		/// <summary>
		/// The name of the definition.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// The revision number.
		/// </summary>
		public System.Nullable<System.Int32> Revision { get; set; }
	}
	
	public enum BuildDefinitionRevisionChangeType
	{
		
		add = 0,
		
		update = 1,
		
		delete = 2,
	}
	
	public class BuildDefinitionSourceProvider
	{
		
		/// <summary>
		/// Uri of the associated definition
		/// </summary>
		public string DefinitionUri { get; set; }
		
		/// <summary>
		/// fields associated with this build definition
		/// </summary>
		public System.Collections.Generic.Dictionary<string, string> Fields { get; set; }
		
		/// <summary>
		/// Id of this source provider
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The lst time this source provider was modified
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastModified { get; set; }
		
		/// <summary>
		/// Name of the source provider
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Which trigger types are supported by this definition source provider
		/// </summary>
		public System.Nullable<BuildDefinitionSourceProviderSupportedTriggerTypes> SupportedTriggerTypes { get; set; }
	}
	
	public enum BuildDefinitionSourceProviderSupportedTriggerTypes
	{
		
		none = 0,
		
		continuousIntegration = 1,
		
		batchedContinuousIntegration = 2,
		
		schedule = 3,
		
		gatedCheckIn = 4,
		
		batchedGatedCheckIn = 5,
		
		pullRequest = 6,
		
		buildCompletion = 7,
		
		all = 8,
	}
	
	/// <summary>
	/// Represents a template from which new build definitions can be created.
	/// </summary>
	public class BuildDefinitionTemplate
	{
		
		/// <summary>
		/// Indicates whether the template can be deleted.
		/// </summary>
		public System.Nullable<System.Boolean> CanDelete { get; set; }
		
		/// <summary>
		/// The template category.
		/// </summary>
		public string Category { get; set; }
		
		/// <summary>
		/// An optional hosted agent queue for the template to use by default.
		/// </summary>
		public string DefaultHostedQueue { get; set; }
		
		/// <summary>
		/// A description of the template.
		/// </summary>
		public string Description { get; set; }
		
		public System.Collections.Generic.Dictionary<string, string> Icons { get; set; }
		
		/// <summary>
		/// The ID of the task whose icon is used when showing this template in the UI.
		/// </summary>
		public string IconTaskId { get; set; }
		
		/// <summary>
		/// The ID of the template.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the template.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Represents a build definition.
		/// </summary>
		public BuildDefinition Template { get; set; }
	}
	
	/// <summary>
	/// For back-compat with extensions that use the old Steps format instead of Process and Phases
	/// </summary>
	public class BuildDefinitionTemplate3_2
	{
		
		public System.Nullable<System.Boolean> CanDelete { get; set; }
		
		public string Category { get; set; }
		
		public string DefaultHostedQueue { get; set; }
		
		public string Description { get; set; }
		
		public System.Collections.Generic.Dictionary<string, string> Icons { get; set; }
		
		public string IconTaskId { get; set; }
		
		public string Id { get; set; }
		
		public string Name { get; set; }
		
		/// <summary>
		/// For back-compat with extensions that use the old Steps format instead of Process and Phases
		/// </summary>
		public BuildDefinition3_2 Template { get; set; }
	}
	
	public class BuildDeletedEvent
	{
		
		/// <summary>
		/// Data representation of a build.
		/// </summary>
		public Build Build { get; set; }
	}
	
	public class BuildDeployment
	{
		
		public BuildSummary Deployment { get; set; }
		
		public XamlBuildReference SourceBuild { get; set; }
	}
	
	public class BuildSummary
	{
		
		public XamlBuildReference Build { get; set; }
		
		public System.Nullable<System.DateTimeOffset> FinishTime { get; set; }
		
		public System.Nullable<System.Boolean> KeepForever { get; set; }
		
		public string Quality { get; set; }
		
		public System.Nullable<BuildSummaryReason> Reason { get; set; }
		
		public IdentityRef RequestedFor { get; set; }
		
		public System.Nullable<System.DateTimeOffset> StartTime { get; set; }
		
		public System.Nullable<BuildSummaryStatus> Status { get; set; }
	}
	
	public class XamlBuildReference
	{
		
		/// <summary>
		/// Id of the resource
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Name of the linked resource (definition name, controller name, etc.)
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Full http link to the resource
		/// </summary>
		public string Url { get; set; }
	}
	
	public enum BuildSummaryReason
	{
		
		none = 0,
		
		manual = 1,
		
		individualCI = 2,
		
		batchedCI = 3,
		
		schedule = 4,
		
		scheduleForced = 5,
		
		userCreated = 6,
		
		validateShelveset = 7,
		
		checkInShelveset = 8,
		
		pullRequest = 9,
		
		buildCompletion = 10,
		
		resourceTrigger = 11,
		
		triggered = 12,
		
		all = 13,
	}
	
	public enum BuildSummaryStatus
	{
		
		none = 0,
		
		inProgress = 1,
		
		completed = 2,
		
		cancelling = 3,
		
		postponed = 4,
		
		notStarted = 5,
		
		all = 6,
	}
	
	public class BuildEvent
	{
		
		public string[] Data { get; set; }
		
		public string Identifier { get; set; }
	}
	
	/// <summary>
	/// Represents a build log.
	/// </summary>
	public class BuildLog
	{
		
		/// <summary>
		/// The date and time the log was created.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedOn { get; set; }
		
		/// <summary>
		/// The date and time the log was last changed.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastChangedOn { get; set; }
		
		/// <summary>
		/// The number of lines in the log.
		/// </summary>
		public System.Nullable<System.Int64> LineCount { get; set; }
	}
	
	/// <summary>
	/// Represents an optional behavior that can be applied to a build definition.
	/// </summary>
	public class BuildOptionDefinition
	{
		
		/// <summary>
		/// The description.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// The list of input groups defined for the build option.
		/// </summary>
		public BuildOptionGroupDefinition[] Groups { get; set; }
		
		/// <summary>
		/// The list of inputs defined for the build option.
		/// </summary>
		public BuildOptionInputDefinition[] Inputs { get; set; }
		
		/// <summary>
		/// The name of the build option.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// A value that indicates the relative order in which the behavior should be applied.
		/// </summary>
		public System.Nullable<System.Int32> Ordinal { get; set; }
	}
	
	/// <summary>
	/// Represents a group of inputs for a build option.
	/// </summary>
	public class BuildOptionGroupDefinition
	{
		
		/// <summary>
		/// The name of the group to display in the UI.
		/// </summary>
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Indicates whether the group is initially displayed as expanded in the UI.
		/// </summary>
		public System.Nullable<System.Boolean> IsExpanded { get; set; }
		
		/// <summary>
		/// The internal name of the group.
		/// </summary>
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Represents an input for a build option.
	/// </summary>
	public class BuildOptionInputDefinition
	{
		
		/// <summary>
		/// The default value.
		/// </summary>
		public string DefaultValue { get; set; }
		
		/// <summary>
		/// The name of the input group that this input belongs to.
		/// </summary>
		public string GroupName { get; set; }
		
		public System.Collections.Generic.Dictionary<string, string> Help { get; set; }
		
		/// <summary>
		/// The label for the input.
		/// </summary>
		public string Label { get; set; }
		
		/// <summary>
		/// The name of the input.
		/// </summary>
		public string Name { get; set; }
		
		public System.Collections.Generic.Dictionary<string, string> Options { get; set; }
		
		/// <summary>
		/// Indicates whether the input is required to have a value.
		/// </summary>
		public System.Nullable<System.Boolean> Required { get; set; }
		
		/// <summary>
		/// Indicates the type of the input value.
		/// </summary>
		public System.Nullable<BuildOptionInputDefinitionType> Type { get; set; }
		
		/// <summary>
		/// The rule that is applied to determine whether the input is visible in the UI.
		/// </summary>
		public string VisibleRule { get; set; }
	}
	
	public enum BuildOptionInputDefinitionType
	{
		
		_string = 0,
		
		boolean = 1,
		
		stringList = 2,
		
		radio = 3,
		
		pickList = 4,
		
		multiLine = 5,
		
		branchFilter = 6,
	}
	
	/// <summary>
	/// Represents resources used by a build process.
	/// </summary>
	public class BuildProcessResources
	{
		
		public ServiceEndpointReference[] Endpoints { get; set; }
		
		public SecureFileReference[] Files { get; set; }
		
		public AgentPoolQueueReference[] Queues { get; set; }
		
		public VariableGroupReference[] VariableGroups { get; set; }
	}
	
	/// <summary>
	/// Represents a referenec to a service endpoint.
	/// </summary>
	public class ServiceEndpointReference
	{
		
		/// <summary>
		/// The ID of the service endpoint.
		/// </summary>
		public string Id { get; set; }
	}
	
	/// <summary>
	/// Represents a reference to a secure file.
	/// </summary>
	public class SecureFileReference
	{
		
		/// <summary>
		/// The ID of the secure file.
		/// </summary>
		public string Id { get; set; }
	}
	
	/// <summary>
	/// Represents a reference to a variable group.
	/// </summary>
	public class VariableGroupReference
	{
		
		/// <summary>
		/// The Name of the variable group.
		/// </summary>
		public string Alias { get; set; }
		
		/// <summary>
		/// The ID of the variable group.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
	}
	
	public class BuildProcessTemplate
	{
		
		public string Description { get; set; }
		
		public System.Nullable<System.Boolean> FileExists { get; set; }
		
		public System.Nullable<System.Int32> Id { get; set; }
		
		public string Parameters { get; set; }
		
		public string ServerPath { get; set; }
		
		public System.Nullable<BuildProcessTemplateSupportedReasons> SupportedReasons { get; set; }
		
		public string TeamProject { get; set; }
		
		public System.Nullable<BuildProcessTemplateTemplateType> TemplateType { get; set; }
		
		public string Url { get; set; }
		
		public string Version { get; set; }
	}
	
	public enum BuildProcessTemplateSupportedReasons
	{
		
		none = 0,
		
		manual = 1,
		
		individualCI = 2,
		
		batchedCI = 3,
		
		schedule = 4,
		
		scheduleForced = 5,
		
		userCreated = 6,
		
		validateShelveset = 7,
		
		checkInShelveset = 8,
		
		pullRequest = 9,
		
		buildCompletion = 10,
		
		resourceTrigger = 11,
		
		triggered = 12,
		
		all = 13,
	}
	
	public enum BuildProcessTemplateTemplateType
	{
		
		custom = 0,
		
		_default = 1,
		
		upgrade = 2,
	}
	
	public class BuildQueuedEvent
	{
	}
	
	/// <summary>
	/// Represents information about a build report.
	/// </summary>
	public class BuildReportMetadata
	{
		
		/// <summary>
		/// The Id of the build.
		/// </summary>
		public System.Nullable<System.Int32> BuildId { get; set; }
		
		/// <summary>
		/// The content of the report.
		/// </summary>
		public string Content { get; set; }
		
		/// <summary>
		/// The type of the report.
		/// </summary>
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Represents information about resources used by builds in the system.
	/// </summary>
	public class BuildResourceUsage
	{
		
		/// <summary>
		/// The number of build agents.
		/// </summary>
		public System.Nullable<System.Int32> DistributedTaskAgents { get; set; }
		
		/// <summary>
		/// The number of paid private agent slots.
		/// </summary>
		public System.Nullable<System.Int32> PaidPrivateAgentSlots { get; set; }
		
		/// <summary>
		/// The total usage.
		/// </summary>
		public System.Nullable<System.Int32> TotalUsage { get; set; }
		
		/// <summary>
		/// The number of XAML controllers.
		/// </summary>
		public System.Nullable<System.Int32> XamlControllers { get; set; }
	}
	
	public class BuildsDeletedEvent
	{
	}
	
	public class BuildsDeletedEvent1
	{
		
		public int[] BuildIds { get; set; }
		
		/// <summary>
		/// The ID of the definition.
		/// </summary>
		public System.Nullable<System.Int32> DefinitionId { get; set; }
		
		/// <summary>
		/// The ID of the project.
		/// </summary>
		public string ProjectId { get; set; }
	}
	
	public class BuildServer
	{
		
		public BuildAgentReference[] Agents { get; set; }
		
		public XamlBuildControllerReference Controller { get; set; }
		
		public System.Nullable<System.Int32> Id { get; set; }
		
		public System.Nullable<System.Boolean> IsVirtual { get; set; }
		
		public string MessageQueueUrl { get; set; }
		
		public string Name { get; set; }
		
		public System.Nullable<System.Boolean> RequireClientCertificates { get; set; }
		
		public System.Nullable<BuildServerStatus> Status { get; set; }
		
		public System.Nullable<System.DateTimeOffset> StatusChangedDate { get; set; }
		
		public string Uri { get; set; }
		
		public string Url { get; set; }
		
		public System.Nullable<System.Int32> Version { get; set; }
	}
	
	public enum BuildServerStatus
	{
		
		online = 0,
		
		offline = 1,
	}
	
	/// <summary>
	/// Represents system-wide build settings.
	/// </summary>
	public class BuildSettings
	{
		
		/// <summary>
		/// The number of days to keep records of deleted builds.
		/// </summary>
		public System.Nullable<System.Int32> DaysToKeepDeletedBuildsBeforeDestroy { get; set; }
		
		/// <summary>
		/// Represents a retention policy for a build definition.
		/// </summary>
		public RetentionPolicy DefaultRetentionPolicy { get; set; }
		
		/// <summary>
		/// Represents a retention policy for a build definition.
		/// </summary>
		public RetentionPolicy MaximumRetentionPolicy { get; set; }
	}
	
	public class BuildTagsAddedEvent
	{
		
		public string[] AllTags { get; set; }
		
		public string[] NewTags { get; set; }
	}
	
	public class BuildUpdatedEvent
	{
		
		/// <summary>
		/// Data representation of a build.
		/// </summary>
		public Build Build { get; set; }
	}
	
	/// <summary>
	/// Represents a workspace mapping.
	/// </summary>
	public class BuildWorkspace
	{
		
		public MappingDetails[] Mappings { get; set; }
	}
	
	/// <summary>
	/// Represents an entry in a workspace mapping.
	/// </summary>
	public class MappingDetails
	{
		
		/// <summary>
		/// The local path.
		/// </summary>
		public string LocalPath { get; set; }
		
		/// <summary>
		/// The mapping type.
		/// </summary>
		public string MappingType { get; set; }
		
		/// <summary>
		/// The server path.
		/// </summary>
		public string ServerPath { get; set; }
	}
	
	public class ConsoleLogEvent
	{
		
		public string[] Lines { get; set; }
		
		public string StepRecordId { get; set; }
		
		public string TimelineId { get; set; }
		
		public string TimelineRecordId { get; set; }
	}
	
	public class ContinuousDeploymentDefinition
	{
		
		public WebApiConnectedServiceRef ConnectedService { get; set; }
		
		public XamlDefinitionReference Definition { get; set; }
		
		public string GitBranch { get; set; }
		
		public string HostedServiceName { get; set; }
		
		/// <summary>
		/// Represents a shallow reference to a TeamProject.
		/// </summary>
		public TeamProjectReference Project { get; set; }
		
		public string RepositoryId { get; set; }
		
		public string StorageAccountName { get; set; }
		
		public string SubscriptionId { get; set; }
		
		public string Website { get; set; }
		
		public string Webspace { get; set; }
	}
	
	public class WebApiConnectedServiceRef
	{
		
		public string Id { get; set; }
		
		public string Url { get; set; }
	}
	
	public class XamlDefinitionReference
	{
		
		/// <summary>
		/// Id of the resource
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Name of the linked resource (definition name, controller name, etc.)
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Full http link to the resource
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Represents a continuous integration (CI) trigger.
	/// </summary>
	public class ContinuousIntegrationTrigger
	{
		
		/// <summary>
		/// Indicates whether changes should be batched while another CI build is running.
		/// </summary>
		public System.Nullable<System.Boolean> BatchChanges { get; set; }
		
		public string[] BranchFilters { get; set; }
		
		/// <summary>
		/// The maximum number of simultaneous CI builds that will run per branch.
		/// </summary>
		public System.Nullable<System.Int32> MaxConcurrentBuildsPerBranch { get; set; }
		
		public string[] PathFilters { get; set; }
		
		/// <summary>
		/// The polling interval, in seconds.
		/// </summary>
		public System.Nullable<System.Int32> PollingInterval { get; set; }
		
		/// <summary>
		/// The ID of the job used to poll an external repository.
		/// </summary>
		public string PollingJobId { get; set; }
		
		public System.Nullable<System.Int32> SettingsSourceType { get; set; }
	}
	
	public class DefinitionResourceReference
	{
		
		/// <summary>
		/// Indicates whether the resource is authorized for use.
		/// </summary>
		public System.Nullable<System.Boolean> Authorized { get; set; }
		
		/// <summary>
		/// The id of the resource.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// A friendly name for the resource.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// The type of the resource.
		/// </summary>
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Represents a dependency.
	/// </summary>
	public class Dependency
	{
		
		/// <summary>
		/// The event. The dependency is satisfied when the referenced object emits this event.
		/// </summary>
		public string Event { get; set; }
		
		/// <summary>
		/// The scope. This names the object referenced by the dependency.
		/// </summary>
		public string Scope { get; set; }
	}
	
	/// <summary>
	/// Represents the data from the build information nodes for type "DeploymentInformation" for xaml builds
	/// </summary>
	public class Deployment
	{
		
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Deployment information for type "Build"
	/// </summary>
	public class DeploymentBuild
	{
		
		public System.Nullable<System.Int32> BuildId { get; set; }
	}
	
	/// <summary>
	/// Deployment information for type "Deploy"
	/// </summary>
	public class DeploymentDeploy
	{
		
		public string Message { get; set; }
	}
	
	/// <summary>
	/// Deployment information for type "Test"
	/// </summary>
	public class DeploymentTest
	{
		
		public System.Nullable<System.Int32> RunId { get; set; }
	}
	
	/// <summary>
	/// Represents a build process supported by the build definition designer.
	/// </summary>
	public class DesignerProcess
	{
		
		public Phase[] Phases { get; set; }
		
		/// <summary>
		/// Represents the target for the build process.
		/// </summary>
		public DesignerProcessTarget Target { get; set; }
	}
	
	/// <summary>
	/// Represents a phase of a build definition.
	/// </summary>
	public class Phase
	{
		
		/// <summary>
		/// The condition that must be true for this phase to execute.
		/// </summary>
		public string Condition { get; set; }
		
		public Dependency[] Dependencies { get; set; }
		
		/// <summary>
		/// The job authorization scope for builds queued against this definition.
		/// </summary>
		public System.Nullable<PhaseJobAuthorizationScope> JobAuthorizationScope { get; set; }
		
		/// <summary>
		/// The cancellation timeout, in minutes, for builds queued against this definition.
		/// </summary>
		public System.Nullable<System.Int32> JobCancelTimeoutInMinutes { get; set; }
		
		/// <summary>
		/// The job execution timeout, in minutes, for builds queued against this definition.
		/// </summary>
		public System.Nullable<System.Int32> JobTimeoutInMinutes { get; set; }
		
		/// <summary>
		/// The name of the phase.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// The unique ref name of the phase.
		/// </summary>
		public string RefName { get; set; }
		
		public BuildDefinitionStep[] Steps { get; set; }
		
		/// <summary>
		/// Represents the target of a phase.
		/// </summary>
		public PhaseTarget Target { get; set; }
		
		public System.Collections.Generic.Dictionary<string, BuildDefinitionVariable> Variables { get; set; }
	}
	
	public enum PhaseJobAuthorizationScope
	{
		
		projectCollection = 0,
		
		project = 1,
	}
	
	/// <summary>
	/// Represents the target of a phase.
	/// </summary>
	public class PhaseTarget
	{
		
		/// <summary>
		/// The type of the target.
		/// </summary>
		public System.Nullable<System.Int32> Type { get; set; }
	}
	
	/// <summary>
	/// Represents the target for the build process.
	/// </summary>
	public class DesignerProcessTarget
	{
		
		/// <summary>
		/// Specification of the agent defined by the pool provider.
		/// </summary>
		public AgentSpecification AgentSpecification { get; set; }
	}
	
	public class DockerProcess
	{
		
		/// <summary>
		/// Represents the target for the docker build process.
		/// </summary>
		public DockerProcessTarget Target { get; set; }
	}
	
	/// <summary>
	/// Represents the target for the docker build process.
	/// </summary>
	public class DockerProcessTarget
	{
	}
	
	/// <summary>
	/// Represents a folder that contains build definitions.
	/// </summary>
	public class Folder
	{
		
		public IdentityRef CreatedBy { get; set; }
		
		/// <summary>
		/// The date the folder was created.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedOn { get; set; }
		
		/// <summary>
		/// The description.
		/// </summary>
		public string Description { get; set; }
		
		public IdentityRef LastChangedBy { get; set; }
		
		/// <summary>
		/// The date the folder was last changed.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastChangedDate { get; set; }
		
		/// <summary>
		/// The full path.
		/// </summary>
		public string Path { get; set; }
		
		/// <summary>
		/// Represents a shallow reference to a TeamProject.
		/// </summary>
		public TeamProjectReference Project { get; set; }
	}
	
	/// <summary>
	/// Represents the ability to build forks of the selected repository.
	/// </summary>
	public class Forks
	{
		
		/// <summary>
		/// Indicates whether a build should use secrets when building forks of the selected repository.
		/// </summary>
		public System.Nullable<System.Boolean> AllowSecrets { get; set; }
		
		/// <summary>
		/// Indicates whether the trigger should queue builds for forks of the selected repository.
		/// </summary>
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	/// <summary>
	/// Represents a gated check-in trigger.
	/// </summary>
	public class GatedCheckInTrigger
	{
		
		public string[] PathFilters { get; set; }
		
		/// <summary>
		/// Indicates whether CI triggers should run after the gated check-in succeeds.
		/// </summary>
		public System.Nullable<System.Boolean> RunContinuousIntegration { get; set; }
		
		/// <summary>
		/// Indicates whether to take workspace mappings into account when determining whether a build should run.
		/// </summary>
		public System.Nullable<System.Boolean> UseWorkspaceMappings { get; set; }
	}
	
	public class GraphSubjectBase
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
		/// </summary>
		public string Descriptor { get; set; }
		
		/// <summary>
		/// This is the non-unique display name of the graph subject. To change this field, you must alter its value in the source provider.
		/// </summary>
		public string DisplayName { get; set; }
		
		/// <summary>
		/// This url is the full route to the source resource of this graph subject.
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Data representation of an information node associated with a build
	/// </summary>
	public class InformationNode
	{
		
		/// <summary>
		/// Fields of the information node
		/// </summary>
		public System.Collections.Generic.Dictionary<string, string> Fields { get; set; }
		
		/// <summary>
		/// Process or person that last modified this node
		/// </summary>
		public string LastModifiedBy { get; set; }
		
		/// <summary>
		/// Date this node was last modified
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastModifiedDate { get; set; }
		
		/// <summary>
		/// Node Id of this information node
		/// </summary>
		public System.Nullable<System.Int32> NodeId { get; set; }
		
		/// <summary>
		/// Id of parent node (xml tree)
		/// </summary>
		public System.Nullable<System.Int32> ParentId { get; set; }
		
		/// <summary>
		/// The type of the information node
		/// </summary>
		public string Type { get; set; }
	}
	
	/// <summary>
	/// The JSON model for JSON Patch Operations
	/// </summary>
	public class JsonPatchDocument
	{
	}
	
	/// <summary>
	/// The JSON model for a JSON Patch operation
	/// </summary>
	public class JsonPatchOperation
	{
		
		/// <summary>
		/// The path to copy from for the Move/Copy operation.
		/// </summary>
		public string From { get; set; }
		
		/// <summary>
		/// The patch operation
		/// </summary>
		public System.Nullable<JsonPatchOperationOp> Op { get; set; }
		
		/// <summary>
		/// The path for the operation. In the case of an array, a zero based index can be used to specify the position in the array (e.g. /biscuits/0/name). The "-" character can be used instead of an index to insert at the end of the array (e.g. /biscuits/-).
		/// </summary>
		public string Path { get; set; }
		
		/// <summary>
		/// The value for the operation. This is either a primitive or a JToken.
		/// </summary>
		public string Value { get; set; }
	}
	
	public enum JsonPatchOperationOp
	{
		
		add = 0,
		
		remove = 1,
		
		replace = 2,
		
		move = 3,
		
		copy = 4,
		
		test = 5,
	}
	
	public class JustInTimeProcess
	{
	}
	
	/// <summary>
	/// Represents options for running a phase against multiple agents.
	/// </summary>
	public class MultipleAgentExecutionOptions
	{
		
		/// <summary>
		/// Indicates whether failure on one agent should prevent the phase from running on other agents.
		/// </summary>
		public System.Nullable<System.Boolean> ContinueOnError { get; set; }
		
		/// <summary>
		/// The maximum number of agents to use simultaneously.
		/// </summary>
		public System.Nullable<System.Int32> MaxConcurrency { get; set; }
	}
	
	public class NewRetentionLease
	{
		
		/// <summary>
		/// The number of days to consider the lease valid.
		/// </summary>
		public System.Nullable<System.Int32> DaysValid { get; set; }
		
		/// <summary>
		/// The pipeline definition of the run.
		/// </summary>
		public System.Nullable<System.Int32> DefinitionId { get; set; }
		
		/// <summary>
		/// User-provided string that identifies the owner of a retention lease.
		/// </summary>
		public string OwnerId { get; set; }
		
		/// <summary>
		/// If set, this lease will also prevent the pipeline from being deleted while the lease is still valid.
		/// </summary>
		public System.Nullable<System.Boolean> ProtectPipeline { get; set; }
		
		/// <summary>
		/// The pipeline run to protect.
		/// </summary>
		public System.Nullable<System.Int32> RunId { get; set; }
	}
	
	/// <summary>
	/// Contains pipeline general settings.
	/// </summary>
	public class PipelineGeneralSettings
	{
		
		/// <summary>
		/// If enabled, scope of access for all pipelines reduces to the current project.
		/// </summary>
		public System.Nullable<System.Boolean> EnforceJobAuthScope { get; set; }
		
		/// <summary>
		/// If enabled, only those variables that are explicitly marked as "Settable at queue time" can be set at queue time.
		/// </summary>
		public System.Nullable<System.Boolean> EnforceSettableVar { get; set; }
		
		/// <summary>
		/// Allows pipelines to record metadata.
		/// </summary>
		public System.Nullable<System.Boolean> PublishPipelineMetadata { get; set; }
		
		/// <summary>
		/// Anonymous users can access the status badge API for all pipelines unless this option is enabled.
		/// </summary>
		public System.Nullable<System.Boolean> StatusBadgesArePublic { get; set; }
	}
	
	/// <summary>
	/// Contains the settings for the retention rules.
	/// </summary>
	public class ProjectRetentionSetting
	{
		
		/// <summary>
		/// Contains the minimum, maximum, and current value for a retention setting.
		/// </summary>
		public RetentionSetting PurgeArtifacts { get; set; }
		
		/// <summary>
		/// Contains the minimum, maximum, and current value for a retention setting.
		/// </summary>
		public RetentionSetting PurgePullRequestRuns { get; set; }
		
		/// <summary>
		/// Contains the minimum, maximum, and current value for a retention setting.
		/// </summary>
		public RetentionSetting PurgeRuns { get; set; }
		
		/// <summary>
		/// Contains the minimum, maximum, and current value for a retention setting.
		/// </summary>
		public RetentionSetting RetainRunsPerProtectedBranch { get; set; }
	}
	
	/// <summary>
	/// Contains the minimum, maximum, and current value for a retention setting.
	/// </summary>
	public class RetentionSetting
	{
		
		public System.Nullable<System.Int32> Max { get; set; }
		
		public System.Nullable<System.Int32> Min { get; set; }
		
		public System.Nullable<System.Int32> Value { get; set; }
	}
	
	/// <summary>
	/// Represents a pull request trigger.
	/// </summary>
	public class PullRequestTrigger
	{
		
		/// <summary>
		/// Indicates if an update to a PR should delete current in-progress builds.
		/// </summary>
		public System.Nullable<System.Boolean> AutoCancel { get; set; }
		
		public string[] BranchFilters { get; set; }
		
		/// <summary>
		/// Represents the ability to build forks of the selected repository.
		/// </summary>
		public Forks Forks { get; set; }
		
		public System.Nullable<System.Boolean> IsCommentRequiredForPullRequest { get; set; }
		
		public string[] PathFilters { get; set; }
		
		public System.Nullable<System.Boolean> RequireCommentsForNonTeamMembersOnly { get; set; }
		
		public System.Nullable<System.Int32> SettingsSourceType { get; set; }
	}
	
	public class RealtimeBuildEvent
	{
		
		public System.Nullable<System.Int32> BuildId { get; set; }
	}
	
	/// <summary>
	/// Represents a repository's webhook returned from a source provider.
	/// </summary>
	public class RepositoryWebhook
	{
		
		/// <summary>
		/// The friendly name of the repository.
		/// </summary>
		public string Name { get; set; }
		
		public BuildTriggerTriggerType[] Types { get; set; }
		
		/// <summary>
		/// The URL of the repository.
		/// </summary>
		public string Url { get; set; }
	}
	
	public class ResourceRef
	{
		
		public string Id { get; set; }
		
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Represents a reference to a resource.
	/// </summary>
	public class ResourceReference
	{
		
		/// <summary>
		/// An alias to be used when referencing the resource.
		/// </summary>
		public string Alias { get; set; }
	}
	
	/// <summary>
	/// A valid retention lease prevents automated systems from deleting a pipeline run.
	/// </summary>
	public class RetentionLease
	{
		
		/// <summary>
		/// When the lease was created.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedOn { get; set; }
		
		/// <summary>
		/// The pipeline definition of the run.
		/// </summary>
		public System.Nullable<System.Int32> DefinitionId { get; set; }
		
		/// <summary>
		/// The unique identifier for this lease.
		/// </summary>
		public System.Nullable<System.Int32> LeaseId { get; set; }
		
		/// <summary>
		/// Non-unique string that identifies the owner of a retention lease.
		/// </summary>
		public string OwnerId { get; set; }
		
		/// <summary>
		/// The pipeline run protected by this lease.
		/// </summary>
		public System.Nullable<System.Int32> RunId { get; set; }
		
		/// <summary>
		/// The last day the lease is considered valid.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ValidUntil { get; set; }
	}
	
	public class Schedule
	{
		
		public string[] BranchFilters { get; set; }
		
		/// <summary>
		/// Days for a build (flags enum for days of the week)
		/// </summary>
		public System.Nullable<ScheduleDaysToBuild> DaysToBuild { get; set; }
		
		/// <summary>
		/// The Job Id of the Scheduled job that will queue the scheduled build. Since a single trigger can have multiple schedules and we want a single job to process a single schedule (since each schedule has a list of branches to build), the schedule itself needs to define the Job Id. This value will be filled in when a definition is added or updated.  The UI does not provide it or use it.
		/// </summary>
		public string ScheduleJobId { get; set; }
		
		/// <summary>
		/// Flag to determine if this schedule should only build if the associated source has been changed.
		/// </summary>
		public System.Nullable<System.Boolean> ScheduleOnlyWithChanges { get; set; }
		
		/// <summary>
		/// Local timezone hour to start
		/// </summary>
		public System.Nullable<System.Int32> StartHours { get; set; }
		
		/// <summary>
		/// Local timezone minute to start
		/// </summary>
		public System.Nullable<System.Int32> StartMinutes { get; set; }
		
		/// <summary>
		/// Time zone of the build schedule (String representation of the time zone ID)
		/// </summary>
		public string TimeZoneId { get; set; }
	}
	
	public enum ScheduleDaysToBuild
	{
		
		none = 0,
		
		monday = 1,
		
		tuesday = 2,
		
		wednesday = 3,
		
		thursday = 4,
		
		friday = 5,
		
		saturday = 6,
		
		sunday = 7,
		
		all = 8,
	}
	
	/// <summary>
	/// Represents a schedule trigger.
	/// </summary>
	public class ScheduleTrigger
	{
		
		public Schedule[] Schedules { get; set; }
	}
	
	/// <summary>
	/// Represents a phase target that runs on the server.
	/// </summary>
	public class ServerTarget
	{
		
		/// <summary>
		/// Represents options for running a phase on the server.
		/// </summary>
		public ServerTargetExecutionOptions ExecutionOptions { get; set; }
	}
	
	/// <summary>
	/// Represents options for running a phase on the server.
	/// </summary>
	public class ServerTargetExecutionOptions
	{
		
		/// <summary>
		/// The type.
		/// </summary>
		public System.Nullable<System.Int32> Type { get; set; }
	}
	
	public class SourceProviderAttributes
	{
		
		/// <summary>
		/// The name of the source provider.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// The capabilities supported by this source provider.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, bool> SupportedCapabilities { get; set; }
		
		/// <summary>
		/// The types of triggers supported by this source provider.
		/// </summary>
		public SupportedTrigger[] SupportedTriggers { get; set; }
	}
	
	public class SupportedTrigger
	{
		
		/// <summary>
		/// The default interval to wait between polls (only relevant when NotificationType is Polling).
		/// </summary>
		public System.Nullable<System.Int32> DefaultPollingInterval { get; set; }
		
		/// <summary>
		/// How the trigger is notified of changes.
		/// </summary>
		public string NotificationType { get; set; }
		
		/// <summary>
		/// The capabilities supported by this trigger.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, object> SupportedCapabilities { get; set; }
		
		/// <summary>
		/// The type of trigger.
		/// </summary>
		public System.Nullable<SupportedTriggerType> Type { get; set; }
	}
	
	public enum SupportedTriggerType
	{
		
		none = 0,
		
		continuousIntegration = 1,
		
		batchedContinuousIntegration = 2,
		
		schedule = 3,
		
		gatedCheckIn = 4,
		
		batchedGatedCheckIn = 5,
		
		pullRequest = 6,
		
		buildCompletion = 7,
		
		all = 8,
	}
	
	/// <summary>
	/// Represents a work item related to some source item. These are retrieved from Source Providers.
	/// </summary>
	public class SourceRelatedWorkItem
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		public IdentityRef AssignedTo { get; set; }
		
		/// <summary>
		/// Current state of the work item, e.g. Active, Resolved, Closed, etc.
		/// </summary>
		public string CurrentState { get; set; }
		
		/// <summary>
		/// Long description for the work item.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Unique identifier for the work item
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the provider the work item is associated with.
		/// </summary>
		public string ProviderName { get; set; }
		
		/// <summary>
		/// Short name for the work item.
		/// </summary>
		public string Title { get; set; }
		
		/// <summary>
		/// Type of work item, e.g. Bug, Task, User Story, etc.
		/// </summary>
		public string Type { get; set; }
	}
	
	/// <summary>
	/// A set of repositories returned from the source provider.
	/// </summary>
	public class SourceRepositories
	{
		
		/// <summary>
		/// A token used to continue this paged request; 'null' if the request is complete
		/// </summary>
		public string ContinuationToken { get; set; }
		
		/// <summary>
		/// The number of repositories requested for each page
		/// </summary>
		public System.Nullable<System.Int32> PageLength { get; set; }
		
		/// <summary>
		/// A list of repositories
		/// </summary>
		public SourceRepository[] Repositories { get; set; }
		
		/// <summary>
		/// The total number of pages, or '-1' if unknown
		/// </summary>
		public System.Nullable<System.Int32> TotalPageCount { get; set; }
	}
	
	/// <summary>
	/// Represents a repository returned from a source provider.
	/// </summary>
	public class SourceRepository
	{
		
		/// <summary>
		/// The name of the default branch.
		/// </summary>
		public string DefaultBranch { get; set; }
		
		/// <summary>
		/// The full name of the repository.
		/// </summary>
		public string FullName { get; set; }
		
		/// <summary>
		/// The ID of the repository.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// The friendly name of the repository.
		/// </summary>
		public string Name { get; set; }
		
		public System.Collections.Generic.Dictionary<string, string> Properties { get; set; }
		
		/// <summary>
		/// The name of the source provider the repository is from.
		/// </summary>
		public string SourceProviderName { get; set; }
		
		/// <summary>
		/// The URL of the repository.
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Represents an item in a repository from a source provider.
	/// </summary>
	public class SourceRepositoryItem
	{
		
		/// <summary>
		/// Whether the item is able to have sub-items (e.g., is a folder).
		/// </summary>
		public System.Nullable<System.Boolean> IsContainer { get; set; }
		
		/// <summary>
		/// The full path of the item, relative to the root of the repository.
		/// </summary>
		public string Path { get; set; }
		
		/// <summary>
		/// The type of the item (folder, file, etc).
		/// </summary>
		public string Type { get; set; }
		
		/// <summary>
		/// The URL of the item.
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Represents a Subversion mapping entry.
	/// </summary>
	public class SvnMappingDetails
	{
		
		/// <summary>
		/// The depth.
		/// </summary>
		public System.Nullable<System.Int32> Depth { get; set; }
		
		/// <summary>
		/// Indicates whether to ignore externals.
		/// </summary>
		public System.Nullable<System.Boolean> IgnoreExternals { get; set; }
		
		/// <summary>
		/// The local path.
		/// </summary>
		public string LocalPath { get; set; }
		
		/// <summary>
		/// The revision.
		/// </summary>
		public string Revision { get; set; }
		
		/// <summary>
		/// The server path.
		/// </summary>
		public string ServerPath { get; set; }
	}
	
	/// <summary>
	/// Represents a subversion workspace.
	/// </summary>
	public class SvnWorkspace
	{
		
		public SvnMappingDetails[] Mappings { get; set; }
	}
	
	/// <summary>
	/// Represents a reference to a plan group.
	/// </summary>
	public class TaskOrchestrationPlanGroupReference
	{
		
		/// <summary>
		/// The name of the plan group.
		/// </summary>
		public string PlanGroup { get; set; }
		
		/// <summary>
		/// The project ID.
		/// </summary>
		public string ProjectId { get; set; }
	}
	
	public class TaskOrchestrationPlanGroupsStartedEvent
	{
		
		public TaskOrchestrationPlanGroupReference[] PlanGroups { get; set; }
	}
	
	/// <summary>
	/// Represents the timeline of a build.
	/// </summary>
	public class Timeline
	{
		
		/// <summary>
		/// The process or person that last changed the timeline.
		/// </summary>
		public string LastChangedBy { get; set; }
		
		/// <summary>
		/// The time the timeline was last changed.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastChangedOn { get; set; }
		
		public TimelineRecord[] Records { get; set; }
	}
	
	public class TimelineRecordsUpdatedEvent
	{
		
		public TimelineRecord[] TimelineRecords { get; set; }
	}
	
	/// <summary>
	/// Contains members for updating the retention settings values. All fields are optional.
	/// </summary>
	public class UpdateProjectRetentionSettingModel
	{
		
		public UpdateRetentionSettingModel ArtifactsRetention { get; set; }
		
		public UpdateRetentionSettingModel PullRequestRunRetention { get; set; }
		
		public UpdateRetentionSettingModel RetainRunsPerProtectedBranch { get; set; }
		
		public UpdateRetentionSettingModel RunRetention { get; set; }
	}
	
	public class UpdateRetentionSettingModel
	{
		
		public System.Nullable<System.Int32> Value { get; set; }
	}
	
	public class UpdateStageParameters
	{
		
		public System.Nullable<UpdateStageParametersState> State { get; set; }
	}
	
	public enum UpdateStageParametersState
	{
		
		cancel = 0,
		
		retry = 1,
	}
	
	/// <summary>
	/// Represents options for running a phase based on values specified by a list of variables.
	/// </summary>
	public class VariableMultipliersAgentExecutionOptions
	{
		
		/// <summary>
		/// Indicates whether failure on one agent should prevent the phase from running on other agents.
		/// </summary>
		public System.Nullable<System.Boolean> ContinueOnError { get; set; }
		
		/// <summary>
		/// The maximum number of agents to use in parallel.
		/// </summary>
		public System.Nullable<System.Int32> MaxConcurrency { get; set; }
		
		public string[] Multipliers { get; set; }
	}
	
	/// <summary>
	/// Represents options for running a phase based on values specified by a list of variables.
	/// </summary>
	public class VariableMultipliersServerExecutionOptions
	{
		
		/// <summary>
		/// Indicates whether failure of one job should prevent the phase from running in other jobs.
		/// </summary>
		public System.Nullable<System.Boolean> ContinueOnError { get; set; }
		
		/// <summary>
		/// The maximum number of server jobs to run in parallel.
		/// </summary>
		public System.Nullable<System.Int32> MaxConcurrency { get; set; }
		
		public string[] Multipliers { get; set; }
	}
	
	/// <summary>
	/// This class is used to serialized collections as a single JSON object on the wire, to avoid serializing JSON arrays directly to the client, which can be a security hole
	/// </summary>
	public class VssJsonCollectionWrapper
	{
		
		public string Value { get; set; }
	}
	
	public class VssJsonCollectionWrapperBase
	{
		
		public System.Nullable<System.Int32> Count { get; set; }
	}
	
	/// <summary>
	/// Mapping for a workspace
	/// </summary>
	public class WorkspaceMapping
	{
		
		/// <summary>
		/// Uri of the associated definition
		/// </summary>
		public string DefinitionUri { get; set; }
		
		/// <summary>
		/// Depth of this mapping
		/// </summary>
		public System.Nullable<System.Int32> Depth { get; set; }
		
		/// <summary>
		/// local location of the definition
		/// </summary>
		public string LocalItem { get; set; }
		
		/// <summary>
		/// type of workspace mapping
		/// </summary>
		public System.Nullable<WorkspaceMappingMappingType> MappingType { get; set; }
		
		/// <summary>
		/// Server location of the definition
		/// </summary>
		public string ServerItem { get; set; }
		
		/// <summary>
		/// Id of the workspace
		/// </summary>
		public System.Nullable<System.Int32> WorkspaceId { get; set; }
	}
	
	public enum WorkspaceMappingMappingType
	{
		
		map = 0,
		
		cloak = 1,
	}
	
	public class WorkspaceTemplate
	{
		
		/// <summary>
		/// Uri of the associated definition
		/// </summary>
		public string DefinitionUri { get; set; }
		
		/// <summary>
		/// The identity that last modified this template
		/// </summary>
		public string LastModifiedBy { get; set; }
		
		/// <summary>
		/// The last time this template was modified
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastModifiedDate { get; set; }
		
		/// <summary>
		/// List of workspace mappings
		/// </summary>
		public WorkspaceMapping[] Mappings { get; set; }
		
		/// <summary>
		/// Id of the workspace for this template
		/// </summary>
		public System.Nullable<System.Int32> WorkspaceId { get; set; }
	}
	
	public class XamlBuildDefinition
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// Batch size of the definition
		/// </summary>
		public System.Nullable<System.Int32> BatchSize { get; set; }
		
		public string BuildArgs { get; set; }
		
		/// <summary>
		/// The continuous integration quiet period
		/// </summary>
		public System.Nullable<System.Int32> ContinuousIntegrationQuietPeriod { get; set; }
		
		public BuildController Controller { get; set; }
		
		/// <summary>
		/// The date this definition was created
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedOn { get; set; }
		
		/// <summary>
		/// Default drop location for builds from this definition
		/// </summary>
		public string DefaultDropLocation { get; set; }
		
		/// <summary>
		/// Description of the definition
		/// </summary>
		public string Description { get; set; }
		
		public XamlBuildReference LastBuild { get; set; }
		
		/// <summary>
		/// Represents a repository used by a build definition.
		/// </summary>
		public BuildRepository Repository { get; set; }
		
		/// <summary>
		/// The reasons supported by the template
		/// </summary>
		public System.Nullable<XamlBuildDefinitionSupportedReasons> SupportedReasons { get; set; }
		
		/// <summary>
		/// How builds are triggered from this definition
		/// </summary>
		public System.Nullable<XamlBuildDefinitionTriggerType> TriggerType { get; set; }
	}
	
	public enum XamlBuildDefinitionSupportedReasons
	{
		
		none = 0,
		
		manual = 1,
		
		individualCI = 2,
		
		batchedCI = 3,
		
		schedule = 4,
		
		scheduleForced = 5,
		
		userCreated = 6,
		
		validateShelveset = 7,
		
		checkInShelveset = 8,
		
		pullRequest = 9,
		
		buildCompletion = 10,
		
		resourceTrigger = 11,
		
		triggered = 12,
		
		all = 13,
	}
	
	public enum XamlBuildDefinitionTriggerType
	{
		
		none = 0,
		
		continuousIntegration = 1,
		
		batchedContinuousIntegration = 2,
		
		schedule = 3,
		
		gatedCheckIn = 4,
		
		batchedGatedCheckIn = 5,
		
		pullRequest = 6,
		
		buildCompletion = 7,
		
		all = 8,
	}
	
	/// <summary>
	/// Represents a YAML process.
	/// </summary>
	public class YamlProcess
	{
		
		public string[] Errors { get; set; }
		
		/// <summary>
		/// Represents resources used by a build process.
		/// </summary>
		public BuildProcessResources Resources { get; set; }
		
		/// <summary>
		/// The YAML filename.
		/// </summary>
		public string YamlFilename { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient client;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient client, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (client == null)
				throw new ArgumentNullException("Null HttpClient.", "client");

			if (client.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "client");

			this.client = client;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Gets controller, optionally filtered by name
		/// Controllers_List {organization}/_apis/build/controllers
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildController[]> Controllers_ListAsync(string organization, string name, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/build/controllers&name=" + (name==null? "" : Uri.EscapeDataString(name))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildController[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets controller, optionally filtered by name
		/// Controllers_List {organization}/_apis/build/controllers
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public BuildController[] Controllers_List(string organization, string name, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/build/controllers&name=" + (name==null? "" : Uri.EscapeDataString(name))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildController[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a controller
		/// Controllers_Get {organization}/_apis/build/controllers/{controllerId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildController> Controllers_GetAsync(string organization, int controllerId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/build/controllers/"+controllerId+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildController>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a controller
		/// Controllers_Get {organization}/_apis/build/controllers/{controllerId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public BuildController Controllers_Get(string organization, int controllerId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/build/controllers/"+controllerId+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildController>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information about build resources in the system.
		/// Resource_Usage_Get {organization}/_apis/build/resourceusage
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildResourceUsage> Resource_Usage_GetAsync(string organization, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/build/resourceusage&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildResourceUsage>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information about build resources in the system.
		/// Resource_Usage_Get {organization}/_apis/build/resourceusage
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public BuildResourceUsage Resource_Usage_Get(string organization, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/build/resourceusage&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildResourceUsage>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// This endpoint is deprecated. Please see the Build Status REST endpoint.
		/// Badge_Get {organization}/_apis/public/build/definitions/{project}/{definitionId}/badge
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">The project ID or name.</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="branchName">The name of the branch.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<string> Badge_GetAsync(string organization, string project, int definitionId, string branchName, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/public/build/definitions/"+ (project==null? "" : Uri.EscapeDataString(project))+"/"+definitionId+"/badge&branchName=" + (branchName==null? "" : Uri.EscapeDataString(branchName))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// This endpoint is deprecated. Please see the Build Status REST endpoint.
		/// Badge_Get {organization}/_apis/public/build/definitions/{project}/{definitionId}/badge
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">The project ID or name.</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="branchName">The name of the branch.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public string Badge_Get(string organization, string project, int definitionId, string branchName, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/public/build/definitions/"+ (project==null? "" : Uri.EscapeDataString(project))+"/"+definitionId+"/badge&branchName=" + (branchName==null? "" : Uri.EscapeDataString(branchName))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Authorizedresources_Authorize_Project_Resources {organization}/{project}/_apis/build/authorizedresources
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<DefinitionResourceReference[]> Authorizedresources_Authorize_Project_ResourcesAsync(string organization, string project, string api_version, DefinitionResourceReference[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/authorizedresources&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DefinitionResourceReference[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Authorizedresources_Authorize_Project_Resources {organization}/{project}/_apis/build/authorizedresources
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public DefinitionResourceReference[] Authorizedresources_Authorize_Project_Resources(string organization, string project, string api_version, DefinitionResourceReference[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/authorizedresources&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DefinitionResourceReference[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Authorizedresources_List {organization}/{project}/_apis/build/authorizedresources
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<DefinitionResourceReference[]> Authorizedresources_ListAsync(string organization, string project, string type, string id, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/authorizedresources&type=" + (type==null? "" : Uri.EscapeDataString(type))+"&id=" + (id==null? "" : Uri.EscapeDataString(id))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DefinitionResourceReference[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Authorizedresources_List {organization}/{project}/_apis/build/authorizedresources
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public DefinitionResourceReference[] Authorizedresources_List(string organization, string project, string type, string id, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/authorizedresources&type=" + (type==null? "" : Uri.EscapeDataString(type))+"&id=" + (id==null? "" : Uri.EscapeDataString(id))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DefinitionResourceReference[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of builds.
		/// Builds_List {organization}/{project}/_apis/build/builds
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitions">A comma-delimited list of definition IDs. If specified, filters to builds for these definitions.</param>
		/// <param name="queues">A comma-delimited list of queue IDs. If specified, filters to builds that ran against these queues.</param>
		/// <param name="buildNumber">If specified, filters to builds that match this build number. Append * to do a prefix search.</param>
		/// <param name="minTime">If specified, filters to builds that finished/started/queued after this date based on the queryOrder specified.</param>
		/// <param name="maxTime">If specified, filters to builds that finished/started/queued before this date based on the queryOrder specified.</param>
		/// <param name="requestedFor">If specified, filters to builds requested for the specified user.</param>
		/// <param name="reasonFilter">If specified, filters to builds that match this reason.</param>
		/// <param name="statusFilter">If specified, filters to builds that match this status.</param>
		/// <param name="resultFilter">If specified, filters to builds that match this result.</param>
		/// <param name="tagFilters">A comma-delimited list of tags. If specified, filters to builds that have the specified tags.</param>
		/// <param name="properties">A comma-delimited list of properties to retrieve.</param>
		/// <param name="top">The maximum number of builds to return.</param>
		/// <param name="continuationToken">A continuation token, returned by a previous call to this method, that can be used to return the next set of builds.</param>
		/// <param name="maxBuildsPerDefinition">The maximum number of builds to return per definition.</param>
		/// <param name="deletedFilter">Indicates whether to exclude, include, or only return deleted builds.</param>
		/// <param name="queryOrder">The order in which builds should be returned.</param>
		/// <param name="branchName">If specified, filters to builds that built branches that built this branch.</param>
		/// <param name="buildIds">A comma-delimited list that specifies the IDs of builds to retrieve.</param>
		/// <param name="repositoryId">If specified, filters to builds that built from this repository.</param>
		/// <param name="repositoryType">If specified, filters to builds that built from repositories of this type.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.5' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<Build[]> Builds_ListAsync(
					string organization, 
					string project, 
					string definitions, 
					string queues, 
					string buildNumber, 
					System.DateTimeOffset minTime, 
					System.DateTimeOffset maxTime, 
					string requestedFor, 
					BuildReason reasonFilter, 
					BuildReferenceStatus statusFilter, 
					BuildReferenceResult resultFilter, 
					string tagFilters, 
					string properties, 
					int top, 
					string continuationToken, 
					int maxBuildsPerDefinition, 
					Builds_ListDeletedFilter deletedFilter, 
					Builds_ListQueryOrder queryOrder, 
					string branchName, 
					string buildIds, 
					string repositoryId, 
					string repositoryType, 
					string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds&definitions=" + (definitions==null? "" : Uri.EscapeDataString(definitions))+"&queues=" + (queues==null? "" : Uri.EscapeDataString(queues))+"&buildNumber=" + (buildNumber==null? "" : Uri.EscapeDataString(buildNumber))+"&minTime=" + minTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&maxTime=" + maxTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&requestedFor=" + (requestedFor==null? "" : Uri.EscapeDataString(requestedFor))+"&reasonFilter=" + reasonFilter+"&statusFilter=" + statusFilter+"&resultFilter=" + resultFilter+"&tagFilters=" + (tagFilters==null? "" : Uri.EscapeDataString(tagFilters))+"&properties=" + (properties==null? "" : Uri.EscapeDataString(properties))+"&$top="+top+"&continuationToken=" + (continuationToken==null? "" : Uri.EscapeDataString(continuationToken))+"&maxBuildsPerDefinition="+maxBuildsPerDefinition+"&deletedFilter=" + deletedFilter+"&queryOrder=" + queryOrder+"&branchName=" + (branchName==null? "" : Uri.EscapeDataString(branchName))+"&buildIds=" + (buildIds==null? "" : Uri.EscapeDataString(buildIds))+"&repositoryId=" + (repositoryId==null? "" : Uri.EscapeDataString(repositoryId))+"&repositoryType=" + (repositoryType==null? "" : Uri.EscapeDataString(repositoryType))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Build[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of builds.
		/// Builds_List {organization}/{project}/_apis/build/builds
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitions">A comma-delimited list of definition IDs. If specified, filters to builds for these definitions.</param>
		/// <param name="queues">A comma-delimited list of queue IDs. If specified, filters to builds that ran against these queues.</param>
		/// <param name="buildNumber">If specified, filters to builds that match this build number. Append * to do a prefix search.</param>
		/// <param name="minTime">If specified, filters to builds that finished/started/queued after this date based on the queryOrder specified.</param>
		/// <param name="maxTime">If specified, filters to builds that finished/started/queued before this date based on the queryOrder specified.</param>
		/// <param name="requestedFor">If specified, filters to builds requested for the specified user.</param>
		/// <param name="reasonFilter">If specified, filters to builds that match this reason.</param>
		/// <param name="statusFilter">If specified, filters to builds that match this status.</param>
		/// <param name="resultFilter">If specified, filters to builds that match this result.</param>
		/// <param name="tagFilters">A comma-delimited list of tags. If specified, filters to builds that have the specified tags.</param>
		/// <param name="properties">A comma-delimited list of properties to retrieve.</param>
		/// <param name="top">The maximum number of builds to return.</param>
		/// <param name="continuationToken">A continuation token, returned by a previous call to this method, that can be used to return the next set of builds.</param>
		/// <param name="maxBuildsPerDefinition">The maximum number of builds to return per definition.</param>
		/// <param name="deletedFilter">Indicates whether to exclude, include, or only return deleted builds.</param>
		/// <param name="queryOrder">The order in which builds should be returned.</param>
		/// <param name="branchName">If specified, filters to builds that built branches that built this branch.</param>
		/// <param name="buildIds">A comma-delimited list that specifies the IDs of builds to retrieve.</param>
		/// <param name="repositoryId">If specified, filters to builds that built from this repository.</param>
		/// <param name="repositoryType">If specified, filters to builds that built from repositories of this type.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.5' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public Build[] Builds_List(
					string organization, 
					string project, 
					string definitions, 
					string queues, 
					string buildNumber, 
					System.DateTimeOffset minTime, 
					System.DateTimeOffset maxTime, 
					string requestedFor, 
					BuildReason reasonFilter, 
					BuildReferenceStatus statusFilter, 
					BuildReferenceResult resultFilter, 
					string tagFilters, 
					string properties, 
					int top, 
					string continuationToken, 
					int maxBuildsPerDefinition, 
					Builds_ListDeletedFilter deletedFilter, 
					Builds_ListQueryOrder queryOrder, 
					string branchName, 
					string buildIds, 
					string repositoryId, 
					string repositoryType, 
					string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds&definitions=" + (definitions==null? "" : Uri.EscapeDataString(definitions))+"&queues=" + (queues==null? "" : Uri.EscapeDataString(queues))+"&buildNumber=" + (buildNumber==null? "" : Uri.EscapeDataString(buildNumber))+"&minTime=" + minTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&maxTime=" + maxTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&requestedFor=" + (requestedFor==null? "" : Uri.EscapeDataString(requestedFor))+"&reasonFilter=" + reasonFilter+"&statusFilter=" + statusFilter+"&resultFilter=" + resultFilter+"&tagFilters=" + (tagFilters==null? "" : Uri.EscapeDataString(tagFilters))+"&properties=" + (properties==null? "" : Uri.EscapeDataString(properties))+"&$top="+top+"&continuationToken=" + (continuationToken==null? "" : Uri.EscapeDataString(continuationToken))+"&maxBuildsPerDefinition="+maxBuildsPerDefinition+"&deletedFilter=" + deletedFilter+"&queryOrder=" + queryOrder+"&branchName=" + (branchName==null? "" : Uri.EscapeDataString(branchName))+"&buildIds=" + (buildIds==null? "" : Uri.EscapeDataString(buildIds))+"&repositoryId=" + (repositoryId==null? "" : Uri.EscapeDataString(repositoryId))+"&repositoryType=" + (repositoryType==null? "" : Uri.EscapeDataString(repositoryType))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Build[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Queues a build
		/// Builds_Queue {organization}/{project}/_apis/build/builds
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.5' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<Build> Builds_QueueAsync(string organization, string project, bool ignoreWarnings, string checkInTicket, int sourceBuildId, string api_version, Build requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds&ignoreWarnings="+ignoreWarnings+"&checkInTicket=" + (checkInTicket==null? "" : Uri.EscapeDataString(checkInTicket))+"&sourceBuildId="+sourceBuildId+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Build>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Queues a build
		/// Builds_Queue {organization}/{project}/_apis/build/builds
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.5' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public Build Builds_Queue(string organization, string project, bool ignoreWarnings, string checkInTicket, int sourceBuildId, string api_version, Build requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds&ignoreWarnings="+ignoreWarnings+"&checkInTicket=" + (checkInTicket==null? "" : Uri.EscapeDataString(checkInTicket))+"&sourceBuildId="+sourceBuildId+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Build>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates multiple builds.
		/// Builds_Update_Builds {organization}/{project}/_apis/build/builds
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.5' to use this version of the api.</param>
		/// <param name="requestBody">The builds to update.</param>
		/// <returns>successful operation</returns>
		public async Task<Build[]> Builds_Update_BuildsAsync(string organization, string project, string api_version, Build[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Build[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates multiple builds.
		/// Builds_Update_Builds {organization}/{project}/_apis/build/builds
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.5' to use this version of the api.</param>
		/// <param name="requestBody">The builds to update.</param>
		/// <returns>successful operation</returns>
		public Build[] Builds_Update_Builds(string organization, string project, string api_version, Build[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Build[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a build.
		/// Builds_Delete {organization}/{project}/_apis/build/builds/{buildId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.5' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Builds_DeleteAsync(string organization, string project, int buildId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a build.
		/// Builds_Delete {organization}/{project}/_apis/build/builds/{buildId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.5' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Builds_Delete(string organization, string project, int buildId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a build
		/// Builds_Get {organization}/{project}/_apis/build/builds/{buildId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.5' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<Build> Builds_GetAsync(string organization, string project, int buildId, string propertyFilters, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"&propertyFilters=" + (propertyFilters==null? "" : Uri.EscapeDataString(propertyFilters))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Build>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a build
		/// Builds_Get {organization}/{project}/_apis/build/builds/{buildId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.5' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public Build Builds_Get(string organization, string project, int buildId, string propertyFilters, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"&propertyFilters=" + (propertyFilters==null? "" : Uri.EscapeDataString(propertyFilters))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Build>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a build.
		/// Builds_Update_Build {organization}/{project}/_apis/build/builds/{buildId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.5' to use this version of the api.</param>
		/// <param name="requestBody">The build.</param>
		/// <returns>successful operation</returns>
		public async Task<Build> Builds_Update_BuildAsync(string organization, string project, int buildId, bool retry, string api_version, Build requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"&retry="+retry+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Build>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates a build.
		/// Builds_Update_Build {organization}/{project}/_apis/build/builds/{buildId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.5' to use this version of the api.</param>
		/// <param name="requestBody">The build.</param>
		/// <returns>successful operation</returns>
		public Build Builds_Update_Build(string organization, string project, int buildId, bool retry, string api_version, Build requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"&retry="+retry+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Build>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets a specific attachment.
		/// Attachments_Get {organization}/{project}/_apis/build/builds/{buildId}/{timelineId}/{recordId}/attachments/{type}/{name}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="timelineId">The ID of the timeline.</param>
		/// <param name="recordId">The ID of the timeline record.</param>
		/// <param name="type">The type of the attachment.</param>
		/// <param name="name">The name of the attachment.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Attachments_GetAsync(string organization, string project, int buildId, string timelineId, string recordId, string type, string name, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/"+ (timelineId==null? "" : Uri.EscapeDataString(timelineId))+"/"+ (recordId==null? "" : Uri.EscapeDataString(recordId))+"/attachments/"+ (type==null? "" : Uri.EscapeDataString(type))+"/"+ (name==null? "" : Uri.EscapeDataString(name))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a specific attachment.
		/// Attachments_Get {organization}/{project}/_apis/build/builds/{buildId}/{timelineId}/{recordId}/attachments/{type}/{name}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="timelineId">The ID of the timeline.</param>
		/// <param name="recordId">The ID of the timeline record.</param>
		/// <param name="type">The type of the attachment.</param>
		/// <param name="name">The name of the attachment.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Attachments_Get(string organization, string project, int buildId, string timelineId, string recordId, string type, string name, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/"+ (timelineId==null? "" : Uri.EscapeDataString(timelineId))+"/"+ (recordId==null? "" : Uri.EscapeDataString(recordId))+"/attachments/"+ (type==null? "" : Uri.EscapeDataString(type))+"/"+ (name==null? "" : Uri.EscapeDataString(name))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Associates an artifact with a build.
		/// Artifacts_Create {organization}/{project}/_apis/build/builds/{buildId}/artifacts
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.5' to use this version of the api.</param>
		/// <param name="requestBody">The artifact.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildArtifact> Artifacts_CreateAsync(string organization, string project, int buildId, string api_version, BuildArtifact requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/artifacts&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildArtifact>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Associates an artifact with a build.
		/// Artifacts_Create {organization}/{project}/_apis/build/builds/{buildId}/artifacts
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.5' to use this version of the api.</param>
		/// <param name="requestBody">The artifact.</param>
		/// <returns>successful operation</returns>
		public BuildArtifact Artifacts_Create(string organization, string project, int buildId, string api_version, BuildArtifact requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/artifacts&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildArtifact>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets all artifacts for a build.
		/// Artifacts_List {organization}/{project}/_apis/build/builds/{buildId}/artifacts
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.5' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildArtifact[]> Artifacts_ListAsync(string organization, string project, int buildId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/artifacts&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildArtifact[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all artifacts for a build.
		/// Artifacts_List {organization}/{project}/_apis/build/builds/{buildId}/artifacts
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.5' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public BuildArtifact[] Artifacts_List(string organization, string project, int buildId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/artifacts&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildArtifact[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the list of attachments of a specific type that are associated with a build.
		/// Attachments_List {organization}/{project}/_apis/build/builds/{buildId}/attachments/{type}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="type">The type of attachment.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<Attachment[]> Attachments_ListAsync(string organization, string project, int buildId, string type, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/attachments/"+ (type==null? "" : Uri.EscapeDataString(type))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Attachment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the list of attachments of a specific type that are associated with a build.
		/// Attachments_List {organization}/{project}/_apis/build/builds/{buildId}/attachments/{type}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="type">The type of attachment.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public Attachment[] Attachments_List(string organization, string project, int buildId, string type, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/attachments/"+ (type==null? "" : Uri.EscapeDataString(type))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Attachment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the changes associated with a build
		/// Builds_Get_Build_Changes {organization}/{project}/_apis/build/builds/{buildId}/changes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="top">The maximum number of changes to return</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<Change[]> Builds_Get_Build_ChangesAsync(string organization, string project, int buildId, string continuationToken, int top, bool includeSourceChange, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/changes&continuationToken=" + (continuationToken==null? "" : Uri.EscapeDataString(continuationToken))+"&$top="+top+"&includeSourceChange="+includeSourceChange+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Change[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the changes associated with a build
		/// Builds_Get_Build_Changes {organization}/{project}/_apis/build/builds/{buildId}/changes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="top">The maximum number of changes to return</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public Change[] Builds_Get_Build_Changes(string organization, string project, int buildId, string continuationToken, int top, bool includeSourceChange, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/changes&continuationToken=" + (continuationToken==null? "" : Uri.EscapeDataString(continuationToken))+"&$top="+top+"&includeSourceChange="+includeSourceChange+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Change[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the logs for a build.
		/// Builds_Get_Build_Logs {organization}/{project}/_apis/build/builds/{buildId}/logs
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildLog[]> Builds_Get_Build_LogsAsync(string organization, string project, int buildId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/logs&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildLog[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the logs for a build.
		/// Builds_Get_Build_Logs {organization}/{project}/_apis/build/builds/{buildId}/logs
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public BuildLog[] Builds_Get_Build_Logs(string organization, string project, int buildId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/logs&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildLog[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets an individual log file for a build.
		/// Builds_Get_Build_Log {organization}/{project}/_apis/build/builds/{buildId}/logs/{logId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="logId">The ID of the log file.</param>
		/// <param name="startLine">The start line.</param>
		/// <param name="endLine">The end line.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<string> Builds_Get_Build_LogAsync(string organization, string project, int buildId, int logId, long startLine, long endLine, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/logs/"+logId+"&startLine="+startLine+"&endLine="+endLine+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets an individual log file for a build.
		/// Builds_Get_Build_Log {organization}/{project}/_apis/build/builds/{buildId}/logs/{logId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="logId">The ID of the log file.</param>
		/// <param name="startLine">The start line.</param>
		/// <param name="endLine">The end line.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public string Builds_Get_Build_Log(string organization, string project, int buildId, int logId, long startLine, long endLine, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/logs/"+logId+"&startLine="+startLine+"&endLine="+endLine+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets properties for a build.
		/// Properties_Get_Build_Properties {organization}/{project}/_apis/build/builds/{buildId}/properties
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="filter">A comma-delimited list of properties. If specified, filters to these specific properties.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<PropertiesCollection> Properties_Get_Build_PropertiesAsync(string organization, string project, int buildId, string filter, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/properties&filter=" + (filter==null? "" : Uri.EscapeDataString(filter))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PropertiesCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets properties for a build.
		/// Properties_Get_Build_Properties {organization}/{project}/_apis/build/builds/{buildId}/properties
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="filter">A comma-delimited list of properties. If specified, filters to these specific properties.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public PropertiesCollection Properties_Get_Build_Properties(string organization, string project, int buildId, string filter, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/properties&filter=" + (filter==null? "" : Uri.EscapeDataString(filter))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PropertiesCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a build report.
		/// Report_Get {organization}/{project}/_apis/build/builds/{buildId}/report
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildReportMetadata> Report_GetAsync(string organization, string project, int buildId, string type, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/report&type=" + (type==null? "" : Uri.EscapeDataString(type))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildReportMetadata>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a build report.
		/// Report_Get {organization}/{project}/_apis/build/builds/{buildId}/report
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public BuildReportMetadata Report_Get(string organization, string project, int buildId, string type, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/report&type=" + (type==null? "" : Uri.EscapeDataString(type))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildReportMetadata>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a build stage
		/// Stages_Update {organization}/{project}/_apis/build/builds/{buildId}/stages/{stageRefName}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Stages_UpdateAsync(string organization, int buildId, string stageRefName, string project, string api_version, UpdateStageParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/stages/"+ (stageRefName==null? "" : Uri.EscapeDataString(stageRefName))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update a build stage
		/// Stages_Update {organization}/{project}/_apis/build/builds/{buildId}/stages/{stageRefName}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Stages_Update(string organization, int buildId, string stageRefName, string project, string api_version, UpdateStageParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/stages/"+ (stageRefName==null? "" : Uri.EscapeDataString(stageRefName))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds tags to a build.
		/// Tags_Add_Build_Tags {organization}/{project}/_apis/build/builds/{buildId}/tags
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <param name="requestBody">The tags to add.</param>
		/// <returns>successful operation</returns>
		public async Task<string[]> Tags_Add_Build_TagsAsync(string organization, string project, int buildId, string api_version, string[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/tags&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds tags to a build.
		/// Tags_Add_Build_Tags {organization}/{project}/_apis/build/builds/{buildId}/tags
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <param name="requestBody">The tags to add.</param>
		/// <returns>successful operation</returns>
		public string[] Tags_Add_Build_Tags(string organization, string project, int buildId, string api_version, string[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/tags&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the tags for a build.
		/// Tags_Get_Build_Tags {organization}/{project}/_apis/build/builds/{buildId}/tags
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<string[]> Tags_Get_Build_TagsAsync(string organization, string project, int buildId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/tags&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the tags for a build.
		/// Tags_Get_Build_Tags {organization}/{project}/_apis/build/builds/{buildId}/tags
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public string[] Tags_Get_Build_Tags(string organization, string project, int buildId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/tags&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a tag to a build.
		/// Tags_Add_Build_Tag {organization}/{project}/_apis/build/builds/{buildId}/tags/{tag}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="tag">The tag to add.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<string[]> Tags_Add_Build_TagAsync(string organization, string project, int buildId, string tag, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/tags/"+ (tag==null? "" : Uri.EscapeDataString(tag))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a tag to a build.
		/// Tags_Add_Build_Tag {organization}/{project}/_apis/build/builds/{buildId}/tags/{tag}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="tag">The tag to add.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public string[] Tags_Add_Build_Tag(string organization, string project, int buildId, string tag, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/tags/"+ (tag==null? "" : Uri.EscapeDataString(tag))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes a tag from a build.
		/// Tags_Delete_Build_Tag {organization}/{project}/_apis/build/builds/{buildId}/tags/{tag}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="tag">The tag to remove.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<string[]> Tags_Delete_Build_TagAsync(string organization, string project, int buildId, string tag, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/tags/"+ (tag==null? "" : Uri.EscapeDataString(tag))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes a tag from a build.
		/// Tags_Delete_Build_Tag {organization}/{project}/_apis/build/builds/{buildId}/tags/{tag}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="tag">The tag to remove.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public string[] Tags_Delete_Build_Tag(string organization, string project, int buildId, string tag, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/tags/"+ (tag==null? "" : Uri.EscapeDataString(tag))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets details for a build
		/// Timeline_Get {organization}/{project}/_apis/build/builds/{buildId}/timeline/{timelineId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<Timeline> Timeline_GetAsync(string organization, string project, int buildId, string timelineId, int changeId, string planId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/timeline/"+ (timelineId==null? "" : Uri.EscapeDataString(timelineId))+"&changeId="+changeId+"&planId=" + (planId==null? "" : Uri.EscapeDataString(planId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Timeline>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets details for a build
		/// Timeline_Get {organization}/{project}/_apis/build/builds/{buildId}/timeline/{timelineId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public Timeline Timeline_Get(string organization, string project, int buildId, string timelineId, int changeId, string planId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/timeline/"+ (timelineId==null? "" : Uri.EscapeDataString(timelineId))+"&changeId="+changeId+"&planId=" + (planId==null? "" : Uri.EscapeDataString(planId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Timeline>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the work items associated with a build.
		/// Builds_Get_Build_Work_Items_Refs {organization}/{project}/_apis/build/builds/{buildId}/workitems
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="top">The maximum number of work items to return.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<ResourceRef[]> Builds_Get_Build_Work_Items_RefsAsync(string organization, string project, int buildId, int top, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/workitems&$top="+top+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ResourceRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the work items associated with a build.
		/// Builds_Get_Build_Work_Items_Refs {organization}/{project}/_apis/build/builds/{buildId}/workitems
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="top">The maximum number of work items to return.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public ResourceRef[] Builds_Get_Build_Work_Items_Refs(string organization, string project, int buildId, int top, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/workitems&$top="+top+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ResourceRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the work items associated with a build, filtered to specific commits.
		/// Builds_Get_Build_Work_Items_Refs_From_Commits {organization}/{project}/_apis/build/builds/{buildId}/workitems
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="top">The maximum number of work items to return, or the number of commits to consider if no commit IDs are specified.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <param name="requestBody">A comma-delimited list of commit IDs.</param>
		/// <returns>successful operation</returns>
		public async Task<ResourceRef[]> Builds_Get_Build_Work_Items_Refs_From_CommitsAsync(string organization, string project, int buildId, int top, string api_version, string[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/workitems&$top="+top+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ResourceRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the work items associated with a build, filtered to specific commits.
		/// Builds_Get_Build_Work_Items_Refs_From_Commits {organization}/{project}/_apis/build/builds/{buildId}/workitems
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="buildId">The ID of the build.</param>
		/// <param name="top">The maximum number of work items to return, or the number of commits to consider if no commit IDs are specified.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <param name="requestBody">A comma-delimited list of commit IDs.</param>
		/// <returns>successful operation</returns>
		public ResourceRef[] Builds_Get_Build_Work_Items_Refs_From_Commits(string organization, string project, int buildId, int top, string api_version, string[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/builds/"+buildId+"/workitems&$top="+top+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ResourceRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the changes made to the repository between two given builds.
		/// Builds_Get_Changes_Between_Builds {organization}/{project}/_apis/build/changes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="fromBuildId">The ID of the first build.</param>
		/// <param name="toBuildId">The ID of the last build.</param>
		/// <param name="top">The maximum number of changes to return.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<Change[]> Builds_Get_Changes_Between_BuildsAsync(string organization, string project, int fromBuildId, int toBuildId, int top, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/changes&fromBuildId="+fromBuildId+"&toBuildId="+toBuildId+"&$top="+top+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Change[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the changes made to the repository between two given builds.
		/// Builds_Get_Changes_Between_Builds {organization}/{project}/_apis/build/changes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="fromBuildId">The ID of the first build.</param>
		/// <param name="toBuildId">The ID of the last build.</param>
		/// <param name="top">The maximum number of changes to return.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public Change[] Builds_Get_Changes_Between_Builds(string organization, string project, int fromBuildId, int toBuildId, int top, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/changes&fromBuildId="+fromBuildId+"&toBuildId="+toBuildId+"&$top="+top+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Change[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new definition.
		/// Definitions_Create {organization}/{project}/_apis/build/definitions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.7' to use this version of the api.</param>
		/// <param name="requestBody">The definition.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildDefinition> Definitions_CreateAsync(string organization, string project, int definitionToCloneId, int definitionToCloneRevision, string api_version, BuildDefinition requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions&definitionToCloneId="+definitionToCloneId+"&definitionToCloneRevision="+definitionToCloneRevision+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildDefinition>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a new definition.
		/// Definitions_Create {organization}/{project}/_apis/build/definitions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.7' to use this version of the api.</param>
		/// <param name="requestBody">The definition.</param>
		/// <returns>successful operation</returns>
		public BuildDefinition Definitions_Create(string organization, string project, int definitionToCloneId, int definitionToCloneRevision, string api_version, BuildDefinition requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions&definitionToCloneId="+definitionToCloneId+"&definitionToCloneRevision="+definitionToCloneRevision+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildDefinition>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets a list of definitions.
		/// Definitions_List {organization}/{project}/_apis/build/definitions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="name">If specified, filters to definitions whose names match this pattern.</param>
		/// <param name="repositoryId">A repository ID. If specified, filters to definitions that use this repository.</param>
		/// <param name="repositoryType">If specified, filters to definitions that have a repository of this type.</param>
		/// <param name="queryOrder">Indicates the order in which definitions should be returned.</param>
		/// <param name="top">The maximum number of definitions to return.</param>
		/// <param name="continuationToken">A continuation token, returned by a previous call to this method, that can be used to return the next set of definitions.</param>
		/// <param name="minMetricsTime">If specified, indicates the date from which metrics should be included.</param>
		/// <param name="definitionIds">A comma-delimited list that specifies the IDs of definitions to retrieve.</param>
		/// <param name="path">If specified, filters to definitions under this folder.</param>
		/// <param name="builtAfter">If specified, filters to definitions that have builds after this date.</param>
		/// <param name="notBuiltAfter">If specified, filters to definitions that do not have builds after this date.</param>
		/// <param name="includeAllProperties">Indicates whether the full definitions should be returned. By default, shallow representations of the definitions are returned.</param>
		/// <param name="includeLatestBuilds">Indicates whether to return the latest and latest completed builds for this definition.</param>
		/// <param name="taskIdFilter">If specified, filters to definitions that use the specified task.</param>
		/// <param name="processType">If specified, filters to definitions with the given process type.</param>
		/// <param name="yamlFilename">If specified, filters to YAML definitions that match the given filename.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.7' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildDefinitionReference[]> Definitions_ListAsync(
					string organization, 
					string project, 
					string name, 
					string repositoryId, 
					string repositoryType, 
					Definitions_ListQueryOrder queryOrder, 
					int top, 
					string continuationToken, 
					System.DateTimeOffset minMetricsTime, 
					string definitionIds, 
					string path, 
					System.DateTimeOffset builtAfter, 
					System.DateTimeOffset notBuiltAfter, 
					bool includeAllProperties, 
					bool includeLatestBuilds, 
					string taskIdFilter, 
					int processType, 
					string yamlFilename, 
					string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions&name=" + (name==null? "" : Uri.EscapeDataString(name))+"&repositoryId=" + (repositoryId==null? "" : Uri.EscapeDataString(repositoryId))+"&repositoryType=" + (repositoryType==null? "" : Uri.EscapeDataString(repositoryType))+"&queryOrder=" + queryOrder+"&$top="+top+"&continuationToken=" + (continuationToken==null? "" : Uri.EscapeDataString(continuationToken))+"&minMetricsTime=" + minMetricsTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&definitionIds=" + (definitionIds==null? "" : Uri.EscapeDataString(definitionIds))+"&path=" + (path==null? "" : Uri.EscapeDataString(path))+"&builtAfter=" + builtAfter.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&notBuiltAfter=" + notBuiltAfter.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&includeAllProperties="+includeAllProperties+"&includeLatestBuilds="+includeLatestBuilds+"&taskIdFilter=" + (taskIdFilter==null? "" : Uri.EscapeDataString(taskIdFilter))+"&processType="+processType+"&yamlFilename=" + (yamlFilename==null? "" : Uri.EscapeDataString(yamlFilename))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildDefinitionReference[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of definitions.
		/// Definitions_List {organization}/{project}/_apis/build/definitions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="name">If specified, filters to definitions whose names match this pattern.</param>
		/// <param name="repositoryId">A repository ID. If specified, filters to definitions that use this repository.</param>
		/// <param name="repositoryType">If specified, filters to definitions that have a repository of this type.</param>
		/// <param name="queryOrder">Indicates the order in which definitions should be returned.</param>
		/// <param name="top">The maximum number of definitions to return.</param>
		/// <param name="continuationToken">A continuation token, returned by a previous call to this method, that can be used to return the next set of definitions.</param>
		/// <param name="minMetricsTime">If specified, indicates the date from which metrics should be included.</param>
		/// <param name="definitionIds">A comma-delimited list that specifies the IDs of definitions to retrieve.</param>
		/// <param name="path">If specified, filters to definitions under this folder.</param>
		/// <param name="builtAfter">If specified, filters to definitions that have builds after this date.</param>
		/// <param name="notBuiltAfter">If specified, filters to definitions that do not have builds after this date.</param>
		/// <param name="includeAllProperties">Indicates whether the full definitions should be returned. By default, shallow representations of the definitions are returned.</param>
		/// <param name="includeLatestBuilds">Indicates whether to return the latest and latest completed builds for this definition.</param>
		/// <param name="taskIdFilter">If specified, filters to definitions that use the specified task.</param>
		/// <param name="processType">If specified, filters to definitions with the given process type.</param>
		/// <param name="yamlFilename">If specified, filters to YAML definitions that match the given filename.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.7' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public BuildDefinitionReference[] Definitions_List(
					string organization, 
					string project, 
					string name, 
					string repositoryId, 
					string repositoryType, 
					Definitions_ListQueryOrder queryOrder, 
					int top, 
					string continuationToken, 
					System.DateTimeOffset minMetricsTime, 
					string definitionIds, 
					string path, 
					System.DateTimeOffset builtAfter, 
					System.DateTimeOffset notBuiltAfter, 
					bool includeAllProperties, 
					bool includeLatestBuilds, 
					string taskIdFilter, 
					int processType, 
					string yamlFilename, 
					string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions&name=" + (name==null? "" : Uri.EscapeDataString(name))+"&repositoryId=" + (repositoryId==null? "" : Uri.EscapeDataString(repositoryId))+"&repositoryType=" + (repositoryType==null? "" : Uri.EscapeDataString(repositoryType))+"&queryOrder=" + queryOrder+"&$top="+top+"&continuationToken=" + (continuationToken==null? "" : Uri.EscapeDataString(continuationToken))+"&minMetricsTime=" + minMetricsTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&definitionIds=" + (definitionIds==null? "" : Uri.EscapeDataString(definitionIds))+"&path=" + (path==null? "" : Uri.EscapeDataString(path))+"&builtAfter=" + builtAfter.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&notBuiltAfter=" + notBuiltAfter.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&includeAllProperties="+includeAllProperties+"&includeLatestBuilds="+includeLatestBuilds+"&taskIdFilter=" + (taskIdFilter==null? "" : Uri.EscapeDataString(taskIdFilter))+"&processType="+processType+"&yamlFilename=" + (yamlFilename==null? "" : Uri.EscapeDataString(yamlFilename))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildDefinitionReference[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a definition and all associated builds.
		/// Definitions_Delete {organization}/{project}/_apis/build/definitions/{definitionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.7' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Definitions_DeleteAsync(string organization, string project, int definitionId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/"+definitionId+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a definition and all associated builds.
		/// Definitions_Delete {organization}/{project}/_apis/build/definitions/{definitionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.7' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Definitions_Delete(string organization, string project, int definitionId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/"+definitionId+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a definition, optionally at a specific revision.
		/// Definitions_Get {organization}/{project}/_apis/build/definitions/{definitionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="revision">The revision number to retrieve. If this is not specified, the latest version will be returned.</param>
		/// <param name="minMetricsTime">If specified, indicates the date from which metrics should be included.</param>
		/// <param name="propertyFilters">A comma-delimited list of properties to include in the results.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.7' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildDefinition> Definitions_GetAsync(string organization, string project, int definitionId, int revision, System.DateTimeOffset minMetricsTime, string propertyFilters, bool includeLatestBuilds, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/"+definitionId+"&revision="+revision+"&minMetricsTime=" + minMetricsTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&propertyFilters=" + (propertyFilters==null? "" : Uri.EscapeDataString(propertyFilters))+"&includeLatestBuilds="+includeLatestBuilds+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildDefinition>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a definition, optionally at a specific revision.
		/// Definitions_Get {organization}/{project}/_apis/build/definitions/{definitionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="revision">The revision number to retrieve. If this is not specified, the latest version will be returned.</param>
		/// <param name="minMetricsTime">If specified, indicates the date from which metrics should be included.</param>
		/// <param name="propertyFilters">A comma-delimited list of properties to include in the results.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.7' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public BuildDefinition Definitions_Get(string organization, string project, int definitionId, int revision, System.DateTimeOffset minMetricsTime, string propertyFilters, bool includeLatestBuilds, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/"+definitionId+"&revision="+revision+"&minMetricsTime=" + minMetricsTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&propertyFilters=" + (propertyFilters==null? "" : Uri.EscapeDataString(propertyFilters))+"&includeLatestBuilds="+includeLatestBuilds+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildDefinition>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Restores a deleted definition
		/// Definitions_Restore_Definition {organization}/{project}/_apis/build/definitions/{definitionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The identifier of the definition to restore.</param>
		/// <param name="deleted">When false, restores a deleted definition.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.7' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildDefinition> Definitions_Restore_DefinitionAsync(string organization, string project, int definitionId, bool deleted, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/"+definitionId+"&deleted="+deleted+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildDefinition>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Restores a deleted definition
		/// Definitions_Restore_Definition {organization}/{project}/_apis/build/definitions/{definitionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The identifier of the definition to restore.</param>
		/// <param name="deleted">When false, restores a deleted definition.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.7' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public BuildDefinition Definitions_Restore_Definition(string organization, string project, int definitionId, bool deleted, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/"+definitionId+"&deleted="+deleted+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildDefinition>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an existing definition.
		/// Definitions_Update {organization}/{project}/_apis/build/definitions/{definitionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.7' to use this version of the api.</param>
		/// <param name="requestBody">The new version of the definition.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildDefinition> Definitions_UpdateAsync(string organization, string project, int definitionId, int secretsSourceDefinitionId, int secretsSourceDefinitionRevision, string api_version, BuildDefinition requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/"+definitionId+"&secretsSourceDefinitionId="+secretsSourceDefinitionId+"&secretsSourceDefinitionRevision="+secretsSourceDefinitionRevision+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildDefinition>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates an existing definition.
		/// Definitions_Update {organization}/{project}/_apis/build/definitions/{definitionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.7' to use this version of the api.</param>
		/// <param name="requestBody">The new version of the definition.</param>
		/// <returns>successful operation</returns>
		public BuildDefinition Definitions_Update(string organization, string project, int definitionId, int secretsSourceDefinitionId, int secretsSourceDefinitionRevision, string api_version, BuildDefinition requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/"+definitionId+"&secretsSourceDefinitionId="+secretsSourceDefinitionId+"&secretsSourceDefinitionRevision="+secretsSourceDefinitionRevision+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildDefinition>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets build metrics for a definition.
		/// Metrics_Get_Definition_Metrics {organization}/{project}/_apis/build/definitions/{definitionId}/metrics
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="minMetricsTime">The date from which to calculate metrics.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildMetric[]> Metrics_Get_Definition_MetricsAsync(string organization, string project, int definitionId, System.DateTimeOffset minMetricsTime, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/"+definitionId+"/metrics&minMetricsTime=" + minMetricsTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildMetric[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets build metrics for a definition.
		/// Metrics_Get_Definition_Metrics {organization}/{project}/_apis/build/definitions/{definitionId}/metrics
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="minMetricsTime">The date from which to calculate metrics.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public BuildMetric[] Metrics_Get_Definition_Metrics(string organization, string project, int definitionId, System.DateTimeOffset minMetricsTime, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/"+definitionId+"/metrics&minMetricsTime=" + minMetricsTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildMetric[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets properties for a definition.
		/// Properties_Get_Definition_Properties {organization}/{project}/_apis/build/definitions/{definitionId}/properties
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="filter">A comma-delimited list of properties. If specified, filters to these specific properties.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<PropertiesCollection> Properties_Get_Definition_PropertiesAsync(string organization, string project, int definitionId, string filter, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/"+definitionId+"/properties&filter=" + (filter==null? "" : Uri.EscapeDataString(filter))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PropertiesCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets properties for a definition.
		/// Properties_Get_Definition_Properties {organization}/{project}/_apis/build/definitions/{definitionId}/properties
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="filter">A comma-delimited list of properties. If specified, filters to these specific properties.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public PropertiesCollection Properties_Get_Definition_Properties(string organization, string project, int definitionId, string filter, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/"+definitionId+"/properties&filter=" + (filter==null? "" : Uri.EscapeDataString(filter))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PropertiesCollection>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Resources_Authorize_Definition_Resources {organization}/{project}/_apis/build/definitions/{definitionId}/resources
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<DefinitionResourceReference[]> Resources_Authorize_Definition_ResourcesAsync(string organization, string project, int definitionId, string api_version, DefinitionResourceReference[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/"+definitionId+"/resources&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DefinitionResourceReference[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Resources_Authorize_Definition_Resources {organization}/{project}/_apis/build/definitions/{definitionId}/resources
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public DefinitionResourceReference[] Resources_Authorize_Definition_Resources(string organization, string project, int definitionId, string api_version, DefinitionResourceReference[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/"+definitionId+"/resources&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DefinitionResourceReference[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Resources_List {organization}/{project}/_apis/build/definitions/{definitionId}/resources
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<DefinitionResourceReference[]> Resources_ListAsync(string organization, string project, int definitionId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/"+definitionId+"/resources&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DefinitionResourceReference[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Resources_List {organization}/{project}/_apis/build/definitions/{definitionId}/resources
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public DefinitionResourceReference[] Resources_List(string organization, string project, int definitionId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/"+definitionId+"/resources&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DefinitionResourceReference[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all revisions of a definition.
		/// Definitions_Get_Definition_Revisions {organization}/{project}/_apis/build/definitions/{definitionId}/revisions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.3' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildDefinitionRevision[]> Definitions_Get_Definition_RevisionsAsync(string organization, string project, int definitionId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/"+definitionId+"/revisions&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildDefinitionRevision[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all revisions of a definition.
		/// Definitions_Get_Definition_Revisions {organization}/{project}/_apis/build/definitions/{definitionId}/revisions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.3' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public BuildDefinitionRevision[] Definitions_Get_Definition_Revisions(string organization, string project, int definitionId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/"+definitionId+"/revisions&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildDefinitionRevision[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds multiple tags to a definition.
		/// Tags_Add_Definition_Tags {organization}/{project}/_apis/build/definitions/{DefinitionId}/tags
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <param name="requestBody">The tags to add.</param>
		/// <returns>successful operation</returns>
		public async Task<string[]> Tags_Add_Definition_TagsAsync(string organization, string project, int definitionId, string api_version, string[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/{DefinitionId}/tags&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds multiple tags to a definition.
		/// Tags_Add_Definition_Tags {organization}/{project}/_apis/build/definitions/{DefinitionId}/tags
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <param name="requestBody">The tags to add.</param>
		/// <returns>successful operation</returns>
		public string[] Tags_Add_Definition_Tags(string organization, string project, int definitionId, string api_version, string[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/{DefinitionId}/tags&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the tags for a definition.
		/// Tags_Get_Definition_Tags {organization}/{project}/_apis/build/definitions/{DefinitionId}/tags
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="revision">The definition revision number. If not specified, uses the latest revision of the definition.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<string[]> Tags_Get_Definition_TagsAsync(string organization, string project, int definitionId, int revision, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/{DefinitionId}/tags&revision="+revision+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the tags for a definition.
		/// Tags_Get_Definition_Tags {organization}/{project}/_apis/build/definitions/{DefinitionId}/tags
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="revision">The definition revision number. If not specified, uses the latest revision of the definition.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public string[] Tags_Get_Definition_Tags(string organization, string project, int definitionId, int revision, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/{DefinitionId}/tags&revision="+revision+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a tag to a definition
		/// Tags_Add_Definition_Tag {organization}/{project}/_apis/build/definitions/{DefinitionId}/tags/{tag}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="tag">The tag to add.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<string[]> Tags_Add_Definition_TagAsync(string organization, string project, int definitionId, string tag, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/{DefinitionId}/tags/"+ (tag==null? "" : Uri.EscapeDataString(tag))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a tag to a definition
		/// Tags_Add_Definition_Tag {organization}/{project}/_apis/build/definitions/{DefinitionId}/tags/{tag}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="tag">The tag to add.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public string[] Tags_Add_Definition_Tag(string organization, string project, int definitionId, string tag, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/{DefinitionId}/tags/"+ (tag==null? "" : Uri.EscapeDataString(tag))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes a tag from a definition.
		/// Tags_Delete_Definition_Tag {organization}/{project}/_apis/build/definitions/{DefinitionId}/tags/{tag}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="tag">The tag to remove.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<string[]> Tags_Delete_Definition_TagAsync(string organization, string project, int definitionId, string tag, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/{DefinitionId}/tags/"+ (tag==null? "" : Uri.EscapeDataString(tag))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes a tag from a definition.
		/// Tags_Delete_Definition_Tag {organization}/{project}/_apis/build/definitions/{DefinitionId}/tags/{tag}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">The ID of the definition.</param>
		/// <param name="tag">The tag to remove.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public string[] Tags_Delete_Definition_Tag(string organization, string project, int definitionId, string tag, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/{DefinitionId}/tags/"+ (tag==null? "" : Uri.EscapeDataString(tag))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all definition templates.
		/// Templates_List {organization}/{project}/_apis/build/definitions/templates
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.3' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildDefinitionTemplate[]> Templates_ListAsync(string organization, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/templates&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildDefinitionTemplate[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all definition templates.
		/// Templates_List {organization}/{project}/_apis/build/definitions/templates
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.3' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public BuildDefinitionTemplate[] Templates_List(string organization, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/templates&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildDefinitionTemplate[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a build definition template.
		/// Templates_Delete {organization}/{project}/_apis/build/definitions/templates/{templateId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="templateId">The ID of the template.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.3' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Templates_DeleteAsync(string organization, string project, string templateId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/templates/"+ (templateId==null? "" : Uri.EscapeDataString(templateId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a build definition template.
		/// Templates_Delete {organization}/{project}/_apis/build/definitions/templates/{templateId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="templateId">The ID of the template.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.3' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Templates_Delete(string organization, string project, string templateId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/templates/"+ (templateId==null? "" : Uri.EscapeDataString(templateId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a specific build definition template.
		/// Templates_Get {organization}/{project}/_apis/build/definitions/templates/{templateId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="templateId">The ID of the requested template.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.3' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildDefinitionTemplate> Templates_GetAsync(string organization, string project, string templateId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/templates/"+ (templateId==null? "" : Uri.EscapeDataString(templateId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildDefinitionTemplate>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a specific build definition template.
		/// Templates_Get {organization}/{project}/_apis/build/definitions/templates/{templateId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="templateId">The ID of the requested template.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.3' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public BuildDefinitionTemplate Templates_Get(string organization, string project, string templateId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/templates/"+ (templateId==null? "" : Uri.EscapeDataString(templateId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildDefinitionTemplate>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an existing build definition template.
		/// Templates_Save_Template {organization}/{project}/_apis/build/definitions/templates/{templateId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="templateId">The ID of the template.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.3' to use this version of the api.</param>
		/// <param name="requestBody">The new version of the template.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildDefinitionTemplate> Templates_Save_TemplateAsync(string organization, string project, string templateId, string api_version, BuildDefinitionTemplate requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/templates/"+ (templateId==null? "" : Uri.EscapeDataString(templateId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildDefinitionTemplate>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates an existing build definition template.
		/// Templates_Save_Template {organization}/{project}/_apis/build/definitions/templates/{templateId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="templateId">The ID of the template.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.3' to use this version of the api.</param>
		/// <param name="requestBody">The new version of the template.</param>
		/// <returns>successful operation</returns>
		public BuildDefinitionTemplate Templates_Save_Template(string organization, string project, string templateId, string api_version, BuildDefinitionTemplate requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/definitions/templates/"+ (templateId==null? "" : Uri.EscapeDataString(templateId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildDefinitionTemplate>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a new folder.
		/// Folders_Create {organization}/{project}/_apis/build/folders
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="path">The full path of the folder.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <param name="requestBody">The folder.</param>
		/// <returns>successful operation</returns>
		public async Task<Folder> Folders_CreateAsync(string organization, string project, string path, string api_version, Folder requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/folders&path=" + (path==null? "" : Uri.EscapeDataString(path))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Folder>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a new folder.
		/// Folders_Create {organization}/{project}/_apis/build/folders
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="path">The full path of the folder.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <param name="requestBody">The folder.</param>
		/// <returns>successful operation</returns>
		public Folder Folders_Create(string organization, string project, string path, string api_version, Folder requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/folders&path=" + (path==null? "" : Uri.EscapeDataString(path))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Folder>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a definition folder. Definitions and their corresponding builds will also be deleted.
		/// Folders_Delete {organization}/{project}/_apis/build/folders
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="path">The full path to the folder.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Folders_DeleteAsync(string organization, string project, string path, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/folders&path=" + (path==null? "" : Uri.EscapeDataString(path))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a definition folder. Definitions and their corresponding builds will also be deleted.
		/// Folders_Delete {organization}/{project}/_apis/build/folders
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="path">The full path to the folder.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Folders_Delete(string organization, string project, string path, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/folders&path=" + (path==null? "" : Uri.EscapeDataString(path))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an existing folder at given  existing path
		/// Folders_Update {organization}/{project}/_apis/build/folders
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="path">The full path to the folder.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <param name="requestBody">The new version of the folder.</param>
		/// <returns>successful operation</returns>
		public async Task<Folder> Folders_UpdateAsync(string organization, string project, string path, string api_version, Folder requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/folders&path=" + (path==null? "" : Uri.EscapeDataString(path))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Folder>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates an existing folder at given  existing path
		/// Folders_Update {organization}/{project}/_apis/build/folders
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="path">The full path to the folder.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <param name="requestBody">The new version of the folder.</param>
		/// <returns>successful operation</returns>
		public Folder Folders_Update(string organization, string project, string path, string api_version, Folder requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/folders&path=" + (path==null? "" : Uri.EscapeDataString(path))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Folder>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets a list of build definition folders.
		/// Folders_List {organization}/{project}/_apis/build/folders/{path}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="path">The path to start with.</param>
		/// <param name="queryOrder">The order in which folders should be returned.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<Folder[]> Folders_ListAsync(string organization, string project, string path, Folders_ListQueryOrder queryOrder, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/folders/"+ (path==null? "" : Uri.EscapeDataString(path))+"&queryOrder=" + queryOrder+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Folder[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of build definition folders.
		/// Folders_List {organization}/{project}/_apis/build/folders/{path}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="path">The path to start with.</param>
		/// <param name="queryOrder">The order in which folders should be returned.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public Folder[] Folders_List(string organization, string project, string path, Folders_ListQueryOrder queryOrder, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/folders/"+ (path==null? "" : Uri.EscapeDataString(path))+"&queryOrder=" + queryOrder+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Folder[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets pipeline general settings.
		/// General_Settings_Get {organization}/{project}/_apis/build/generalsettings
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<PipelineGeneralSettings> General_Settings_GetAsync(string organization, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/generalsettings&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PipelineGeneralSettings>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets pipeline general settings.
		/// General_Settings_Get {organization}/{project}/_apis/build/generalsettings
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public PipelineGeneralSettings General_Settings_Get(string organization, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/generalsettings&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PipelineGeneralSettings>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the latest build for a definition, optionally scoped to a specific branch.
		/// Latest_Get {organization}/{project}/_apis/build/latest/{definition}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definition">definition name with optional leading folder path, or the definition id</param>
		/// <param name="branchName">optional parameter that indicates the specific branch to use</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<Build> Latest_GetAsync(string organization, string project, string definition, string branchName, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/latest/"+ (definition==null? "" : Uri.EscapeDataString(definition))+"&branchName=" + (branchName==null? "" : Uri.EscapeDataString(branchName))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Build>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the latest build for a definition, optionally scoped to a specific branch.
		/// Latest_Get {organization}/{project}/_apis/build/latest/{definition}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definition">definition name with optional leading folder path, or the definition id</param>
		/// <param name="branchName">optional parameter that indicates the specific branch to use</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public Build Latest_Get(string organization, string project, string definition, string branchName, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/latest/"+ (definition==null? "" : Uri.EscapeDataString(definition))+"&branchName=" + (branchName==null? "" : Uri.EscapeDataString(branchName))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Build>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets build metrics for a project.
		/// Metrics_Get_Project_Metrics {organization}/{project}/_apis/build/metrics/{metricAggregationType}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="metricAggregationType">The aggregation type to use (hourly, daily).</param>
		/// <param name="minMetricsTime">The date from which to calculate metrics.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildMetric[]> Metrics_Get_Project_MetricsAsync(string organization, string project, string metricAggregationType, System.DateTimeOffset minMetricsTime, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/metrics/"+ (metricAggregationType==null? "" : Uri.EscapeDataString(metricAggregationType))+"&minMetricsTime=" + minMetricsTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildMetric[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets build metrics for a project.
		/// Metrics_Get_Project_Metrics {organization}/{project}/_apis/build/metrics/{metricAggregationType}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="metricAggregationType">The aggregation type to use (hourly, daily).</param>
		/// <param name="minMetricsTime">The date from which to calculate metrics.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public BuildMetric[] Metrics_Get_Project_Metrics(string organization, string project, string metricAggregationType, System.DateTimeOffset minMetricsTime, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/metrics/"+ (metricAggregationType==null? "" : Uri.EscapeDataString(metricAggregationType))+"&minMetricsTime=" + minMetricsTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildMetric[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all build definition options supported by the system.
		/// Options_List {organization}/{project}/_apis/build/options
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildOptionDefinition[]> Options_ListAsync(string organization, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/options&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildOptionDefinition[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all build definition options supported by the system.
		/// Options_List {organization}/{project}/_apis/build/options
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public BuildOptionDefinition[] Options_List(string organization, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/options&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildOptionDefinition[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a badge that indicates the status of the most recent build for the specified branch.
		/// Badge_Get_Build_Badge_Data {organization}/{project}/_apis/build/repos/{repoType}/badge
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repoType">The repository type.</param>
		/// <param name="repoId">The repository ID.</param>
		/// <param name="branchName">The branch name.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<string> Badge_Get_Build_Badge_DataAsync(string organization, string project, string repoType, string repoId, string branchName, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/repos/"+ (repoType==null? "" : Uri.EscapeDataString(repoType))+"/badge&repoId=" + (repoId==null? "" : Uri.EscapeDataString(repoId))+"&branchName=" + (branchName==null? "" : Uri.EscapeDataString(branchName))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a badge that indicates the status of the most recent build for the specified branch.
		/// Badge_Get_Build_Badge_Data {organization}/{project}/_apis/build/repos/{repoType}/badge
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="repoType">The repository type.</param>
		/// <param name="repoId">The repository ID.</param>
		/// <param name="branchName">The branch name.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public string Badge_Get_Build_Badge_Data(string organization, string project, string repoType, string repoId, string branchName, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/repos/"+ (repoType==null? "" : Uri.EscapeDataString(repoType))+"/badge&repoId=" + (repoId==null? "" : Uri.EscapeDataString(repoId))+"&branchName=" + (branchName==null? "" : Uri.EscapeDataString(branchName))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the project's retention settings.
		/// Retention_Get {organization}/{project}/_apis/build/retention
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<ProjectRetentionSetting> Retention_GetAsync(string organization, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/retention&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectRetentionSetting>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the project's retention settings.
		/// Retention_Get {organization}/{project}/_apis/build/retention
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public ProjectRetentionSetting Retention_Get(string organization, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/retention&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectRetentionSetting>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the project's retention settings.
		/// Retention_Update {organization}/{project}/_apis/build/retention
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<ProjectRetentionSetting> Retention_UpdateAsync(string organization, string project, string api_version, UpdateProjectRetentionSettingModel requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/retention&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectRetentionSetting>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the project's retention settings.
		/// Retention_Update {organization}/{project}/_apis/build/retention
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public ProjectRetentionSetting Retention_Update(string organization, string project, string api_version, UpdateProjectRetentionSettingModel requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/retention&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectRetentionSetting>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds new leases for pipeline runs.
		/// Leases_Add {organization}/{project}/_apis/build/retention/leases
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<RetentionLease[]> Leases_AddAsync(string organization, string project, string api_version, NewRetentionLease[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/retention/leases&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RetentionLease[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds new leases for pipeline runs.
		/// Leases_Add {organization}/{project}/_apis/build/retention/leases
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public RetentionLease[] Leases_Add(string organization, string project, string api_version, NewRetentionLease[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/retention/leases&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RetentionLease[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes specific retention leases.
		/// Leases_Delete {organization}/{project}/_apis/build/retention/leases
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Leases_DeleteAsync(string organization, string project, string ids, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/retention/leases&ids=" + (ids==null? "" : Uri.EscapeDataString(ids))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes specific retention leases.
		/// Leases_Delete {organization}/{project}/_apis/build/retention/leases
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Leases_Delete(string organization, string project, string ids, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/retention/leases&ids=" + (ids==null? "" : Uri.EscapeDataString(ids))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns any leases owned by the specified user, optionally scoped to a single pipeline definition and run.
		/// Leases_Get_Retention_Leases_By_User_Id {organization}/{project}/_apis/build/retention/leases
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="userOwnerId">The user id to search for.</param>
		/// <param name="definitionId">An optional parameter to limit the search to a specific pipeline definition.</param>
		/// <param name="runId">An optional parameter to limit the search to a single pipeline run. Requires definitionId.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<RetentionLease[]> Leases_Get_Retention_Leases_By_User_IdAsync(string organization, string project, string userOwnerId, int definitionId, int runId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/retention/leases&userOwnerId=" + (userOwnerId==null? "" : Uri.EscapeDataString(userOwnerId))+"&definitionId="+definitionId+"&runId="+runId+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RetentionLease[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns any leases owned by the specified user, optionally scoped to a single pipeline definition and run.
		/// Leases_Get_Retention_Leases_By_User_Id {organization}/{project}/_apis/build/retention/leases
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="userOwnerId">The user id to search for.</param>
		/// <param name="definitionId">An optional parameter to limit the search to a specific pipeline definition.</param>
		/// <param name="runId">An optional parameter to limit the search to a single pipeline run. Requires definitionId.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public RetentionLease[] Leases_Get_Retention_Leases_By_User_Id(string organization, string project, string userOwnerId, int definitionId, int runId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/retention/leases&userOwnerId=" + (userOwnerId==null? "" : Uri.EscapeDataString(userOwnerId))+"&definitionId="+definitionId+"&runId="+runId+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RetentionLease[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the details of the retention lease given a lease id.
		/// Leases_Get {organization}/{project}/_apis/build/retention/leases/{leaseId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<RetentionLease> Leases_GetAsync(string organization, string project, int leaseId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/retention/leases/"+leaseId+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RetentionLease>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the details of the retention lease given a lease id.
		/// Leases_Get {organization}/{project}/_apis/build/retention/leases/{leaseId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public RetentionLease Leases_Get(string organization, string project, int leaseId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/retention/leases/"+leaseId+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RetentionLease>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the build settings.
		/// Settings_Get {organization}/{project}/_apis/build/settings
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildSettings> Settings_GetAsync(string organization, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/settings&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildSettings>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the build settings.
		/// Settings_Get {organization}/{project}/_apis/build/settings
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public BuildSettings Settings_Get(string organization, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/settings&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildSettings>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the build settings.
		/// Settings_Update {organization}/{project}/_apis/build/settings
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The new settings.</param>
		/// <returns>successful operation</returns>
		public async Task<BuildSettings> Settings_UpdateAsync(string organization, string project, string api_version, BuildSettings requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/settings&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildSettings>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the build settings.
		/// Settings_Update {organization}/{project}/_apis/build/settings
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The new settings.</param>
		/// <returns>successful operation</returns>
		public BuildSettings Settings_Update(string organization, string project, string api_version, BuildSettings requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/settings&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BuildSettings>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Gets the build status for a definition, optionally scoped to a specific branch, stage, job, and configuration.</p> <p>If there are more than one, then it is required to pass in a stageName value when specifying a jobName, and the same rule then applies for both if passing a configuration parameter.</p>
		/// Status_Get {organization}/{project}/_apis/build/status/{definition}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definition">Either the definition name with optional leading folder path, or the definition id.</param>
		/// <param name="branchName">Only consider the most recent build for this branch.</param>
		/// <param name="stageName">Use this stage within the pipeline to render the status.</param>
		/// <param name="jobName">Use this job within a stage of the pipeline to render the status.</param>
		/// <param name="configuration">Use this job configuration to render the status</param>
		/// <param name="label">Replaces the default text on the left side of the badge.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<string> Status_GetAsync(string organization, string project, string definition, string branchName, string stageName, string jobName, string configuration, string label, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/status/"+ (definition==null? "" : Uri.EscapeDataString(definition))+"&branchName=" + (branchName==null? "" : Uri.EscapeDataString(branchName))+"&stageName=" + (stageName==null? "" : Uri.EscapeDataString(stageName))+"&jobName=" + (jobName==null? "" : Uri.EscapeDataString(jobName))+"&configuration=" + (configuration==null? "" : Uri.EscapeDataString(configuration))+"&label=" + (label==null? "" : Uri.EscapeDataString(label))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets the build status for a definition, optionally scoped to a specific branch, stage, job, and configuration.</p> <p>If there are more than one, then it is required to pass in a stageName value when specifying a jobName, and the same rule then applies for both if passing a configuration parameter.</p>
		/// Status_Get {organization}/{project}/_apis/build/status/{definition}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definition">Either the definition name with optional leading folder path, or the definition id.</param>
		/// <param name="branchName">Only consider the most recent build for this branch.</param>
		/// <param name="stageName">Use this stage within the pipeline to render the status.</param>
		/// <param name="jobName">Use this job within a stage of the pipeline to render the status.</param>
		/// <param name="configuration">Use this job configuration to render the status</param>
		/// <param name="label">Replaces the default text on the left side of the badge.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public string Status_Get(string organization, string project, string definition, string branchName, string stageName, string jobName, string configuration, string label, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/status/"+ (definition==null? "" : Uri.EscapeDataString(definition))+"&branchName=" + (branchName==null? "" : Uri.EscapeDataString(branchName))+"&stageName=" + (stageName==null? "" : Uri.EscapeDataString(stageName))+"&jobName=" + (jobName==null? "" : Uri.EscapeDataString(jobName))+"&configuration=" + (configuration==null? "" : Uri.EscapeDataString(configuration))+"&label=" + (label==null? "" : Uri.EscapeDataString(label))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of all build tags in the project.
		/// Tags_Get_Tags {organization}/{project}/_apis/build/tags
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<string[]> Tags_Get_TagsAsync(string organization, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/tags&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of all build tags in the project.
		/// Tags_Get_Tags {organization}/{project}/_apis/build/tags
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public string[] Tags_Get_Tags(string organization, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/tags&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes a tag from builds, definitions, and from the tag store
		/// Tags_Delete_Tag {organization}/{project}/_apis/build/tags/{tag}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="tag">The tag to remove.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<string[]> Tags_Delete_TagAsync(string organization, string project, string tag, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/tags/"+ (tag==null? "" : Uri.EscapeDataString(tag))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes a tag from builds, definitions, and from the tag store
		/// Tags_Delete_Tag {organization}/{project}/_apis/build/tags/{tag}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="tag">The tag to remove.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public string[] Tags_Delete_Tag(string organization, string project, string tag, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/tags/"+ (tag==null? "" : Uri.EscapeDataString(tag))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all the work items between two builds.
		/// Builds_Get_Work_Items_Between_Builds {organization}/{project}/_apis/build/workitems
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="fromBuildId">The ID of the first build.</param>
		/// <param name="toBuildId">The ID of the last build.</param>
		/// <param name="top">The maximum number of work items to return.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<ResourceRef[]> Builds_Get_Work_Items_Between_BuildsAsync(string organization, string project, int fromBuildId, int toBuildId, int top, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/workitems&fromBuildId="+fromBuildId+"&toBuildId="+toBuildId+"&$top="+top+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ResourceRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all the work items between two builds.
		/// Builds_Get_Work_Items_Between_Builds {organization}/{project}/_apis/build/workitems
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="fromBuildId">The ID of the first build.</param>
		/// <param name="toBuildId">The ID of the last build.</param>
		/// <param name="top">The maximum number of work items to return.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public ResourceRef[] Builds_Get_Work_Items_Between_Builds(string organization, string project, int fromBuildId, int toBuildId, int top, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/build/workitems&fromBuildId="+fromBuildId+"&toBuildId="+toBuildId+"&$top="+top+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ResourceRef[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a list of source providers and their capabilities.
		/// Source_Providers_List {organization}/{project}/_apis/sourceproviders
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<SourceProviderAttributes[]> Source_Providers_ListAsync(string organization, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/sourceproviders&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SourceProviderAttributes[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a list of source providers and their capabilities.
		/// Source_Providers_List {organization}/{project}/_apis/sourceproviders
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public SourceProviderAttributes[] Source_Providers_List(string organization, string project, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/sourceproviders&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SourceProviderAttributes[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of branches for the given source code repository.
		/// Source_Providers_List_Branches {organization}/{project}/_apis/sourceProviders/{providerName}/branches
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="providerName">The name of the source provider.</param>
		/// <param name="serviceEndpointId">If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.</param>
		/// <param name="repository">The vendor-specific identifier or the name of the repository to get branches. Can only be omitted for providers that do not support multiple repositories.</param>
		/// <param name="branchName">If supplied, the name of the branch to check for specifically.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<string[]> Source_Providers_List_BranchesAsync(string organization, string project, string providerName, string serviceEndpointId, string repository, string branchName, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/sourceProviders/"+ (providerName==null? "" : Uri.EscapeDataString(providerName))+"/branches&serviceEndpointId=" + (serviceEndpointId==null? "" : Uri.EscapeDataString(serviceEndpointId))+"&repository=" + (repository==null? "" : Uri.EscapeDataString(repository))+"&branchName=" + (branchName==null? "" : Uri.EscapeDataString(branchName))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of branches for the given source code repository.
		/// Source_Providers_List_Branches {organization}/{project}/_apis/sourceProviders/{providerName}/branches
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="providerName">The name of the source provider.</param>
		/// <param name="serviceEndpointId">If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.</param>
		/// <param name="repository">The vendor-specific identifier or the name of the repository to get branches. Can only be omitted for providers that do not support multiple repositories.</param>
		/// <param name="branchName">If supplied, the name of the branch to check for specifically.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public string[] Source_Providers_List_Branches(string organization, string project, string providerName, string serviceEndpointId, string repository, string branchName, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/sourceProviders/"+ (providerName==null? "" : Uri.EscapeDataString(providerName))+"/branches&serviceEndpointId=" + (serviceEndpointId==null? "" : Uri.EscapeDataString(serviceEndpointId))+"&repository=" + (repository==null? "" : Uri.EscapeDataString(repository))+"&branchName=" + (branchName==null? "" : Uri.EscapeDataString(branchName))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the contents of a file in the given source code repository.
		/// Source_Providers_Get_File_Contents {organization}/{project}/_apis/sourceProviders/{providerName}/filecontents
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="providerName">The name of the source provider.</param>
		/// <param name="serviceEndpointId">If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.</param>
		/// <param name="repository">If specified, the vendor-specific identifier or the name of the repository to get branches. Can only be omitted for providers that do not support multiple repositories.</param>
		/// <param name="commitOrBranch">The identifier of the commit or branch from which a file's contents are retrieved.</param>
		/// <param name="path">The path to the file to retrieve, relative to the root of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<string> Source_Providers_Get_File_ContentsAsync(string organization, string project, string providerName, string serviceEndpointId, string repository, string commitOrBranch, string path, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/sourceProviders/"+ (providerName==null? "" : Uri.EscapeDataString(providerName))+"/filecontents&serviceEndpointId=" + (serviceEndpointId==null? "" : Uri.EscapeDataString(serviceEndpointId))+"&repository=" + (repository==null? "" : Uri.EscapeDataString(repository))+"&commitOrBranch=" + (commitOrBranch==null? "" : Uri.EscapeDataString(commitOrBranch))+"&path=" + (path==null? "" : Uri.EscapeDataString(path))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (System.IO.StreamReader streamReader = new System.IO.StreamReader(stream))
				{
				return streamReader.ReadToEnd();;
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the contents of a file in the given source code repository.
		/// Source_Providers_Get_File_Contents {organization}/{project}/_apis/sourceProviders/{providerName}/filecontents
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="providerName">The name of the source provider.</param>
		/// <param name="serviceEndpointId">If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.</param>
		/// <param name="repository">If specified, the vendor-specific identifier or the name of the repository to get branches. Can only be omitted for providers that do not support multiple repositories.</param>
		/// <param name="commitOrBranch">The identifier of the commit or branch from which a file's contents are retrieved.</param>
		/// <param name="path">The path to the file to retrieve, relative to the root of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public string Source_Providers_Get_File_Contents(string organization, string project, string providerName, string serviceEndpointId, string repository, string commitOrBranch, string path, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/sourceProviders/"+ (providerName==null? "" : Uri.EscapeDataString(providerName))+"/filecontents&serviceEndpointId=" + (serviceEndpointId==null? "" : Uri.EscapeDataString(serviceEndpointId))+"&repository=" + (repository==null? "" : Uri.EscapeDataString(repository))+"&commitOrBranch=" + (commitOrBranch==null? "" : Uri.EscapeDataString(commitOrBranch))+"&path=" + (path==null? "" : Uri.EscapeDataString(path))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (System.IO.StreamReader streamReader = new System.IO.StreamReader(stream))
				{
				return streamReader.ReadToEnd();;
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the contents of a directory in the given source code repository.
		/// Source_Providers_Get_Path_Contents {organization}/{project}/_apis/sourceProviders/{providerName}/pathcontents
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="providerName">The name of the source provider.</param>
		/// <param name="serviceEndpointId">If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.</param>
		/// <param name="repository">If specified, the vendor-specific identifier or the name of the repository to get branches. Can only be omitted for providers that do not support multiple repositories.</param>
		/// <param name="commitOrBranch">The identifier of the commit or branch from which a file's contents are retrieved.</param>
		/// <param name="path">The path contents to list, relative to the root of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<SourceRepositoryItem[]> Source_Providers_Get_Path_ContentsAsync(string organization, string project, string providerName, string serviceEndpointId, string repository, string commitOrBranch, string path, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/sourceProviders/"+ (providerName==null? "" : Uri.EscapeDataString(providerName))+"/pathcontents&serviceEndpointId=" + (serviceEndpointId==null? "" : Uri.EscapeDataString(serviceEndpointId))+"&repository=" + (repository==null? "" : Uri.EscapeDataString(repository))+"&commitOrBranch=" + (commitOrBranch==null? "" : Uri.EscapeDataString(commitOrBranch))+"&path=" + (path==null? "" : Uri.EscapeDataString(path))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SourceRepositoryItem[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the contents of a directory in the given source code repository.
		/// Source_Providers_Get_Path_Contents {organization}/{project}/_apis/sourceProviders/{providerName}/pathcontents
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="providerName">The name of the source provider.</param>
		/// <param name="serviceEndpointId">If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.</param>
		/// <param name="repository">If specified, the vendor-specific identifier or the name of the repository to get branches. Can only be omitted for providers that do not support multiple repositories.</param>
		/// <param name="commitOrBranch">The identifier of the commit or branch from which a file's contents are retrieved.</param>
		/// <param name="path">The path contents to list, relative to the root of the repository.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public SourceRepositoryItem[] Source_Providers_Get_Path_Contents(string organization, string project, string providerName, string serviceEndpointId, string repository, string commitOrBranch, string path, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/sourceProviders/"+ (providerName==null? "" : Uri.EscapeDataString(providerName))+"/pathcontents&serviceEndpointId=" + (serviceEndpointId==null? "" : Uri.EscapeDataString(serviceEndpointId))+"&repository=" + (repository==null? "" : Uri.EscapeDataString(repository))+"&commitOrBranch=" + (commitOrBranch==null? "" : Uri.EscapeDataString(commitOrBranch))+"&path=" + (path==null? "" : Uri.EscapeDataString(path))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SourceRepositoryItem[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a pull request object from source provider.
		/// Source_Providers_Get_Pull_Request {organization}/{project}/_apis/sourceProviders/{providerName}/pullrequests/{pullRequestId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="providerName">The name of the source provider.</param>
		/// <param name="pullRequestId">Vendor-specific id of the pull request.</param>
		/// <param name="repositoryId">Vendor-specific identifier or the name of the repository that contains the pull request.</param>
		/// <param name="serviceEndpointId">If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<PullRequest> Source_Providers_Get_Pull_RequestAsync(string organization, string project, string providerName, string pullRequestId, string repositoryId, string serviceEndpointId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/sourceProviders/"+ (providerName==null? "" : Uri.EscapeDataString(providerName))+"/pullrequests/"+ (pullRequestId==null? "" : Uri.EscapeDataString(pullRequestId))+"&repositoryId=" + (repositoryId==null? "" : Uri.EscapeDataString(repositoryId))+"&serviceEndpointId=" + (serviceEndpointId==null? "" : Uri.EscapeDataString(serviceEndpointId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PullRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a pull request object from source provider.
		/// Source_Providers_Get_Pull_Request {organization}/{project}/_apis/sourceProviders/{providerName}/pullrequests/{pullRequestId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="providerName">The name of the source provider.</param>
		/// <param name="pullRequestId">Vendor-specific id of the pull request.</param>
		/// <param name="repositoryId">Vendor-specific identifier or the name of the repository that contains the pull request.</param>
		/// <param name="serviceEndpointId">If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public PullRequest Source_Providers_Get_Pull_Request(string organization, string project, string providerName, string pullRequestId, string repositoryId, string serviceEndpointId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/sourceProviders/"+ (providerName==null? "" : Uri.EscapeDataString(providerName))+"/pullrequests/"+ (pullRequestId==null? "" : Uri.EscapeDataString(pullRequestId))+"&repositoryId=" + (repositoryId==null? "" : Uri.EscapeDataString(repositoryId))+"&serviceEndpointId=" + (serviceEndpointId==null? "" : Uri.EscapeDataString(serviceEndpointId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PullRequest>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of source code repositories.
		/// Source_Providers_List_Repositories {organization}/{project}/_apis/sourceProviders/{providerName}/repositories
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="providerName">The name of the source provider.</param>
		/// <param name="serviceEndpointId">If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.</param>
		/// <param name="repository">If specified, the vendor-specific identifier or the name of a single repository to get.</param>
		/// <param name="resultSet">'top' for the repositories most relevant for the endpoint. If not set, all repositories are returned. Ignored if 'repository' is set.</param>
		/// <param name="pageResults">If set to true, this will limit the set of results and will return a continuation token to continue the query.</param>
		/// <param name="continuationToken">When paging results, this is a continuation token, returned by a previous call to this method, that can be used to return the next set of repositories.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<SourceRepositories> Source_Providers_List_RepositoriesAsync(string organization, string project, string providerName, string serviceEndpointId, string repository, Source_Providers_List_RepositoriesResultSet resultSet, bool pageResults, string continuationToken, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/sourceProviders/"+ (providerName==null? "" : Uri.EscapeDataString(providerName))+"/repositories&serviceEndpointId=" + (serviceEndpointId==null? "" : Uri.EscapeDataString(serviceEndpointId))+"&repository=" + (repository==null? "" : Uri.EscapeDataString(repository))+"&resultSet=" + resultSet+"&pageResults="+pageResults+"&continuationToken=" + (continuationToken==null? "" : Uri.EscapeDataString(continuationToken))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SourceRepositories>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of source code repositories.
		/// Source_Providers_List_Repositories {organization}/{project}/_apis/sourceProviders/{providerName}/repositories
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="providerName">The name of the source provider.</param>
		/// <param name="serviceEndpointId">If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.</param>
		/// <param name="repository">If specified, the vendor-specific identifier or the name of a single repository to get.</param>
		/// <param name="resultSet">'top' for the repositories most relevant for the endpoint. If not set, all repositories are returned. Ignored if 'repository' is set.</param>
		/// <param name="pageResults">If set to true, this will limit the set of results and will return a continuation token to continue the query.</param>
		/// <param name="continuationToken">When paging results, this is a continuation token, returned by a previous call to this method, that can be used to return the next set of repositories.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public SourceRepositories Source_Providers_List_Repositories(string organization, string project, string providerName, string serviceEndpointId, string repository, Source_Providers_List_RepositoriesResultSet resultSet, bool pageResults, string continuationToken, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/sourceProviders/"+ (providerName==null? "" : Uri.EscapeDataString(providerName))+"/repositories&serviceEndpointId=" + (serviceEndpointId==null? "" : Uri.EscapeDataString(serviceEndpointId))+"&repository=" + (repository==null? "" : Uri.EscapeDataString(repository))+"&resultSet=" + resultSet+"&pageResults="+pageResults+"&continuationToken=" + (continuationToken==null? "" : Uri.EscapeDataString(continuationToken))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SourceRepositories>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Recreates the webhooks for the specified triggers in the given source code repository.
		/// Source_Providers_Restore_Webhooks {organization}/{project}/_apis/sourceProviders/{providerName}/webhooks
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="providerName">The name of the source provider.</param>
		/// <param name="serviceEndpointId">If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.</param>
		/// <param name="repository">If specified, the vendor-specific identifier or the name of the repository to get webhooks. Can only be omitted for providers that do not support multiple repositories.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The types of triggers to restore webhooks for.</param>
		/// <returns>successful operation</returns>
		public async Task Source_Providers_Restore_WebhooksAsync(string organization, string project, string providerName, string serviceEndpointId, string repository, string api_version, string[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/sourceProviders/"+ (providerName==null? "" : Uri.EscapeDataString(providerName))+"/webhooks&serviceEndpointId=" + (serviceEndpointId==null? "" : Uri.EscapeDataString(serviceEndpointId))+"&repository=" + (repository==null? "" : Uri.EscapeDataString(repository))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Recreates the webhooks for the specified triggers in the given source code repository.
		/// Source_Providers_Restore_Webhooks {organization}/{project}/_apis/sourceProviders/{providerName}/webhooks
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="providerName">The name of the source provider.</param>
		/// <param name="serviceEndpointId">If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.</param>
		/// <param name="repository">If specified, the vendor-specific identifier or the name of the repository to get webhooks. Can only be omitted for providers that do not support multiple repositories.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The types of triggers to restore webhooks for.</param>
		/// <returns>successful operation</returns>
		public void Source_Providers_Restore_Webhooks(string organization, string project, string providerName, string serviceEndpointId, string repository, string api_version, string[] requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/sourceProviders/"+ (providerName==null? "" : Uri.EscapeDataString(providerName))+"/webhooks&serviceEndpointId=" + (serviceEndpointId==null? "" : Uri.EscapeDataString(serviceEndpointId))+"&repository=" + (repository==null? "" : Uri.EscapeDataString(repository))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets a list of webhooks installed in the given source code repository.
		/// Source_Providers_List_Webhooks {organization}/{project}/_apis/sourceProviders/{providerName}/webhooks
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="providerName">The name of the source provider.</param>
		/// <param name="serviceEndpointId">If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.</param>
		/// <param name="repository">If specified, the vendor-specific identifier or the name of the repository to get webhooks. Can only be omitted for providers that do not support multiple repositories.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<RepositoryWebhook[]> Source_Providers_List_WebhooksAsync(string organization, string project, string providerName, string serviceEndpointId, string repository, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/sourceProviders/"+ (providerName==null? "" : Uri.EscapeDataString(providerName))+"/webhooks&serviceEndpointId=" + (serviceEndpointId==null? "" : Uri.EscapeDataString(serviceEndpointId))+"&repository=" + (repository==null? "" : Uri.EscapeDataString(repository))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RepositoryWebhook[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of webhooks installed in the given source code repository.
		/// Source_Providers_List_Webhooks {organization}/{project}/_apis/sourceProviders/{providerName}/webhooks
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="providerName">The name of the source provider.</param>
		/// <param name="serviceEndpointId">If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.</param>
		/// <param name="repository">If specified, the vendor-specific identifier or the name of the repository to get webhooks. Can only be omitted for providers that do not support multiple repositories.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public RepositoryWebhook[] Source_Providers_List_Webhooks(string organization, string project, string providerName, string serviceEndpointId, string repository, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/"+ (project==null? "" : Uri.EscapeDataString(project))+"/_apis/sourceProviders/"+ (providerName==null? "" : Uri.EscapeDataString(providerName))+"/webhooks&serviceEndpointId=" + (serviceEndpointId==null? "" : Uri.EscapeDataString(serviceEndpointId))+"&repository=" + (repository==null? "" : Uri.EscapeDataString(repository))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RepositoryWebhook[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum Builds_ListDeletedFilter
	{
		
		excludeDeleted = 0,
		
		includeDeleted = 1,
		
		onlyDeleted = 2,
	}
	
	public enum Builds_ListQueryOrder
	{
		
		finishTimeAscending = 0,
		
		finishTimeDescending = 1,
		
		queueTimeDescending = 2,
		
		queueTimeAscending = 3,
		
		startTimeDescending = 4,
		
		startTimeAscending = 5,
	}
	
	public enum Definitions_ListQueryOrder
	{
		
		none = 0,
		
		lastModifiedAscending = 1,
		
		lastModifiedDescending = 2,
		
		definitionNameAscending = 3,
		
		definitionNameDescending = 4,
	}
	
	public enum Folders_ListQueryOrder
	{
		
		none = 0,
		
		folderAscending = 1,
		
		folderDescending = 2,
	}
	
	public enum Source_Providers_List_RepositoriesResultSet
	{
		
		all = 0,
		
		top = 1,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
