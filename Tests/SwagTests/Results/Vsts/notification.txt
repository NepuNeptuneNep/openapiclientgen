//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Net.Http;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	public class ActorFilter
	{
	}
	
	public class ActorNotificationReason
	{
		
		public string[] MatchedRoles { get; set; }
	}
	
	/// <summary>
	/// Artifact filter options. Used in "follow" subscriptions.
	/// </summary>
	public class ArtifactFilter
	{
		
		public string ArtifactId { get; set; }
		
		public string ArtifactType { get; set; }
		
		public string ArtifactUri { get; set; }
		
		public string Type { get; set; }
	}
	
	public class BaseSubscriptionFilter
	{
		
		public string EventType { get; set; }
		
		public string Type { get; set; }
	}
	
	public class BatchNotificationOperation
	{
		
		public BatchNotificationOperationNotificationOperation NotificationOperation { get; set; }
		
		public NotificationQueryCondition[] NotificationQueryConditions { get; set; }
	}
	
	public enum BatchNotificationOperationNotificationOperation
	{
		
		none = 0,
		
		suspendUnprocessed = 1,
	}
	
	public class NotificationQueryCondition
	{
		
		public string EventInitiator { get; set; }
		
		public string EventType { get; set; }
		
		public string Subscriber { get; set; }
		
		public string SubscriptionId { get; set; }
	}
	
	public class BlockFilter
	{
	}
	
	public class BlockSubscriptionChannel
	{
		
		public string Type { get; set; }
	}
	
	public class DiagnosticIdentity
	{
		
		public string DisplayName { get; set; }
		
		public string EmailAddress { get; set; }
		
		public string Id { get; set; }
	}
	
	public class DiagnosticNotification
	{
		
		public System.Nullable<System.Int32> EventId { get; set; }
		
		public string EventType { get; set; }
		
		public System.Nullable<System.Int32> Id { get; set; }
		
		public NotificationDiagnosticLogMessage[] Messages { get; set; }
		
		public System.Collections.Generic.Dictionary<string, DiagnosticRecipient> Recipients { get; set; }
		
		public string Result { get; set; }
		
		public System.Collections.Generic.Dictionary<string, object> Stats { get; set; }
		
		public string SubscriptionId { get; set; }
	}
	
	public class NotificationDiagnosticLogMessage
	{
		
		/// <summary>
		/// Corresponds to .Net TraceLevel enumeration
		/// </summary>
		public System.Nullable<System.Int32> Level { get; set; }
		
		public string Message { get; set; }
		
		public string Time { get; set; }
	}
	
	public class DiagnosticRecipient
	{
		
		public DiagnosticIdentity Recipient { get; set; }
		
		public string Status { get; set; }
	}
	
	public class EmailHtmlSubscriptionChannel
	{
		
		public string Type { get; set; }
	}
	
	public class EmailPlaintextSubscriptionChannel
	{
		
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Defines an "actor" for an event.
	/// </summary>
	public class EventActor
	{
		
		/// <summary>
		/// Required: This is the identity of the user for the specified role.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Required: The event specific name of a role.
		/// </summary>
		public string Role { get; set; }
	}
	
	public class EventBacklogStatus
	{
		
		public System.Nullable<System.DateTimeOffset> CaptureTime { get; set; }
		
		public string JobId { get; set; }
		
		public System.Nullable<System.DateTimeOffset> LastEventBatchStartTime { get; set; }
		
		public System.Nullable<System.DateTimeOffset> LastEventProcessedTime { get; set; }
		
		public System.Nullable<System.DateTimeOffset> LastJobBatchStartTime { get; set; }
		
		public System.Nullable<System.DateTimeOffset> LastJobProcessedTime { get; set; }
		
		public System.Nullable<System.DateTimeOffset> OldestPendingEventTime { get; set; }
		
		public string Publisher { get; set; }
		
		public System.Nullable<System.Int32> UnprocessedEvents { get; set; }
	}
	
	public class EventBatch
	{
		
		public string EndTime { get; set; }
		
		public System.Collections.Generic.Dictionary<string, object> EventCounts { get; set; }
		
		public string EventIds { get; set; }
		
		public System.Collections.Generic.Dictionary<string, object> NotificationCounts { get; set; }
		
		public string PreProcessEndTime { get; set; }
		
		public string PreProcessStartTime { get; set; }
		
		public string ProcessEndTime { get; set; }
		
		public string ProcessStartTime { get; set; }
		
		public string StartTime { get; set; }
		
		public System.Collections.Generic.Dictionary<string, object> SubscriptionCounts { get; set; }
	}
	
	public class EventProcessingLog
	{
		
		public EventBatch[] Batches { get; set; }
		
		public MatcherResult[] MatcherResults { get; set; }
	}
	
	public class MatcherResult
	{
		
		public string Matcher { get; set; }
		
		public System.Collections.Generic.Dictionary<string, object> Stats { get; set; }
	}
	
	/// <summary>
	/// Defines a scope for an event.
	/// </summary>
	public class EventScope
	{
		
		/// <summary>
		/// Required: This is the identity of the scope for the type.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Optional: The display name of the scope
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Required: The event specific type of a scope.
		/// </summary>
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Encapsulates events result properties. It defines the total number of events used and the number of matched events.
	/// </summary>
	public class EventsEvaluationResult
	{
		
		/// <summary>
		/// Count of events evaluated.
		/// </summary>
		public System.Nullable<System.Int32> Count { get; set; }
		
		/// <summary>
		/// Count of matched events.
		/// </summary>
		public System.Nullable<System.Int32> MatchedCount { get; set; }
	}
	
	/// <summary>
	/// A transform request specify the properties of a notification event to be transformed.
	/// </summary>
	public class EventTransformRequest
	{
		
		/// <summary>
		/// Event payload.
		/// </summary>
		public string EventPayload { get; set; }
		
		/// <summary>
		/// Event type.
		/// </summary>
		public string EventType { get; set; }
		
		/// <summary>
		/// System inputs.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, object> SystemInputs { get; set; }
	}
	
	/// <summary>
	/// Result of transforming a notification event.
	/// </summary>
	public class EventTransformResult
	{
		
		/// <summary>
		/// Transformed html content.
		/// </summary>
		public string Content { get; set; }
		
		/// <summary>
		/// Calculated data.
		/// </summary>
		public string Data { get; set; }
		
		/// <summary>
		/// Calculated system inputs.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, object> SystemInputs { get; set; }
	}
	
	public class ExpressionFilter
	{
		
		public ExpressionFilterModel Criteria { get; set; }
		
		public string Type { get; set; }
	}
	
	public class ExpressionFilterModel
	{
		
		/// <summary>
		/// Flat list of clauses in this subscription
		/// </summary>
		public ExpressionFilterClause[] Clauses { get; set; }
		
		/// <summary>
		/// Grouping of clauses in the subscription
		/// </summary>
		public ExpressionFilterGroup[] Groups { get; set; }
		
		/// <summary>
		/// Max depth of the Subscription tree
		/// </summary>
		public System.Nullable<System.Int32> MaxGroupLevel { get; set; }
	}
	
	/// <summary>
	/// Subscription Filter Clause represents a single clause in a subscription filter e.g. If the subscription has the following criteria "Project Name = [Current Project] AND Assigned To = [Me] it will be represented as two Filter Clauses Clause 1: Index = 1, Logical Operator: NULL  , FieldName = 'Project Name', Operator = '=', Value = '[Current Project]' Clause 2: Index = 2, Logical Operator: 'AND' , FieldName = 'Assigned To' , Operator = '=', Value = '[Me]'
	/// </summary>
	public class ExpressionFilterClause
	{
		
		public string FieldName { get; set; }
		
		/// <summary>
		/// The order in which this clause appeared in the filter query
		/// </summary>
		public System.Nullable<System.Int32> Index { get; set; }
		
		/// <summary>
		/// Logical Operator 'AND', 'OR' or NULL (only for the first clause in the filter)
		/// </summary>
		public string LogicalOperator { get; set; }
		
		public string Operator { get; set; }
		
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents a hierarchy of SubscritionFilterClauses that have been grouped together through either adding a group in the WebUI or using parethesis in the Subscription condition string
	/// </summary>
	public class ExpressionFilterGroup
	{
		
		/// <summary>
		/// The index of the last FilterClause in this group
		/// </summary>
		public System.Nullable<System.Int32> End { get; set; }
		
		/// <summary>
		/// Level of the group, since groups can be nested for each nested group the level will increase by 1
		/// </summary>
		public System.Nullable<System.Int32> Level { get; set; }
		
		/// <summary>
		/// The index of the first FilterClause in this group
		/// </summary>
		public System.Nullable<System.Int32> Start { get; set; }
	}
	
	public class FieldInputValues
	{
		
		public string[] Operators { get; set; }
	}
	
	public class FieldValuesQuery
	{
		
		public FieldInputValues[] InputValues { get; set; }
		
		public string Scope { get; set; }
	}
	
	public class GeneratedNotification
	{
		
		public DiagnosticIdentity[] Recipients { get; set; }
	}
	
	public class GraphSubjectBase
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
		/// </summary>
		public string Descriptor { get; set; }
		
		/// <summary>
		/// This is the non-unique display name of the graph subject. To change this field, you must alter its value in the source provider.
		/// </summary>
		public string DisplayName { get; set; }
		
		/// <summary>
		/// This url is the full route to the source resource of this graph subject.
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// The class to represent a collection of REST reference links.
	/// </summary>
	public class ReferenceLinks
	{
		
		/// <summary>
		/// The readonly view of the links.  Because Reference links are readonly, we only want to expose them as read only.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, object> Links { get; set; }
	}
	
	public class GroupSubscriptionChannel
	{
		
		public string Type { get; set; }
	}
	
	public class IdentityRef
	{
		
		/// <summary>
		/// Deprecated - Can be retrieved by querying the Graph user referenced in the "self" entry of the IdentityRef "_links" dictionary
		/// </summary>
		public string DirectoryAlias { get; set; }
		
		public string Id { get; set; }
		
		/// <summary>
		/// Deprecated - Available in the "avatar" entry of the IdentityRef "_links" dictionary
		/// </summary>
		public string ImageUrl { get; set; }
		
		/// <summary>
		/// Deprecated - Can be retrieved by querying the Graph membership state referenced in the "membershipState" entry of the GraphUser "_links" dictionary
		/// </summary>
		public System.Nullable<System.Boolean> Inactive { get; set; }
		
		/// <summary>
		/// Deprecated - Can be inferred from the subject type of the descriptor (Descriptor.IsAadUserType/Descriptor.IsAadGroupType)
		/// </summary>
		public System.Nullable<System.Boolean> IsAadIdentity { get; set; }
		
		/// <summary>
		/// Deprecated - Can be inferred from the subject type of the descriptor (Descriptor.IsGroupType)
		/// </summary>
		public System.Nullable<System.Boolean> IsContainer { get; set; }
		
		public System.Nullable<System.Boolean> IsDeletedInOrigin { get; set; }
		
		/// <summary>
		/// Deprecated - not in use in most preexisting implementations of ToIdentityRef
		/// </summary>
		public string ProfileUrl { get; set; }
		
		/// <summary>
		/// Deprecated - use Domain+PrincipalName instead
		/// </summary>
		public string UniqueName { get; set; }
	}
	
	/// <summary>
	/// Abstraction interface for the diagnostic log.  Primarily for deserialization.
	/// </summary>
	public class INotificationDiagnosticLog
	{
		
		/// <summary>
		/// Identifier used for correlating to other diagnostics that may have been recorded elsewhere.
		/// </summary>
		public string ActivityId { get; set; }
		
		/// <summary>
		/// Description of what subscription or notification job is being logged.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Time the log ended.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> EndTime { get; set; }
		
		/// <summary>
		/// Unique instance identifier.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Type of information being logged.
		/// </summary>
		public string LogType { get; set; }
		
		/// <summary>
		/// List of log messages.
		/// </summary>
		public NotificationDiagnosticLogMessage[] Messages { get; set; }
		
		/// <summary>
		/// Dictionary of log properties and settings for the job.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, object> Properties { get; set; }
		
		/// <summary>
		/// This identifier depends on the logType.  For notification jobs, this will be the job Id. For subscription tracing, this will be a special root Guid with the subscription Id encoded.
		/// </summary>
		public string Source { get; set; }
		
		/// <summary>
		/// Time the log started.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> StartTime { get; set; }
	}
	
	/// <summary>
	/// Information about a single value for an input
	/// </summary>
	public class InputValue
	{
		
		/// <summary>
		/// Any other data about this input
		/// </summary>
		public System.Collections.Generic.Dictionary<string, object> Data { get; set; }
		
		/// <summary>
		/// The text to show for the display of this value
		/// </summary>
		public string DisplayValue { get; set; }
		
		/// <summary>
		/// The value to store for this input
		/// </summary>
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Information about the possible/allowed values for a given subscription input
	/// </summary>
	public class InputValues
	{
		
		/// <summary>
		/// The default value to use for this input
		/// </summary>
		public string DefaultValue { get; set; }
		
		/// <summary>
		/// Error information related to a subscription input value.
		/// </summary>
		public InputValuesError Error { get; set; }
		
		/// <summary>
		/// The id of the input
		/// </summary>
		public string InputId { get; set; }
		
		/// <summary>
		/// Should this input be disabled
		/// </summary>
		public System.Nullable<System.Boolean> IsDisabled { get; set; }
		
		/// <summary>
		/// Should the value be restricted to one of the values in the PossibleValues (True) or are the values in PossibleValues just a suggestion (False)
		/// </summary>
		public System.Nullable<System.Boolean> IsLimitedToPossibleValues { get; set; }
		
		/// <summary>
		/// Should this input be made read-only
		/// </summary>
		public System.Nullable<System.Boolean> IsReadOnly { get; set; }
		
		/// <summary>
		/// Possible values that this input can take
		/// </summary>
		public InputValue[] PossibleValues { get; set; }
	}
	
	/// <summary>
	/// Error information related to a subscription input value.
	/// </summary>
	public class InputValuesError
	{
		
		/// <summary>
		/// The error message.
		/// </summary>
		public string Message { get; set; }
	}
	
	public class InputValuesQuery
	{
		
		public System.Collections.Generic.Dictionary<string, object> CurrentValues { get; set; }
		
		/// <summary>
		/// The input values to return on input, and the result from the consumer on output.
		/// </summary>
		public InputValues[] InputValues { get; set; }
		
		/// <summary>
		/// Subscription containing information about the publisher/consumer and the current input values
		/// </summary>
		public string Resource { get; set; }
	}
	
	public class ISubscriptionChannel
	{
		
		public string Type { get; set; }
	}
	
	public class ISubscriptionFilter
	{
		
		public string EventType { get; set; }
		
		public string Type { get; set; }
	}
	
	public class MessageQueueSubscriptionChannel
	{
		
		public string Type { get; set; }
	}
	
	public class NotificationAdminSettings
	{
		
		/// <summary>
		/// The default group delivery preference for groups in this collection
		/// </summary>
		public NotificationAdminSettingsDefaultGroupDeliveryPreference DefaultGroupDeliveryPreference { get; set; }
	}
	
	public enum NotificationAdminSettingsDefaultGroupDeliveryPreference
	{
		
		noDelivery = 0,
		
		eachMember = 1,
	}
	
	public class NotificationAdminSettingsUpdateParameters
	{
		
		public NotificationAdminSettingsUpdateParametersDefaultGroupDeliveryPreference DefaultGroupDeliveryPreference { get; set; }
	}
	
	public enum NotificationAdminSettingsUpdateParametersDefaultGroupDeliveryPreference
	{
		
		noDelivery = 0,
		
		eachMember = 1,
	}
	
	public class NotificationBacklogStatus
	{
		
		public System.Nullable<System.DateTimeOffset> CaptureTime { get; set; }
		
		public string Channel { get; set; }
		
		public string JobId { get; set; }
		
		public System.Nullable<System.DateTimeOffset> LastJobBatchStartTime { get; set; }
		
		public System.Nullable<System.DateTimeOffset> LastJobProcessedTime { get; set; }
		
		public System.Nullable<System.DateTimeOffset> LastNotificationBatchStartTime { get; set; }
		
		public System.Nullable<System.DateTimeOffset> LastNotificationProcessedTime { get; set; }
		
		public System.Nullable<System.DateTimeOffset> OldestPendingNotificationTime { get; set; }
		
		public string Publisher { get; set; }
		
		/// <summary>
		/// Null status is unprocessed
		/// </summary>
		public string Status { get; set; }
		
		public System.Nullable<System.Int32> UnprocessedNotifications { get; set; }
	}
	
	public class NotificationBatch
	{
		
		public string EndTime { get; set; }
		
		public System.Nullable<System.Int32> NotificationCount { get; set; }
		
		public string NotificationIds { get; set; }
		
		public DiagnosticNotification[] ProblematicNotifications { get; set; }
		
		public string StartTime { get; set; }
	}
	
	public class NotificationDeliveryLog
	{
		
		public NotificationBatch[] Batches { get; set; }
	}
	
	/// <summary>
	/// Abstract base class for all of the diagnostic logs.
	/// </summary>
	public class NotificationDiagnosticLog
	{
		
		/// <summary>
		/// Identifier used for correlating to other diagnostics that may have been recorded elsewhere.
		/// </summary>
		public string ActivityId { get; set; }
		
		public string Description { get; set; }
		
		public System.Nullable<System.DateTimeOffset> EndTime { get; set; }
		
		public System.Nullable<System.Int32> Errors { get; set; }
		
		/// <summary>
		/// Unique instance identifier.
		/// </summary>
		public string Id { get; set; }
		
		public string LogType { get; set; }
		
		public NotificationDiagnosticLogMessage[] Messages { get; set; }
		
		public System.Collections.Generic.Dictionary<string, object> Properties { get; set; }
		
		/// <summary>
		/// This identifier depends on the logType.  For notification jobs, this will be the job Id. For subscription tracing, this will be a special root Guid with the subscription Id encoded.
		/// </summary>
		public string Source { get; set; }
		
		public System.Nullable<System.DateTimeOffset> StartTime { get; set; }
		
		public System.Nullable<System.Int32> Warnings { get; set; }
	}
	
	public class NotificationEventBacklogStatus
	{
		
		public EventBacklogStatus[] EventBacklogStatus { get; set; }
		
		public NotificationBacklogStatus[] NotificationBacklogStatus { get; set; }
	}
	
	/// <summary>
	/// Encapsulates the properties of a filterable field. A filterable field is a field in an event that can used to filter notifications for a certain event type.
	/// </summary>
	public class NotificationEventField
	{
		
		/// <summary>
		/// Encapsulates the properties of a field type. It describes the data type of a field, the operators it support and how to populate it in the UI
		/// </summary>
		public NotificationEventFieldType FieldType { get; set; }
		
		/// <summary>
		/// Gets or sets the unique identifier of this field.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets the name of this field.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the path to the field in the event object. This path can be either Json Path or XPath, depending on if the event will be serialized into Json or XML
		/// </summary>
		public string Path { get; set; }
		
		/// <summary>
		/// Gets or sets the scopes that this field supports. If not specified then the event type scopes apply.
		/// </summary>
		public string[] SupportedScopes { get; set; }
	}
	
	/// <summary>
	/// Encapsulates the properties of a field type. It describes the data type of a field, the operators it support and how to populate it in the UI
	/// </summary>
	public class NotificationEventFieldType
	{
		
		/// <summary>
		/// Gets or sets the unique identifier of this field type.
		/// </summary>
		public string Id { get; set; }
		
		public OperatorConstraint[] OperatorConstraints { get; set; }
		
		/// <summary>
		/// Gets or sets the list of operators that this type supports.
		/// </summary>
		public NotificationEventFieldOperator[] Operators { get; set; }
		
		public NotificationEventFieldTypeSubscriptionFieldType SubscriptionFieldType { get; set; }
		
		/// <summary>
		/// Encapsulates the properties of a field value definition. It has the information needed to retrieve the list of possible values for a certain field and how to handle that field values in the UI. This information includes what type of object this value represents, which property to use for UI display and which property to use for saving the subscription
		/// </summary>
		public ValueDefinition Value { get; set; }
	}
	
	/// <summary>
	/// Encapsulates the properties of an operator constraint. An operator constraint defines if some operator is available only for specific scope like a project scope.
	/// </summary>
	public class OperatorConstraint
	{
		
		public string Operator { get; set; }
		
		/// <summary>
		/// Gets or sets the list of scopes that this type supports.
		/// </summary>
		public string[] SupportedScopes { get; set; }
	}
	
	/// <summary>
	/// Encapsulates the properties of a field type. It includes a unique id for the operator and a localized string for display name
	/// </summary>
	public class NotificationEventFieldOperator
	{
		
		/// <summary>
		/// Gets or sets the display name of an operator
		/// </summary>
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Gets or sets the id of an operator
		/// </summary>
		public string Id { get; set; }
	}
	
	public enum NotificationEventFieldTypeSubscriptionFieldType
	{
		
		_string = 0,
		
		integer = 1,
		
		dateTime = 2,
		
		plainText = 3,
		
		html = 4,
		
		treePath = 5,
		
		history = 6,
		
		_double = 7,
		
		guid = 8,
		
		boolean = 9,
		
		identity = 10,
		
		picklistInteger = 11,
		
		picklistString = 12,
		
		picklistDouble = 13,
		
		teamProject = 14,
	}
	
	/// <summary>
	/// Encapsulates the properties of a field value definition. It has the information needed to retrieve the list of possible values for a certain field and how to handle that field values in the UI. This information includes what type of object this value represents, which property to use for UI display and which property to use for saving the subscription
	/// </summary>
	public class ValueDefinition
	{
		
		/// <summary>
		/// Gets or sets the data source.
		/// </summary>
		public InputValue[] DataSource { get; set; }
		
		/// <summary>
		/// Gets or sets the rest end point.
		/// </summary>
		public string EndPoint { get; set; }
		
		/// <summary>
		/// Gets or sets the result template.
		/// </summary>
		public string ResultTemplate { get; set; }
	}
	
	/// <summary>
	/// Encapsulates the properties of a notification event publisher.
	/// </summary>
	public class NotificationEventPublisher
	{
		
		public string Id { get; set; }
		
		/// <summary>
		/// Encapsulates the properties needed to manage subscriptions, opt in and out of subscriptions.
		/// </summary>
		public SubscriptionManagement SubscriptionManagementInfo { get; set; }
		
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Encapsulates the properties needed to manage subscriptions, opt in and out of subscriptions.
	/// </summary>
	public class SubscriptionManagement
	{
		
		public string ServiceInstanceType { get; set; }
		
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Encapsulates the properties of an event role.  An event Role is used for role based subscription for example for a buildCompletedEvent, one role is request by field
	/// </summary>
	public class NotificationEventRole
	{
		
		/// <summary>
		/// Gets or sets an Id for that role, this id is used by the event.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets the Name for that role, this name is used for UI display.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets whether this role can be a group or just an individual user
		/// </summary>
		public System.Nullable<System.Boolean> SupportsGroups { get; set; }
	}
	
	/// <summary>
	/// Encapsulates the properties of an event type. It defines the fields, that can be used for filtering, for that event type.
	/// </summary>
	public class NotificationEventType
	{
		
		/// <summary>
		/// Encapsulates the properties of a category. A category will be used by the UI to group event types
		/// </summary>
		public NotificationEventTypeCategory Category { get; set; }
		
		/// <summary>
		/// Gets or sets the color representing this event type. Example: rgb(128,245,211) or #fafafa
		/// </summary>
		public string Color { get; set; }
		
		public System.Nullable<System.Boolean> CustomSubscriptionsAllowed { get; set; }
		
		/// <summary>
		/// Encapsulates the properties of a notification event publisher.
		/// </summary>
		public NotificationEventPublisher EventPublisher { get; set; }
		
		public System.Collections.Generic.Dictionary<string, NotificationEventField> Fields { get; set; }
		
		public System.Nullable<System.Boolean> HasInitiator { get; set; }
		
		/// <summary>
		/// Gets or sets the icon representing this event type. Can be a URL or a CSS class. Example: css://some-css-class
		/// </summary>
		public string Icon { get; set; }
		
		/// <summary>
		/// Gets or sets the unique identifier of this event definition.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets the name of this event definition.
		/// </summary>
		public string Name { get; set; }
		
		public NotificationEventRole[] Roles { get; set; }
		
		/// <summary>
		/// Gets or sets the scopes that this event type supports
		/// </summary>
		public string[] SupportedScopes { get; set; }
		
		/// <summary>
		/// Gets or sets the rest end point to get this event type details (fields, fields types)
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Encapsulates the properties of a category. A category will be used by the UI to group event types
	/// </summary>
	public class NotificationEventTypeCategory
	{
		
		/// <summary>
		/// Gets or sets the unique identifier of this category.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets the friendly name of this category.
		/// </summary>
		public string Name { get; set; }
	}
	
	public class NotificationJobDiagnosticLog
	{
		
		public string Result { get; set; }
		
		public System.Collections.Generic.Dictionary<string, object> Stats { get; set; }
	}
	
	public class NotificationReason
	{
		
		public NotificationReasonNotificationReasonType NotificationReasonType { get; set; }
		
		public IdentityRef[] TargetIdentities { get; set; }
	}
	
	public enum NotificationReasonNotificationReasonType
	{
		
		unknown = 0,
		
		follows = 1,
		
		personal = 2,
		
		personalAlias = 3,
		
		directMember = 4,
		
		indirectMember = 5,
		
		groupAlias = 6,
		
		subscriptionAlias = 7,
		
		singleRole = 8,
		
		directMemberGroupRole = 9,
		
		inDirectMemberGroupRole = 10,
		
		aliasMemberGroupRole = 11,
	}
	
	/// <summary>
	/// Encapsulates notifications result properties. It defines the number of notifications and the recipients of notifications.
	/// </summary>
	public class NotificationsEvaluationResult
	{
		
		/// <summary>
		/// Count of generated notifications
		/// </summary>
		public System.Nullable<System.Int32> Count { get; set; }
	}
	
	public class NotificationStatistic
	{
		
		public System.Nullable<System.DateTimeOffset> Date { get; set; }
		
		public System.Nullable<System.Int32> HitCount { get; set; }
		
		public string Path { get; set; }
		
		public NotificationStatisticType Type { get; set; }
		
		public IdentityRef User { get; set; }
	}
	
	public enum NotificationStatisticType
	{
		
		notificationBySubscription = 0,
		
		eventsByEventType = 1,
		
		notificationByEventType = 2,
		
		eventsByEventTypePerUser = 3,
		
		notificationByEventTypePerUser = 4,
		
		events = 5,
		
		notifications = 6,
		
		notificationFailureBySubscription = 7,
		
		unprocessedRangeStart = 8,
		
		unprocessedEventsByPublisher = 9,
		
		unprocessedEventDelayByPublisher = 10,
		
		unprocessedNotificationsByChannelByPublisher = 11,
		
		unprocessedNotificationDelayByChannelByPublisher = 12,
		
		delayRangeStart = 13,
		
		totalPipelineTime = 14,
		
		notificationPipelineTime = 15,
		
		eventPipelineTime = 16,
		
		hourlyRangeStart = 17,
		
		hourlyNotificationBySubscription = 18,
		
		hourlyEventsByEventTypePerUser = 19,
		
		hourlyEvents = 20,
		
		hourlyNotifications = 21,
		
		hourlyUnprocessedEventsByPublisher = 22,
		
		hourlyUnprocessedEventDelayByPublisher = 23,
		
		hourlyUnprocessedNotificationsByChannelByPublisher = 24,
		
		hourlyUnprocessedNotificationDelayByChannelByPublisher = 25,
		
		hourlyTotalPipelineTime = 26,
		
		hourlyNotificationPipelineTime = 27,
		
		hourlyEventPipelineTime = 28,
	}
	
	public class NotificationStatisticsQuery
	{
		
		public NotificationStatisticsQueryConditions[] Conditions { get; set; }
	}
	
	public class NotificationStatisticsQueryConditions
	{
		
		public System.Nullable<System.DateTimeOffset> EndDate { get; set; }
		
		public System.Nullable<System.Int32> HitCountMinimum { get; set; }
		
		public string Path { get; set; }
		
		public System.Nullable<System.DateTimeOffset> StartDate { get; set; }
		
		public NotificationStatisticsQueryConditionsType Type { get; set; }
		
		public IdentityRef User { get; set; }
	}
	
	public enum NotificationStatisticsQueryConditionsType
	{
		
		notificationBySubscription = 0,
		
		eventsByEventType = 1,
		
		notificationByEventType = 2,
		
		eventsByEventTypePerUser = 3,
		
		notificationByEventTypePerUser = 4,
		
		events = 5,
		
		notifications = 6,
		
		notificationFailureBySubscription = 7,
		
		unprocessedRangeStart = 8,
		
		unprocessedEventsByPublisher = 9,
		
		unprocessedEventDelayByPublisher = 10,
		
		unprocessedNotificationsByChannelByPublisher = 11,
		
		unprocessedNotificationDelayByChannelByPublisher = 12,
		
		delayRangeStart = 13,
		
		totalPipelineTime = 14,
		
		notificationPipelineTime = 15,
		
		eventPipelineTime = 16,
		
		hourlyRangeStart = 17,
		
		hourlyNotificationBySubscription = 18,
		
		hourlyEventsByEventTypePerUser = 19,
		
		hourlyEvents = 20,
		
		hourlyNotifications = 21,
		
		hourlyUnprocessedEventsByPublisher = 22,
		
		hourlyUnprocessedEventDelayByPublisher = 23,
		
		hourlyUnprocessedNotificationsByChannelByPublisher = 24,
		
		hourlyUnprocessedNotificationDelayByChannelByPublisher = 25,
		
		hourlyTotalPipelineTime = 26,
		
		hourlyNotificationPipelineTime = 27,
		
		hourlyEventPipelineTime = 28,
	}
	
	/// <summary>
	/// A subscriber is a user or group that has the potential to receive notifications.
	/// </summary>
	public class NotificationSubscriber
	{
		
		/// <summary>
		/// Indicates how the subscriber should be notified by default.
		/// </summary>
		public NotificationSubscriberDeliveryPreference DeliveryPreference { get; set; }
		
		public NotificationSubscriberFlags Flags { get; set; }
		
		/// <summary>
		/// Identifier of the subscriber.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Preferred email address of the subscriber. A null or empty value indicates no preferred email address has been set.
		/// </summary>
		public string PreferredEmailAddress { get; set; }
	}
	
	public enum NotificationSubscriberDeliveryPreference
	{
		
		noDelivery = 0,
		
		preferredEmailAddress = 1,
		
		eachMember = 2,
		
		useDefault = 3,
	}
	
	public enum NotificationSubscriberFlags
	{
		
		none = 0,
		
		deliveryPreferencesEditable = 1,
		
		supportsPreferredEmailAddressDelivery = 2,
		
		supportsEachMemberDelivery = 3,
		
		supportsNoDelivery = 4,
		
		isUser = 5,
		
		isGroup = 6,
		
		isTeam = 7,
	}
	
	/// <summary>
	/// Updates to a subscriber. Typically used to change (or set) a preferred email address or default delivery preference.
	/// </summary>
	public class NotificationSubscriberUpdateParameters
	{
		
		/// <summary>
		/// New delivery preference for the subscriber (indicates how the subscriber should be notified).
		/// </summary>
		public NotificationSubscriberUpdateParametersDeliveryPreference DeliveryPreference { get; set; }
		
		/// <summary>
		/// New preferred email address for the subscriber. Specify an empty string to clear the current address.
		/// </summary>
		public string PreferredEmailAddress { get; set; }
	}
	
	public enum NotificationSubscriberUpdateParametersDeliveryPreference
	{
		
		noDelivery = 0,
		
		preferredEmailAddress = 1,
		
		eachMember = 2,
		
		useDefault = 3,
	}
	
	/// <summary>
	/// A subscription defines criteria for matching events and how the subscription's subscriber should be notified about those events.
	/// </summary>
	public class NotificationSubscription
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// Admin-managed settings for a group subscription.
		/// </summary>
		public SubscriptionAdminSettings AdminSettings { get; set; }
		
		public ISubscriptionChannel Channel { get; set; }
		
		/// <summary>
		/// Description of the subscription. Typically describes filter criteria which helps identity the subscription.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Contains all the diagnostics settings for a subscription.
		/// </summary>
		public SubscriptionDiagnostics Diagnostics { get; set; }
		
		/// <summary>
		/// Any extra properties like detailed description for different contexts, user/group contexts
		/// </summary>
		public System.Collections.Generic.Dictionary<string, object> ExtendedProperties { get; set; }
		
		public ISubscriptionFilter Filter { get; set; }
		
		/// <summary>
		/// Read-only indicators that further describe the subscription.
		/// </summary>
		public NotificationSubscriptionFlags Flags { get; set; }
		
		/// <summary>
		/// Subscription identifier.
		/// </summary>
		public string Id { get; set; }
		
		public IdentityRef LastModifiedBy { get; set; }
		
		/// <summary>
		/// Date when the subscription was last modified. If the subscription has not been updated since it was created, this value will indicate when the subscription was created.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ModifiedDate { get; set; }
		
		/// <summary>
		/// The permissions the user have for this subscriptions.
		/// </summary>
		public NotificationSubscriptionPermissions Permissions { get; set; }
		
		/// <summary>
		/// A resource, typically an account or project, in which events are published from.
		/// </summary>
		public SubscriptionScope Scope { get; set; }
		
		/// <summary>
		/// Status of the subscription. Typically indicates whether the subscription is enabled or not.
		/// </summary>
		public NotificationSubscriptionStatus Status { get; set; }
		
		/// <summary>
		/// Message that provides more details about the status of the subscription.
		/// </summary>
		public string StatusMessage { get; set; }
		
		public IdentityRef Subscriber { get; set; }
		
		/// <summary>
		/// REST API URL of the subscriotion.
		/// </summary>
		public string Url { get; set; }
		
		/// <summary>
		/// User-managed settings for a group subscription.
		/// </summary>
		public SubscriptionUserSettings UserSettings { get; set; }
	}
	
	/// <summary>
	/// Admin-managed settings for a group subscription.
	/// </summary>
	public class SubscriptionAdminSettings
	{
		
		/// <summary>
		/// If true, members of the group subscribed to the associated subscription cannot opt (choose not to get notified)
		/// </summary>
		public System.Nullable<System.Boolean> BlockUserOptOut { get; set; }
	}
	
	/// <summary>
	/// Contains all the diagnostics settings for a subscription.
	/// </summary>
	public class SubscriptionDiagnostics
	{
		
		/// <summary>
		/// Data controlling a single diagnostic setting for a subscription.
		/// </summary>
		public SubscriptionTracing DeliveryResults { get; set; }
		
		/// <summary>
		/// Data controlling a single diagnostic setting for a subscription.
		/// </summary>
		public SubscriptionTracing DeliveryTracing { get; set; }
		
		/// <summary>
		/// Data controlling a single diagnostic setting for a subscription.
		/// </summary>
		public SubscriptionTracing EvaluationTracing { get; set; }
	}
	
	/// <summary>
	/// Data controlling a single diagnostic setting for a subscription.
	/// </summary>
	public class SubscriptionTracing
	{
		
		/// <summary>
		/// Indicates whether the diagnostic tracing is enabled or not.
		/// </summary>
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Trace until the specified end date.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> EndDate { get; set; }
		
		/// <summary>
		/// The maximum number of result details to trace.
		/// </summary>
		public System.Nullable<System.Int32> MaxTracedEntries { get; set; }
		
		/// <summary>
		/// The date and time tracing started.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> StartDate { get; set; }
		
		/// <summary>
		/// Trace until remaining count reaches 0.
		/// </summary>
		public System.Nullable<System.Int32> TracedEntries { get; set; }
	}
	
	public enum NotificationSubscriptionFlags
	{
		
		none = 0,
		
		groupSubscription = 1,
		
		contributedSubscription = 2,
		
		canOptOut = 3,
		
		teamSubscription = 4,
		
		oneActorMatches = 5,
	}
	
	public enum NotificationSubscriptionPermissions
	{
		
		none = 0,
		
		view = 1,
		
		edit = 2,
		
		delete = 3,
	}
	
	/// <summary>
	/// A resource, typically an account or project, in which events are published from.
	/// </summary>
	public class SubscriptionScope
	{
	}
	
	public enum NotificationSubscriptionStatus
	{
		
		jailedByNotificationsVolume = 0,
		
		pendingDeletion = 1,
		
		disabledArgumentException = 2,
		
		disabledProjectInvalid = 3,
		
		disabledMissingPermissions = 4,
		
		disabledFromProbation = 5,
		
		disabledInactiveIdentity = 6,
		
		disabledMessageQueueNotSupported = 7,
		
		disabledMissingIdentity = 8,
		
		disabledInvalidRoleExpression = 9,
		
		disabledInvalidPathClause = 10,
		
		disabledAsDuplicateOfDefault = 11,
		
		disabledByAdmin = 12,
		
		disabled = 13,
		
		enabled = 14,
		
		enabledOnProbation = 15,
	}
	
	/// <summary>
	/// User-managed settings for a group subscription.
	/// </summary>
	public class SubscriptionUserSettings
	{
		
		/// <summary>
		/// Indicates whether the user will receive notifications for the associated group subscription.
		/// </summary>
		public System.Nullable<System.Boolean> OptedOut { get; set; }
	}
	
	/// <summary>
	/// Parameters for creating a new subscription. A subscription defines criteria for matching events and how the subscription's subscriber should be notified about those events.
	/// </summary>
	public class NotificationSubscriptionCreateParameters
	{
		
		public ISubscriptionChannel Channel { get; set; }
		
		/// <summary>
		/// Brief description for the new subscription. Typically describes filter criteria which helps identity the subscription.
		/// </summary>
		public string Description { get; set; }
		
		public ISubscriptionFilter Filter { get; set; }
		
		/// <summary>
		/// A resource, typically an account or project, in which events are published from.
		/// </summary>
		public SubscriptionScope Scope { get; set; }
		
		public IdentityRef Subscriber { get; set; }
	}
	
	public class NotificationSubscriptionTemplate
	{
		
		public string Description { get; set; }
		
		public ISubscriptionFilter Filter { get; set; }
		
		public string Id { get; set; }
		
		/// <summary>
		/// Encapsulates the properties of an event type. It defines the fields, that can be used for filtering, for that event type.
		/// </summary>
		public NotificationEventType NotificationEventInformation { get; set; }
		
		public NotificationSubscriptionTemplateType Type { get; set; }
	}
	
	public enum NotificationSubscriptionTemplateType
	{
		
		user = 0,
		
		team = 1,
		
		both = 2,
		
		none = 3,
	}
	
	/// <summary>
	/// Parameters for updating an existing subscription. A subscription defines criteria for matching events and how the subscription's subscriber should be notified about those events. Note: only the fields to be updated should be set.
	/// </summary>
	public class NotificationSubscriptionUpdateParameters
	{
		
		/// <summary>
		/// Admin-managed settings for a group subscription.
		/// </summary>
		public SubscriptionAdminSettings AdminSettings { get; set; }
		
		public ISubscriptionChannel Channel { get; set; }
		
		/// <summary>
		/// Updated description for the subscription. Typically describes filter criteria which helps identity the subscription.
		/// </summary>
		public string Description { get; set; }
		
		public ISubscriptionFilter Filter { get; set; }
		
		/// <summary>
		/// A resource, typically an account or project, in which events are published from.
		/// </summary>
		public SubscriptionScope Scope { get; set; }
		
		/// <summary>
		/// Updated status for the subscription. Typically used to enable or disable a subscription.
		/// </summary>
		public NotificationSubscriptionUpdateParametersStatus Status { get; set; }
		
		/// <summary>
		/// Optional message that provides more details about the updated status.
		/// </summary>
		public string StatusMessage { get; set; }
		
		/// <summary>
		/// User-managed settings for a group subscription.
		/// </summary>
		public SubscriptionUserSettings UserSettings { get; set; }
	}
	
	public enum NotificationSubscriptionUpdateParametersStatus
	{
		
		jailedByNotificationsVolume = 0,
		
		pendingDeletion = 1,
		
		disabledArgumentException = 2,
		
		disabledProjectInvalid = 3,
		
		disabledMissingPermissions = 4,
		
		disabledFromProbation = 5,
		
		disabledInactiveIdentity = 6,
		
		disabledMessageQueueNotSupported = 7,
		
		disabledMissingIdentity = 8,
		
		disabledInvalidRoleExpression = 9,
		
		disabledInvalidPathClause = 10,
		
		disabledAsDuplicateOfDefault = 11,
		
		disabledByAdmin = 12,
		
		disabled = 13,
		
		enabled = 14,
		
		enabledOnProbation = 15,
	}
	
	public class ProcessedEvent
	{
		
		/// <summary>
		/// All of the users that were associated with this event and their role.
		/// </summary>
		public EventActor[] Actors { get; set; }
		
		public string AllowedChannels { get; set; }
		
		public string ArtifactUri { get; set; }
		
		public ProcessingIdentities DeliveryIdentities { get; set; }
		
		/// <summary>
		/// Evaluations for each user
		/// </summary>
		public System.Collections.Generic.Dictionary<string, SubscriptionEvaluation> Evaluations { get; set; }
		
		public System.Nullable<System.Int32> EventId { get; set; }
		
		/// <summary>
		/// Which members were excluded from evaluation (only applies to ActorMatcher subscriptions)
		/// </summary>
		public EventActor[] Exclusions { get; set; }
		
		/// <summary>
		/// Which members were included for evaluation (only applies to ActorMatcher subscriptions)
		/// </summary>
		public EventActor[] Inclusions { get; set; }
		
		public GeneratedNotification[] Notifications { get; set; }
	}
	
	public class ProcessingIdentities
	{
		
		public System.Collections.Generic.Dictionary<string, ProcessingDiagnosticIdentity> ExcludedIdentities { get; set; }
		
		public System.Collections.Generic.Dictionary<string, ProcessingDiagnosticIdentity> IncludedIdentities { get; set; }
		
		public NotificationDiagnosticLogMessage[] Messages { get; set; }
		
		public string[] MissingIdentities { get; set; }
		
		public System.Collections.Generic.Dictionary<string, object> Properties { get; set; }
	}
	
	public class ProcessingDiagnosticIdentity
	{
		
		public string DeliveryPreference { get; set; }
		
		public System.Nullable<System.Boolean> IsActive { get; set; }
		
		public System.Nullable<System.Boolean> IsGroup { get; set; }
		
		public string Message { get; set; }
	}
	
	public class SubscriptionEvaluation
	{
		
		public SubscriptionEvaluationClause[] Clauses { get; set; }
		
		public DiagnosticIdentity User { get; set; }
	}
	
	public class SubscriptionEvaluationClause
	{
		
		public string Clause { get; set; }
		
		public System.Nullable<System.Int32> Order { get; set; }
		
		public System.Nullable<System.Boolean> Result { get; set; }
	}
	
	public class RoleBasedFilter
	{
		
		public string[] Exclusions { get; set; }
		
		public string[] Inclusions { get; set; }
	}
	
	public class ServiceBusSubscriptionChannel
	{
		
		public string Type { get; set; }
	}
	
	public class ServiceHooksSubscriptionChannel
	{
		
		public string Type { get; set; }
	}
	
	public class SoapSubscriptionChannel
	{
		
		public string Type { get; set; }
	}
	
	public class SubscriptionChannelWithAddress
	{
		
		public string Address { get; set; }
		
		public string Type { get; set; }
		
		public System.Nullable<System.Boolean> UseCustomAddress { get; set; }
	}
	
	/// <summary>
	/// Encapsulates the properties of a SubscriptionEvaluationRequest. It defines the subscription to be evaluated and time interval for events used in evaluation.
	/// </summary>
	public class SubscriptionEvaluationRequest
	{
		
		/// <summary>
		/// The min created date for the events used for matching in UTC. Use all events created since this date
		/// </summary>
		public System.Nullable<System.DateTimeOffset> MinEventsCreatedDate { get; set; }
		
		/// <summary>
		/// Parameters for creating a new subscription. A subscription defines criteria for matching events and how the subscription's subscriber should be notified about those events.
		/// </summary>
		public NotificationSubscriptionCreateParameters SubscriptionCreateParameters { get; set; }
	}
	
	/// <summary>
	/// Encapsulates the subscription evaluation results. It defines the Date Interval that was used, number of events evaluated and events and notifications results
	/// </summary>
	public class SubscriptionEvaluationResult
	{
		
		/// <summary>
		/// Subscription evaluation job status
		/// </summary>
		public SubscriptionEvaluationResultEvaluationJobStatus EvaluationJobStatus { get; set; }
		
		/// <summary>
		/// Encapsulates events result properties. It defines the total number of events used and the number of matched events.
		/// </summary>
		public EventsEvaluationResult Events { get; set; }
		
		/// <summary>
		/// The requestId which is the subscription evaluation jobId
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Encapsulates notifications result properties. It defines the number of notifications and the recipients of notifications.
		/// </summary>
		public NotificationsEvaluationResult Notifications { get; set; }
	}
	
	public enum SubscriptionEvaluationResultEvaluationJobStatus
	{
		
		notSet = 0,
		
		queued = 1,
		
		inProgress = 2,
		
		cancelled = 3,
		
		succeeded = 4,
		
		failed = 5,
		
		timedOut = 6,
		
		notFound = 7,
	}
	
	/// <summary>
	/// Encapsulates the subscription evaluation settings needed for the UI
	/// </summary>
	public class SubscriptionEvaluationSettings
	{
		
		/// <summary>
		/// Indicates whether subscription evaluation before saving is enabled or not
		/// </summary>
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Time interval to check on subscription evaluation job in seconds
		/// </summary>
		public System.Nullable<System.Int32> Interval { get; set; }
		
		/// <summary>
		/// Threshold on the number of notifications for considering a subscription too noisy
		/// </summary>
		public System.Nullable<System.Int32> Threshold { get; set; }
		
		/// <summary>
		/// Time out for the subscription evaluation check in seconds
		/// </summary>
		public System.Nullable<System.Int32> TimeOut { get; set; }
	}
	
	/// <summary>
	/// Notification subscriptions query input.
	/// </summary>
	public class SubscriptionQuery
	{
		
		/// <summary>
		/// One or more conditions to query on. If more than 2 conditions are specified, the combined results of each condition is returned (i.e. conditions are logically OR'ed).
		/// </summary>
		public SubscriptionQueryCondition[] Conditions { get; set; }
		
		/// <summary>
		/// Flags the refine the types of subscriptions that will be returned from the query.
		/// </summary>
		public SubscriptionQueryQueryFlags QueryFlags { get; set; }
	}
	
	/// <summary>
	/// Conditions a subscription must match to qualify for the query result set. Not all fields are required. A subscription must match all conditions specified in order to qualify for the result set.
	/// </summary>
	public class SubscriptionQueryCondition
	{
		
		public ISubscriptionFilter Filter { get; set; }
		
		/// <summary>
		/// Flags to specify the the type subscriptions to query for.
		/// </summary>
		public SubscriptionQueryConditionFlags Flags { get; set; }
		
		/// <summary>
		/// Scope that matching subscriptions must have.
		/// </summary>
		public string Scope { get; set; }
		
		/// <summary>
		/// ID of the subscriber (user or group) that matching subscriptions must be subscribed to.
		/// </summary>
		public string SubscriberId { get; set; }
		
		/// <summary>
		/// ID of the subscription to query for.
		/// </summary>
		public string SubscriptionId { get; set; }
	}
	
	public enum SubscriptionQueryConditionFlags
	{
		
		none = 0,
		
		groupSubscription = 1,
		
		contributedSubscription = 2,
		
		canOptOut = 3,
		
		teamSubscription = 4,
		
		oneActorMatches = 5,
	}
	
	public enum SubscriptionQueryQueryFlags
	{
		
		none = 0,
		
		includeInvalidSubscriptions = 1,
		
		includeDeletedSubscriptions = 2,
		
		includeFilterDetails = 3,
		
		alwaysReturnBasicInformation = 4,
		
		includeSystemSubscriptions = 5,
	}
	
	public class SubscriptionTraceDiagnosticLog
	{
		
		/// <summary>
		/// Indicates the job Id that processed or delivered this subscription
		/// </summary>
		public string JobId { get; set; }
		
		/// <summary>
		/// Indicates unique instance identifier for the job that processed or delivered this subscription
		/// </summary>
		public string JobInstanceId { get; set; }
		
		public string SubscriptionId { get; set; }
	}
	
	public class SubscriptionTraceEventProcessingLog
	{
		
		public string Channel { get; set; }
		
		public ProcessingIdentities EvaluationIdentities { get; set; }
		
		/// <summary>
		/// Which members opted out from receiving notifications from this subscription
		/// </summary>
		public DiagnosticIdentity[] OptedOut { get; set; }
		
		public System.Collections.Generic.Dictionary<string, ProcessedEvent> ProcessedEvents { get; set; }
	}
	
	public class SubscriptionTraceNotificationDeliveryLog
	{
		
		public DiagnosticNotification[] Notifications { get; set; }
	}
	
	public class UnsupportedFilter
	{
		
		public string Type { get; set; }
	}
	
	public class UnsupportedSubscriptionChannel
	{
		
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Parameters to update diagnostics settings for a subscription.
	/// </summary>
	public class UpdateSubscripitonDiagnosticsParameters
	{
		
		/// <summary>
		/// Parameters to update a specific diagnostic setting.
		/// </summary>
		public UpdateSubscripitonTracingParameters DeliveryResults { get; set; }
		
		/// <summary>
		/// Parameters to update a specific diagnostic setting.
		/// </summary>
		public UpdateSubscripitonTracingParameters DeliveryTracing { get; set; }
		
		/// <summary>
		/// Parameters to update a specific diagnostic setting.
		/// </summary>
		public UpdateSubscripitonTracingParameters EvaluationTracing { get; set; }
	}
	
	/// <summary>
	/// Parameters to update a specific diagnostic setting.
	/// </summary>
	public class UpdateSubscripitonTracingParameters
	{
		
		/// <summary>
		/// Indicates whether to enable to disable the diagnostic tracing.
		/// </summary>
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UserSubscriptionChannel
	{
		
		public string Type { get; set; }
	}
	
	public class UserSystemSubscriptionChannel
	{
		
		public string Type { get; set; }
	}
	
	/// <summary>
	/// This class is used to serialized collections as a single JSON object on the wire, to avoid serializing JSON arrays directly to the client, which can be a security hole
	/// </summary>
	public class VssJsonCollectionWrapper
	{
		
		public string Value { get; set; }
	}
	
	public class VssJsonCollectionWrapperBase
	{
		
		public System.Nullable<System.Int32> Count { get; set; }
	}
	
	/// <summary>
	/// This is the type used for firing notifications intended for the subsystem in the Notifications SDK. For components that can't take a dependency on the Notifications SDK directly, they can use ITeamFoundationEventService.PublishNotification and the Notifications SDK ISubscriber implementation will get it.
	/// </summary>
	public class VssNotificationEvent
	{
		
		/// <summary>
		/// Optional: A list of actors which are additional identities with corresponding roles that are relevant to the event.
		/// </summary>
		public EventActor[] Actors { get; set; }
		
		/// <summary>
		/// Optional: A list of artifacts referenced or impacted by this event.
		/// </summary>
		public string[] ArtifactUris { get; set; }
		
		/// <summary>
		/// Required: The event payload.  If Data is a string, it must be in Json or XML format.  Otherwise it must have a serialization format attribute.
		/// </summary>
		public string Data { get; set; }
		
		/// <summary>
		/// Required: The name of the event.  This event must be registered in the context it is being fired.
		/// </summary>
		public string EventType { get; set; }
		
		/// <summary>
		/// How long before the event expires and will be cleaned up.  The default is to use the system default.
		/// </summary>
		public string ExpiresIn { get; set; }
		
		/// <summary>
		/// The id of the item, artifact, extension, project, etc.
		/// </summary>
		public string ItemId { get; set; }
		
		/// <summary>
		/// How long to wait before processing this event.  The default is to process immediately.
		/// </summary>
		public string ProcessDelay { get; set; }
		
		/// <summary>
		/// Optional: A list of scopes which are are relevant to the event.
		/// </summary>
		public EventScope[] Scopes { get; set; }
		
		/// <summary>
		/// This is the time the original source event for this VssNotificationEvent was created.  For example, for something like a build completion notification SourceEventCreatedTime should be the time the build finished not the time this event was raised.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> SourceEventCreatedTime { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient client;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient client, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (client == null)
				throw new ArgumentNullException("Null HttpClient.", "client");

			if (client.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "client");

			this.client = client;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Get a list of diagnostic logs for this service.
		/// Diagnostic_Logs_List {organization}/_apis/notification/diagnosticlogs/{source}/entries/{entryId}
		/// </summary>
		/// <param name="source">ID specifying which type of logs to check diagnostics for.</param>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="entryId">The ID of the specific log to query for.</param>
		/// <param name="startTime">Start time for the time range to query in.</param>
		/// <param name="endTime">End time for the time range to query in.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<INotificationDiagnosticLog[]> Diagnostic_Logs_ListAsync(string source, string organization, string entryId, System.DateTimeOffset startTime, System.DateTimeOffset endTime, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/diagnosticlogs/"+ (source==null? "" : Uri.EscapeDataString(source))+"/entries/"+ (entryId==null? "" : Uri.EscapeDataString(entryId))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<INotificationDiagnosticLog[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a list of diagnostic logs for this service.
		/// Diagnostic_Logs_List {organization}/_apis/notification/diagnosticlogs/{source}/entries/{entryId}
		/// </summary>
		/// <param name="source">ID specifying which type of logs to check diagnostics for.</param>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="entryId">The ID of the specific log to query for.</param>
		/// <param name="startTime">Start time for the time range to query in.</param>
		/// <param name="endTime">End time for the time range to query in.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public INotificationDiagnosticLog[] Diagnostic_Logs_List(string source, string organization, string entryId, System.DateTimeOffset startTime, System.DateTimeOffset endTime, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/diagnosticlogs/"+ (source==null? "" : Uri.EscapeDataString(source))+"/entries/"+ (entryId==null? "" : Uri.EscapeDataString(entryId))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<INotificationDiagnosticLog[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List available event types for this service. Optionally filter by only event types for the specified publisher.
		/// Event_Types_List {organization}/_apis/notification/eventtypes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="publisherId">Limit to event types for this publisher</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<NotificationEventType[]> Event_Types_ListAsync(string organization, string publisherId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/eventtypes&publisherId=" + (publisherId==null? "" : Uri.EscapeDataString(publisherId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationEventType[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List available event types for this service. Optionally filter by only event types for the specified publisher.
		/// Event_Types_List {organization}/_apis/notification/eventtypes
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="publisherId">Limit to event types for this publisher</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public NotificationEventType[] Event_Types_List(string organization, string publisherId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/eventtypes&publisherId=" + (publisherId==null? "" : Uri.EscapeDataString(publisherId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationEventType[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a specific event type.
		/// Event_Types_Get {organization}/_apis/notification/eventtypes/{eventType}
		/// </summary>
		/// <param name="eventType">The ID of the event type.</param>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<NotificationEventType> Event_Types_GetAsync(string eventType, string organization, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/eventtypes/"+ (eventType==null? "" : Uri.EscapeDataString(eventType))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationEventType>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a specific event type.
		/// Event_Types_Get {organization}/_apis/notification/eventtypes/{eventType}
		/// </summary>
		/// <param name="eventType">The ID of the event type.</param>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public NotificationEventType Event_Types_Get(string eventType, string organization, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/eventtypes/"+ (eventType==null? "" : Uri.EscapeDataString(eventType))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationEventType>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Settings_Get {organization}/_apis/notification/settings
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<NotificationAdminSettings> Settings_GetAsync(string organization, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/settings&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationAdminSettings>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Settings_Get {organization}/_apis/notification/settings
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public NotificationAdminSettings Settings_Get(string organization, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/settings&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationAdminSettings>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Settings_Update {organization}/_apis/notification/settings
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<NotificationAdminSettings> Settings_UpdateAsync(string organization, string api_version, NotificationAdminSettingsUpdateParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/settings&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationAdminSettings>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Settings_Update {organization}/_apis/notification/settings
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public NotificationAdminSettings Settings_Update(string organization, string api_version, NotificationAdminSettingsUpdateParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/settings&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationAdminSettings>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get delivery preferences of a notifications subscriber.
		/// Subscribers_Get {organization}/_apis/notification/subscribers/{subscriberId}
		/// </summary>
		/// <param name="subscriberId">ID of the user or group.</param>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<NotificationSubscriber> Subscribers_GetAsync(string subscriberId, string organization, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscribers/"+ (subscriberId==null? "" : Uri.EscapeDataString(subscriberId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationSubscriber>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get delivery preferences of a notifications subscriber.
		/// Subscribers_Get {organization}/_apis/notification/subscribers/{subscriberId}
		/// </summary>
		/// <param name="subscriberId">ID of the user or group.</param>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public NotificationSubscriber Subscribers_Get(string subscriberId, string organization, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscribers/"+ (subscriberId==null? "" : Uri.EscapeDataString(subscriberId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationSubscriber>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update delivery preferences of a notifications subscriber.
		/// Subscribers_Update {organization}/_apis/notification/subscribers/{subscriberId}
		/// </summary>
		/// <param name="subscriberId">ID of the user or group.</param>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<NotificationSubscriber> Subscribers_UpdateAsync(string subscriberId, string organization, string api_version, NotificationSubscriberUpdateParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscribers/"+ (subscriberId==null? "" : Uri.EscapeDataString(subscriberId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationSubscriber>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update delivery preferences of a notifications subscriber.
		/// Subscribers_Update {organization}/_apis/notification/subscribers/{subscriberId}
		/// </summary>
		/// <param name="subscriberId">ID of the user or group.</param>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public NotificationSubscriber Subscribers_Update(string subscriberId, string organization, string api_version, NotificationSubscriberUpdateParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscribers/"+ (subscriberId==null? "" : Uri.EscapeDataString(subscriberId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationSubscriber>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Query for subscriptions. A subscription is returned if it matches one or more of the specified conditions.
		/// Subscriptions_Query {organization}/_apis/notification/subscriptionquery
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<NotificationSubscription[]> Subscriptions_QueryAsync(string organization, string api_version, SubscriptionQuery requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscriptionquery&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationSubscription[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Query for subscriptions. A subscription is returned if it matches one or more of the specified conditions.
		/// Subscriptions_Query {organization}/_apis/notification/subscriptionquery
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public NotificationSubscription[] Subscriptions_Query(string organization, string api_version, SubscriptionQuery requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscriptionquery&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationSubscription[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a new subscription.
		/// Subscriptions_Create {organization}/_apis/notification/subscriptions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<NotificationSubscription> Subscriptions_CreateAsync(string organization, string api_version, NotificationSubscriptionCreateParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscriptions&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationSubscription>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a new subscription.
		/// Subscriptions_Create {organization}/_apis/notification/subscriptions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public NotificationSubscription Subscriptions_Create(string organization, string api_version, NotificationSubscriptionCreateParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscriptions&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationSubscription>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a list of notification subscriptions, either by subscription IDs or by all subscriptions for a given user or group.
		/// Subscriptions_List {organization}/_apis/notification/subscriptions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="targetId">User or Group ID</param>
		/// <param name="ids">List of subscription IDs</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<NotificationSubscription[]> Subscriptions_ListAsync(string organization, string targetId, string ids, SubscriptionQueryQueryFlags queryFlags, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscriptions&targetId=" + (targetId==null? "" : Uri.EscapeDataString(targetId))+"&ids=" + (ids==null? "" : Uri.EscapeDataString(ids))+"&queryFlags=" + queryFlags+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationSubscription[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a list of notification subscriptions, either by subscription IDs or by all subscriptions for a given user or group.
		/// Subscriptions_List {organization}/_apis/notification/subscriptions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="targetId">User or Group ID</param>
		/// <param name="ids">List of subscription IDs</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public NotificationSubscription[] Subscriptions_List(string organization, string targetId, string ids, SubscriptionQueryQueryFlags queryFlags, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscriptions&targetId=" + (targetId==null? "" : Uri.EscapeDataString(targetId))+"&ids=" + (ids==null? "" : Uri.EscapeDataString(ids))+"&queryFlags=" + queryFlags+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationSubscription[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a subscription.
		/// Subscriptions_Delete {organization}/_apis/notification/subscriptions/{subscriptionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Subscriptions_DeleteAsync(string subscriptionId, string organization, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscriptions/"+ (subscriptionId==null? "" : Uri.EscapeDataString(subscriptionId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a subscription.
		/// Subscriptions_Delete {organization}/_apis/notification/subscriptions/{subscriptionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Subscriptions_Delete(string subscriptionId, string organization, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscriptions/"+ (subscriptionId==null? "" : Uri.EscapeDataString(subscriptionId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a notification subscription by its ID.
		/// Subscriptions_Get {organization}/_apis/notification/subscriptions/{subscriptionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<NotificationSubscription> Subscriptions_GetAsync(string subscriptionId, string organization, SubscriptionQueryQueryFlags queryFlags, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscriptions/"+ (subscriptionId==null? "" : Uri.EscapeDataString(subscriptionId))+"&queryFlags=" + queryFlags+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationSubscription>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a notification subscription by its ID.
		/// Subscriptions_Get {organization}/_apis/notification/subscriptions/{subscriptionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public NotificationSubscription Subscriptions_Get(string subscriptionId, string organization, SubscriptionQueryQueryFlags queryFlags, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscriptions/"+ (subscriptionId==null? "" : Uri.EscapeDataString(subscriptionId))+"&queryFlags=" + queryFlags+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationSubscription>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an existing subscription. Depending on the type of subscription and permissions, the caller can update the description, filter settings, channel (delivery) settings and more.
		/// Subscriptions_Update {organization}/_apis/notification/subscriptions/{subscriptionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<NotificationSubscription> Subscriptions_UpdateAsync(string subscriptionId, string organization, string api_version, NotificationSubscriptionUpdateParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscriptions/"+ (subscriptionId==null? "" : Uri.EscapeDataString(subscriptionId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationSubscription>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update an existing subscription. Depending on the type of subscription and permissions, the caller can update the description, filter settings, channel (delivery) settings and more.
		/// Subscriptions_Update {organization}/_apis/notification/subscriptions/{subscriptionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public NotificationSubscription Subscriptions_Update(string subscriptionId, string organization, string api_version, NotificationSubscriptionUpdateParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscriptions/"+ (subscriptionId==null? "" : Uri.EscapeDataString(subscriptionId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationSubscription>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the diagnostics settings for a subscription.
		/// Diagnostics_Get {organization}/_apis/notification/subscriptions/{subscriptionId}/diagnostics
		/// </summary>
		/// <param name="subscriptionId">The id of the notifications subscription.</param>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<SubscriptionDiagnostics> Diagnostics_GetAsync(string subscriptionId, string organization, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscriptions/"+ (subscriptionId==null? "" : Uri.EscapeDataString(subscriptionId))+"/diagnostics&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<SubscriptionDiagnostics>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the diagnostics settings for a subscription.
		/// Diagnostics_Get {organization}/_apis/notification/subscriptions/{subscriptionId}/diagnostics
		/// </summary>
		/// <param name="subscriptionId">The id of the notifications subscription.</param>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public SubscriptionDiagnostics Diagnostics_Get(string subscriptionId, string organization, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscriptions/"+ (subscriptionId==null? "" : Uri.EscapeDataString(subscriptionId))+"/diagnostics&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<SubscriptionDiagnostics>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the diagnostics settings for a subscription.
		/// Diagnostics_Update {organization}/_apis/notification/subscriptions/{subscriptionId}/diagnostics
		/// </summary>
		/// <param name="subscriptionId">The id of the notifications subscription.</param>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<SubscriptionDiagnostics> Diagnostics_UpdateAsync(string subscriptionId, string organization, string api_version, UpdateSubscripitonDiagnosticsParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscriptions/"+ (subscriptionId==null? "" : Uri.EscapeDataString(subscriptionId))+"/diagnostics&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<SubscriptionDiagnostics>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update the diagnostics settings for a subscription.
		/// Diagnostics_Update {organization}/_apis/notification/subscriptions/{subscriptionId}/diagnostics
		/// </summary>
		/// <param name="subscriptionId">The id of the notifications subscription.</param>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public SubscriptionDiagnostics Diagnostics_Update(string subscriptionId, string organization, string api_version, UpdateSubscripitonDiagnosticsParameters requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscriptions/"+ (subscriptionId==null? "" : Uri.EscapeDataString(subscriptionId))+"/diagnostics&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<SubscriptionDiagnostics>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update the specified user's settings for the specified subscription. This API is typically used to opt in or out of a shared subscription. User settings can only be applied to shared subscriptions, like team subscriptions or default subscriptions.
		/// Subscriptions_Update_Subscription_User_Settings {organization}/_apis/notification/Subscriptions/{subscriptionId}/usersettings/{userId}
		/// </summary>
		/// <param name="userId">ID of the user</param>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<SubscriptionUserSettings> Subscriptions_Update_Subscription_User_SettingsAsync(string subscriptionId, string userId, string organization, string api_version, SubscriptionUserSettings requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/Subscriptions/"+ (subscriptionId==null? "" : Uri.EscapeDataString(subscriptionId))+"/usersettings/"+ (userId==null? "" : Uri.EscapeDataString(userId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<SubscriptionUserSettings>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update the specified user's settings for the specified subscription. This API is typically used to opt in or out of a shared subscription. User settings can only be applied to shared subscriptions, like team subscriptions or default subscriptions.
		/// Subscriptions_Update_Subscription_User_Settings {organization}/_apis/notification/Subscriptions/{subscriptionId}/usersettings/{userId}
		/// </summary>
		/// <param name="userId">ID of the user</param>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public SubscriptionUserSettings Subscriptions_Update_Subscription_User_Settings(string subscriptionId, string userId, string organization, string api_version, SubscriptionUserSettings requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/Subscriptions/"+ (subscriptionId==null? "" : Uri.EscapeDataString(subscriptionId))+"/usersettings/"+ (userId==null? "" : Uri.EscapeDataString(userId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<SubscriptionUserSettings>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get available subscription templates.
		/// Subscriptions_Get_Subscription_Templates {organization}/_apis/notification/subscriptiontemplates
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<NotificationSubscriptionTemplate[]> Subscriptions_Get_Subscription_TemplatesAsync(string organization, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscriptiontemplates&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationSubscriptionTemplate[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get available subscription templates.
		/// Subscriptions_Get_Subscription_Templates {organization}/_apis/notification/subscriptiontemplates
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public NotificationSubscriptionTemplate[] Subscriptions_Get_Subscription_Templates(string organization, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/notification/subscriptiontemplates&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<NotificationSubscriptionTemplate[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
