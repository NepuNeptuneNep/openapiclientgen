//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Net.Http;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// A dual-purpose data object, the debug entry is used by the client to publish the symbol file (with file's blob identifier, which can be calculated from VSTS hashing algorithm) or query the file (with a client key). Since the symbol server tries to return a matched symbol file with the richest information level, it may not always point to the same symbol file for different queries with same client key.
	/// </summary>
	public class DebugEntry
	{
		
		/// <summary>
		/// BlobIdentifier with block hashes formatted to be deserialzied for symbol service.
		/// </summary>
		public JsonBlobIdentifierWithBlocks BlobDetails { get; set; }
		
		public JsonBlobIdentifier BlobIdentifier { get; set; }
		
		/// <summary>
		/// The URI to get the symbol file. Provided by the server, the URI contains authentication information and is readily accessible by plain HTTP GET request. The client is recommended to retrieve the file as soon as it can since the URI will expire in a short period.
		/// </summary>
		public string BlobUri { get; set; }
		
		/// <summary>
		/// A key the client (debugger, for example) uses to find the debug entry. Note it is not unique for each different symbol file as it does not distinguish between those which only differ by information level.
		/// </summary>
		public string ClientKey { get; set; }
		
		/// <summary>
		/// The information level this debug entry contains.
		/// </summary>
		public DebugEntryInformationLevel InformationLevel { get; set; }
		
		/// <summary>
		/// The identifier of symbol request to which this debug entry belongs.
		/// </summary>
		public string RequestId { get; set; }
		
		/// <summary>
		/// The size for the debug entry.
		/// </summary>
		public System.Nullable<System.Int64> Size { get; set; }
		
		/// <summary>
		/// The status of debug entry.
		/// </summary>
		public DebugEntryStatus Status { get; set; }
	}
	
	/// <summary>
	/// BlobIdentifier with block hashes formatted to be deserialzied for symbol service.
	/// </summary>
	public class JsonBlobIdentifierWithBlocks
	{
		
		/// <summary>
		/// List of blob block hashes.
		/// </summary>
		public JsonBlobBlockHash[] BlockHashes { get; set; }
		
		/// <summary>
		/// Array of blobId bytes.
		/// </summary>
		public string[] IdentifierValue { get; set; }
	}
	
	/// <summary>
	/// BlobBlock hash formatted to be deserialized for symbol service.
	/// </summary>
	public class JsonBlobBlockHash
	{
		
		/// <summary>
		/// Array of hash bytes.
		/// </summary>
		public string[] HashBytes { get; set; }
	}
	
	public class JsonBlobIdentifier
	{
		
		public string[] IdentifierValue { get; set; }
	}
	
	public enum DebugEntryInformationLevel
	{
		
		none = 0,
		
		binary = 1,
		
		publics = 2,
		
		traceFormatPresent = 3,
		
		typeInfo = 4,
		
		lineNumbers = 5,
		
		globalSymbols = 6,
		
		_private = 7,
		
		sourceIndexed = 8,
	}
	
	public enum DebugEntryStatus
	{
		
		none = 0,
		
		created = 1,
		
		blobMissing = 2,
	}
	
	/// <summary>
	/// A batch of debug entry to create.
	/// </summary>
	public class DebugEntryCreateBatch
	{
		
		/// <summary>
		/// Defines what to do when a debug entry in the batch already exists.
		/// </summary>
		public DebugEntryCreateBatchCreateBehavior CreateBehavior { get; set; }
		
		/// <summary>
		/// The debug entries.
		/// </summary>
		public DebugEntry[] DebugEntries { get; set; }
	}
	
	public enum DebugEntryCreateBatchCreateBehavior
	{
		
		throwIfExists = 0,
		
		skipIfExists = 1,
		
		overwriteIfExists = 2,
	}
	
	/// <summary>
	/// Symbol request.
	/// </summary>
	public class Request
	{
		
		/// <summary>
		/// An optional human-facing description.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// An optional expiration date for the request. The request will become inaccessible and get deleted after the date, regardless of its status.  On an HTTP POST, if expiration date is null/missing, the server will assign a default expiration data (30 days unless overwridden in the registry at the account level). On PATCH, if expiration date is null/missing, the behavior is to not change whatever the request's current expiration date is.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ExpirationDate { get; set; }
		
		/// <summary>
		/// A human-facing name for the request. Required on POST, ignored on PATCH.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// The total Size for this request.
		/// </summary>
		public System.Nullable<System.Int64> Size { get; set; }
		
		/// <summary>
		/// The status for this request.
		/// </summary>
		public RequestStatus Status { get; set; }
	}
	
	public enum RequestStatus
	{
		
		none = 0,
		
		created = 1,
		
		_sealed = 2,
		
		unavailable = 3,
	}
	
	public class ResourceBase
	{
		
		/// <summary>
		/// The ID of user who created this item. Optional.
		/// </summary>
		public string CreatedBy { get; set; }
		
		/// <summary>
		/// The date time when this item is created. Optional.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedDate { get; set; }
		
		/// <summary>
		/// An identifier for this item. Optional.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// An opaque ETag used to synchronize with the version stored at server end. Optional.
		/// </summary>
		public string StorageETag { get; set; }
		
		/// <summary>
		/// A URI which can be used to retrieve this item in its raw format. Optional. Note this is distinguished from other URIs that are present in a derived resource.
		/// </summary>
		public string Url { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient client;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient client, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (client == null)
				throw new ArgumentNullException("Null HttpClient.", "client");

			if (client.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "client");

			this.client = client;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Check the availability of symbol service. This includes checking for feature flag, and possibly license in future. Note this is NOT an anonymous endpoint, and the caller will be redirected to authentication before hitting it.
		/// Availability_Check_Availability {organization}/_apis/symbol/availability
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>The symbol service is available</returns>
		public async Task Availability_Check_AvailabilityAsync(string organization, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/symbol/availability&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check the availability of symbol service. This includes checking for feature flag, and possibly license in future. Note this is NOT an anonymous endpoint, and the caller will be redirected to authentication before hitting it.
		/// Availability_Check_Availability {organization}/_apis/symbol/availability
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>The symbol service is available</returns>
		public void Availability_Check_Availability(string organization, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/symbol/availability&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the client package.
		/// Client_Get {organization}/_apis/symbol/client/{clientType}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="clientType">Either "EXE" for a zip file containing a Windows symbol client (a.k.a. symbol.exe) along with dependencies, or "TASK" for a VSTS task that can be run on a VSTS build agent. All the other values are invalid. The parameter is case-insensitive.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>Successfully retrieved the client package. The user agent may read response body to get the package.</returns>
		public async Task<string> Client_GetAsync(string organization, string clientType, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/symbol/client/"+ (clientType==null? "" : Uri.EscapeDataString(clientType))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the client package.
		/// Client_Get {organization}/_apis/symbol/client/{clientType}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="clientType">Either "EXE" for a zip file containing a Windows symbol client (a.k.a. symbol.exe) along with dependencies, or "TASK" for a VSTS task that can be run on a VSTS build agent. All the other values are invalid. The parameter is case-insensitive.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>Successfully retrieved the client package. The user agent may read response body to get the package.</returns>
		public string Client_Get(string organization, string clientType, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/symbol/client/"+ (clientType==null? "" : Uri.EscapeDataString(clientType))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new symbol request.
		/// Requests_Create_Requests {organization}/_apis/symbol/requests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The symbol request to create.</param>
		public async Task Requests_Create_RequestsAsync(string organization, string api_version, Request requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/symbol/requests&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a new symbol request.
		/// Requests_Create_Requests {organization}/_apis/symbol/requests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">The symbol request to create.</param>
		public void Requests_Create_Requests(string organization, string api_version, Request requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/symbol/requests&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a symbol request by request name.
		/// Requests_Delete_Requests_Request_Name {organization}/_apis/symbol/requests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="requestName">The symbol request name.</param>
		/// <param name="synchronous">If true, delete all the debug entries under this request synchronously in the current session. If false, the deletion will be postponed to a later point and be executed automatically by the system.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>The request no longer exists.</returns>
		public async Task Requests_Delete_Requests_Request_NameAsync(string organization, string requestName, bool synchronous, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/symbol/requests&requestName=" + (requestName==null? "" : Uri.EscapeDataString(requestName))+"&synchronous="+synchronous+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a symbol request by request name.
		/// Requests_Delete_Requests_Request_Name {organization}/_apis/symbol/requests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="requestName">The symbol request name.</param>
		/// <param name="synchronous">If true, delete all the debug entries under this request synchronously in the current session. If false, the deletion will be postponed to a later point and be executed automatically by the system.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>The request no longer exists.</returns>
		public void Requests_Delete_Requests_Request_Name(string organization, string requestName, bool synchronous, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/symbol/requests&requestName=" + (requestName==null? "" : Uri.EscapeDataString(requestName))+"&synchronous="+synchronous+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a symbol request by request name.
		/// Requests_Get_Requests_Request_Name {organization}/_apis/symbol/requests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="requestName">The symbol request name.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>Successfully retrieved the symbol request as specified by the request name.</returns>
		public async Task<Request> Requests_Get_Requests_Request_NameAsync(string organization, string requestName, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/symbol/requests&requestName=" + (requestName==null? "" : Uri.EscapeDataString(requestName))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Request>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a symbol request by request name.
		/// Requests_Get_Requests_Request_Name {organization}/_apis/symbol/requests
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="requestName">The symbol request name.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>Successfully retrieved the symbol request as specified by the request name.</returns>
		public Request Requests_Get_Requests_Request_Name(string organization, string requestName, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/symbol/requests&requestName=" + (requestName==null? "" : Uri.EscapeDataString(requestName))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Request>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create debug entries for a symbol request as specified by its identifier.
		/// Requests_Create_Requests_Request_Id_Debug_Entries {organization}/_apis/symbol/requests/{requestId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="requestId">The symbol request identifier.</param>
		/// <param name="collection">A valid debug entry collection name. Must be "debugentries".</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">A batch that contains debug entries to create.</param>
		/// <returns>Successfully created debug entries for the specified request.</returns>
		public async Task<DebugEntry[]> Requests_Create_Requests_Request_Id_Debug_EntriesAsync(string organization, string requestId, string collection, string api_version, DebugEntryCreateBatch requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/symbol/requests/"+ (requestId==null? "" : Uri.EscapeDataString(requestId))+"&collection=" + (collection==null? "" : Uri.EscapeDataString(collection))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DebugEntry[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create debug entries for a symbol request as specified by its identifier.
		/// Requests_Create_Requests_Request_Id_Debug_Entries {organization}/_apis/symbol/requests/{requestId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="requestId">The symbol request identifier.</param>
		/// <param name="collection">A valid debug entry collection name. Must be "debugentries".</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">A batch that contains debug entries to create.</param>
		/// <returns>Successfully created debug entries for the specified request.</returns>
		public DebugEntry[] Requests_Create_Requests_Request_Id_Debug_Entries(string organization, string requestId, string collection, string api_version, DebugEntryCreateBatch requestBody)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/symbol/requests/"+ (requestId==null? "" : Uri.EscapeDataString(requestId))+"&collection=" + (collection==null? "" : Uri.EscapeDataString(collection))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DebugEntry[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a symbol request by request identifier.
		/// Requests_Delete_Requests_Request_Id {organization}/_apis/symbol/requests/{requestId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="requestId">The symbol request identifier.</param>
		/// <param name="synchronous">If true, delete all the debug entries under this request synchronously in the current session. If false, the deletion will be postponed to a later point and be executed automatically by the system.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>The request no longer exists.</returns>
		public async Task Requests_Delete_Requests_Request_IdAsync(string organization, string requestId, bool synchronous, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/symbol/requests/"+ (requestId==null? "" : Uri.EscapeDataString(requestId))+"&synchronous="+synchronous+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a symbol request by request identifier.
		/// Requests_Delete_Requests_Request_Id {organization}/_apis/symbol/requests/{requestId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="requestId">The symbol request identifier.</param>
		/// <param name="synchronous">If true, delete all the debug entries under this request synchronously in the current session. If false, the deletion will be postponed to a later point and be executed automatically by the system.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>The request no longer exists.</returns>
		public void Requests_Delete_Requests_Request_Id(string organization, string requestId, bool synchronous, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/symbol/requests/"+ (requestId==null? "" : Uri.EscapeDataString(requestId))+"&synchronous="+synchronous+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a symbol request by request identifier.
		/// Requests_Get_Requests_Request_Id {organization}/_apis/symbol/requests/{requestId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="requestId">The symbol request identifier.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>Successfully retrieved the symbol request as specified by the request identifier.</returns>
		public async Task<Request> Requests_Get_Requests_Request_IdAsync(string organization, string requestId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/symbol/requests/"+ (requestId==null? "" : Uri.EscapeDataString(requestId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Request>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a symbol request by request identifier.
		/// Requests_Get_Requests_Request_Id {organization}/_apis/symbol/requests/{requestId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="requestId">The symbol request identifier.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>Successfully retrieved the symbol request as specified by the request identifier.</returns>
		public Request Requests_Get_Requests_Request_Id(string organization, string requestId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/symbol/requests/"+ (requestId==null? "" : Uri.EscapeDataString(requestId))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var stream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Request>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Given a client key, returns the best matched debug entry.
		/// Symsrv_Get {organization}/_apis/symbol/symsrv/{debugEntryClientKey}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="debugEntryClientKey">A "client key" used by both ends of Microsoft's symbol protocol to identify a debug entry. The semantics of client key is governed by symsrv and is beyond the scope of this documentation.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		public async Task Symsrv_GetAsync(string organization, string debugEntryClientKey, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/symbol/symsrv/"+ (debugEntryClientKey==null? "" : Uri.EscapeDataString(debugEntryClientKey))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Given a client key, returns the best matched debug entry.
		/// Symsrv_Get {organization}/_apis/symbol/symsrv/{debugEntryClientKey}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="debugEntryClientKey">A "client key" used by both ends of Microsoft's symbol protocol to identify a debug entry. The semantics of client key is governed by symsrv and is beyond the scope of this documentation.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		public void Symsrv_Get(string organization, string debugEntryClientKey, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : Uri.EscapeDataString(organization))+"/_apis/symbol/symsrv/"+ (debugEntryClientKey==null? "" : Uri.EscapeDataString(debugEntryClientKey))+"&api-version=" + (api_version==null? "" : Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
