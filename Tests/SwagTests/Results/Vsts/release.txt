//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	public class AgentArtifactDefinition
	{
		
		/// <summary>
		/// Gets or sets the artifact definition alias.
		/// </summary>
		public string Alias { get; set; }
		
		/// <summary>
		/// Gets or sets the artifact type.
		/// </summary>
		public System.Nullable<AgentArtifactDefinitionArtifactType> ArtifactType { get; set; }
		
		/// <summary>
		/// Gets or sets the artifact definition details.
		/// </summary>
		public string Details { get; set; }
		
		/// <summary>
		/// Gets or sets the name of artifact definition.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the version of artifact definition.
		/// </summary>
		public string Version { get; set; }
	}
	
	public enum AgentArtifactDefinitionArtifactType
	{
		
		xamlBuild = 0,
		
		build = 1,
		
		jenkins = 2,
		
		fileShare = 3,
		
		nuget = 4,
		
		tfsOnPrem = 5,
		
		gitHub = 6,
		
		tfGit = 7,
		
		externalTfsBuild = 8,
		
		custom = 9,
		
		tfvc = 10,
	}
	
	public class AgentBasedDeployPhase
	{
		
		public AgentDeploymentInput DeploymentInput { get; set; }
	}
	
	public class AgentDeploymentInput
	{
		
		/// <summary>
		/// Specification of the agent defined by the pool provider.
		/// </summary>
		public AgentSpecification AgentSpecification { get; set; }
		
		/// <summary>
		/// Gets or sets the image ID.
		/// </summary>
		public System.Nullable<System.Int32> ImageId { get; set; }
		
		public ExecutionInput ParallelExecution { get; set; }
	}
	
	/// <summary>
	/// Specification of the agent defined by the pool provider.
	/// </summary>
	public class AgentSpecification
	{
		
		/// <summary>
		/// Agent specification unique identifier.
		/// </summary>
		public string Identifier { get; set; }
	}
	
	public class ExecutionInput
	{
		
		/// <summary>
		/// Parallel execution type, for example MultiConfiguration or MultiMachine.
		/// </summary>
		public System.Nullable<ExecutionInputParallelExecutionType> ParallelExecutionType { get; set; }
	}
	
	public enum ExecutionInputParallelExecutionType
	{
		
		none = 0,
		
		multiConfiguration = 1,
		
		multiMachine = 2,
	}
	
	/// <summary>
	/// Represents a reference to an agent queue.
	/// </summary>
	public class AgentPoolQueueReference
	{
		
		/// <summary>
		/// The ID of the queue.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
	}
	
	public class ApprovalOptions
	{
		
		/// <summary>
		/// Specify whether the approval can be skipped if the same approver approved the previous stage.
		/// </summary>
		public System.Nullable<System.Boolean> AutoTriggeredAndPreviousEnvironmentApprovedCanBeSkipped { get; set; }
		
		/// <summary>
		/// Specify whether revalidate identity of approver before completing the approval.
		/// </summary>
		public System.Nullable<System.Boolean> EnforceIdentityRevalidation { get; set; }
		
		/// <summary>
		/// Approvals execution order.
		/// </summary>
		public System.Nullable<ApprovalOptionsExecutionOrder> ExecutionOrder { get; set; }
		
		/// <summary>
		/// Specify whether the user requesting a release or deployment should allow to approver.
		/// </summary>
		public System.Nullable<System.Boolean> ReleaseCreatorCanBeApprover { get; set; }
		
		/// <summary>
		/// The number of approvals required to move release forward. '0' means all approvals required.
		/// </summary>
		public System.Nullable<System.Int32> RequiredApproverCount { get; set; }
		
		/// <summary>
		/// Approval timeout. Approval default timeout is 30 days. Maximum allowed timeout is 365 days. '0' means default timeout i.e 30 days.
		/// </summary>
		public System.Nullable<System.Int32> TimeoutInMinutes { get; set; }
	}
	
	public enum ApprovalOptionsExecutionOrder
	{
		
		beforeGates = 0,
		
		afterSuccessfulGates = 1,
		
		afterGatesAlways = 2,
	}
	
	public class Artifact
	{
		
		/// <summary>
		/// Gets or sets alias.
		/// </summary>
		public string Alias { get; set; }
		
		/// <summary>
		/// Gets or sets definition reference. e.g. {"project":{"id":"fed755ea-49c5-4399-acea-fd5b5aa90a6c","name":"myProject"},"definition":{"id":"1","name":"mybuildDefinition"},"connection":{"id":"1","name":"myConnection"}}.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, ArtifactSourceReference> DefinitionReference { get; set; }
		
		/// <summary>
		/// Indicates whether artifact is primary or not.
		/// </summary>
		public System.Nullable<System.Boolean> IsPrimary { get; set; }
		
		/// <summary>
		/// Indicates whether artifact is retained by release or not.
		/// </summary>
		public System.Nullable<System.Boolean> IsRetained { get; set; }
		
		/// <summary>
		/// Gets or sets type. It can have value as 'Build', 'Jenkins', 'GitHub', 'Nuget', 'Team Build (external)', 'ExternalTFSBuild', 'Git', 'TFVC', 'ExternalTfsXamlBuild'.
		/// </summary>
		public string Type { get; set; }
	}
	
	public class ArtifactSourceReference
	{
		
		/// <summary>
		/// ID of the artifact source.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the artifact source.
		/// </summary>
		public string Name { get; set; }
	}
	
	public class ArtifactContributionDefinition
	{
		
		public ArtifactTriggerConfiguration ArtifactTriggerConfiguration { get; set; }
		
		public string ArtifactType { get; set; }
		
		public System.Collections.Generic.Dictionary<string, string> ArtifactTypeStreamMapping { get; set; }
		
		public System.Collections.Generic.Dictionary<string, string> BrowsableArtifactTypeMapping { get; set; }
		
		public DataSourceBinding[] DataSourceBindings { get; set; }
		
		public string DisplayName { get; set; }
		
		public string DownloadTaskId { get; set; }
		
		public string EndpointTypeId { get; set; }
		
		public InputDescriptor[] InputDescriptors { get; set; }
		
		public System.Nullable<System.Boolean> IsCommitsTraceabilitySupported { get; set; }
		
		public System.Nullable<System.Boolean> IsWorkitemsTraceabilitySupported { get; set; }
		
		public string Name { get; set; }
		
		public System.Collections.Generic.Dictionary<string, string> TaskInputMapping { get; set; }
		
		public string UniqueSourceIdentifier { get; set; }
	}
	
	public class ArtifactTriggerConfiguration
	{
		
		/// <summary>
		/// Gets or sets the whether trigger is supported or not.
		/// </summary>
		public System.Nullable<System.Boolean> IsTriggerSupported { get; set; }
		
		/// <summary>
		/// Gets or sets the whether trigger is supported only on hosted environment.
		/// </summary>
		public System.Nullable<System.Boolean> IsTriggerSupportedOnlyInHosted { get; set; }
		
		/// <summary>
		/// Gets or sets the whether webhook is supported at server level.
		/// </summary>
		public System.Nullable<System.Boolean> IsWebhookSupportedAtServerLevel { get; set; }
		
		/// <summary>
		/// Gets or sets the payload hash header name for the artifact trigger configuration.
		/// </summary>
		public string PayloadHashHeaderName { get; set; }
		
		/// <summary>
		/// Gets or sets the resources for artifact trigger configuration.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, string> Resources { get; set; }
		
		/// <summary>
		/// Gets or sets the webhook payload mapping for artifact trigger configuration.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, string> WebhookPayloadMapping { get; set; }
	}
	
	public class DataSourceBinding
	{
		
		/// <summary>
		/// Pagination format supported by this data source(ContinuationToken/SkipTop).
		/// </summary>
		public string CallbackContextTemplate { get; set; }
		
		/// <summary>
		/// Subsequent calls needed?
		/// </summary>
		public string CallBackRequiredTemplate { get; set; }
		
		/// <summary>
		/// Name of the datasource.
		/// </summary>
		public string DataSourceName { get; set; }
		
		/// <summary>
		/// Endpoint ID of the datasource.
		/// </summary>
		public string EndpointId { get; set; }
		
		/// <summary>
		/// Endpoint URL of the datasource.
		/// </summary>
		public string EndpointUrl { get; set; }
		
		/// <summary>
		/// Defines the initial value of the query params
		/// </summary>
		public string InitialContextTemplate { get; set; }
		
		/// <summary>
		/// Parameters of the datasource.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, string> Parameters { get; set; }
		
		/// <summary>
		/// Gets or sets http request body
		/// </summary>
		public string RequestContent { get; set; }
		
		/// <summary>
		/// Gets or sets http request verb
		/// </summary>
		public string RequestVerb { get; set; }
		
		/// <summary>
		/// Result selector applied on output of datasource result, for example jsonpath:$.value[?(@.properties.isEnabled == true)].
		/// </summary>
		public string ResultSelector { get; set; }
		
		/// <summary>
		/// Format of the return results, for example. { "Value" : "{{{id}}}", "DisplayValue" : "{{{name}}}" }.
		/// </summary>
		public string ResultTemplate { get; set; }
		
		/// <summary>
		/// Target of the datasource.
		/// </summary>
		public string Target { get; set; }
	}
	
	/// <summary>
	/// Describes an input for subscriptions.
	/// </summary>
	public class InputDescriptor
	{
		
		/// <summary>
		/// The ids of all inputs that the value of this input is dependent on.
		/// </summary>
		public string[] DependencyInputIds { get; set; }
		
		/// <summary>
		/// Description of what this input is used for
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// The group localized name to which this input belongs and can be shown as a header for the container that will include all the inputs in the group.
		/// </summary>
		public string GroupName { get; set; }
		
		/// <summary>
		/// If true, the value information for this input is dynamic and should be fetched when the value of dependency inputs change.
		/// </summary>
		public System.Nullable<System.Boolean> HasDynamicValueInformation { get; set; }
		
		/// <summary>
		/// Identifier for the subscription input
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Mode in which the value of this input should be entered
		/// </summary>
		public System.Nullable<InputDescriptorInputMode> InputMode { get; set; }
		
		/// <summary>
		/// Gets whether this input is confidential, such as for a password or application key
		/// </summary>
		public System.Nullable<System.Boolean> IsConfidential { get; set; }
		
		/// <summary>
		/// Localized name which can be shown as a label for the subscription input
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Custom properties for the input which can be used by the service provider
		/// </summary>
		public System.Collections.Generic.Dictionary<string, object> Properties { get; set; }
		
		/// <summary>
		/// Underlying data type for the input value. When this value is specified, InputMode, Validation and Values are optional.
		/// </summary>
		public string Type { get; set; }
		
		/// <summary>
		/// Gets whether this input is included in the default generated action description.
		/// </summary>
		public System.Nullable<System.Boolean> UseInDefaultDescription { get; set; }
		
		/// <summary>
		/// Describes what values are valid for a subscription input
		/// </summary>
		public InputValidation Validation { get; set; }
		
		/// <summary>
		/// A hint for input value. It can be used in the UI as the input placeholder.
		/// </summary>
		public string ValueHint { get; set; }
		
		/// <summary>
		/// Information about the possible/allowed values for a given subscription input
		/// </summary>
		public InputValues Values { get; set; }
	}
	
	public enum InputDescriptorInputMode
	{
		
		none = 0,
		
		textBox = 1,
		
		passwordBox = 2,
		
		combo = 3,
		
		radioButtons = 4,
		
		checkBox = 5,
		
		textArea = 6,
	}
	
	/// <summary>
	/// Describes what values are valid for a subscription input
	/// </summary>
	public class InputValidation
	{
		
		/// <summary>
		/// Gets or sets the data data type to validate.
		/// </summary>
		public System.Nullable<InputValidationDataType> DataType { get; set; }
		
		/// <summary>
		/// Gets or sets if this is a required field.
		/// </summary>
		public System.Nullable<System.Boolean> IsRequired { get; set; }
		
		/// <summary>
		/// Gets or sets the maximum length of this descriptor.
		/// </summary>
		public System.Nullable<System.Int32> MaxLength { get; set; }
		
		/// <summary>
		/// Gets or sets the minimum value for this descriptor.
		/// </summary>
		public string MaxValue { get; set; }
		
		/// <summary>
		/// Gets or sets the minimum length of this descriptor.
		/// </summary>
		public System.Nullable<System.Int32> MinLength { get; set; }
		
		/// <summary>
		/// Gets or sets the minimum value for this descriptor.
		/// </summary>
		public string MinValue { get; set; }
		
		/// <summary>
		/// Gets or sets the pattern to validate.
		/// </summary>
		public string Pattern { get; set; }
		
		/// <summary>
		/// Gets or sets the error on pattern mismatch.
		/// </summary>
		public string PatternMismatchErrorMessage { get; set; }
	}
	
	public enum InputValidationDataType
	{
		
		none = 0,
		
		_string = 1,
		
		number = 2,
		
		boolean = 3,
		
		guid = 4,
		
		uri = 5,
	}
	
	/// <summary>
	/// Information about the possible/allowed values for a given subscription input
	/// </summary>
	public class InputValues
	{
		
		/// <summary>
		/// The default value to use for this input
		/// </summary>
		public string DefaultValue { get; set; }
		
		/// <summary>
		/// Error information related to a subscription input value.
		/// </summary>
		public InputValuesError Error { get; set; }
		
		/// <summary>
		/// The id of the input
		/// </summary>
		public string InputId { get; set; }
		
		/// <summary>
		/// Should this input be disabled
		/// </summary>
		public System.Nullable<System.Boolean> IsDisabled { get; set; }
		
		/// <summary>
		/// Should the value be restricted to one of the values in the PossibleValues (True) or are the values in PossibleValues just a suggestion (False)
		/// </summary>
		public System.Nullable<System.Boolean> IsLimitedToPossibleValues { get; set; }
		
		/// <summary>
		/// Should this input be made read-only
		/// </summary>
		public System.Nullable<System.Boolean> IsReadOnly { get; set; }
		
		/// <summary>
		/// Possible values that this input can take
		/// </summary>
		public InputValue[] PossibleValues { get; set; }
	}
	
	/// <summary>
	/// Error information related to a subscription input value.
	/// </summary>
	public class InputValuesError
	{
		
		/// <summary>
		/// The error message.
		/// </summary>
		public string Message { get; set; }
	}
	
	/// <summary>
	/// Information about a single value for an input
	/// </summary>
	public class InputValue
	{
		
		/// <summary>
		/// Any other data about this input
		/// </summary>
		public System.Collections.Generic.Dictionary<string, object> Data { get; set; }
		
		/// <summary>
		/// The text to show for the display of this value
		/// </summary>
		public string DisplayValue { get; set; }
		
		/// <summary>
		/// The value to store for this input
		/// </summary>
		public string Value { get; set; }
	}
	
	public class ArtifactDownloadInputBase
	{
		
		/// <summary>
		/// Gets or sets the alias of artifact.
		/// </summary>
		public string Alias { get; set; }
		
		/// <summary>
		/// Gets or sets the name of artifact definition. Valid values are 'Skip', 'Selective', 'All'.
		/// </summary>
		public string ArtifactDownloadMode { get; set; }
		
		/// <summary>
		/// Gets or sets the artifact items of the input.
		/// </summary>
		public string[] ArtifactItems { get; set; }
		
		/// <summary>
		/// Gets or sets the type of artifact.
		/// </summary>
		public string ArtifactType { get; set; }
	}
	
	public class ArtifactFilter
	{
		
		/// <summary>
		/// Gets or sets whether a release should be created on build tagging.
		/// </summary>
		public System.Nullable<System.Boolean> CreateReleaseOnBuildTagging { get; set; }
		
		/// <summary>
		/// Gets or sets the branch for the filter.
		/// </summary>
		public string SourceBranch { get; set; }
		
		public TagFilter TagFilter { get; set; }
		
		/// <summary>
		/// Gets or sets the list of tags for the filter.
		/// </summary>
		public string[] Tags { get; set; }
		
		/// <summary>
		/// Gets or sets whether filter should default to build definition branch.
		/// </summary>
		public System.Nullable<System.Boolean> UseBuildDefinitionBranch { get; set; }
	}
	
	public class TagFilter
	{
		
		/// <summary>
		/// Gets or sets the tag filter pattern.
		/// </summary>
		public string Pattern { get; set; }
	}
	
	public class ArtifactInstanceData
	{
		
		public string AccountName { get; set; }
		
		public string AuthenticationToken { get; set; }
		
		public string TfsUrl { get; set; }
		
		public string Version { get; set; }
	}
	
	public class ArtifactMetadata
	{
		
		/// <summary>
		/// Sets alias of artifact.
		/// </summary>
		public string Alias { get; set; }
		
		public BuildVersion InstanceReference { get; set; }
	}
	
	public class BuildVersion
	{
		
		/// <summary>
		/// Gets or sets the commit message for the artifact.
		/// </summary>
		public string CommitMessage { get; set; }
		
		/// <summary>
		/// Gets or sets the definition id.
		/// </summary>
		public string DefinitionId { get; set; }
		
		/// <summary>
		/// Gets or sets the definition name.
		/// </summary>
		public string DefinitionName { get; set; }
		
		/// <summary>
		/// Gets or sets the build id.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets if the artifact supports multiple definitions.
		/// </summary>
		public System.Nullable<System.Boolean> IsMultiDefinitionType { get; set; }
		
		/// <summary>
		/// Gets or sets the build number.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the source branch for the artifact.
		/// </summary>
		public string SourceBranch { get; set; }
		
		public SourcePullRequestVersion SourcePullRequestVersion { get; set; }
		
		/// <summary>
		/// Gets or sets the repository id for the artifact.
		/// </summary>
		public string SourceRepositoryId { get; set; }
		
		/// <summary>
		/// Gets or sets the repository type for the artifact.
		/// </summary>
		public string SourceRepositoryType { get; set; }
		
		/// <summary>
		/// Gets or sets the source version for the artifact.
		/// </summary>
		public string SourceVersion { get; set; }
	}
	
	public class SourcePullRequestVersion
	{
		
		/// <summary>
		/// Pull Request Iteration Id for which the release will publish status.
		/// </summary>
		public string IterationId { get; set; }
		
		/// <summary>
		/// Pull Request Id for which the release will publish status.
		/// </summary>
		public string PullRequestId { get; set; }
		
		/// <summary>
		/// Date and time of the pull request merge creation. It is required to keep timeline record of Releases created by pull request.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> PullRequestMergedAt { get; set; }
		
		/// <summary>
		/// Source branch of the Pull Request.
		/// </summary>
		public string SourceBranch { get; set; }
		
		/// <summary>
		/// Source branch commit Id of the Pull Request for which the release will publish status.
		/// </summary>
		public string SourceBranchCommitId { get; set; }
		
		/// <summary>
		/// Target branch of the Pull Request.
		/// </summary>
		public string TargetBranch { get; set; }
	}
	
	public class ArtifactProvider
	{
		
		/// <summary>
		/// Gets or sets the id of artifact provider.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Gets or sets the name of artifact provider.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the link of artifact provider.
		/// </summary>
		public string SourceUri { get; set; }
		
		/// <summary>
		/// Gets or sets the version of artifact provider.
		/// </summary>
		public string Version { get; set; }
	}
	
	public class ArtifactsDownloadInput
	{
		
		public ArtifactDownloadInputBase[] DownloadInputs { get; set; }
	}
	
	public class ArtifactSourceId
	{
		
		/// <summary>
		/// Gets or sets the artifact type of artifact source.
		/// </summary>
		public string ArtifactTypeId { get; set; }
		
		/// <summary>
		/// Gets or sets the list of sourceIdInput of artifact source.
		/// </summary>
		public SourceIdInput[] SourceIdInputs { get; set; }
	}
	
	public class SourceIdInput
	{
		
		/// <summary>
		/// ID of source.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the source.
		/// </summary>
		public string Name { get; set; }
	}
	
	public class ArtifactSourceIdsQueryResult
	{
		
		/// <summary>
		/// Gets or sets the list of artifactsourceIds.
		/// </summary>
		public ArtifactSourceId[] ArtifactSourceIds { get; set; }
	}
	
	public class ArtifactSourceTrigger
	{
		
		/// <summary>
		/// Artifact source alias for Artifact Source trigger type
		/// </summary>
		public string ArtifactAlias { get; set; }
		
		public ArtifactFilter[] TriggerConditions { get; set; }
	}
	
	public class ArtifactTypeDefinition
	{
		
		public ArtifactTriggerConfiguration ArtifactTriggerConfiguration { get; set; }
		
		/// <summary>
		/// Gets or sets the artifact type of artifact type definition. Valid values are 'Build', 'Package', 'Source' or 'ContainerImage'.
		/// </summary>
		public string ArtifactType { get; set; }
		
		/// <summary>
		/// Gets or sets the display name of artifact type definition.
		/// </summary>
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Gets or sets the endpoint type id of artifact type definition.
		/// </summary>
		public string EndpointTypeId { get; set; }
		
		/// <summary>
		/// Gets or sets the input descriptors of artifact type definition.
		/// </summary>
		public InputDescriptor[] InputDescriptors { get; set; }
		
		/// <summary>
		/// Gets or sets the is commits tracebility supported value of artifact type defintion.
		/// </summary>
		public System.Nullable<System.Boolean> IsCommitsTraceabilitySupported { get; set; }
		
		/// <summary>
		/// Gets or sets the is workitems tracebility supported value of artifact type defintion.
		/// </summary>
		public System.Nullable<System.Boolean> IsWorkitemsTraceabilitySupported { get; set; }
		
		/// <summary>
		/// Gets or sets the name of artifact type definition.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the unique source identifier of artifact type definition.
		/// </summary>
		public string UniqueSourceIdentifier { get; set; }
	}
	
	public class ArtifactVersion
	{
		
		/// <summary>
		/// Gets or sets the alias of artifact.
		/// </summary>
		public string Alias { get; set; }
		
		public BuildVersion DefaultVersion { get; set; }
		
		/// <summary>
		/// Gets or sets the error message encountered during querying of versions for artifact.
		/// </summary>
		public string ErrorMessage { get; set; }
		
		/// <summary>
		/// Gets or sets the list of build versions of artifact.
		/// </summary>
		public BuildVersion[] Versions { get; set; }
	}
	
	public class ArtifactVersionQueryResult
	{
		
		/// <summary>
		/// Gets or sets the list for artifact versions of artifact version query result.
		/// </summary>
		public ArtifactVersion[] ArtifactVersions { get; set; }
	}
	
	public class AuthorizationHeader
	{
		
		public string Name { get; set; }
		
		public string Value { get; set; }
	}
	
	public class AutoTriggerIssue
	{
		
		public Issue Issue { get; set; }
		
		public System.Nullable<AutoTriggerIssueIssueSource> IssueSource { get; set; }
		
		public ProjectReference Project { get; set; }
		
		public ReleaseDefinitionShallowReference ReleaseDefinitionReference { get; set; }
		
		public System.Nullable<AutoTriggerIssueReleaseTriggerType> ReleaseTriggerType { get; set; }
	}
	
	public class Issue
	{
		
		/// <summary>
		/// Issue data.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, string> Data { get; set; }
		
		/// <summary>
		/// Issue type, for example error, warning or info.
		/// </summary>
		public string IssueType { get; set; }
		
		/// <summary>
		/// Issue message.
		/// </summary>
		public string Message { get; set; }
	}
	
	public enum AutoTriggerIssueIssueSource
	{
		
		none = 0,
		
		user = 1,
		
		system = 2,
	}
	
	public class ProjectReference
	{
		
		/// <summary>
		/// Gets the unique identifier of this field.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Gets name of project.
		/// </summary>
		public string Name { get; set; }
	}
	
	public class ReleaseDefinitionShallowReference
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// Gets the unique identifier of release definition.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the release definition.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the path of the release definition.
		/// </summary>
		public string Path { get; set; }
		
		public ProjectReference ProjectReference { get; set; }
		
		/// <summary>
		/// Gets the REST API url to access the release definition.
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// The class to represent a collection of REST reference links.
	/// </summary>
	public class ReferenceLinks
	{
		
		/// <summary>
		/// The readonly view of the links.  Because Reference links are readonly, we only want to expose them as read only.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, object> Links { get; set; }
	}
	
	public enum AutoTriggerIssueReleaseTriggerType
	{
		
		undefined = 0,
		
		artifactSource = 1,
		
		schedule = 2,
		
		sourceRepo = 3,
		
		containerImage = 4,
		
		_package = 5,
		
		pullRequest = 6,
	}
	
	public class AzureKeyVaultVariableGroupProviderData
	{
		
		/// <summary>
		/// Gets or sets last refreshed time.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastRefreshedOn { get; set; }
		
		/// <summary>
		/// Gets or sets the service endpoint ID.
		/// </summary>
		public string ServiceEndpointId { get; set; }
		
		/// <summary>
		/// Gets or sets the vault name.
		/// </summary>
		public string Vault { get; set; }
	}
	
	public class AzureKeyVaultVariableValue
	{
		
		/// <summary>
		/// Gets or sets the content type of key vault variable value.
		/// </summary>
		public string ContentType { get; set; }
		
		/// <summary>
		/// Indicates the vault variable value enabled or not.
		/// </summary>
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Gets or sets the expire time of key vault variable value.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> Expires { get; set; }
	}
	
	public class BaseDeploymentInput
	{
		
		/// <summary>
		/// Gets or sets the job condition.
		/// </summary>
		public string Condition { get; set; }
		
		/// <summary>
		/// Gets or sets the job cancel timeout in minutes for deployment which are cancelled by user for this release environment.
		/// </summary>
		public System.Nullable<System.Int32> JobCancelTimeoutInMinutes { get; set; }
		
		/// <summary>
		/// Gets or sets the override inputs.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, string> OverrideInputs { get; set; }
		
		/// <summary>
		/// Gets or sets the job execution timeout in minutes for deployment which are queued against this release environment.
		/// </summary>
		public System.Nullable<System.Int32> TimeoutInMinutes { get; set; }
	}
	
	public class BuildArtifactDownloadInput
	{
	}
	
	/// <summary>
	/// Represents a change associated with a build.
	/// </summary>
	public class Change
	{
		
		public IdentityRef Author { get; set; }
		
		/// <summary>
		/// The type of source. "TfsVersionControl", "TfsGit", etc.
		/// </summary>
		public string ChangeType { get; set; }
		
		/// <summary>
		/// The location of a user-friendly representation of the resource.
		/// </summary>
		public string DisplayUri { get; set; }
		
		/// <summary>
		/// Something that identifies the change. For a commit, this would be the SHA1. For a TFVC changeset, this would be the changeset id.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// The location of the full representation of the resource.
		/// </summary>
		public string Location { get; set; }
		
		/// <summary>
		/// A description of the change. This might be a commit message or changeset description.
		/// </summary>
		public string Message { get; set; }
		
		public IdentityRef PushedBy { get; set; }
		
		/// <summary>
		/// A timestamp for the change.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> Timestamp { get; set; }
	}
	
	public class IdentityRef
	{
		
		/// <summary>
		/// Deprecated - Can be retrieved by querying the Graph user referenced in the "self" entry of the IdentityRef "_links" dictionary
		/// </summary>
		public string DirectoryAlias { get; set; }
		
		public string Id { get; set; }
		
		/// <summary>
		/// Deprecated - Available in the "avatar" entry of the IdentityRef "_links" dictionary
		/// </summary>
		public string ImageUrl { get; set; }
		
		/// <summary>
		/// Deprecated - Can be retrieved by querying the Graph membership state referenced in the "membershipState" entry of the GraphUser "_links" dictionary
		/// </summary>
		public System.Nullable<System.Boolean> Inactive { get; set; }
		
		/// <summary>
		/// Deprecated - Can be inferred from the subject type of the descriptor (Descriptor.IsAadUserType/Descriptor.IsAadGroupType)
		/// </summary>
		public System.Nullable<System.Boolean> IsAadIdentity { get; set; }
		
		/// <summary>
		/// Deprecated - Can be inferred from the subject type of the descriptor (Descriptor.IsGroupType)
		/// </summary>
		public System.Nullable<System.Boolean> IsContainer { get; set; }
		
		public System.Nullable<System.Boolean> IsDeletedInOrigin { get; set; }
		
		/// <summary>
		/// Deprecated - not in use in most preexisting implementations of ToIdentityRef
		/// </summary>
		public string ProfileUrl { get; set; }
		
		/// <summary>
		/// Deprecated - use Domain+PrincipalName instead
		/// </summary>
		public string UniqueName { get; set; }
	}
	
	public class CodeRepositoryReference
	{
		
		/// <summary>
		/// Gets and sets the repository references.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, ReleaseManagementInputValue> RepositoryReference { get; set; }
		
		/// <summary>
		/// It can have value as ‘GitHub’, ‘Vsts’.
		/// </summary>
		public System.Nullable<CodeRepositoryReferenceSystemType> SystemType { get; set; }
	}
	
	public class ReleaseManagementInputValue
	{
		
		/// <summary>
		/// The text to show for the display of this value.
		/// </summary>
		public string DisplayValue { get; set; }
		
		/// <summary>
		/// The value to store for this input.
		/// </summary>
		public string Value { get; set; }
	}
	
	public enum CodeRepositoryReferenceSystemType
	{
		
		none = 0,
		
		tfsGit = 1,
		
		gitHub = 2,
	}
	
	public class ComplianceSettings
	{
		
		/// <summary>
		/// Scan the release definition for secrets
		/// </summary>
		public System.Nullable<System.Boolean> CheckForCredentialsAndOtherSecrets { get; set; }
	}
	
	public class Condition
	{
		
		/// <summary>
		/// Gets or sets the condition type.
		/// </summary>
		public System.Nullable<ConditionConditionType> ConditionType { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the condition. e.g. 'ReleaseStarted'.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or set value of the condition.
		/// </summary>
		public string Value { get; set; }
	}
	
	public enum ConditionConditionType
	{
		
		undefined = 0,
		
		_event = 1,
		
		environmentState = 2,
		
		artifact = 3,
	}
	
	public class ConfigurationVariableValue
	{
		
		/// <summary>
		/// Gets and sets if a variable can be overridden at deployment time or not.
		/// </summary>
		public System.Nullable<System.Boolean> AllowOverride { get; set; }
		
		/// <summary>
		/// Gets or sets as variable is secret or not.
		/// </summary>
		public System.Nullable<System.Boolean> IsSecret { get; set; }
		
		/// <summary>
		/// Gets and sets value of the configuration variable.
		/// </summary>
		public string Value { get; set; }
	}
	
	public class Consumer
	{
		
		/// <summary>
		/// ID of the consumer.
		/// </summary>
		public System.Nullable<System.Int32> ConsumerId { get; set; }
		
		/// <summary>
		/// Name of the consumer.
		/// </summary>
		public string ConsumerName { get; set; }
	}
	
	public class ContainerImageTrigger
	{
		
		/// <summary>
		/// Alias of the trigger.
		/// </summary>
		public string Alias { get; set; }
		
		/// <summary>
		/// List tag filters applied while trigger.
		/// </summary>
		public TagFilter[] TagFilters { get; set; }
	}
	
	public class ContinuousDeploymentTriggerIssue
	{
		
		/// <summary>
		/// Artifact type.
		/// </summary>
		public string ArtifactType { get; set; }
		
		/// <summary>
		/// ArtifactVersion ID.
		/// </summary>
		public string ArtifactVersionId { get; set; }
		
		/// <summary>
		/// Artifact source ID.
		/// </summary>
		public string SourceId { get; set; }
	}
	
	public class ControlOptions
	{
		
		/// <summary>
		/// Always run the job.
		/// </summary>
		public System.Nullable<System.Boolean> AlwaysRun { get; set; }
		
		/// <summary>
		/// Indicates whether to continue job on error or not.
		/// </summary>
		public System.Nullable<System.Boolean> ContinueOnError { get; set; }
		
		/// <summary>
		/// Indicates the job enabled or not.
		/// </summary>
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class CustomArtifactDownloadInput
	{
	}
	
	/// <summary>
	/// Represents binding of data source for the service endpoint request.
	/// </summary>
	public class DataSourceBindingBase
	{
		
		/// <summary>
		/// Pagination format supported by this data source(ContinuationToken/SkipTop).
		/// </summary>
		public string CallbackContextTemplate { get; set; }
		
		/// <summary>
		/// Subsequent calls needed?
		/// </summary>
		public string CallbackRequiredTemplate { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the data source.
		/// </summary>
		public string DataSourceName { get; set; }
		
		/// <summary>
		/// Gets or sets the endpoint Id.
		/// </summary>
		public string EndpointId { get; set; }
		
		/// <summary>
		/// Gets or sets the url of the service endpoint.
		/// </summary>
		public string EndpointUrl { get; set; }
		
		/// <summary>
		/// Gets or sets the authorization headers.
		/// </summary>
		public AuthorizationHeader[] Headers { get; set; }
		
		/// <summary>
		/// Defines the initial value of the query params
		/// </summary>
		public string InitialContextTemplate { get; set; }
		
		/// <summary>
		/// Gets or sets the parameters for the data source.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, string> Parameters { get; set; }
		
		/// <summary>
		/// Gets or sets http request body
		/// </summary>
		public string RequestContent { get; set; }
		
		/// <summary>
		/// Gets or sets http request verb
		/// </summary>
		public string RequestVerb { get; set; }
		
		/// <summary>
		/// Gets or sets the result selector.
		/// </summary>
		public string ResultSelector { get; set; }
		
		/// <summary>
		/// Gets or sets the result template.
		/// </summary>
		public string ResultTemplate { get; set; }
		
		/// <summary>
		/// Gets or sets the target of the data source.
		/// </summary>
		public string Target { get; set; }
	}
	
	public class DefinitionEnvironmentReference
	{
		
		/// <summary>
		/// Definition environment ID.
		/// </summary>
		public System.Nullable<System.Int32> DefinitionEnvironmentId { get; set; }
		
		/// <summary>
		/// Definition environment name.
		/// </summary>
		public string DefinitionEnvironmentName { get; set; }
		
		/// <summary>
		/// ReleaseDefinition ID.
		/// </summary>
		public System.Nullable<System.Int32> ReleaseDefinitionId { get; set; }
		
		/// <summary>
		/// ReleaseDefinition name.
		/// </summary>
		public string ReleaseDefinitionName { get; set; }
	}
	
	public class Demand
	{
		
		/// <summary>
		/// Gets and sets the name of demand.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Gets and sets the value of demand.
		/// </summary>
		public string Value { get; set; }
	}
	
	public class Deployment
	{
		
		/// <summary>
		/// Gets attempt number.
		/// </summary>
		public System.Nullable<System.Int32> Attempt { get; set; }
		
		/// <summary>
		/// Gets the date on which deployment is complete.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CompletedOn { get; set; }
		
		/// <summary>
		/// Gets the list of condition associated with deployment.
		/// </summary>
		public Condition[] Conditions { get; set; }
		
		/// <summary>
		/// Gets release definition environment id.
		/// </summary>
		public System.Nullable<System.Int32> DefinitionEnvironmentId { get; set; }
		
		/// <summary>
		/// Gets status of the deployment.
		/// </summary>
		public System.Nullable<DeploymentDeploymentStatus> DeploymentStatus { get; set; }
		
		/// <summary>
		/// Gets the unique identifier for deployment.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		public IdentityRef LastModifiedBy { get; set; }
		
		/// <summary>
		/// Gets the date on which deployment is last modified.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastModifiedOn { get; set; }
		
		/// <summary>
		/// Gets operation status of deployment.
		/// </summary>
		public System.Nullable<DeploymentOperationStatus> OperationStatus { get; set; }
		
		/// <summary>
		/// Gets list of PostDeployApprovals.
		/// </summary>
		public ReleaseApproval[] PostDeployApprovals { get; set; }
		
		/// <summary>
		/// Gets list of PreDeployApprovals.
		/// </summary>
		public ReleaseApproval[] PreDeployApprovals { get; set; }
		
		public ProjectReference ProjectReference { get; set; }
		
		/// <summary>
		/// Gets the date on which deployment is queued.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> QueuedOn { get; set; }
		
		/// <summary>
		/// Gets reason of deployment.
		/// </summary>
		public System.Nullable<DeploymentReason> Reason { get; set; }
		
		public ReleaseReference Release { get; set; }
		
		public ReleaseDefinitionShallowReference ReleaseDefinition { get; set; }
		
		public ReleaseEnvironmentShallowReference ReleaseEnvironment { get; set; }
		
		public IdentityRef RequestedBy { get; set; }
		
		public IdentityRef RequestedFor { get; set; }
		
		/// <summary>
		/// Gets the date on which deployment is scheduled.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ScheduledDeploymentTime { get; set; }
		
		/// <summary>
		/// Gets the date on which deployment is started.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> StartedOn { get; set; }
	}
	
	public enum DeploymentDeploymentStatus
	{
		
		undefined = 0,
		
		notDeployed = 1,
		
		inProgress = 2,
		
		succeeded = 3,
		
		partiallySucceeded = 4,
		
		failed = 5,
		
		all = 6,
	}
	
	public enum DeploymentOperationStatus
	{
		
		undefined = 0,
		
		queued = 1,
		
		scheduled = 2,
		
		pending = 3,
		
		approved = 4,
		
		rejected = 5,
		
		deferred = 6,
		
		queuedForAgent = 7,
		
		phaseInProgress = 8,
		
		phaseSucceeded = 9,
		
		phasePartiallySucceeded = 10,
		
		phaseFailed = 11,
		
		canceled = 12,
		
		phaseCanceled = 13,
		
		manualInterventionPending = 14,
		
		queuedForPipeline = 15,
		
		cancelling = 16,
		
		evaluatingGates = 17,
		
		gateFailed = 18,
		
		all = 19,
	}
	
	public class ReleaseApproval
	{
		
		/// <summary>
		/// Gets or sets the type of approval.
		/// </summary>
		public System.Nullable<ReleaseApprovalApprovalType> ApprovalType { get; set; }
		
		public IdentityRef ApprovedBy { get; set; }
		
		public IdentityRef Approver { get; set; }
		
		/// <summary>
		/// Gets or sets attempt which specifies as which deployment attempt it belongs.
		/// </summary>
		public System.Nullable<System.Int32> Attempt { get; set; }
		
		/// <summary>
		/// Gets or sets comments for approval.
		/// </summary>
		public string Comments { get; set; }
		
		/// <summary>
		/// Gets date on which it got created.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedOn { get; set; }
		
		/// <summary>
		/// Gets history which specifies all approvals associated with this approval.
		/// </summary>
		public ReleaseApprovalHistory[] History { get; set; }
		
		/// <summary>
		/// Gets the unique identifier of this field.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Gets or sets as approval is automated or not.
		/// </summary>
		public System.Nullable<System.Boolean> IsAutomated { get; set; }
		
		/// <summary>
		/// Gets date on which it got modified.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ModifiedOn { get; set; }
		
		/// <summary>
		/// Gets or sets rank which specifies the order of the approval. e.g. Same rank denotes parallel approval.
		/// </summary>
		public System.Nullable<System.Int32> Rank { get; set; }
		
		public ReleaseShallowReference Release { get; set; }
		
		public ReleaseDefinitionShallowReference ReleaseDefinition { get; set; }
		
		public ReleaseEnvironmentShallowReference ReleaseEnvironment { get; set; }
		
		/// <summary>
		/// Gets the revision number.
		/// </summary>
		public System.Nullable<System.Int32> Revision { get; set; }
		
		/// <summary>
		/// Gets or sets the status of the approval.
		/// </summary>
		public System.Nullable<ReleaseApprovalStatus> Status { get; set; }
		
		/// <summary>
		/// Gets url to access the approval.
		/// </summary>
		public string Url { get; set; }
	}
	
	public enum ReleaseApprovalApprovalType
	{
		
		undefined = 0,
		
		preDeploy = 1,
		
		postDeploy = 2,
		
		all = 3,
	}
	
	public class ReleaseApprovalHistory
	{
		
		public IdentityRef Approver { get; set; }
		
		public IdentityRef ChangedBy { get; set; }
		
		/// <summary>
		/// Approval history comments.
		/// </summary>
		public string Comments { get; set; }
		
		/// <summary>
		/// Time when this approval created.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedOn { get; set; }
		
		/// <summary>
		/// Time when this approval modified.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ModifiedOn { get; set; }
		
		/// <summary>
		/// Approval history revision.
		/// </summary>
		public System.Nullable<System.Int32> Revision { get; set; }
	}
	
	public class ReleaseShallowReference
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// Gets the unique identifier of release.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the release.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Gets the REST API url to access the release.
		/// </summary>
		public string Url { get; set; }
	}
	
	public class ReleaseEnvironmentShallowReference
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// Gets the unique identifier of release environment.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the release environment.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Gets the REST API url to access the release environment.
		/// </summary>
		public string Url { get; set; }
	}
	
	public enum ReleaseApprovalStatus
	{
		
		undefined = 0,
		
		pending = 1,
		
		approved = 2,
		
		rejected = 3,
		
		reassigned = 4,
		
		canceled = 5,
		
		skipped = 6,
	}
	
	public enum DeploymentReason
	{
		
		none = 0,
		
		manual = 1,
		
		automated = 2,
		
		scheduled = 3,
		
		redeployTrigger = 4,
	}
	
	public class ReleaseReference
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// Gets list of artifacts.
		/// </summary>
		public Artifact[] Artifacts { get; set; }
		
		public IdentityRef CreatedBy { get; set; }
		
		/// <summary>
		/// Gets date on when this release created.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedOn { get; set; }
		
		/// <summary>
		/// Gets description.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Release.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		public IdentityRef ModifiedBy { get; set; }
		
		/// <summary>
		/// Gets name of release.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Gets reason for release.
		/// </summary>
		public System.Nullable<ReleaseReferenceReason> Reason { get; set; }
		
		public ReleaseDefinitionShallowReference ReleaseDefinition { get; set; }
	}
	
	public enum ReleaseReferenceReason
	{
		
		none = 0,
		
		manual = 1,
		
		continuousIntegration = 2,
		
		schedule = 3,
		
		pullRequest = 4,
	}
	
	public class DeploymentApprovalCompletedEvent
	{
		
		public ReleaseApproval Approval { get; set; }
		
		public ProjectReference Project { get; set; }
		
		public Release Release { get; set; }
	}
	
	public class Release
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// Gets or sets the list of artifacts.
		/// </summary>
		public Artifact[] Artifacts { get; set; }
		
		/// <summary>
		/// Gets or sets comment.
		/// </summary>
		public string Comment { get; set; }
		
		public IdentityRef CreatedBy { get; set; }
		
		public IdentityRef CreatedFor { get; set; }
		
		/// <summary>
		/// Gets date on which it got created.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedOn { get; set; }
		
		/// <summary>
		/// Gets revision number of definition snapshot.
		/// </summary>
		public System.Nullable<System.Int32> DefinitionSnapshotRevision { get; set; }
		
		/// <summary>
		/// Gets or sets description of release.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Gets list of environments.
		/// </summary>
		public ReleaseEnvironment[] Environments { get; set; }
		
		/// <summary>
		/// Gets the unique identifier of this field.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Whether to exclude the release from retention policies.
		/// </summary>
		public System.Nullable<System.Boolean> KeepForever { get; set; }
		
		/// <summary>
		/// Gets logs container url.
		/// </summary>
		public string LogsContainerUrl { get; set; }
		
		public IdentityRef ModifiedBy { get; set; }
		
		/// <summary>
		/// Gets date on which it got modified.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ModifiedOn { get; set; }
		
		/// <summary>
		/// Gets name.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Gets pool name.
		/// </summary>
		public string PoolName { get; set; }
		
		public ProjectReference ProjectReference { get; set; }
		
		/// <summary>
		/// The class represents a property bag as a collection of key-value pairs. Values of all primitive types (any type with a `TypeCode != TypeCode.Object`) except for `DBNull` are accepted. Values of type Byte[], Int32, Double, DateType and String preserve their type, other primitives are retuned as a String. Byte[] expected as base64 encoded string.
		/// </summary>
		public PropertiesCollection Properties { get; set; }
		
		/// <summary>
		/// Gets reason of release.
		/// </summary>
		public System.Nullable<ReleaseReason> Reason { get; set; }
		
		public ReleaseDefinitionShallowReference ReleaseDefinition { get; set; }
		
		/// <summary>
		/// Gets or sets the release definition revision.
		/// </summary>
		public System.Nullable<System.Int32> ReleaseDefinitionRevision { get; set; }
		
		/// <summary>
		/// Gets release name format.
		/// </summary>
		public string ReleaseNameFormat { get; set; }
		
		/// <summary>
		/// Gets status.
		/// </summary>
		public System.Nullable<ReleaseStatus> Status { get; set; }
		
		/// <summary>
		/// Gets or sets list of tags.
		/// </summary>
		public string[] Tags { get; set; }
		
		public string TriggeringArtifactAlias { get; set; }
		
		/// <summary>
		/// Gets the list of variable groups.
		/// </summary>
		public VariableGroup[] VariableGroups { get; set; }
		
		/// <summary>
		/// Gets or sets the dictionary of variables.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, ConfigurationVariableValue> Variables { get; set; }
	}
	
	public class ReleaseEnvironment
	{
		
		/// <summary>
		/// Gets list of conditions.
		/// </summary>
		public ReleaseCondition[] Conditions { get; set; }
		
		/// <summary>
		/// Gets date on which it got created.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedOn { get; set; }
		
		/// <summary>
		/// Gets definition environment id.
		/// </summary>
		public System.Nullable<System.Int32> DefinitionEnvironmentId { get; set; }
		
		/// <summary>
		/// Gets list of deploy phases snapshot.
		/// </summary>
		public DeployPhase[] DeployPhasesSnapshot { get; set; }
		
		/// <summary>
		/// Gets deploy steps.
		/// </summary>
		public DeploymentAttempt[] DeploySteps { get; set; }
		
		public EnvironmentOptions EnvironmentOptions { get; set; }
		
		/// <summary>
		/// Gets the unique identifier of this field.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Gets date on which it got modified.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ModifiedOn { get; set; }
		
		/// <summary>
		/// Gets name.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Gets next scheduled UTC time.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> NextScheduledUtcTime { get; set; }
		
		public IdentityRef Owner { get; set; }
		
		public ReleaseDefinitionApprovals PostApprovalsSnapshot { get; set; }
		
		/// <summary>
		/// Gets list of post deploy approvals.
		/// </summary>
		public ReleaseApproval[] PostDeployApprovals { get; set; }
		
		public ReleaseDefinitionGatesStep PostDeploymentGatesSnapshot { get; set; }
		
		public ReleaseDefinitionApprovals PreApprovalsSnapshot { get; set; }
		
		/// <summary>
		/// Gets list of pre deploy approvals.
		/// </summary>
		public ReleaseApproval[] PreDeployApprovals { get; set; }
		
		public ReleaseDefinitionGatesStep PreDeploymentGatesSnapshot { get; set; }
		
		public ProcessParameters ProcessParameters { get; set; }
		
		/// <summary>
		/// Gets rank.
		/// </summary>
		public System.Nullable<System.Int32> Rank { get; set; }
		
		public ReleaseShallowReference Release { get; set; }
		
		public IdentityRef ReleaseCreatedBy { get; set; }
		
		public ReleaseDefinitionShallowReference ReleaseDefinition { get; set; }
		
		/// <summary>
		/// Gets release id.
		/// </summary>
		public System.Nullable<System.Int32> ReleaseId { get; set; }
		
		/// <summary>
		/// Gets schedule deployment time of release environment.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ScheduledDeploymentTime { get; set; }
		
		/// <summary>
		/// Gets list of schedules.
		/// </summary>
		public ReleaseSchedule[] Schedules { get; set; }
		
		/// <summary>
		/// Gets environment status.
		/// </summary>
		public System.Nullable<ReleaseEnvironmentStatus> Status { get; set; }
		
		/// <summary>
		/// Gets time to deploy.
		/// </summary>
		public System.Nullable<System.Double> TimeToDeploy { get; set; }
		
		/// <summary>
		/// Gets trigger reason.
		/// </summary>
		public string TriggerReason { get; set; }
		
		/// <summary>
		/// Gets the list of variable groups.
		/// </summary>
		public VariableGroup[] VariableGroups { get; set; }
		
		/// <summary>
		/// Gets the dictionary of variables.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, ConfigurationVariableValue> Variables { get; set; }
	}
	
	public class ReleaseCondition
	{
		
		/// <summary>
		/// The release condition result.
		/// </summary>
		public System.Nullable<System.Boolean> Result { get; set; }
	}
	
	public class DeployPhase
	{
		
		/// <summary>
		/// Gets and sets the name of deploy phase.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Indicates the deploy phase type.
		/// </summary>
		public System.Nullable<DeployPhasePhaseType> PhaseType { get; set; }
		
		/// <summary>
		/// Gets and sets the rank of deploy phase.
		/// </summary>
		public System.Nullable<System.Int32> Rank { get; set; }
		
		/// <summary>
		/// Gets and sets the reference name of deploy phase.
		/// </summary>
		public string RefName { get; set; }
		
		/// <summary>
		/// Gets and sets the workflow tasks for the deploy phase.
		/// </summary>
		public WorkflowTask[] WorkflowTasks { get; set; }
	}
	
	public enum DeployPhasePhaseType
	{
		
		undefined = 0,
		
		agentBasedDeployment = 1,
		
		runOnServer = 2,
		
		machineGroupBasedDeployment = 3,
		
		deploymentGates = 4,
	}
	
	public class WorkflowTask
	{
		
		/// <summary>
		/// Gets or sets as the task always run or not.
		/// </summary>
		public System.Nullable<System.Boolean> AlwaysRun { get; set; }
		
		/// <summary>
		/// Gets or sets the task condition.
		/// </summary>
		public string Condition { get; set; }
		
		/// <summary>
		/// Gets or sets as the task continue run on error or not.
		/// </summary>
		public System.Nullable<System.Boolean> ContinueOnError { get; set; }
		
		/// <summary>
		/// Gets or sets the task definition type. Example:- 'Agent', DeploymentGroup', 'Server' or 'ServerGate'.
		/// </summary>
		public string DefinitionType { get; set; }
		
		/// <summary>
		/// Gets or sets as the task enabled or not.
		/// </summary>
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Gets or sets the task environment variables.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, string> Environment { get; set; }
		
		/// <summary>
		/// Gets or sets the task inputs.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, string> Inputs { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the task.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the task override inputs.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, string> OverrideInputs { get; set; }
		
		/// <summary>
		/// Gets or sets the reference name of the task.
		/// </summary>
		public string RefName { get; set; }
		
		/// <summary>
		/// Gets or sets the ID of the task.
		/// </summary>
		public string TaskId { get; set; }
		
		/// <summary>
		/// Gets or sets the task timeout.
		/// </summary>
		public System.Nullable<System.Int32> TimeoutInMinutes { get; set; }
		
		/// <summary>
		/// Gets or sets the version of the task.
		/// </summary>
		public string Version { get; set; }
	}
	
	public class DeploymentAttempt
	{
		
		/// <summary>
		/// Deployment attempt.
		/// </summary>
		public System.Nullable<System.Int32> Attempt { get; set; }
		
		/// <summary>
		/// ID of the deployment.
		/// </summary>
		public System.Nullable<System.Int32> DeploymentId { get; set; }
		
		/// <summary>
		/// Specifies whether deployment has started or not.
		/// </summary>
		public System.Nullable<System.Boolean> HasStarted { get; set; }
		
		/// <summary>
		/// ID of deployment.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// All the issues related to the deployment.
		/// </summary>
		public Issue[] Issues { get; set; }
		
		public IdentityRef LastModifiedBy { get; set; }
		
		/// <summary>
		/// Time when this deployment last modified.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastModifiedOn { get; set; }
		
		/// <summary>
		/// Deployment operation status.
		/// </summary>
		public System.Nullable<DeploymentAttemptOperationStatus> OperationStatus { get; set; }
		
		public ReleaseGates PostDeploymentGates { get; set; }
		
		public ReleaseGates PreDeploymentGates { get; set; }
		
		/// <summary>
		/// When this deployment queued on.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> QueuedOn { get; set; }
		
		/// <summary>
		/// Reason for the deployment.
		/// </summary>
		public System.Nullable<DeploymentAttemptReason> Reason { get; set; }
		
		/// <summary>
		/// List of release deployphases executed in this deployment.
		/// </summary>
		public ReleaseDeployPhase[] ReleaseDeployPhases { get; set; }
		
		public IdentityRef RequestedBy { get; set; }
		
		public IdentityRef RequestedFor { get; set; }
		
		/// <summary>
		/// status of the deployment.
		/// </summary>
		public System.Nullable<DeploymentAttemptStatus> Status { get; set; }
	}
	
	public enum DeploymentAttemptOperationStatus
	{
		
		undefined = 0,
		
		queued = 1,
		
		scheduled = 2,
		
		pending = 3,
		
		approved = 4,
		
		rejected = 5,
		
		deferred = 6,
		
		queuedForAgent = 7,
		
		phaseInProgress = 8,
		
		phaseSucceeded = 9,
		
		phasePartiallySucceeded = 10,
		
		phaseFailed = 11,
		
		canceled = 12,
		
		phaseCanceled = 13,
		
		manualInterventionPending = 14,
		
		queuedForPipeline = 15,
		
		cancelling = 16,
		
		evaluatingGates = 17,
		
		gateFailed = 18,
		
		all = 19,
	}
	
	public class ReleaseGates
	{
		
		/// <summary>
		/// Contains the gates job details of each evaluation.
		/// </summary>
		public DeploymentJob[] DeploymentJobs { get; set; }
		
		/// <summary>
		/// ID of release gates.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// List of ignored gates.
		/// </summary>
		public IgnoredGate[] IgnoredGates { get; set; }
		
		/// <summary>
		/// Gates last modified time.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastModifiedOn { get; set; }
		
		/// <summary>
		/// Run plan ID of the gates.
		/// </summary>
		public string RunPlanId { get; set; }
		
		/// <summary>
		/// Gates stabilization completed date and time.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> StabilizationCompletedOn { get; set; }
		
		/// <summary>
		/// Gates evaluation started time.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> StartedOn { get; set; }
		
		/// <summary>
		/// Status of release gates.
		/// </summary>
		public System.Nullable<ReleaseGatesStatus> Status { get; set; }
		
		/// <summary>
		/// Date and time at which all gates executed successfully.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> SucceedingSince { get; set; }
	}
	
	public class DeploymentJob
	{
		
		public ReleaseTask Job { get; set; }
		
		/// <summary>
		/// List of  executed tasks with in job.
		/// </summary>
		public ReleaseTask[] Tasks { get; set; }
	}
	
	public class ReleaseTask
	{
		
		/// <summary>
		/// Agent name on which task executed.
		/// </summary>
		public string AgentName { get; set; }
		
		/// <summary>
		/// Finish time of the release task.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> FinishTime { get; set; }
		
		/// <summary>
		/// ID of the release task.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// List of issues occurred while execution of task.
		/// </summary>
		public Issue[] Issues { get; set; }
		
		/// <summary>
		/// Number of lines log release task has.
		/// </summary>
		public System.Nullable<System.Int64> LineCount { get; set; }
		
		/// <summary>
		/// Log URL of the task.
		/// </summary>
		public string LogUrl { get; set; }
		
		/// <summary>
		/// Name of the task.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Task execution complete precent.
		/// </summary>
		public System.Nullable<System.Int32> PercentComplete { get; set; }
		
		/// <summary>
		/// Rank of the release task.
		/// </summary>
		public System.Nullable<System.Int32> Rank { get; set; }
		
		/// <summary>
		/// Result code of the task.
		/// </summary>
		public string ResultCode { get; set; }
		
		/// <summary>
		/// ID of the release task.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> StartTime { get; set; }
		
		/// <summary>
		/// Status of release task.
		/// </summary>
		public System.Nullable<ReleaseTaskStatus> Status { get; set; }
		
		public WorkflowTaskReference Task { get; set; }
		
		/// <summary>
		/// Timeline record ID of the release task.
		/// </summary>
		public string TimelineRecordId { get; set; }
	}
	
	public enum ReleaseTaskStatus
	{
		
		unknown = 0,
		
		pending = 1,
		
		inProgress = 2,
		
		success = 3,
		
		failure = 4,
		
		canceled = 5,
		
		skipped = 6,
		
		succeeded = 7,
		
		failed = 8,
		
		partiallySucceeded = 9,
	}
	
	public class WorkflowTaskReference
	{
		
		/// <summary>
		/// Task identifier.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the task.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Version of the task.
		/// </summary>
		public string Version { get; set; }
	}
	
	public class IgnoredGate
	{
		
		/// <summary>
		/// Gets the date on which gate is last ignored.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastModifiedOn { get; set; }
		
		/// <summary>
		/// Name of gate ignored.
		/// </summary>
		public string Name { get; set; }
	}
	
	public enum ReleaseGatesStatus
	{
		
		none = 0,
		
		pending = 1,
		
		inProgress = 2,
		
		succeeded = 3,
		
		failed = 4,
		
		canceled = 5,
	}
	
	public enum DeploymentAttemptReason
	{
		
		none = 0,
		
		manual = 1,
		
		automated = 2,
		
		scheduled = 3,
		
		redeployTrigger = 4,
	}
	
	public class ReleaseDeployPhase
	{
		
		/// <summary>
		/// Deployment jobs of the phase.
		/// </summary>
		public DeploymentJob[] DeploymentJobs { get; set; }
		
		/// <summary>
		/// Phase execution error logs.
		/// </summary>
		public string ErrorLog { get; set; }
		
		/// <summary>
		/// List of manual intervention tasks execution information in phase.
		/// </summary>
		public ManualIntervention[] ManualInterventions { get; set; }
		
		/// <summary>
		/// Name of the phase.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// ID of the phase.
		/// </summary>
		public string PhaseId { get; set; }
		
		/// <summary>
		/// Type of the phase.
		/// </summary>
		public System.Nullable<ReleaseDeployPhasePhaseType> PhaseType { get; set; }
		
		/// <summary>
		/// Rank of the phase.
		/// </summary>
		public System.Nullable<System.Int32> Rank { get; set; }
		
		/// <summary>
		/// Run Plan ID of the phase.
		/// </summary>
		public string RunPlanId { get; set; }
		
		/// <summary>
		/// Phase start time.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> StartedOn { get; set; }
		
		/// <summary>
		/// Status of the phase.
		/// </summary>
		public System.Nullable<ReleaseDeployPhaseStatus> Status { get; set; }
	}
	
	public class ManualIntervention
	{
		
		public IdentityRef Approver { get; set; }
		
		/// <summary>
		/// Gets or sets comments for approval.
		/// </summary>
		public string Comments { get; set; }
		
		/// <summary>
		/// Gets date on which it got created.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedOn { get; set; }
		
		/// <summary>
		/// Gets the unique identifier for manual intervention.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Gets or sets instructions for approval.
		/// </summary>
		public string Instructions { get; set; }
		
		/// <summary>
		/// Gets date on which it got modified.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ModifiedOn { get; set; }
		
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		public string Name { get; set; }
		
		public ReleaseShallowReference Release { get; set; }
		
		public ReleaseDefinitionShallowReference ReleaseDefinition { get; set; }
		
		public ReleaseEnvironmentShallowReference ReleaseEnvironment { get; set; }
		
		/// <summary>
		/// Gets or sets the status of the manual intervention.
		/// </summary>
		public System.Nullable<ManualInterventionStatus> Status { get; set; }
		
		/// <summary>
		/// Get task instance identifier.
		/// </summary>
		public string TaskInstanceId { get; set; }
		
		/// <summary>
		/// Gets url to access the manual intervention.
		/// </summary>
		public string Url { get; set; }
	}
	
	public enum ManualInterventionStatus
	{
		
		unknown = 0,
		
		pending = 1,
		
		rejected = 2,
		
		approved = 3,
		
		canceled = 4,
	}
	
	public enum ReleaseDeployPhasePhaseType
	{
		
		undefined = 0,
		
		agentBasedDeployment = 1,
		
		runOnServer = 2,
		
		machineGroupBasedDeployment = 3,
		
		deploymentGates = 4,
	}
	
	public enum ReleaseDeployPhaseStatus
	{
		
		undefined = 0,
		
		notStarted = 1,
		
		inProgress = 2,
		
		partiallySucceeded = 3,
		
		succeeded = 4,
		
		failed = 5,
		
		canceled = 6,
		
		skipped = 7,
		
		cancelling = 8,
	}
	
	public enum DeploymentAttemptStatus
	{
		
		undefined = 0,
		
		notDeployed = 1,
		
		inProgress = 2,
		
		succeeded = 3,
		
		partiallySucceeded = 4,
		
		failed = 5,
		
		all = 6,
	}
	
	public class EnvironmentOptions
	{
		
		/// <summary>
		/// Gets and sets as the auto link workitems or not.
		/// </summary>
		public System.Nullable<System.Boolean> AutoLinkWorkItems { get; set; }
		
		/// <summary>
		/// Gets and sets as the badge enabled or not.
		/// </summary>
		public System.Nullable<System.Boolean> BadgeEnabled { get; set; }
		
		/// <summary>
		/// Gets and sets as the publish deployment status or not.
		/// </summary>
		public System.Nullable<System.Boolean> PublishDeploymentStatus { get; set; }
		
		/// <summary>
		/// Gets and sets as the.pull request deployment enabled or not.
		/// </summary>
		public System.Nullable<System.Boolean> PullRequestDeploymentEnabled { get; set; }
	}
	
	public class ReleaseDefinitionApprovals
	{
		
		public ApprovalOptions ApprovalOptions { get; set; }
		
		/// <summary>
		/// Gets or sets the approvals.
		/// </summary>
		public ReleaseDefinitionApprovalStep[] Approvals { get; set; }
	}
	
	public class ReleaseDefinitionApprovalStep
	{
		
		public IdentityRef Approver { get; set; }
		
		/// <summary>
		/// Indicates whether the approval automated.
		/// </summary>
		public System.Nullable<System.Boolean> IsAutomated { get; set; }
		
		/// <summary>
		/// Indicates whether the approval notification set.
		/// </summary>
		public System.Nullable<System.Boolean> IsNotificationOn { get; set; }
		
		/// <summary>
		/// Gets or sets the rank of approval step.
		/// </summary>
		public System.Nullable<System.Int32> Rank { get; set; }
	}
	
	public class ReleaseDefinitionGatesStep
	{
		
		/// <summary>
		/// Gets or sets the gates.
		/// </summary>
		public ReleaseDefinitionGate[] Gates { get; set; }
		
		public ReleaseDefinitionGatesOptions GatesOptions { get; set; }
		
		/// <summary>
		/// ID of the ReleaseDefinitionGateStep.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
	}
	
	public class ReleaseDefinitionGate
	{
		
		/// <summary>
		/// Gets or sets the gates workflow.
		/// </summary>
		public WorkflowTask[] Tasks { get; set; }
	}
	
	public class ReleaseDefinitionGatesOptions
	{
		
		/// <summary>
		/// Gets or sets as the gates enabled or not.
		/// </summary>
		public System.Nullable<System.Boolean> IsEnabled { get; set; }
		
		/// <summary>
		/// Gets or sets the minimum duration for steady results after a successful gates evaluation.
		/// </summary>
		public System.Nullable<System.Int32> MinimumSuccessDuration { get; set; }
		
		/// <summary>
		/// Gets or sets the time between re-evaluation of gates.
		/// </summary>
		public System.Nullable<System.Int32> SamplingInterval { get; set; }
		
		/// <summary>
		/// Gets or sets the delay before evaluation.
		/// </summary>
		public System.Nullable<System.Int32> StabilizationTime { get; set; }
		
		/// <summary>
		/// Gets or sets the timeout after which gates fail.
		/// </summary>
		public System.Nullable<System.Int32> Timeout { get; set; }
	}
	
	public class ProcessParameters
	{
		
		public DataSourceBindingBase[] DataSourceBindings { get; set; }
		
		public TaskInputDefinitionBase[] Inputs { get; set; }
		
		public TaskSourceDefinitionBase[] SourceDefinitions { get; set; }
	}
	
	public class TaskInputDefinitionBase
	{
		
		public string[] Aliases { get; set; }
		
		public string DefaultValue { get; set; }
		
		public string GroupName { get; set; }
		
		public string HelpMarkDown { get; set; }
		
		public string Label { get; set; }
		
		public string Name { get; set; }
		
		public System.Collections.Generic.Dictionary<string, string> Options { get; set; }
		
		public System.Collections.Generic.Dictionary<string, string> Properties { get; set; }
		
		public System.Nullable<System.Boolean> Required { get; set; }
		
		public string Type { get; set; }
		
		public TaskInputValidation Validation { get; set; }
		
		public string VisibleRule { get; set; }
	}
	
	public class TaskInputValidation
	{
		
		/// <summary>
		/// Conditional expression
		/// </summary>
		public string Expression { get; set; }
		
		/// <summary>
		/// Message explaining how user can correct if validation fails
		/// </summary>
		public string Message { get; set; }
	}
	
	public class TaskSourceDefinitionBase
	{
		
		public string AuthKey { get; set; }
		
		public string Endpoint { get; set; }
		
		public string KeySelector { get; set; }
		
		public string Selector { get; set; }
		
		public string Target { get; set; }
	}
	
	public class ReleaseSchedule
	{
		
		/// <summary>
		/// Days of the week to release.
		/// </summary>
		public System.Nullable<ReleaseScheduleDaysToRelease> DaysToRelease { get; set; }
		
		/// <summary>
		/// Team Foundation Job Definition Job Id.
		/// </summary>
		public string JobId { get; set; }
		
		/// <summary>
		/// Flag to determine if this schedule should only release if the associated artifact has been changed or release definition changed.
		/// </summary>
		public System.Nullable<System.Boolean> ScheduleOnlyWithChanges { get; set; }
		
		/// <summary>
		/// Local time zone hour to start.
		/// </summary>
		public System.Nullable<System.Int32> StartHours { get; set; }
		
		/// <summary>
		/// Local time zone minute to start.
		/// </summary>
		public System.Nullable<System.Int32> StartMinutes { get; set; }
		
		/// <summary>
		/// Time zone Id of release schedule, such as 'UTC'.
		/// </summary>
		public string TimeZoneId { get; set; }
	}
	
	public enum ReleaseScheduleDaysToRelease
	{
		
		none = 0,
		
		monday = 1,
		
		tuesday = 2,
		
		wednesday = 3,
		
		thursday = 4,
		
		friday = 5,
		
		saturday = 6,
		
		sunday = 7,
		
		all = 8,
	}
	
	public enum ReleaseEnvironmentStatus
	{
		
		undefined = 0,
		
		notStarted = 1,
		
		inProgress = 2,
		
		succeeded = 3,
		
		canceled = 4,
		
		rejected = 5,
		
		queued = 6,
		
		scheduled = 7,
		
		partiallySucceeded = 8,
	}
	
	public class VariableGroup
	{
		
		public IdentityRef CreatedBy { get; set; }
		
		/// <summary>
		/// Gets date on which it got created.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedOn { get; set; }
		
		/// <summary>
		/// Gets or sets description.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Gets the unique identifier of this field.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Denotes if a variable group is shared with other project or not.
		/// </summary>
		public System.Nullable<System.Boolean> IsShared { get; set; }
		
		public IdentityRef ModifiedBy { get; set; }
		
		/// <summary>
		/// Gets date on which it got modified.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ModifiedOn { get; set; }
		
		/// <summary>
		/// Gets or sets name.
		/// </summary>
		public string Name { get; set; }
		
		public VariableGroupProviderData ProviderData { get; set; }
		
		/// <summary>
		/// Gets or sets type.
		/// </summary>
		public string Type { get; set; }
		
		/// <summary>
		/// all project references where the variable group is shared with other projects.
		/// </summary>
		public VariableGroupProjectReference[] VariableGroupProjectReferences { get; set; }
		
		/// <summary>
		/// Gets and sets the dictionary of variables.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, VariableValue> Variables { get; set; }
	}
	
	public class VariableGroupProviderData
	{
	}
	
	/// <summary>
	/// A variable group reference is a shallow reference to variable group.
	/// </summary>
	public class VariableGroupProjectReference
	{
		
		/// <summary>
		/// Gets or sets description of the variable group.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Gets or sets name of the variable group.
		/// </summary>
		public string Name { get; set; }
		
		public ProjectReference ProjectReference { get; set; }
	}
	
	public class VariableValue
	{
		
		/// <summary>
		/// Gets or sets if the variable is read only or not.
		/// </summary>
		public System.Nullable<System.Boolean> IsReadOnly { get; set; }
		
		/// <summary>
		/// Gets or sets as the variable is secret or not.
		/// </summary>
		public System.Nullable<System.Boolean> IsSecret { get; set; }
		
		/// <summary>
		/// Gets or sets the value.
		/// </summary>
		public string Value { get; set; }
	}
	
	/// <summary>
	/// The class represents a property bag as a collection of key-value pairs. Values of all primitive types (any type with a `TypeCode != TypeCode.Object`) except for `DBNull` are accepted. Values of type Byte[], Int32, Double, DateType and String preserve their type, other primitives are retuned as a String. Byte[] expected as base64 encoded string.
	/// </summary>
	public class PropertiesCollection
	{
		
		/// <summary>
		/// The count of properties in the collection.
		/// </summary>
		public System.Nullable<System.Int32> Count { get; set; }
		
		public string Item { get; set; }
		
		/// <summary>
		/// The set of keys in the collection.
		/// </summary>
		public string[] Keys { get; set; }
		
		/// <summary>
		/// The set of values in the collection.
		/// </summary>
		public string[] Values { get; set; }
	}
	
	public enum ReleaseReason
	{
		
		none = 0,
		
		manual = 1,
		
		continuousIntegration = 2,
		
		schedule = 3,
		
		pullRequest = 4,
	}
	
	public enum ReleaseStatus
	{
		
		undefined = 0,
		
		draft = 1,
		
		active = 2,
		
		abandoned = 3,
	}
	
	public class DeploymentApprovalPendingEvent
	{
		
		public ReleaseApproval Approval { get; set; }
		
		public ApprovalOptions ApprovalOptions { get; set; }
		
		public ReleaseApproval[] CompletedApprovals { get; set; }
		
		public System.Collections.Generic.Dictionary<string, object> Data { get; set; }
		
		public Deployment Deployment { get; set; }
		
		public System.Nullable<System.Boolean> IsMultipleRankApproval { get; set; }
		
		public ReleaseApproval[] PendingApprovals { get; set; }
		
		public ProjectReference Project { get; set; }
		
		public Release Release { get; set; }
	}
	
	public class DeploymentAuthorizationInfo
	{
		
		/// <summary>
		/// Authorization header type, typically either RevalidateApproverIdentity or OnBehalfOf.
		/// </summary>
		public System.Nullable<DeploymentAuthorizationInfoAuthorizationHeaderFor> AuthorizationHeaderFor { get; set; }
		
		/// <summary>
		/// List of resources.
		/// </summary>
		public string[] Resources { get; set; }
		
		/// <summary>
		/// ID of the tenant.
		/// </summary>
		public string TenantId { get; set; }
		
		/// <summary>
		/// Access token key.
		/// </summary>
		public string VstsAccessTokenKey { get; set; }
	}
	
	public enum DeploymentAuthorizationInfoAuthorizationHeaderFor
	{
		
		revalidateApproverIdentity = 0,
		
		onBehalfOf = 1,
	}
	
	public class DeploymentCompletedEvent
	{
		
		public string Comment { get; set; }
		
		public System.Collections.Generic.Dictionary<string, object> Data { get; set; }
		
		public Deployment Deployment { get; set; }
		
		public ReleaseEnvironment Environment { get; set; }
		
		public ProjectReference Project { get; set; }
	}
	
	public class DeploymentEvent
	{
		
		public System.Nullable<System.Int32> AttemptId { get; set; }
		
		public string StageName { get; set; }
	}
	
	public class DeploymentInput
	{
		
		public ArtifactsDownloadInput ArtifactsDownloadInput { get; set; }
		
		/// <summary>
		/// List demands that needs to meet to execute the job.
		/// </summary>
		public Demand[] Demands { get; set; }
		
		/// <summary>
		/// Indicates whether to include access token in deployment job or not.
		/// </summary>
		public System.Nullable<System.Boolean> EnableAccessToken { get; set; }
		
		/// <summary>
		/// Id of the pool on which job get executed.
		/// </summary>
		public System.Nullable<System.Int32> QueueId { get; set; }
		
		/// <summary>
		/// Indicates whether artifacts downloaded while job execution or not.
		/// </summary>
		public System.Nullable<System.Boolean> SkipArtifactsDownload { get; set; }
	}
	
	public class DeploymentManualInterventionPendingEvent
	{
		
		public Deployment Deployment { get; set; }
		
		public string[] EmailRecipients { get; set; }
		
		public IdentityRef EnvironmentOwner { get; set; }
		
		public ManualIntervention ManualIntervention { get; set; }
		
		public ProjectReference Project { get; set; }
		
		public Release Release { get; set; }
	}
	
	public class DeploymentQueryParameters
	{
		
		/// <summary>
		/// Query deployments based specified artifact source id.
		/// </summary>
		public string ArtifactSourceId { get; set; }
		
		/// <summary>
		/// Query deployments based specified artifact type id.
		/// </summary>
		public string ArtifactTypeId { get; set; }
		
		/// <summary>
		/// Query deployments based specified artifact versions.
		/// </summary>
		public string[] ArtifactVersions { get; set; }
		
		/// <summary>
		/// Query deployments number of deployments per environment.
		/// </summary>
		public System.Nullable<System.Int32> DeploymentsPerEnvironment { get; set; }
		
		/// <summary>
		/// Query deployment based on deployment status.
		/// </summary>
		public System.Nullable<DeploymentQueryParametersDeploymentStatus> DeploymentStatus { get; set; }
		
		/// <summary>
		/// Query deployments of specified environments.
		/// </summary>
		public DefinitionEnvironmentReference[] Environments { get; set; }
		
		/// <summary>
		/// Query deployments based specified expands.
		/// </summary>
		public System.Nullable<DeploymentQueryParametersExpands> Expands { get; set; }
		
		/// <summary>
		/// Specify deleted deployments should return or not.
		/// </summary>
		public System.Nullable<System.Boolean> IsDeleted { get; set; }
		
		/// <summary>
		/// Query deployment based on deployment operation status.
		/// </summary>
		public System.Nullable<DeploymentQueryParametersOperationStatus> OperationStatus { get; set; }
		
		/// <summary>
		/// Query deployments based query type.
		/// </summary>
		public System.Nullable<DeploymentQueryParametersQueryType> QueryType { get; set; }
		
		/// <summary>
		/// Query deployments based specified source branch.
		/// </summary>
		public string SourceBranch { get; set; }
	}
	
	public enum DeploymentQueryParametersDeploymentStatus
	{
		
		undefined = 0,
		
		notDeployed = 1,
		
		inProgress = 2,
		
		succeeded = 3,
		
		partiallySucceeded = 4,
		
		failed = 5,
		
		all = 6,
	}
	
	public enum DeploymentQueryParametersExpands
	{
		
		all = 0,
		
		deploymentOnly = 1,
		
		approvals = 2,
		
		artifacts = 3,
	}
	
	public enum DeploymentQueryParametersOperationStatus
	{
		
		undefined = 0,
		
		queued = 1,
		
		scheduled = 2,
		
		pending = 3,
		
		approved = 4,
		
		rejected = 5,
		
		deferred = 6,
		
		queuedForAgent = 7,
		
		phaseInProgress = 8,
		
		phaseSucceeded = 9,
		
		phasePartiallySucceeded = 10,
		
		phaseFailed = 11,
		
		canceled = 12,
		
		phaseCanceled = 13,
		
		manualInterventionPending = 14,
		
		queuedForPipeline = 15,
		
		cancelling = 16,
		
		evaluatingGates = 17,
		
		gateFailed = 18,
		
		all = 19,
	}
	
	public enum DeploymentQueryParametersQueryType
	{
		
		regular = 0,
		
		failingSince = 1,
	}
	
	public class DeploymentStartedEvent
	{
		
		public ReleaseEnvironment Environment { get; set; }
		
		public ProjectReference Project { get; set; }
		
		public Release Release { get; set; }
	}
	
	public class EmailRecipients
	{
		
		/// <summary>
		/// List of email addresses.
		/// </summary>
		public string[] EmailAddresses { get; set; }
		
		/// <summary>
		/// List of TFS IDs guids.
		/// </summary>
		public string[] TfsIds { get; set; }
	}
	
	/// <summary>
	/// Defines policy on environment queuing at Release Management side queue. We will send to Environment Runner [creating pre-deploy and other steps] only when the policies mentioned are satisfied.
	/// </summary>
	public class EnvironmentExecutionPolicy
	{
		
		/// <summary>
		/// This policy decides, how many environments would be with Environment Runner.
		/// </summary>
		public System.Nullable<System.Int32> ConcurrencyCount { get; set; }
		
		/// <summary>
		/// Queue depth in the EnvironmentQueue table, this table keeps the environment entries till Environment Runner is free [as per it's policy] to take another environment for running.
		/// </summary>
		public System.Nullable<System.Int32> QueueDepthCount { get; set; }
	}
	
	public class EnvironmentRetentionPolicy
	{
		
		/// <summary>
		/// Gets and sets the number of days to keep environment.
		/// </summary>
		public System.Nullable<System.Int32> DaysToKeep { get; set; }
		
		/// <summary>
		/// Gets and sets the number of releases to keep.
		/// </summary>
		public System.Nullable<System.Int32> ReleasesToKeep { get; set; }
		
		/// <summary>
		/// Gets and sets as the build to be retained or not.
		/// </summary>
		public System.Nullable<System.Boolean> RetainBuild { get; set; }
	}
	
	public class EnvironmentTrigger
	{
		
		/// <summary>
		/// Definition environment ID on which this trigger applicable.
		/// </summary>
		public System.Nullable<System.Int32> DefinitionEnvironmentId { get; set; }
		
		/// <summary>
		/// ReleaseDefinition ID on which this trigger applicable.
		/// </summary>
		public System.Nullable<System.Int32> ReleaseDefinitionId { get; set; }
		
		/// <summary>
		/// Gets or sets the trigger content.
		/// </summary>
		public string TriggerContent { get; set; }
		
		/// <summary>
		/// Gets or sets the trigger type.
		/// </summary>
		public System.Nullable<EnvironmentTriggerTriggerType> TriggerType { get; set; }
	}
	
	public enum EnvironmentTriggerTriggerType
	{
		
		undefined = 0,
		
		deploymentGroupRedeploy = 1,
		
		rollbackRedeploy = 2,
	}
	
	public class EnvironmentTriggerContent
	{
		
		/// <summary>
		/// Gets or sets action.
		/// </summary>
		public string Action { get; set; }
		
		/// <summary>
		/// Gets or sets list of event types.
		/// </summary>
		public string[] EventTypes { get; set; }
	}
	
	/// <summary>
	/// Class to represent favorite entry.
	/// </summary>
	public class FavoriteItem
	{
		
		/// <summary>
		/// Application specific data for the entry.
		/// </summary>
		public string Data { get; set; }
		
		/// <summary>
		/// Unique Id of the the entry.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Display text for favorite entry.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Application specific favorite entry type. Empty or Null represents that Favorite item is a Folder.
		/// </summary>
		public string Type { get; set; }
	}
	
	public class Folder
	{
		
		public IdentityRef CreatedBy { get; set; }
		
		/// <summary>
		/// Time when this folder created.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedOn { get; set; }
		
		/// <summary>
		/// Description of the folder.
		/// </summary>
		public string Description { get; set; }
		
		public IdentityRef LastChangedBy { get; set; }
		
		/// <summary>
		/// Time when this folder last changed.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastChangedDate { get; set; }
		
		/// <summary>
		/// path of the folder.
		/// </summary>
		public string Path { get; set; }
	}
	
	public class GatesDeploymentInput
	{
		
		/// <summary>
		/// Gates minimum success duration.
		/// </summary>
		public System.Nullable<System.Int32> MinimumSuccessDuration { get; set; }
		
		/// <summary>
		/// Gates sampling interval.
		/// </summary>
		public System.Nullable<System.Int32> SamplingInterval { get; set; }
		
		/// <summary>
		/// Gates stabilization time.
		/// </summary>
		public System.Nullable<System.Int32> StabilizationTime { get; set; }
	}
	
	public class GatesDeployPhase
	{
		
		public GatesDeploymentInput DeploymentInput { get; set; }
	}
	
	public class GateUpdateMetadata
	{
		
		/// <summary>
		/// Comment.
		/// </summary>
		public string Comment { get; set; }
		
		/// <summary>
		/// Name of gate to be ignored.
		/// </summary>
		public string[] GatesToIgnore { get; set; }
	}
	
	public class GitArtifactDownloadInput
	{
	}
	
	public class GitHubArtifactDownloadInput
	{
	}
	
	public class GraphSubjectBase
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
		/// </summary>
		public string Descriptor { get; set; }
		
		/// <summary>
		/// This is the non-unique display name of the graph subject. To change this field, you must alter its value in the source provider.
		/// </summary>
		public string DisplayName { get; set; }
		
		/// <summary>
		/// This url is the full route to the source resource of this graph subject.
		/// </summary>
		public string Url { get; set; }
	}
	
	public class InputValuesQuery
	{
		
		public System.Collections.Generic.Dictionary<string, string> CurrentValues { get; set; }
		
		/// <summary>
		/// The input values to return on input, and the result from the consumer on output.
		/// </summary>
		public InputValues[] InputValues { get; set; }
		
		/// <summary>
		/// Subscription containing information about the publisher/consumer and the current input values
		/// </summary>
		public string Resource { get; set; }
	}
	
	public class JenkinsArtifactDownloadInput
	{
	}
	
	public class MachineGroupBasedDeployPhase
	{
		
		public MachineGroupDeploymentInput DeploymentInput { get; set; }
	}
	
	public class MachineGroupDeploymentInput
	{
		
		/// <summary>
		/// Deployment group health option.
		/// </summary>
		public string DeploymentHealthOption { get; set; }
		
		/// <summary>
		/// Minimum percentage of the targets guaranteed to be healthy.
		/// </summary>
		public System.Nullable<System.Int32> HealthPercent { get; set; }
		
		/// <summary>
		/// Deployment target tag filter.
		/// </summary>
		public string[] Tags { get; set; }
	}
	
	public class MailMessage
	{
		
		/// <summary>
		/// Body of mail.
		/// </summary>
		public string Body { get; set; }
		
		public EmailRecipients Cc { get; set; }
		
		/// <summary>
		/// Reply to.
		/// </summary>
		public string InReplyTo { get; set; }
		
		/// <summary>
		/// Message ID of the mail.
		/// </summary>
		public string MessageId { get; set; }
		
		/// <summary>
		/// Data when should be replied to mail.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ReplyBy { get; set; }
		
		public EmailRecipients ReplyTo { get; set; }
		
		/// <summary>
		/// List of mail section types.
		/// </summary>
		public string[] Sections { get; set; }
		
		/// <summary>
		/// Mail sender type.
		/// </summary>
		public System.Nullable<MailMessageSenderType> SenderType { get; set; }
		
		/// <summary>
		/// Subject of the mail.
		/// </summary>
		public string Subject { get; set; }
		
		public EmailRecipients To { get; set; }
	}
	
	public enum MailMessageSenderType
	{
		
		serviceAccount = 0,
		
		requestingUser = 1,
	}
	
	public class ManualInterventionUpdateMetadata
	{
		
		/// <summary>
		/// Sets the comment for manual intervention update.
		/// </summary>
		public string Comment { get; set; }
		
		/// <summary>
		/// Sets the status of the manual intervention.
		/// </summary>
		public System.Nullable<ManualInterventionUpdateMetadataStatus> Status { get; set; }
	}
	
	public enum ManualInterventionUpdateMetadataStatus
	{
		
		unknown = 0,
		
		pending = 1,
		
		rejected = 2,
		
		approved = 3,
		
		canceled = 4,
	}
	
	public class MappingDetails
	{
		
		public System.Collections.Generic.Dictionary<string, InputValue> Mappings { get; set; }
	}
	
	public class Metric
	{
		
		/// <summary>
		/// Name of the Metric.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Value of the Metric.
		/// </summary>
		public System.Nullable<System.Int32> Value { get; set; }
	}
	
	public class MultiConfigInput
	{
		
		/// <summary>
		/// Multipliers for parallel execution of deployment, for example x86,x64.
		/// </summary>
		public string Multipliers { get; set; }
	}
	
	public class MultiMachineInput
	{
	}
	
	public class PackageTrigger
	{
		
		/// <summary>
		/// Package trigger alias.
		/// </summary>
		public string Alias { get; set; }
	}
	
	public class ParallelExecutionInputBase
	{
		
		/// <summary>
		/// Indicate whether continue execution of deployment on error or not.
		/// </summary>
		public System.Nullable<System.Boolean> ContinueOnError { get; set; }
		
		/// <summary>
		/// Maximum number of agents used while parallel execution.
		/// </summary>
		public System.Nullable<System.Int32> MaxNumberOfAgents { get; set; }
	}
	
	public class PipelineProcess
	{
		
		/// <summary>
		/// Pipeline process type.
		/// </summary>
		public System.Nullable<PipelineProcessType> Type { get; set; }
	}
	
	public enum PipelineProcessType
	{
		
		designer = 0,
		
		yaml = 1,
	}
	
	public class PropertySelector
	{
		
		/// <summary>
		/// List of properties.
		/// </summary>
		public string[] Properties { get; set; }
		
		/// <summary>
		/// Property selector type.
		/// </summary>
		public System.Nullable<PropertySelectorSelectorType> SelectorType { get; set; }
	}
	
	public enum PropertySelectorSelectorType
	{
		
		inclusion = 0,
		
		exclusion = 1,
	}
	
	public class PullRequestConfiguration
	{
		
		public CodeRepositoryReference CodeRepositoryReference { get; set; }
		
		/// <summary>
		/// In case of Source based artifacts, Code reference will be present in Artifact details.
		/// </summary>
		public System.Nullable<System.Boolean> UseArtifactReference { get; set; }
	}
	
	public class PullRequestFilter
	{
		
		/// <summary>
		/// List of tags.
		/// </summary>
		public string[] Tags { get; set; }
		
		/// <summary>
		/// Target branch of pull request.
		/// </summary>
		public string TargetBranch { get; set; }
	}
	
	public class PullRequestTrigger
	{
		
		/// <summary>
		/// Artifact alias trigger is linked to.
		/// </summary>
		public string ArtifactAlias { get; set; }
		
		public PullRequestConfiguration PullRequestConfiguration { get; set; }
		
		/// <summary>
		/// Policy name using which status will be published to pull request.
		/// </summary>
		public string StatusPolicyName { get; set; }
		
		/// <summary>
		/// List of filters applied while trigger.
		/// </summary>
		public PullRequestFilter[] TriggerConditions { get; set; }
	}
	
	public class QueuedReleaseData
	{
		
		/// <summary>
		/// Project ID of the release.
		/// </summary>
		public string ProjectId { get; set; }
		
		/// <summary>
		/// Release queue position.
		/// </summary>
		public System.Nullable<System.Int32> QueuePosition { get; set; }
		
		/// <summary>
		/// Queued release ID.
		/// </summary>
		public System.Nullable<System.Int32> ReleaseId { get; set; }
	}
	
	public class RealtimeReleaseDefinitionEvent
	{
		
		public System.Nullable<System.Int32> DefinitionId { get; set; }
		
		public string ProjectId { get; set; }
	}
	
	public class RealtimeReleaseEvent
	{
		
		public System.Nullable<System.Int32> EnvironmentId { get; set; }
		
		public string ProjectId { get; set; }
		
		public System.Nullable<System.Int32> ReleaseId { get; set; }
	}
	
	public class ReleaseAbandonedEvent
	{
		
		public ProjectReference Project { get; set; }
		
		public Release Release { get; set; }
	}
	
	public class ReleaseApprovalPendingEvent
	{
		
		public ReleaseApproval Approval { get; set; }
		
		public ApprovalOptions ApprovalOptions { get; set; }
		
		public ReleaseApproval[] CompletedApprovals { get; set; }
		
		public string DefinitionName { get; set; }
		
		public Deployment Deployment { get; set; }
		
		public System.Nullable<System.Int32> EnvironmentId { get; set; }
		
		public string EnvironmentName { get; set; }
		
		public ReleaseEnvironment[] Environments { get; set; }
		
		public System.Nullable<System.Boolean> IsMultipleRankApproval { get; set; }
		
		public ReleaseApproval[] PendingApprovals { get; set; }
		
		public string ReleaseCreator { get; set; }
		
		public string ReleaseName { get; set; }
		
		public string Title { get; set; }
		
		public string WebAccessUri { get; set; }
	}
	
	public class ReleaseArtifact
	{
		
		public ArtifactProvider ArtifactProvider { get; set; }
		
		/// <summary>
		/// Gets or sets the artifact type of ReleaseArtifact.
		/// </summary>
		public string ArtifactType { get; set; }
		
		/// <summary>
		/// Gets or sets the definition json of ReleaseArtifact.
		/// </summary>
		public string DefinitionData { get; set; }
		
		/// <summary>
		/// Gets or sets the definition id of ReleaseArtifact.
		/// </summary>
		public System.Nullable<System.Int32> DefinitionId { get; set; }
		
		/// <summary>
		/// Gets or sets the description of ReleaseArtifact.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Gets or sets the id of ReleaseArtifact.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Gets or sets the name of ReleaseArtifact.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the release id.
		/// </summary>
		public System.Nullable<System.Int32> ReleaseId { get; set; }
	}
	
	public class ReleaseCreatedEvent
	{
		
		public ProjectReference Project { get; set; }
		
		public Release Release { get; set; }
	}
	
	public class ReleaseDefinition
	{
		
		/// <summary>
		/// Gets or sets the list of artifacts.
		/// </summary>
		public Artifact[] Artifacts { get; set; }
		
		/// <summary>
		/// Gets or sets comment.
		/// </summary>
		public string Comment { get; set; }
		
		public IdentityRef CreatedBy { get; set; }
		
		/// <summary>
		/// Gets date on which it got created.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedOn { get; set; }
		
		/// <summary>
		/// Gets or sets the description.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Gets or sets the list of environments.
		/// </summary>
		public ReleaseDefinitionEnvironment[] Environments { get; set; }
		
		/// <summary>
		/// Whether release definition is deleted.
		/// </summary>
		public System.Nullable<System.Boolean> IsDeleted { get; set; }
		
		public ReleaseReference LastRelease { get; set; }
		
		public IdentityRef ModifiedBy { get; set; }
		
		/// <summary>
		/// Gets date on which it got modified.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ModifiedOn { get; set; }
		
		/// <summary>
		/// The class represents a property bag as a collection of key-value pairs. Values of all primitive types (any type with a `TypeCode != TypeCode.Object`) except for `DBNull` are accepted. Values of type Byte[], Int32, Double, DateType and String preserve their type, other primitives are retuned as a String. Byte[] expected as base64 encoded string.
		/// </summary>
		public PropertiesCollection Properties { get; set; }
		
		/// <summary>
		/// Gets or sets the release name format.
		/// </summary>
		public string ReleaseNameFormat { get; set; }
		
		/// <summary>
		/// Gets the revision number.
		/// </summary>
		public System.Nullable<System.Int32> Revision { get; set; }
		
		/// <summary>
		/// Gets or sets source of release definition.
		/// </summary>
		public System.Nullable<ReleaseDefinitionSource> Source { get; set; }
		
		/// <summary>
		/// Gets or sets list of tags.
		/// </summary>
		public string[] Tags { get; set; }
		
		/// <summary>
		/// Gets or sets the list of triggers.
		/// </summary>
		public ReleaseTriggerBase[] Triggers { get; set; }
		
		/// <summary>
		/// Gets or sets the list of variable groups.
		/// </summary>
		public int[] VariableGroups { get; set; }
		
		/// <summary>
		/// Gets or sets the dictionary of variables.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, ConfigurationVariableValue> Variables { get; set; }
	}
	
	public class ReleaseDefinitionEnvironment
	{
		
		/// <summary>
		/// Gets or sets the BadgeUrl. BadgeUrl will be used when Badge will be enabled in Release Definition Environment.
		/// </summary>
		public string BadgeUrl { get; set; }
		
		/// <summary>
		/// Gets or sets the environment conditions.
		/// </summary>
		public Condition[] Conditions { get; set; }
		
		public ReleaseShallowReference CurrentRelease { get; set; }
		
		/// <summary>
		/// Gets or sets the demands.
		/// </summary>
		public Demand[] Demands { get; set; }
		
		/// <summary>
		/// Gets or sets the deploy phases of environment.
		/// </summary>
		public DeployPhase[] DeployPhases { get; set; }
		
		public ReleaseDefinitionDeployStep DeployStep { get; set; }
		
		public EnvironmentOptions EnvironmentOptions { get; set; }
		
		/// <summary>
		/// Gets or sets the triggers on environment.
		/// </summary>
		public EnvironmentTrigger[] EnvironmentTriggers { get; set; }
		
		/// <summary>
		/// Defines policy on environment queuing at Release Management side queue. We will send to Environment Runner [creating pre-deploy and other steps] only when the policies mentioned are satisfied.
		/// </summary>
		public EnvironmentExecutionPolicy ExecutionPolicy { get; set; }
		
		/// <summary>
		/// Gets and sets the ID of the ReleaseDefinitionEnvironment.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Gets and sets the name of the ReleaseDefinitionEnvironment.
		/// </summary>
		public string Name { get; set; }
		
		public IdentityRef Owner { get; set; }
		
		public ReleaseDefinitionApprovals PostDeployApprovals { get; set; }
		
		public ReleaseDefinitionGatesStep PostDeploymentGates { get; set; }
		
		public ReleaseDefinitionApprovals PreDeployApprovals { get; set; }
		
		public ReleaseDefinitionGatesStep PreDeploymentGates { get; set; }
		
		public ProcessParameters ProcessParameters { get; set; }
		
		/// <summary>
		/// The class represents a property bag as a collection of key-value pairs. Values of all primitive types (any type with a `TypeCode != TypeCode.Object`) except for `DBNull` are accepted. Values of type Byte[], Int32, Double, DateType and String preserve their type, other primitives are retuned as a String. Byte[] expected as base64 encoded string.
		/// </summary>
		public PropertiesCollection Properties { get; set; }
		
		/// <summary>
		/// Gets or sets the queue ID.
		/// </summary>
		public System.Nullable<System.Int32> QueueId { get; set; }
		
		/// <summary>
		/// Gets and sets the rank of the ReleaseDefinitionEnvironment.
		/// </summary>
		public System.Nullable<System.Int32> Rank { get; set; }
		
		public EnvironmentRetentionPolicy RetentionPolicy { get; set; }
		
		/// <summary>
		/// Gets or sets the schedules
		/// </summary>
		public ReleaseSchedule[] Schedules { get; set; }
		
		/// <summary>
		/// Gets or sets the variable groups.
		/// </summary>
		public int[] VariableGroups { get; set; }
		
		/// <summary>
		/// Gets and sets the variables.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, ConfigurationVariableValue> Variables { get; set; }
	}
	
	public class ReleaseDefinitionDeployStep
	{
		
		/// <summary>
		/// The list of steps for this definition.
		/// </summary>
		public WorkflowTask[] Tasks { get; set; }
	}
	
	public enum ReleaseDefinitionSource
	{
		
		undefined = 0,
		
		restApi = 1,
		
		userInterface = 2,
		
		ibiza = 3,
		
		portalExtensionApi = 4,
	}
	
	public class ReleaseTriggerBase
	{
		
		/// <summary>
		/// Type of release trigger.
		/// </summary>
		public System.Nullable<ReleaseTriggerBaseTriggerType> TriggerType { get; set; }
	}
	
	public enum ReleaseTriggerBaseTriggerType
	{
		
		undefined = 0,
		
		artifactSource = 1,
		
		schedule = 2,
		
		sourceRepo = 3,
		
		containerImage = 4,
		
		_package = 5,
		
		pullRequest = 6,
	}
	
	public class ReleaseDefinitionEnvironmentStep
	{
		
		/// <summary>
		/// ID of the approval or deploy step.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
	}
	
	public class ReleaseDefinitionEnvironmentSummary
	{
		
		/// <summary>
		/// ID of ReleaseDefinition environment summary.
		/// </summary>
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// List of release shallow reference deployed using this ReleaseDefinition.
		/// </summary>
		public ReleaseShallowReference[] LastReleases { get; set; }
		
		/// <summary>
		/// Name of ReleaseDefinition environment summary.
		/// </summary>
		public string Name { get; set; }
	}
	
	public class ReleaseDefinitionEnvironmentTemplate
	{
		
		/// <summary>
		/// Indicates whether template can be deleted or not.
		/// </summary>
		public System.Nullable<System.Boolean> CanDelete { get; set; }
		
		/// <summary>
		/// Category of the ReleaseDefinition environment template.
		/// </summary>
		public string Category { get; set; }
		
		/// <summary>
		/// Description of the ReleaseDefinition environment template.
		/// </summary>
		public string Description { get; set; }
		
		public ReleaseDefinitionEnvironment Environment { get; set; }
		
		/// <summary>
		/// ID of the task which used to display icon used for this template.
		/// </summary>
		public string IconTaskId { get; set; }
		
		/// <summary>
		/// Icon uri of the template.
		/// </summary>
		public string IconUri { get; set; }
		
		/// <summary>
		/// ID of the ReleaseDefinition environment template.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Indicates whether template deleted or not.
		/// </summary>
		public System.Nullable<System.Boolean> IsDeleted { get; set; }
		
		/// <summary>
		/// Name of the ReleaseDefinition environment template.
		/// </summary>
		public string Name { get; set; }
	}
	
	public class ReleaseDefinitionRevision
	{
		
		/// <summary>
		/// Gets api-version for revision object.
		/// </summary>
		public string ApiVersion { get; set; }
		
		public IdentityRef ChangedBy { get; set; }
		
		/// <summary>
		/// Gets date on which ReleaseDefinition changed.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ChangedDate { get; set; }
		
		/// <summary>
		/// Gets type of change.
		/// </summary>
		public System.Nullable<ReleaseDefinitionRevisionChangeType> ChangeType { get; set; }
		
		/// <summary>
		/// Gets comments for revision.
		/// </summary>
		public string Comment { get; set; }
		
		/// <summary>
		/// Get id of the definition.
		/// </summary>
		public System.Nullable<System.Int32> DefinitionId { get; set; }
		
		/// <summary>
		/// Gets definition URL.
		/// </summary>
		public string DefinitionUrl { get; set; }
		
		/// <summary>
		/// Get revision number of the definition.
		/// </summary>
		public System.Nullable<System.Int32> Revision { get; set; }
	}
	
	public enum ReleaseDefinitionRevisionChangeType
	{
		
		add = 0,
		
		update = 1,
		
		_delete = 2,
		
		undelete = 3,
	}
	
	public class ReleaseDefinitionSummary
	{
		
		/// <summary>
		/// List of Release Definition environment summary.
		/// </summary>
		public ReleaseDefinitionEnvironmentSummary[] Environments { get; set; }
		
		public ReleaseDefinitionShallowReference ReleaseDefinition { get; set; }
		
		/// <summary>
		/// List of releases deployed using this Release Definition.
		/// </summary>
		public Release[] Releases { get; set; }
	}
	
	public class ReleaseDefinitionUndeleteParameter
	{
		
		/// <summary>
		/// Gets or sets comment.
		/// </summary>
		public string Comment { get; set; }
	}
	
	public class ReleaseEnvironmentCompletedEvent
	{
		
		public string CreatedByName { get; set; }
		
		public System.Nullable<System.Int32> DefinitionId { get; set; }
		
		public string DefinitionName { get; set; }
		
		public ReleaseEnvironment Environment { get; set; }
		
		public System.Nullable<System.Int32> EnvironmentId { get; set; }
		
		public string ProjectName { get; set; }
		
		public System.Nullable<ReleaseEnvironmentCompletedEventReason> Reason { get; set; }
		
		public IdentityRef ReleaseCreatedBy { get; set; }
		
		public string ReleaseLogsUri { get; set; }
		
		public string ReleaseName { get; set; }
		
		public string Status { get; set; }
		
		public string Title { get; set; }
		
		public string WebAccessUri { get; set; }
	}
	
	public enum ReleaseEnvironmentCompletedEventReason
	{
		
		none = 0,
		
		manual = 1,
		
		automated = 2,
		
		scheduled = 3,
		
		redeployTrigger = 4,
	}
	
	public class ReleaseEnvironmentStatusUpdatedEvent
	{
		
		public System.Nullable<System.Int32> EnvironmentId { get; set; }
		
		public System.Nullable<ReleaseEnvironmentStatusUpdatedEventEnvironmentStatus> EnvironmentStatus { get; set; }
		
		public System.Nullable<ReleaseEnvironmentStatusUpdatedEventLatestDeploymentOperationStatus> LatestDeploymentOperationStatus { get; set; }
		
		public System.Nullable<ReleaseEnvironmentStatusUpdatedEventLatestDeploymentStatus> LatestDeploymentStatus { get; set; }
		
		public System.Nullable<System.Int32> ReleaseId { get; set; }
	}
	
	public enum ReleaseEnvironmentStatusUpdatedEventEnvironmentStatus
	{
		
		undefined = 0,
		
		notStarted = 1,
		
		inProgress = 2,
		
		succeeded = 3,
		
		canceled = 4,
		
		rejected = 5,
		
		queued = 6,
		
		scheduled = 7,
		
		partiallySucceeded = 8,
	}
	
	public enum ReleaseEnvironmentStatusUpdatedEventLatestDeploymentOperationStatus
	{
		
		undefined = 0,
		
		queued = 1,
		
		scheduled = 2,
		
		pending = 3,
		
		approved = 4,
		
		rejected = 5,
		
		deferred = 6,
		
		queuedForAgent = 7,
		
		phaseInProgress = 8,
		
		phaseSucceeded = 9,
		
		phasePartiallySucceeded = 10,
		
		phaseFailed = 11,
		
		canceled = 12,
		
		phaseCanceled = 13,
		
		manualInterventionPending = 14,
		
		queuedForPipeline = 15,
		
		cancelling = 16,
		
		evaluatingGates = 17,
		
		gateFailed = 18,
		
		all = 19,
	}
	
	public enum ReleaseEnvironmentStatusUpdatedEventLatestDeploymentStatus
	{
		
		undefined = 0,
		
		notDeployed = 1,
		
		inProgress = 2,
		
		succeeded = 3,
		
		partiallySucceeded = 4,
		
		failed = 5,
		
		all = 6,
	}
	
	public class ReleaseEnvironmentUpdateMetadata
	{
		
		/// <summary>
		/// Gets or sets comment.
		/// </summary>
		public string Comment { get; set; }
		
		/// <summary>
		/// Gets or sets scheduled deployment time.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ScheduledDeploymentTime { get; set; }
		
		/// <summary>
		/// Gets or sets status of environment.
		/// </summary>
		public System.Nullable<ReleaseEnvironmentUpdateMetadataStatus> Status { get; set; }
		
		/// <summary>
		/// Sets list of environment variables to be overridden at deployment time.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, ConfigurationVariableValue> Variables { get; set; }
	}
	
	public enum ReleaseEnvironmentUpdateMetadataStatus
	{
		
		undefined = 0,
		
		notStarted = 1,
		
		inProgress = 2,
		
		succeeded = 3,
		
		canceled = 4,
		
		rejected = 5,
		
		queued = 6,
		
		scheduled = 7,
		
		partiallySucceeded = 8,
	}
	
	public class ReleaseEvent
	{
		
		public System.Nullable<System.Int32> Id { get; set; }
		
		public string Url { get; set; }
	}
	
	public class ReleaseGatesPhase
	{
		
		/// <summary>
		/// List of ignored gates.
		/// </summary>
		public IgnoredGate[] IgnoredGates { get; set; }
		
		/// <summary>
		/// Date and time at which stabilization of gates completed.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> StabilizationCompletedOn { get; set; }
		
		/// <summary>
		/// Date and time at which all gates executed successfully.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> SucceedingSince { get; set; }
	}
	
	public class ReleaseNotCreatedEvent
	{
		
		public ReleaseDefinitionShallowReference DefinitionReference { get; set; }
		
		public string Message { get; set; }
		
		public System.Nullable<ReleaseNotCreatedEventReleaseReason> ReleaseReason { get; set; }
		
		public IdentityRef RequestedBy { get; set; }
	}
	
	public enum ReleaseNotCreatedEventReleaseReason
	{
		
		none = 0,
		
		manual = 1,
		
		continuousIntegration = 2,
		
		schedule = 3,
		
		pullRequest = 4,
	}
	
	public class ReleaseRevision
	{
		
		public IdentityRef ChangedBy { get; set; }
		
		/// <summary>
		/// Change date of the revision.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ChangedDate { get; set; }
		
		/// <summary>
		/// Change details of the revision.
		/// </summary>
		public string ChangeDetails { get; set; }
		
		/// <summary>
		/// Change details of the revision. Typically ChangeDetails values are Add and Update.
		/// </summary>
		public string ChangeType { get; set; }
		
		/// <summary>
		/// Comment of the revision.
		/// </summary>
		public string Comment { get; set; }
		
		/// <summary>
		/// Release ID of which this revision belongs.
		/// </summary>
		public System.Nullable<System.Int32> DefinitionSnapshotRevision { get; set; }
		
		/// <summary>
		/// Gets or sets the release ID of which this revision belongs.
		/// </summary>
		public System.Nullable<System.Int32> ReleaseId { get; set; }
	}
	
	public class ReleaseSettings
	{
		
		public ComplianceSettings ComplianceSettings { get; set; }
		
		public RetentionSettings RetentionSettings { get; set; }
	}
	
	public class RetentionSettings
	{
		
		/// <summary>
		/// Number of days to keep deleted releases.
		/// </summary>
		public System.Nullable<System.Int32> DaysToKeepDeletedReleases { get; set; }
		
		public EnvironmentRetentionPolicy DefaultEnvironmentRetentionPolicy { get; set; }
		
		public EnvironmentRetentionPolicy MaximumEnvironmentRetentionPolicy { get; set; }
	}
	
	public class ReleaseStartEnvironmentMetadata
	{
		
		/// <summary>
		/// Sets release definition environment id.
		/// </summary>
		public System.Nullable<System.Int32> DefinitionEnvironmentId { get; set; }
		
		/// <summary>
		/// Sets list of environments variables to be overridden at deployment time.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, ConfigurationVariableValue> Variables { get; set; }
	}
	
	public class ReleaseStartMetadata
	{
		
		/// <summary>
		/// Sets list of artifact to create a release.
		/// </summary>
		public ArtifactMetadata[] Artifacts { get; set; }
		
		/// <summary>
		/// Sets definition Id to create a release.
		/// </summary>
		public System.Nullable<System.Int32> DefinitionId { get; set; }
		
		/// <summary>
		/// Sets description to create a release.
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Sets list of environments meta data.
		/// </summary>
		public ReleaseStartEnvironmentMetadata[] EnvironmentsMetadata { get; set; }
		
		/// <summary>
		/// Sets 'true' to create release in draft mode, 'false' otherwise.
		/// </summary>
		public System.Nullable<System.Boolean> IsDraft { get; set; }
		
		/// <summary>
		/// Sets list of environments to manual as condition.
		/// </summary>
		public string[] ManualEnvironments { get; set; }
		
		/// <summary>
		/// The class represents a property bag as a collection of key-value pairs. Values of all primitive types (any type with a `TypeCode != TypeCode.Object`) except for `DBNull` are accepted. Values of type Byte[], Int32, Double, DateType and String preserve their type, other primitives are retuned as a String. Byte[] expected as base64 encoded string.
		/// </summary>
		public PropertiesCollection Properties { get; set; }
		
		/// <summary>
		/// Sets reason to create a release.
		/// </summary>
		public System.Nullable<ReleaseStartMetadataReason> Reason { get; set; }
		
		/// <summary>
		/// Sets list of release variables to be overridden at deployment time.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, ConfigurationVariableValue> Variables { get; set; }
	}
	
	public enum ReleaseStartMetadataReason
	{
		
		none = 0,
		
		manual = 1,
		
		continuousIntegration = 2,
		
		schedule = 3,
		
		pullRequest = 4,
	}
	
	public class ReleaseTaskAttachment
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// Data and time when it created.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> CreatedOn { get; set; }
		
		public IdentityRef ModifiedBy { get; set; }
		
		/// <summary>
		/// Data and time when modified.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ModifiedOn { get; set; }
		
		/// <summary>
		/// Name of the task attachment.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Record ID of the task.
		/// </summary>
		public string RecordId { get; set; }
		
		/// <summary>
		/// Timeline ID of the task.
		/// </summary>
		public string TimelineId { get; set; }
		
		/// <summary>
		/// Type of task attachment.
		/// </summary>
		public string Type { get; set; }
	}
	
	public class ReleaseTaskLogUpdatedEvent
	{
		
		public string[] Lines { get; set; }
		
		public string StepRecordId { get; set; }
		
		public string TimelineRecordId { get; set; }
	}
	
	public class ReleaseTasksUpdatedEvent
	{
		
		public ReleaseTask Job { get; set; }
		
		public string PlanId { get; set; }
		
		public System.Nullable<System.Int32> ReleaseStepId { get; set; }
		
		public ReleaseTask[] Tasks { get; set; }
	}
	
	public class ReleaseUpdatedEvent
	{
		
		public Release Release { get; set; }
	}
	
	public class ReleaseUpdateMetadata
	{
		
		/// <summary>
		/// Sets comment for release.
		/// </summary>
		public string Comment { get; set; }
		
		/// <summary>
		/// Set 'true' to exclude the release from retention policies.
		/// </summary>
		public System.Nullable<System.Boolean> KeepForever { get; set; }
		
		/// <summary>
		/// Sets list of manual environments.
		/// </summary>
		public string[] ManualEnvironments { get; set; }
		
		/// <summary>
		/// Sets name of the release.
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Sets status of the release.
		/// </summary>
		public System.Nullable<ReleaseUpdateMetadataStatus> Status { get; set; }
	}
	
	public enum ReleaseUpdateMetadataStatus
	{
		
		undefined = 0,
		
		draft = 1,
		
		active = 2,
		
		abandoned = 3,
	}
	
	public class ReleaseWorkItemRef
	{
		
		/// <summary>
		/// Gets or sets the ID.
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Gets or sets the provider.
		/// </summary>
		public string Provider { get; set; }
		
		/// <summary>
		/// Gets or sets the state.
		/// </summary>
		public string State { get; set; }
		
		/// <summary>
		/// Gets or sets the title.
		/// </summary>
		public string Title { get; set; }
		
		/// <summary>
		/// Gets or sets the type.
		/// </summary>
		public string Type { get; set; }
		
		/// <summary>
		/// Gets or sets the workitem url.
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Represents a reference to a resource.
	/// </summary>
	public class ResourceReference
	{
		
		/// <summary>
		/// An alias to be used when referencing the resource.
		/// </summary>
		public string Alias { get; set; }
	}
	
	public class RetentionPolicy
	{
		
		/// <summary>
		/// Indicates the number of days to keep deployment.
		/// </summary>
		public System.Nullable<System.Int32> DaysToKeep { get; set; }
	}
	
	public class RunOnServerDeployPhase
	{
		
		public ServerDeploymentInput DeploymentInput { get; set; }
	}
	
	public class ServerDeploymentInput
	{
		
		public ExecutionInput ParallelExecution { get; set; }
	}
	
	public class ScheduledReleaseTrigger
	{
		
		public ReleaseSchedule Schedule { get; set; }
	}
	
	/// <summary>
	/// Represents a reference to a service endpoint.
	/// </summary>
	public class ServiceEndpointReference
	{
		
		/// <summary>
		/// The ID of the service endpoint.
		/// </summary>
		public string Id { get; set; }
	}
	
	public class SourceRepoTrigger
	{
		
		/// <summary>
		/// Alias of the source repo trigger.
		/// </summary>
		public string Alias { get; set; }
		
		public string[] BranchFilters { get; set; }
	}
	
	public class SummaryMailSection
	{
		
		/// <summary>
		/// Html content of summary mail.
		/// </summary>
		public string HtmlContent { get; set; }
		
		/// <summary>
		/// Rank of the summary mail.
		/// </summary>
		public System.Nullable<System.Int32> Rank { get; set; }
		
		/// <summary>
		/// Summary mail section type. MailSectionType has section types.
		/// </summary>
		public System.Nullable<SummaryMailSectionSectionType> SectionType { get; set; }
		
		/// <summary>
		/// Title of the summary mail.
		/// </summary>
		public string Title { get; set; }
	}
	
	public enum SummaryMailSectionSectionType
	{
		
		details = 0,
		
		environments = 1,
		
		issues = 2,
		
		testResults = 3,
		
		workItems = 4,
		
		releaseInfo = 5,
	}
	
	public class TaskOrchestrationPlanGroupReference
	{
		
		/// <summary>
		/// Gets or sets the plan group.
		/// </summary>
		public string PlanGroup { get; set; }
		
		/// <summary>
		/// ID of the Project.
		/// </summary>
		public string ProjectId { get; set; }
	}
	
	public class TaskOrchestrationPlanGroupsStartedEvent
	{
		
		public TaskOrchestrationPlanGroupReference[] PlanGroups { get; set; }
	}
	
	public class TfvcArtifactDownloadInput
	{
	}
	
	public class TimeZone
	{
		
		/// <summary>
		/// Display name of the time zone.
		/// </summary>
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Id of the time zone.
		/// </summary>
		public string Id { get; set; }
	}
	
	public class TimeZoneList
	{
		
		public TimeZone UtcTimeZone { get; set; }
		
		/// <summary>
		/// List of valid timezones.
		/// </summary>
		public TimeZone[] ValidTimeZones { get; set; }
	}
	
	/// <summary>
	/// This class is used to serialized collections as a single JSON object on the wire, to avoid serializing JSON arrays directly to the client, which can be a security hole
	/// </summary>
	public class VssJsonCollectionWrapper
	{
		
		public string Value { get; set; }
	}
	
	public class VssJsonCollectionWrapperBase
	{
		
		public System.Nullable<System.Int32> Count { get; set; }
	}
	
	public class YamlFileSource
	{
		
		/// <summary>
		/// Gets or sets definition reference. e.g. {"project":{"id":"fed755ea-49c5-4399-acea-fd5b5aa90a6c","name":"myProject"},"definition":{"id":"1","name":"mybuildDefinition"},"connection":{"id":"1","name":"myConnection"}}
		/// </summary>
		public System.Collections.Generic.Dictionary<string, YamlSourceReference> SourceReference { get; set; }
		
		public System.Nullable<YamlFileSourceType> Type { get; set; }
	}
	
	public class YamlSourceReference
	{
		
		public string Id { get; set; }
		
		public string Name { get; set; }
	}
	
	public enum YamlFileSourceType
	{
		
		none = 0,
		
		tfsGit = 1,
	}
	
	public class YamlPipelineProcess
	{
		
		public string[] Errors { get; set; }
		
		public string Filename { get; set; }
		
		public YamlFileSource FileSource { get; set; }
		
		public YamlPipelineProcessResources Resources { get; set; }
	}
	
	public class YamlPipelineProcessResources
	{
		
		public ServiceEndpointReference[] Endpoints { get; set; }
		
		public AgentPoolQueueReference[] Queues { get; set; }
	}
	
	public partial class MyClient
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public MyClient(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Get a list of approvals
		/// Approvals_List {organization}/{project}/_apis/release/approvals
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="assignedToFilter">Approvals assigned to this user.</param>
		/// <param name="statusFilter">Approvals with this status. Default is 'pending'.</param>
		/// <param name="releaseIdsFilter">Approvals for release id(s) mentioned in the filter. Multiple releases can be mentioned by separating them with ',' e.g. releaseIdsFilter=1,2,3,4.</param>
		/// <param name="typeFilter">Approval with this type.</param>
		/// <param name="top">Number of approvals to get. Default is 50.</param>
		/// <param name="continuationToken">Gets the approvals after the continuation token provided.</param>
		/// <param name="queryOrder">Gets the results in the defined order of created approvals. Default is 'descending'.</param>
		/// <param name="includeMyGroupApprovals">'true' to include my group approvals. Default is 'false'.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.3' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<ReleaseApproval[]> Approvals_ListAsync(string organization, string project, string assignedToFilter, ReleaseApprovalStatus statusFilter, string releaseIdsFilter, ReleaseApprovalApprovalType typeFilter, int top, int continuationToken, Approvals_ListQueryOrder queryOrder, bool includeMyGroupApprovals, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/approvals&assignedToFilter=" + (assignedToFilter==null? "" : System.Uri.EscapeDataString(assignedToFilter))+"&statusFilter=" + statusFilter+"&releaseIdsFilter=" + (releaseIdsFilter==null? "" : System.Uri.EscapeDataString(releaseIdsFilter))+"&typeFilter=" + typeFilter+"&top="+top+"&continuationToken="+continuationToken+"&queryOrder=" + queryOrder+"&includeMyGroupApprovals="+includeMyGroupApprovals+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseApproval[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a list of approvals
		/// Approvals_List {organization}/{project}/_apis/release/approvals
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="assignedToFilter">Approvals assigned to this user.</param>
		/// <param name="statusFilter">Approvals with this status. Default is 'pending'.</param>
		/// <param name="releaseIdsFilter">Approvals for release id(s) mentioned in the filter. Multiple releases can be mentioned by separating them with ',' e.g. releaseIdsFilter=1,2,3,4.</param>
		/// <param name="typeFilter">Approval with this type.</param>
		/// <param name="top">Number of approvals to get. Default is 50.</param>
		/// <param name="continuationToken">Gets the approvals after the continuation token provided.</param>
		/// <param name="queryOrder">Gets the results in the defined order of created approvals. Default is 'descending'.</param>
		/// <param name="includeMyGroupApprovals">'true' to include my group approvals. Default is 'false'.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.3' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public ReleaseApproval[] Approvals_List(string organization, string project, string assignedToFilter, ReleaseApprovalStatus statusFilter, string releaseIdsFilter, ReleaseApprovalApprovalType typeFilter, int top, int continuationToken, Approvals_ListQueryOrder queryOrder, bool includeMyGroupApprovals, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/approvals&assignedToFilter=" + (assignedToFilter==null? "" : System.Uri.EscapeDataString(assignedToFilter))+"&statusFilter=" + statusFilter+"&releaseIdsFilter=" + (releaseIdsFilter==null? "" : System.Uri.EscapeDataString(releaseIdsFilter))+"&typeFilter=" + typeFilter+"&top="+top+"&continuationToken="+continuationToken+"&queryOrder=" + queryOrder+"&includeMyGroupApprovals="+includeMyGroupApprovals+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseApproval[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update status of an approval
		/// Approvals_Update {organization}/{project}/_apis/release/approvals/{approvalId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="approvalId">Id of the approval.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.3' to use this version of the api.</param>
		/// <param name="requestBody">ReleaseApproval object having status, approver and comments.</param>
		/// <returns>successful operation</returns>
		public async Task<ReleaseApproval> Approvals_UpdateAsync(string organization, string project, int approvalId, string api_version, ReleaseApproval requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/approvals/"+approvalId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseApproval>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update status of an approval
		/// Approvals_Update {organization}/{project}/_apis/release/approvals/{approvalId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="approvalId">Id of the approval.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.3' to use this version of the api.</param>
		/// <param name="requestBody">ReleaseApproval object having status, approver and comments.</param>
		/// <returns>successful operation</returns>
		public ReleaseApproval Approvals_Update(string organization, string project, int approvalId, string api_version, ReleaseApproval requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/approvals/"+approvalId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseApproval>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a list of release definitions.
		/// Definitions_List {organization}/{project}/_apis/release/definitions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="searchText">Get release definitions with names containing searchText.</param>
		/// <param name="expand">The properties that should be expanded in the list of Release definitions.</param>
		/// <param name="artifactType">Release definitions with given artifactType will be returned. Values can be Build, Jenkins, GitHub, Nuget, Team Build (external), ExternalTFSBuild, Git, TFVC, ExternalTfsXamlBuild.</param>
		/// <param name="artifactSourceId">Release definitions with given artifactSourceId will be returned. e.g. For build it would be {projectGuid}:{BuildDefinitionId}, for Jenkins it would be {JenkinsConnectionId}:{JenkinsDefinitionId}, for TfsOnPrem it would be {TfsOnPremConnectionId}:{ProjectName}:{TfsOnPremDefinitionId}. For third-party artifacts e.g. TeamCity, BitBucket you may refer 'uniqueSourceIdentifier' inside vss-extension.json at https://github.com/Microsoft/vsts-rm-extensions/blob/master/Extensions.</param>
		/// <param name="top">Number of release definitions to get.</param>
		/// <param name="continuationToken">Gets the release definitions after the continuation token provided.</param>
		/// <param name="queryOrder">Gets the results in the defined order. Default is 'IdAscending'.</param>
		/// <param name="path">Gets the release definitions under the specified path.</param>
		/// <param name="isExactNameMatch">'true'to gets the release definitions with exact match as specified in searchText. Default is 'false'.</param>
		/// <param name="tagFilter">A comma-delimited list of tags. Only release definitions with these tags will be returned.</param>
		/// <param name="propertyFilters">A comma-delimited list of extended properties to be retrieved. If set, the returned Release Definitions will contain values for the specified property Ids (if they exist). If not set, properties will not be included. Note that this will not filter out any Release Definition from results irrespective of whether it has property set or not.</param>
		/// <param name="definitionIdFilter">A comma-delimited list of release definitions to retrieve.</param>
		/// <param name="isDeleted">'true' to get release definitions that has been deleted. Default is 'false'</param>
		/// <param name="searchTextContainsFolderName">'true' to get the release definitions under the folder with name as specified in searchText. Default is 'false'.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.4' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<ReleaseDefinition[]> Definitions_ListAsync(
					string organization, 
					string project, 
					string searchText, 
					Definitions_ListExpand expand, 
					string artifactType, 
					string artifactSourceId, 
					int top, 
					string continuationToken, 
					Definitions_ListQueryOrder queryOrder, 
					string path, 
					bool isExactNameMatch, 
					string tagFilter, 
					string propertyFilters, 
					string definitionIdFilter, 
					bool isDeleted, 
					bool searchTextContainsFolderName, 
					string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/definitions&searchText=" + (searchText==null? "" : System.Uri.EscapeDataString(searchText))+"&$expand=" + expand+"&artifactType=" + (artifactType==null? "" : System.Uri.EscapeDataString(artifactType))+"&artifactSourceId=" + (artifactSourceId==null? "" : System.Uri.EscapeDataString(artifactSourceId))+"&$top="+top+"&continuationToken=" + (continuationToken==null? "" : System.Uri.EscapeDataString(continuationToken))+"&queryOrder=" + queryOrder+"&path=" + (path==null? "" : System.Uri.EscapeDataString(path))+"&isExactNameMatch="+isExactNameMatch+"&tagFilter=" + (tagFilter==null? "" : System.Uri.EscapeDataString(tagFilter))+"&propertyFilters=" + (propertyFilters==null? "" : System.Uri.EscapeDataString(propertyFilters))+"&definitionIdFilter=" + (definitionIdFilter==null? "" : System.Uri.EscapeDataString(definitionIdFilter))+"&isDeleted="+isDeleted+"&searchTextContainsFolderName="+searchTextContainsFolderName+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseDefinition[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a list of release definitions.
		/// Definitions_List {organization}/{project}/_apis/release/definitions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="searchText">Get release definitions with names containing searchText.</param>
		/// <param name="expand">The properties that should be expanded in the list of Release definitions.</param>
		/// <param name="artifactType">Release definitions with given artifactType will be returned. Values can be Build, Jenkins, GitHub, Nuget, Team Build (external), ExternalTFSBuild, Git, TFVC, ExternalTfsXamlBuild.</param>
		/// <param name="artifactSourceId">Release definitions with given artifactSourceId will be returned. e.g. For build it would be {projectGuid}:{BuildDefinitionId}, for Jenkins it would be {JenkinsConnectionId}:{JenkinsDefinitionId}, for TfsOnPrem it would be {TfsOnPremConnectionId}:{ProjectName}:{TfsOnPremDefinitionId}. For third-party artifacts e.g. TeamCity, BitBucket you may refer 'uniqueSourceIdentifier' inside vss-extension.json at https://github.com/Microsoft/vsts-rm-extensions/blob/master/Extensions.</param>
		/// <param name="top">Number of release definitions to get.</param>
		/// <param name="continuationToken">Gets the release definitions after the continuation token provided.</param>
		/// <param name="queryOrder">Gets the results in the defined order. Default is 'IdAscending'.</param>
		/// <param name="path">Gets the release definitions under the specified path.</param>
		/// <param name="isExactNameMatch">'true'to gets the release definitions with exact match as specified in searchText. Default is 'false'.</param>
		/// <param name="tagFilter">A comma-delimited list of tags. Only release definitions with these tags will be returned.</param>
		/// <param name="propertyFilters">A comma-delimited list of extended properties to be retrieved. If set, the returned Release Definitions will contain values for the specified property Ids (if they exist). If not set, properties will not be included. Note that this will not filter out any Release Definition from results irrespective of whether it has property set or not.</param>
		/// <param name="definitionIdFilter">A comma-delimited list of release definitions to retrieve.</param>
		/// <param name="isDeleted">'true' to get release definitions that has been deleted. Default is 'false'</param>
		/// <param name="searchTextContainsFolderName">'true' to get the release definitions under the folder with name as specified in searchText. Default is 'false'.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.4' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public ReleaseDefinition[] Definitions_List(
					string organization, 
					string project, 
					string searchText, 
					Definitions_ListExpand expand, 
					string artifactType, 
					string artifactSourceId, 
					int top, 
					string continuationToken, 
					Definitions_ListQueryOrder queryOrder, 
					string path, 
					bool isExactNameMatch, 
					string tagFilter, 
					string propertyFilters, 
					string definitionIdFilter, 
					bool isDeleted, 
					bool searchTextContainsFolderName, 
					string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/definitions&searchText=" + (searchText==null? "" : System.Uri.EscapeDataString(searchText))+"&$expand=" + expand+"&artifactType=" + (artifactType==null? "" : System.Uri.EscapeDataString(artifactType))+"&artifactSourceId=" + (artifactSourceId==null? "" : System.Uri.EscapeDataString(artifactSourceId))+"&$top="+top+"&continuationToken=" + (continuationToken==null? "" : System.Uri.EscapeDataString(continuationToken))+"&queryOrder=" + queryOrder+"&path=" + (path==null? "" : System.Uri.EscapeDataString(path))+"&isExactNameMatch="+isExactNameMatch+"&tagFilter=" + (tagFilter==null? "" : System.Uri.EscapeDataString(tagFilter))+"&propertyFilters=" + (propertyFilters==null? "" : System.Uri.EscapeDataString(propertyFilters))+"&definitionIdFilter=" + (definitionIdFilter==null? "" : System.Uri.EscapeDataString(definitionIdFilter))+"&isDeleted="+isDeleted+"&searchTextContainsFolderName="+searchTextContainsFolderName+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseDefinition[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a release definition.
		/// Definitions_Update {organization}/{project}/_apis/release/definitions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.4' to use this version of the api.</param>
		/// <param name="requestBody">Release definition object to update.</param>
		/// <returns>successful operation</returns>
		public async Task<ReleaseDefinition> Definitions_UpdateAsync(string organization, string project, string api_version, ReleaseDefinition requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/definitions&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseDefinition>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update a release definition.
		/// Definitions_Update {organization}/{project}/_apis/release/definitions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.4' to use this version of the api.</param>
		/// <param name="requestBody">Release definition object to update.</param>
		/// <returns>successful operation</returns>
		public ReleaseDefinition Definitions_Update(string organization, string project, string api_version, ReleaseDefinition requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/definitions&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseDefinition>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a release definition
		/// Definitions_Create {organization}/{project}/_apis/release/definitions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.4' to use this version of the api.</param>
		/// <param name="requestBody">release definition object to create.</param>
		/// <returns>successful operation</returns>
		public async Task<ReleaseDefinition> Definitions_CreateAsync(string organization, string project, string api_version, ReleaseDefinition requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/definitions&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseDefinition>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a release definition
		/// Definitions_Create {organization}/{project}/_apis/release/definitions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.4' to use this version of the api.</param>
		/// <param name="requestBody">release definition object to create.</param>
		/// <returns>successful operation</returns>
		public ReleaseDefinition Definitions_Create(string organization, string project, string api_version, ReleaseDefinition requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/definitions&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseDefinition>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a release definition.
		/// Definitions_Get {organization}/{project}/_apis/release/definitions/{definitionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">Id of the release definition.</param>
		/// <param name="propertyFilters">A comma-delimited list of extended properties to be retrieved. If set, the returned Release Definition will contain values for the specified property Ids (if they exist). If not set, properties will not be included.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.4' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<ReleaseDefinition> Definitions_GetAsync(string organization, string project, int definitionId, string propertyFilters, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/definitions/"+definitionId+"&propertyFilters=" + (propertyFilters==null? "" : System.Uri.EscapeDataString(propertyFilters))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseDefinition>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a release definition.
		/// Definitions_Get {organization}/{project}/_apis/release/definitions/{definitionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">Id of the release definition.</param>
		/// <param name="propertyFilters">A comma-delimited list of extended properties to be retrieved. If set, the returned Release Definition will contain values for the specified property Ids (if they exist). If not set, properties will not be included.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.4' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public ReleaseDefinition Definitions_Get(string organization, string project, int definitionId, string propertyFilters, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/definitions/"+definitionId+"&propertyFilters=" + (propertyFilters==null? "" : System.Uri.EscapeDataString(propertyFilters))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseDefinition>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a release definition.
		/// Definitions_Delete {organization}/{project}/_apis/release/definitions/{definitionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">Id of the release definition.</param>
		/// <param name="comment">Comment for deleting a release definition.</param>
		/// <param name="forceDelete">'true' to automatically cancel any in-progress release deployments and proceed with release definition deletion . Default is 'false'.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.4' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Definitions_DeleteAsync(string organization, string project, int definitionId, string comment, bool forceDelete, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/definitions/"+definitionId+"&comment=" + (comment==null? "" : System.Uri.EscapeDataString(comment))+"&forceDelete="+forceDelete+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a release definition.
		/// Definitions_Delete {organization}/{project}/_apis/release/definitions/{definitionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">Id of the release definition.</param>
		/// <param name="comment">Comment for deleting a release definition.</param>
		/// <param name="forceDelete">'true' to automatically cancel any in-progress release deployments and proceed with release definition deletion . Default is 'false'.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.4' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Definitions_Delete(string organization, string project, int definitionId, string comment, bool forceDelete, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/definitions/"+definitionId+"&comment=" + (comment==null? "" : System.Uri.EscapeDataString(comment))+"&forceDelete="+forceDelete+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get revision history for a release definition
		/// Definitions_Get_Release_Definition_History {organization}/{project}/_apis/Release/definitions/{definitionId}/revisions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">Id of the definition.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<ReleaseDefinitionRevision[]> Definitions_Get_Release_Definition_HistoryAsync(string organization, string project, int definitionId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/Release/definitions/"+definitionId+"/revisions&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseDefinitionRevision[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get revision history for a release definition
		/// Definitions_Get_Release_Definition_History {organization}/{project}/_apis/Release/definitions/{definitionId}/revisions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">Id of the definition.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public ReleaseDefinitionRevision[] Definitions_Get_Release_Definition_History(string organization, string project, int definitionId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/Release/definitions/"+definitionId+"/revisions&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseDefinitionRevision[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get release definition for a given definitionId and revision
		/// Definitions_Get_Definition_Revision {organization}/{project}/_apis/Release/definitions/{definitionId}/revisions/{revision}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">Id of the definition.</param>
		/// <param name="revision">Id of the revision.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<string> Definitions_Get_Definition_RevisionAsync(string organization, string project, int definitionId, int revision, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/Release/definitions/"+definitionId+"/revisions/"+revision+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (System.IO.StreamReader streamReader = new System.IO.StreamReader(responseMessageStream))
				{
				return streamReader.ReadToEnd();;
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get release definition for a given definitionId and revision
		/// Definitions_Get_Definition_Revision {organization}/{project}/_apis/Release/definitions/{definitionId}/revisions/{revision}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">Id of the definition.</param>
		/// <param name="revision">Id of the revision.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public string Definitions_Get_Definition_Revision(string organization, string project, int definitionId, int revision, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/Release/definitions/"+definitionId+"/revisions/"+revision+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (System.IO.StreamReader streamReader = new System.IO.StreamReader(responseMessageStream))
				{
				return streamReader.ReadToEnd();;
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deployments_List {organization}/{project}/_apis/release/deployments
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<Deployment[]> Deployments_ListAsync(
					string organization, 
					string project, 
					int definitionId, 
					int definitionEnvironmentId, 
					string createdBy, 
					System.DateTimeOffset minModifiedTime, 
					System.DateTimeOffset maxModifiedTime, 
					DeploymentDeploymentStatus deploymentStatus, 
					DeploymentOperationStatus operationStatus, 
					bool latestAttemptsOnly, 
					Approvals_ListQueryOrder queryOrder, 
					int top, 
					int continuationToken, 
					string createdFor, 
					System.DateTimeOffset minStartedTime, 
					System.DateTimeOffset maxStartedTime, 
					string sourceBranch, 
					string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/deployments&definitionId="+definitionId+"&definitionEnvironmentId="+definitionEnvironmentId+"&createdBy=" + (createdBy==null? "" : System.Uri.EscapeDataString(createdBy))+"&minModifiedTime=" + minModifiedTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&maxModifiedTime=" + maxModifiedTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&deploymentStatus=" + deploymentStatus+"&operationStatus=" + operationStatus+"&latestAttemptsOnly="+latestAttemptsOnly+"&queryOrder=" + queryOrder+"&$top="+top+"&continuationToken="+continuationToken+"&createdFor=" + (createdFor==null? "" : System.Uri.EscapeDataString(createdFor))+"&minStartedTime=" + minStartedTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&maxStartedTime=" + maxStartedTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&sourceBranch=" + (sourceBranch==null? "" : System.Uri.EscapeDataString(sourceBranch))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Deployment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deployments_List {organization}/{project}/_apis/release/deployments
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public Deployment[] Deployments_List(
					string organization, 
					string project, 
					int definitionId, 
					int definitionEnvironmentId, 
					string createdBy, 
					System.DateTimeOffset minModifiedTime, 
					System.DateTimeOffset maxModifiedTime, 
					DeploymentDeploymentStatus deploymentStatus, 
					DeploymentOperationStatus operationStatus, 
					bool latestAttemptsOnly, 
					Approvals_ListQueryOrder queryOrder, 
					int top, 
					int continuationToken, 
					string createdFor, 
					System.DateTimeOffset minStartedTime, 
					System.DateTimeOffset maxStartedTime, 
					string sourceBranch, 
					string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/deployments&definitionId="+definitionId+"&definitionEnvironmentId="+definitionEnvironmentId+"&createdBy=" + (createdBy==null? "" : System.Uri.EscapeDataString(createdBy))+"&minModifiedTime=" + minModifiedTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&maxModifiedTime=" + maxModifiedTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&deploymentStatus=" + deploymentStatus+"&operationStatus=" + operationStatus+"&latestAttemptsOnly="+latestAttemptsOnly+"&queryOrder=" + queryOrder+"&$top="+top+"&continuationToken="+continuationToken+"&createdFor=" + (createdFor==null? "" : System.Uri.EscapeDataString(createdFor))+"&minStartedTime=" + minStartedTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&maxStartedTime=" + maxStartedTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&sourceBranch=" + (sourceBranch==null? "" : System.Uri.EscapeDataString(sourceBranch))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Deployment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets folders.
		/// Folders_List {organization}/{project}/_apis/release/folders/{path}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="path">Path of the folder.</param>
		/// <param name="queryOrder">Gets the results in the defined order. Default is 'None'.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<Folder[]> Folders_ListAsync(string organization, string project, string path, Folders_ListQueryOrder queryOrder, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/folders/"+ (path==null? "" : System.Uri.EscapeDataString(path))+"&queryOrder=" + queryOrder+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Folder[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets folders.
		/// Folders_List {organization}/{project}/_apis/release/folders/{path}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="path">Path of the folder.</param>
		/// <param name="queryOrder">Gets the results in the defined order. Default is 'None'.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public Folder[] Folders_List(string organization, string project, string path, Folders_ListQueryOrder queryOrder, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/folders/"+ (path==null? "" : System.Uri.EscapeDataString(path))+"&queryOrder=" + queryOrder+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Folder[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// This method is no longer supported. Use CreateFolder with folder parameter API.
		/// Folders_Create {organization}/{project}/_apis/release/folders/{path}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="path">Path of the folder.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <param name="requestBody">folder.</param>
		/// <returns>successful operation</returns>
		public async Task<Folder> Folders_CreateAsync(string organization, string project, string path, string api_version, Folder requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/folders/"+ (path==null? "" : System.Uri.EscapeDataString(path))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Folder>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// This method is no longer supported. Use CreateFolder with folder parameter API.
		/// Folders_Create {organization}/{project}/_apis/release/folders/{path}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="path">Path of the folder.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <param name="requestBody">folder.</param>
		/// <returns>successful operation</returns>
		public Folder Folders_Create(string organization, string project, string path, string api_version, Folder requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/folders/"+ (path==null? "" : System.Uri.EscapeDataString(path))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Folder>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a definition folder for given folder name and path and all it's existing definitions.
		/// Folders_Delete {organization}/{project}/_apis/release/folders/{path}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="path">Path of the folder to delete.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Folders_DeleteAsync(string organization, string project, string path, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/folders/"+ (path==null? "" : System.Uri.EscapeDataString(path))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a definition folder for given folder name and path and all it's existing definitions.
		/// Folders_Delete {organization}/{project}/_apis/release/folders/{path}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="path">Path of the folder to delete.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Folders_Delete(string organization, string project, string path, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/folders/"+ (path==null? "" : System.Uri.EscapeDataString(path))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an existing folder at given existing path.
		/// Folders_Update {organization}/{project}/_apis/release/folders/{path}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="path">Path of the folder to update.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <param name="requestBody">folder.</param>
		/// <returns>successful operation</returns>
		public async Task<Folder> Folders_UpdateAsync(string organization, string project, string path, string api_version, Folder requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/folders/"+ (path==null? "" : System.Uri.EscapeDataString(path))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Folder>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates an existing folder at given existing path.
		/// Folders_Update {organization}/{project}/_apis/release/folders/{path}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="path">Path of the folder to update.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <param name="requestBody">folder.</param>
		/// <returns>successful operation</returns>
		public Folder Folders_Update(string organization, string project, string path, string api_version, Folder requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/folders/"+ (path==null? "" : System.Uri.EscapeDataString(path))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Folder>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the gate for a deployment.
		/// Gates_Update {organization}/{project}/_apis/release/gates/{gateStepId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="gateStepId">Gate step Id.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Metadata to patch the Release Gates.</param>
		/// <returns>successful operation</returns>
		public async Task<ReleaseGates> Gates_UpdateAsync(string organization, string project, int gateStepId, string api_version, GateUpdateMetadata requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/gates/"+gateStepId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseGates>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the gate for a deployment.
		/// Gates_Update {organization}/{project}/_apis/release/gates/{gateStepId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="gateStepId">Gate step Id.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Metadata to patch the Release Gates.</param>
		/// <returns>successful operation</returns>
		public ReleaseGates Gates_Update(string organization, string project, int gateStepId, string api_version, GateUpdateMetadata requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/gates/"+gateStepId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseGates>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a list of releases
		/// Releases_List {organization}/{project}/_apis/release/releases
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">Releases from this release definition Id.</param>
		/// <param name="searchText">Releases with names containing searchText.</param>
		/// <param name="createdBy">Releases created by this user.</param>
		/// <param name="statusFilter">Releases that have this status.</param>
		/// <param name="minCreatedTime">Releases that were created after this time.</param>
		/// <param name="maxCreatedTime">Releases that were created before this time.</param>
		/// <param name="queryOrder">Gets the results in the defined order of created date for releases. Default is descending.</param>
		/// <param name="top">Number of releases to get. Default is 50.</param>
		/// <param name="continuationToken">Gets the releases after the continuation token provided.</param>
		/// <param name="expand">The property that should be expanded in the list of releases.</param>
		/// <param name="artifactTypeId">Releases with given artifactTypeId will be returned. Values can be Build, Jenkins, GitHub, Nuget, Team Build (external), ExternalTFSBuild, Git, TFVC, ExternalTfsXamlBuild.</param>
		/// <param name="sourceId">Unique identifier of the artifact used. e.g. For build it would be {projectGuid}:{BuildDefinitionId}, for Jenkins it would be {JenkinsConnectionId}:{JenkinsDefinitionId}, for TfsOnPrem it would be {TfsOnPremConnectionId}:{ProjectName}:{TfsOnPremDefinitionId}. For third-party artifacts e.g. TeamCity, BitBucket you may refer 'uniqueSourceIdentifier' inside vss-extension.json https://github.com/Microsoft/vsts-rm-extensions/blob/master/Extensions.</param>
		/// <param name="artifactVersionId">Releases with given artifactVersionId will be returned. E.g. in case of Build artifactType, it is buildId.</param>
		/// <param name="sourceBranchFilter">Releases with given sourceBranchFilter will be returned.</param>
		/// <param name="isDeleted">Gets the soft deleted releases, if true.</param>
		/// <param name="tagFilter">A comma-delimited list of tags. Only releases with these tags will be returned.</param>
		/// <param name="propertyFilters">A comma-delimited list of extended properties to be retrieved. If set, the returned Releases will contain values for the specified property Ids (if they exist). If not set, properties will not be included. Note that this will not filter out any Release from results irrespective of whether it has property set or not.</param>
		/// <param name="releaseIdFilter">A comma-delimited list of releases Ids. Only releases with these Ids will be returned.</param>
		/// <param name="path">Releases under this folder path will be returned</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.8' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<Release[]> Releases_ListAsync(
					string organization, 
					string project, 
					int definitionId, 
					int definitionEnvironmentId, 
					string searchText, 
					string createdBy, 
					ReleaseStatus statusFilter, 
					int environmentStatusFilter, 
					System.DateTimeOffset minCreatedTime, 
					System.DateTimeOffset maxCreatedTime, 
					Approvals_ListQueryOrder queryOrder, 
					int top, 
					int continuationToken, 
					Releases_ListExpand expand, 
					string artifactTypeId, 
					string sourceId, 
					string artifactVersionId, 
					string sourceBranchFilter, 
					bool isDeleted, 
					string tagFilter, 
					string propertyFilters, 
					string releaseIdFilter, 
					string path, 
					string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases&definitionId="+definitionId+"&definitionEnvironmentId="+definitionEnvironmentId+"&searchText=" + (searchText==null? "" : System.Uri.EscapeDataString(searchText))+"&createdBy=" + (createdBy==null? "" : System.Uri.EscapeDataString(createdBy))+"&statusFilter=" + statusFilter+"&environmentStatusFilter="+environmentStatusFilter+"&minCreatedTime=" + minCreatedTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&maxCreatedTime=" + maxCreatedTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&queryOrder=" + queryOrder+"&$top="+top+"&continuationToken="+continuationToken+"&$expand=" + expand+"&artifactTypeId=" + (artifactTypeId==null? "" : System.Uri.EscapeDataString(artifactTypeId))+"&sourceId=" + (sourceId==null? "" : System.Uri.EscapeDataString(sourceId))+"&artifactVersionId=" + (artifactVersionId==null? "" : System.Uri.EscapeDataString(artifactVersionId))+"&sourceBranchFilter=" + (sourceBranchFilter==null? "" : System.Uri.EscapeDataString(sourceBranchFilter))+"&isDeleted="+isDeleted+"&tagFilter=" + (tagFilter==null? "" : System.Uri.EscapeDataString(tagFilter))+"&propertyFilters=" + (propertyFilters==null? "" : System.Uri.EscapeDataString(propertyFilters))+"&releaseIdFilter=" + (releaseIdFilter==null? "" : System.Uri.EscapeDataString(releaseIdFilter))+"&path=" + (path==null? "" : System.Uri.EscapeDataString(path))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Release[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a list of releases
		/// Releases_List {organization}/{project}/_apis/release/releases
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="definitionId">Releases from this release definition Id.</param>
		/// <param name="searchText">Releases with names containing searchText.</param>
		/// <param name="createdBy">Releases created by this user.</param>
		/// <param name="statusFilter">Releases that have this status.</param>
		/// <param name="minCreatedTime">Releases that were created after this time.</param>
		/// <param name="maxCreatedTime">Releases that were created before this time.</param>
		/// <param name="queryOrder">Gets the results in the defined order of created date for releases. Default is descending.</param>
		/// <param name="top">Number of releases to get. Default is 50.</param>
		/// <param name="continuationToken">Gets the releases after the continuation token provided.</param>
		/// <param name="expand">The property that should be expanded in the list of releases.</param>
		/// <param name="artifactTypeId">Releases with given artifactTypeId will be returned. Values can be Build, Jenkins, GitHub, Nuget, Team Build (external), ExternalTFSBuild, Git, TFVC, ExternalTfsXamlBuild.</param>
		/// <param name="sourceId">Unique identifier of the artifact used. e.g. For build it would be {projectGuid}:{BuildDefinitionId}, for Jenkins it would be {JenkinsConnectionId}:{JenkinsDefinitionId}, for TfsOnPrem it would be {TfsOnPremConnectionId}:{ProjectName}:{TfsOnPremDefinitionId}. For third-party artifacts e.g. TeamCity, BitBucket you may refer 'uniqueSourceIdentifier' inside vss-extension.json https://github.com/Microsoft/vsts-rm-extensions/blob/master/Extensions.</param>
		/// <param name="artifactVersionId">Releases with given artifactVersionId will be returned. E.g. in case of Build artifactType, it is buildId.</param>
		/// <param name="sourceBranchFilter">Releases with given sourceBranchFilter will be returned.</param>
		/// <param name="isDeleted">Gets the soft deleted releases, if true.</param>
		/// <param name="tagFilter">A comma-delimited list of tags. Only releases with these tags will be returned.</param>
		/// <param name="propertyFilters">A comma-delimited list of extended properties to be retrieved. If set, the returned Releases will contain values for the specified property Ids (if they exist). If not set, properties will not be included. Note that this will not filter out any Release from results irrespective of whether it has property set or not.</param>
		/// <param name="releaseIdFilter">A comma-delimited list of releases Ids. Only releases with these Ids will be returned.</param>
		/// <param name="path">Releases under this folder path will be returned</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.8' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public Release[] Releases_List(
					string organization, 
					string project, 
					int definitionId, 
					int definitionEnvironmentId, 
					string searchText, 
					string createdBy, 
					ReleaseStatus statusFilter, 
					int environmentStatusFilter, 
					System.DateTimeOffset minCreatedTime, 
					System.DateTimeOffset maxCreatedTime, 
					Approvals_ListQueryOrder queryOrder, 
					int top, 
					int continuationToken, 
					Releases_ListExpand expand, 
					string artifactTypeId, 
					string sourceId, 
					string artifactVersionId, 
					string sourceBranchFilter, 
					bool isDeleted, 
					string tagFilter, 
					string propertyFilters, 
					string releaseIdFilter, 
					string path, 
					string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases&definitionId="+definitionId+"&definitionEnvironmentId="+definitionEnvironmentId+"&searchText=" + (searchText==null? "" : System.Uri.EscapeDataString(searchText))+"&createdBy=" + (createdBy==null? "" : System.Uri.EscapeDataString(createdBy))+"&statusFilter=" + statusFilter+"&environmentStatusFilter="+environmentStatusFilter+"&minCreatedTime=" + minCreatedTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&maxCreatedTime=" + maxCreatedTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&queryOrder=" + queryOrder+"&$top="+top+"&continuationToken="+continuationToken+"&$expand=" + expand+"&artifactTypeId=" + (artifactTypeId==null? "" : System.Uri.EscapeDataString(artifactTypeId))+"&sourceId=" + (sourceId==null? "" : System.Uri.EscapeDataString(sourceId))+"&artifactVersionId=" + (artifactVersionId==null? "" : System.Uri.EscapeDataString(artifactVersionId))+"&sourceBranchFilter=" + (sourceBranchFilter==null? "" : System.Uri.EscapeDataString(sourceBranchFilter))+"&isDeleted="+isDeleted+"&tagFilter=" + (tagFilter==null? "" : System.Uri.EscapeDataString(tagFilter))+"&propertyFilters=" + (propertyFilters==null? "" : System.Uri.EscapeDataString(propertyFilters))+"&releaseIdFilter=" + (releaseIdFilter==null? "" : System.Uri.EscapeDataString(releaseIdFilter))+"&path=" + (path==null? "" : System.Uri.EscapeDataString(path))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Release[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a release.
		/// Releases_Create {organization}/{project}/_apis/release/releases
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.8' to use this version of the api.</param>
		/// <param name="requestBody">Metadata to create a release.</param>
		/// <returns>successful operation</returns>
		public async Task<Release> Releases_CreateAsync(string organization, string project, string api_version, ReleaseStartMetadata requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Release>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create a release.
		/// Releases_Create {organization}/{project}/_apis/release/releases
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.8' to use this version of the api.</param>
		/// <param name="requestBody">Metadata to create a release.</param>
		/// <returns>successful operation</returns>
		public Release Releases_Create(string organization, string project, string api_version, ReleaseStartMetadata requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Release>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get release for a given revision number.
		/// Releases_Get_Release_Revision {organization}/{project}/_apis/release/releases/{releaseId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="definitionSnapshotRevision">Definition snapshot revision number.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.8' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<string> Releases_Get_Release_RevisionAsync(string organization, string project, int releaseId, int definitionSnapshotRevision, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases/"+releaseId+"&definitionSnapshotRevision="+definitionSnapshotRevision+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (System.IO.StreamReader streamReader = new System.IO.StreamReader(responseMessageStream))
				{
				return streamReader.ReadToEnd();;
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get release for a given revision number.
		/// Releases_Get_Release_Revision {organization}/{project}/_apis/release/releases/{releaseId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="definitionSnapshotRevision">Definition snapshot revision number.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.8' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public string Releases_Get_Release_Revision(string organization, string project, int releaseId, int definitionSnapshotRevision, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases/"+releaseId+"&definitionSnapshotRevision="+definitionSnapshotRevision+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (System.IO.StreamReader streamReader = new System.IO.StreamReader(responseMessageStream))
				{
				return streamReader.ReadToEnd();;
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a complete release object.
		/// Releases_Update_Release {organization}/{project}/_apis/release/releases/{releaseId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release to update.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.8' to use this version of the api.</param>
		/// <param name="requestBody">Release object for update.</param>
		/// <returns>successful operation</returns>
		public async Task<Release> Releases_Update_ReleaseAsync(string organization, string project, int releaseId, string api_version, Release requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases/"+releaseId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Release>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update a complete release object.
		/// Releases_Update_Release {organization}/{project}/_apis/release/releases/{releaseId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release to update.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.8' to use this version of the api.</param>
		/// <param name="requestBody">Release object for update.</param>
		/// <returns>successful operation</returns>
		public Release Releases_Update_Release(string organization, string project, int releaseId, string api_version, Release requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases/"+releaseId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Release>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update few properties of a release.
		/// Releases_Update_Release_Resource {organization}/{project}/_apis/release/releases/{releaseId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release to update.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.8' to use this version of the api.</param>
		/// <param name="requestBody">Properties of release to update.</param>
		/// <returns>successful operation</returns>
		public async Task<Release> Releases_Update_Release_ResourceAsync(string organization, string project, int releaseId, string api_version, ReleaseUpdateMetadata requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases/"+releaseId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Release>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update few properties of a release.
		/// Releases_Update_Release_Resource {organization}/{project}/_apis/release/releases/{releaseId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release to update.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.8' to use this version of the api.</param>
		/// <param name="requestBody">Properties of release to update.</param>
		/// <returns>successful operation</returns>
		public Release Releases_Update_Release_Resource(string organization, string project, int releaseId, string api_version, ReleaseUpdateMetadata requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases/"+releaseId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Release>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get a release environment.
		/// Releases_Get_Release_Environment {organization}/{project}/_apis/Release/releases/{releaseId}/environments/{environmentId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="environmentId">Id of the release environment.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.6' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<ReleaseEnvironment> Releases_Get_Release_EnvironmentAsync(string organization, string project, int releaseId, int environmentId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/Release/releases/"+releaseId+"/environments/"+environmentId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseEnvironment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a release environment.
		/// Releases_Get_Release_Environment {organization}/{project}/_apis/Release/releases/{releaseId}/environments/{environmentId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="environmentId">Id of the release environment.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.6' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public ReleaseEnvironment Releases_Get_Release_Environment(string organization, string project, int releaseId, int environmentId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/Release/releases/"+releaseId+"/environments/"+environmentId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseEnvironment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the status of a release environment
		/// Releases_Update_Release_Environment {organization}/{project}/_apis/Release/releases/{releaseId}/environments/{environmentId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="environmentId">Id of release environment.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.6' to use this version of the api.</param>
		/// <param name="requestBody">Environment update meta data.</param>
		/// <returns>successful operation</returns>
		public async Task<ReleaseEnvironment> Releases_Update_Release_EnvironmentAsync(string organization, string project, int releaseId, int environmentId, string api_version, ReleaseEnvironmentUpdateMetadata requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/Release/releases/"+releaseId+"/environments/"+environmentId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseEnvironment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update the status of a release environment
		/// Releases_Update_Release_Environment {organization}/{project}/_apis/Release/releases/{releaseId}/environments/{environmentId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="environmentId">Id of release environment.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.6' to use this version of the api.</param>
		/// <param name="requestBody">Environment update meta data.</param>
		/// <returns>successful operation</returns>
		public ReleaseEnvironment Releases_Update_Release_Environment(string organization, string project, int releaseId, int environmentId, string api_version, ReleaseEnvironmentUpdateMetadata requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/Release/releases/"+releaseId+"/environments/"+environmentId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseEnvironment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the release task attachments.
		/// Attachments_Get_Release_Task_Attachments {organization}/{project}/_apis/release/releases/{releaseId}/environments/{environmentId}/attempts/{attemptId}/plan/{planId}/attachments/{type}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="environmentId">Id of the release environment.</param>
		/// <param name="attemptId">Attempt number of deployment.</param>
		/// <param name="planId">Plan Id of the deploy phase.</param>
		/// <param name="type">Type of the attachment.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<ReleaseTaskAttachment[]> Attachments_Get_Release_Task_AttachmentsAsync(string organization, string project, int releaseId, int environmentId, int attemptId, string planId, string type, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases/"+releaseId+"/environments/"+environmentId+"/attempts/"+attemptId+"/plan/"+ (planId==null? "" : System.Uri.EscapeDataString(planId))+"/attachments/"+ (type==null? "" : System.Uri.EscapeDataString(type))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseTaskAttachment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the release task attachments.
		/// Attachments_Get_Release_Task_Attachments {organization}/{project}/_apis/release/releases/{releaseId}/environments/{environmentId}/attempts/{attemptId}/plan/{planId}/attachments/{type}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="environmentId">Id of the release environment.</param>
		/// <param name="attemptId">Attempt number of deployment.</param>
		/// <param name="planId">Plan Id of the deploy phase.</param>
		/// <param name="type">Type of the attachment.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public ReleaseTaskAttachment[] Attachments_Get_Release_Task_Attachments(string organization, string project, int releaseId, int environmentId, int attemptId, string planId, string type, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases/"+releaseId+"/environments/"+environmentId+"/attempts/"+attemptId+"/plan/"+ (planId==null? "" : System.Uri.EscapeDataString(planId))+"/attachments/"+ (type==null? "" : System.Uri.EscapeDataString(type))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseTaskAttachment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a release task attachment.
		/// Attachments_Get_Release_Task_Attachment_Content {organization}/{project}/_apis/release/releases/{releaseId}/environments/{environmentId}/attempts/{attemptId}/plan/{planId}/timelines/{timelineId}/records/{recordId}/attachments/{type}/{name}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="environmentId">Id of the release environment.</param>
		/// <param name="attemptId">Attempt number of deployment.</param>
		/// <param name="planId">Plan Id of the deploy phase.</param>
		/// <param name="timelineId">Timeline Id of the task.</param>
		/// <param name="recordId">Record Id of attachment.</param>
		/// <param name="type">Type of the attachment.</param>
		/// <param name="name">Name of the attachment.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Attachments_Get_Release_Task_Attachment_ContentAsync(string organization, string project, int releaseId, int environmentId, int attemptId, string planId, string timelineId, string recordId, string type, string name, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases/"+releaseId+"/environments/"+environmentId+"/attempts/"+attemptId+"/plan/"+ (planId==null? "" : System.Uri.EscapeDataString(planId))+"/timelines/"+ (timelineId==null? "" : System.Uri.EscapeDataString(timelineId))+"/records/"+ (recordId==null? "" : System.Uri.EscapeDataString(recordId))+"/attachments/"+ (type==null? "" : System.Uri.EscapeDataString(type))+"/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a release task attachment.
		/// Attachments_Get_Release_Task_Attachment_Content {organization}/{project}/_apis/release/releases/{releaseId}/environments/{environmentId}/attempts/{attemptId}/plan/{planId}/timelines/{timelineId}/records/{recordId}/attachments/{type}/{name}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="environmentId">Id of the release environment.</param>
		/// <param name="attemptId">Attempt number of deployment.</param>
		/// <param name="planId">Plan Id of the deploy phase.</param>
		/// <param name="timelineId">Timeline Id of the task.</param>
		/// <param name="recordId">Record Id of attachment.</param>
		/// <param name="type">Type of the attachment.</param>
		/// <param name="name">Name of the attachment.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Attachments_Get_Release_Task_Attachment_Content(string organization, string project, int releaseId, int environmentId, int attemptId, string planId, string timelineId, string recordId, string type, string name, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases/"+releaseId+"/environments/"+environmentId+"/attempts/"+attemptId+"/plan/"+ (planId==null? "" : System.Uri.EscapeDataString(planId))+"/timelines/"+ (timelineId==null? "" : System.Uri.EscapeDataString(timelineId))+"/records/"+ (recordId==null? "" : System.Uri.EscapeDataString(recordId))+"/attachments/"+ (type==null? "" : System.Uri.EscapeDataString(type))+"/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// GetTaskAttachments API is deprecated. Use GetReleaseTaskAttachments API instead.
		/// Attachments_Get_Task_Attachments {organization}/{project}/_apis/release/releases/{releaseId}/environments/{environmentId}/attempts/{attemptId}/timelines/{timelineId}/attachments/{type}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="environmentId">Id of the release environment.</param>
		/// <param name="attemptId">Attempt number of deployment.</param>
		/// <param name="timelineId">Timeline Id of the task.</param>
		/// <param name="type">Type of the attachment.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<ReleaseTaskAttachment[]> Attachments_Get_Task_AttachmentsAsync(string organization, string project, int releaseId, int environmentId, int attemptId, string timelineId, string type, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases/"+releaseId+"/environments/"+environmentId+"/attempts/"+attemptId+"/timelines/"+ (timelineId==null? "" : System.Uri.EscapeDataString(timelineId))+"/attachments/"+ (type==null? "" : System.Uri.EscapeDataString(type))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseTaskAttachment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// GetTaskAttachments API is deprecated. Use GetReleaseTaskAttachments API instead.
		/// Attachments_Get_Task_Attachments {organization}/{project}/_apis/release/releases/{releaseId}/environments/{environmentId}/attempts/{attemptId}/timelines/{timelineId}/attachments/{type}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="environmentId">Id of the release environment.</param>
		/// <param name="attemptId">Attempt number of deployment.</param>
		/// <param name="timelineId">Timeline Id of the task.</param>
		/// <param name="type">Type of the attachment.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public ReleaseTaskAttachment[] Attachments_Get_Task_Attachments(string organization, string project, int releaseId, int environmentId, int attemptId, string timelineId, string type, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases/"+releaseId+"/environments/"+environmentId+"/attempts/"+attemptId+"/timelines/"+ (timelineId==null? "" : System.Uri.EscapeDataString(timelineId))+"/attachments/"+ (type==null? "" : System.Uri.EscapeDataString(type))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReleaseTaskAttachment[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// GetTaskAttachmentContent API is deprecated. Use GetReleaseTaskAttachmentContent API instead.
		/// Attachments_Get_Task_Attachment_Content {organization}/{project}/_apis/release/releases/{releaseId}/environments/{environmentId}/attempts/{attemptId}/timelines/{timelineId}/records/{recordId}/attachments/{type}/{name}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="environmentId">Id of the release environment.</param>
		/// <param name="attemptId">Attempt number of deployment.</param>
		/// <param name="timelineId">Timeline Id of the task.</param>
		/// <param name="recordId">Record Id of attachment.</param>
		/// <param name="type">Type of the attachment.</param>
		/// <param name="name">Name of the attachment.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Attachments_Get_Task_Attachment_ContentAsync(string organization, string project, int releaseId, int environmentId, int attemptId, string timelineId, string recordId, string type, string name, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases/"+releaseId+"/environments/"+environmentId+"/attempts/"+attemptId+"/timelines/"+ (timelineId==null? "" : System.Uri.EscapeDataString(timelineId))+"/records/"+ (recordId==null? "" : System.Uri.EscapeDataString(recordId))+"/attachments/"+ (type==null? "" : System.Uri.EscapeDataString(type))+"/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// GetTaskAttachmentContent API is deprecated. Use GetReleaseTaskAttachmentContent API instead.
		/// Attachments_Get_Task_Attachment_Content {organization}/{project}/_apis/release/releases/{releaseId}/environments/{environmentId}/attempts/{attemptId}/timelines/{timelineId}/records/{recordId}/attachments/{type}/{name}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="environmentId">Id of the release environment.</param>
		/// <param name="attemptId">Attempt number of deployment.</param>
		/// <param name="timelineId">Timeline Id of the task.</param>
		/// <param name="recordId">Record Id of attachment.</param>
		/// <param name="type">Type of the attachment.</param>
		/// <param name="name">Name of the attachment.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Attachments_Get_Task_Attachment_Content(string organization, string project, int releaseId, int environmentId, int attemptId, string timelineId, string recordId, string type, string name, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases/"+releaseId+"/environments/"+environmentId+"/attempts/"+attemptId+"/timelines/"+ (timelineId==null? "" : System.Uri.EscapeDataString(timelineId))+"/records/"+ (recordId==null? "" : System.Uri.EscapeDataString(recordId))+"/attachments/"+ (type==null? "" : System.Uri.EscapeDataString(type))+"/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the task log of a release as a plain text file.
		/// Releases_Get_Task_Log {organization}/{project}/_apis/release/releases/{releaseId}/environments/{environmentId}/deployPhases/{releaseDeployPhaseId}/tasks/{taskId}/logs
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="environmentId">Id of release environment.</param>
		/// <param name="releaseDeployPhaseId">Release deploy phase Id.</param>
		/// <param name="taskId">ReleaseTask Id for the log.</param>
		/// <param name="startLine">Starting line number for logs</param>
		/// <param name="endLine">Ending line number for logs</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<string> Releases_Get_Task_LogAsync(string organization, string project, int releaseId, int environmentId, int releaseDeployPhaseId, int taskId, long startLine, long endLine, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases/"+releaseId+"/environments/"+environmentId+"/deployPhases/"+releaseDeployPhaseId+"/tasks/"+taskId+"/logs&startLine="+startLine+"&endLine="+endLine+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (System.IO.StreamReader streamReader = new System.IO.StreamReader(responseMessageStream))
				{
				return streamReader.ReadToEnd();;
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the task log of a release as a plain text file.
		/// Releases_Get_Task_Log {organization}/{project}/_apis/release/releases/{releaseId}/environments/{environmentId}/deployPhases/{releaseDeployPhaseId}/tasks/{taskId}/logs
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="environmentId">Id of release environment.</param>
		/// <param name="releaseDeployPhaseId">Release deploy phase Id.</param>
		/// <param name="taskId">ReleaseTask Id for the log.</param>
		/// <param name="startLine">Starting line number for logs</param>
		/// <param name="endLine">Ending line number for logs</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public string Releases_Get_Task_Log(string organization, string project, int releaseId, int environmentId, int releaseDeployPhaseId, int taskId, long startLine, long endLine, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases/"+releaseId+"/environments/"+environmentId+"/deployPhases/"+releaseDeployPhaseId+"/tasks/"+taskId+"/logs&startLine="+startLine+"&endLine="+endLine+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (System.IO.StreamReader streamReader = new System.IO.StreamReader(responseMessageStream))
				{
				return streamReader.ReadToEnd();;
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get logs for a release Id.
		/// Releases_Get_Logs {organization}/{project}/_apis/release/releases/{releaseId}/logs
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Releases_Get_LogsAsync(string organization, string project, int releaseId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases/"+releaseId+"/logs&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get logs for a release Id.
		/// Releases_Get_Logs {organization}/{project}/_apis/release/releases/{releaseId}/logs
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.2' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Releases_Get_Logs(string organization, string project, int releaseId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/release/releases/"+releaseId+"/logs&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all manual interventions for a given release.
		/// Manual_Interventions_List {organization}/{project}/_apis/Release/releases/{releaseId}/manualinterventions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<ManualIntervention[]> Manual_Interventions_ListAsync(string organization, string project, int releaseId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/Release/releases/"+releaseId+"/manualinterventions&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ManualIntervention[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all manual interventions for a given release.
		/// Manual_Interventions_List {organization}/{project}/_apis/Release/releases/{releaseId}/manualinterventions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public ManualIntervention[] Manual_Interventions_List(string organization, string project, int releaseId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/Release/releases/"+releaseId+"/manualinterventions&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ManualIntervention[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get manual intervention for a given release and manual intervention id.
		/// Manual_Interventions_Get {organization}/{project}/_apis/Release/releases/{releaseId}/manualinterventions/{manualInterventionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="manualInterventionId">Id of the manual intervention.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<ManualIntervention> Manual_Interventions_GetAsync(string organization, string project, int releaseId, int manualInterventionId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/Release/releases/"+releaseId+"/manualinterventions/"+manualInterventionId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ManualIntervention>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get manual intervention for a given release and manual intervention id.
		/// Manual_Interventions_Get {organization}/{project}/_apis/Release/releases/{releaseId}/manualinterventions/{manualInterventionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="manualInterventionId">Id of the manual intervention.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public ManualIntervention Manual_Interventions_Get(string organization, string project, int releaseId, int manualInterventionId, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/Release/releases/"+releaseId+"/manualinterventions/"+manualInterventionId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ManualIntervention>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update manual intervention.
		/// Manual_Interventions_Update {organization}/{project}/_apis/Release/releases/{releaseId}/manualinterventions/{manualInterventionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="manualInterventionId">Id of the manual intervention.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Meta data to update manual intervention.</param>
		/// <returns>successful operation</returns>
		public async Task<ManualIntervention> Manual_Interventions_UpdateAsync(string organization, string project, int releaseId, int manualInterventionId, string api_version, ManualInterventionUpdateMetadata requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/Release/releases/"+releaseId+"/manualinterventions/"+manualInterventionId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ManualIntervention>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update manual intervention.
		/// Manual_Interventions_Update {organization}/{project}/_apis/Release/releases/{releaseId}/manualinterventions/{manualInterventionId}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="project">Project ID or project name</param>
		/// <param name="releaseId">Id of the release.</param>
		/// <param name="manualInterventionId">Id of the manual intervention.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <param name="requestBody">Meta data to update manual intervention.</param>
		/// <returns>successful operation</returns>
		public ManualIntervention Manual_Interventions_Update(string organization, string project, int releaseId, int manualInterventionId, string api_version, ManualInterventionUpdateMetadata requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/_apis/Release/releases/"+releaseId+"/manualinterventions/"+manualInterventionId+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = httpClient.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ManualIntervention>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	public enum Approvals_ListQueryOrder
	{
		
		descending = 0,
		
		ascending = 1,
	}
	
	public enum Definitions_ListExpand
	{
		
		none = 0,
		
		environments = 1,
		
		artifacts = 2,
		
		triggers = 3,
		
		variables = 4,
		
		tags = 5,
		
		lastRelease = 6,
	}
	
	public enum Definitions_ListQueryOrder
	{
		
		idAscending = 0,
		
		idDescending = 1,
		
		nameAscending = 2,
		
		nameDescending = 3,
	}
	
	public enum Folders_ListQueryOrder
	{
		
		none = 0,
		
		ascending = 1,
		
		descending = 2,
	}
	
	public enum Releases_ListExpand
	{
		
		none = 0,
		
		environments = 1,
		
		artifacts = 2,
		
		approvals = 3,
		
		manualInterventions = 4,
		
		variables = 5,
		
		tags = 6,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
