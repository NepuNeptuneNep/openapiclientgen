//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Net.Http;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	public class AcquisitionOperation
	{
		
		/// <summary>
		/// State of the the AcquisitionOperation for the current user
		/// </summary>
		public System.Nullable<AcquisitionOperationOperationState> OperationState { get; set; }
		
		/// <summary>
		/// AcquisitionOperationType: install, request, buy, etc...
		/// </summary>
		public System.Nullable<AcquisitionOperationOperationType> OperationType { get; set; }
		
		/// <summary>
		/// Optional reason to justify current state. Typically used with Disallow state.
		/// </summary>
		public string Reason { get; set; }
		
		/// <summary>
		/// List of reasons indicating why the operation is not allowed.
		/// </summary>
		public AcquisitionOperationDisallowReason[] Reasons { get; set; }
	}
	
	public enum AcquisitionOperationOperationState
	{
		
		disallow = 0,
		
		allow = 1,
		
		completed = 2,
	}
	
	public enum AcquisitionOperationOperationType
	{
		
		get = 0,
		
		install = 1,
		
		buy = 2,
		
		_try = 3,
		
		request = 4,
		
		none = 5,
		
		purchaseRequest = 6,
	}
	
	public class AcquisitionOperationDisallowReason
	{
		
		/// <summary>
		/// User-friendly message clarifying the reason for disallowance
		/// </summary>
		public string Message { get; set; }
		
		/// <summary>
		/// Type of reason for disallowance - AlreadyInstalled, UnresolvedDemand, etc.
		/// </summary>
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Market item acquisition options (install, buy, etc) for an installation target.
	/// </summary>
	public class AcquisitionOptions
	{
		
		public AcquisitionOperation DefaultOperation { get; set; }
		
		/// <summary>
		/// The item id that this options refer to
		/// </summary>
		public string ItemId { get; set; }
		
		/// <summary>
		/// Operations allowed for the ItemId in this target
		/// </summary>
		public AcquisitionOperation[] Operations { get; set; }
		
		/// <summary>
		/// Represents a JSON object.
		/// </summary>
		public JObject Properties { get; set; }
		
		/// <summary>
		/// The target that this options refer to
		/// </summary>
		public string Target { get; set; }
	}
	
	/// <summary>
	/// Represents a JSON object.
	/// </summary>
	public class JObject
	{
		
		public string Item { get; set; }
		
		/// <summary>
		/// Gets the node type for this JToken.
		/// </summary>
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Representation of a ContributionNode that can be used for serialized to clients.
	/// </summary>
	public class ClientContribution
	{
		
		/// <summary>
		/// Description of the contribution/type
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Fully qualified identifier of the contribution/type
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// Includes is a set of contributions that should have this contribution included in their targets list.
		/// </summary>
		public string[] Includes { get; set; }
		
		/// <summary>
		/// Represents a JSON object.
		/// </summary>
		public JObject Properties { get; set; }
		
		/// <summary>
		/// The ids of the contribution(s) that this contribution targets. (parent contributions)
		/// </summary>
		public string[] Targets { get; set; }
		
		/// <summary>
		/// Id of the Contribution Type
		/// </summary>
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Representation of a ContributionNode that can be used for serialized to clients.
	/// </summary>
	public class ClientContributionNode
	{
		
		/// <summary>
		/// List of ids for contributions which are children to the current contribution.
		/// </summary>
		public string[] Children { get; set; }
		
		/// <summary>
		/// Representation of a ContributionNode that can be used for serialized to clients.
		/// </summary>
		public ClientContribution Contribution { get; set; }
		
		/// <summary>
		/// List of ids for contributions which are parents to the current contribution.
		/// </summary>
		public string[] Parents { get; set; }
	}
	
	public class ClientContributionProviderDetails
	{
		
		/// <summary>
		/// Friendly name for the provider.
		/// </summary>
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Unique identifier for this provider. The provider name can be used to cache the contribution data and refer back to it when looking for changes
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Properties associated with the provider
		/// </summary>
		public System.Collections.Generic.Dictionary<string, string> Properties { get; set; }
		
		/// <summary>
		/// Version of contributions associated with this contribution provider.
		/// </summary>
		public string Version { get; set; }
	}
	
	/// <summary>
	/// A client data provider are the details needed to make the data provider request from the client.
	/// </summary>
	public class ClientDataProviderQuery
	{
		
		/// <summary>
		/// The Id of the service instance type that should be communicated with in order to resolve the data providers from the client given the query values.
		/// </summary>
		public string QueryServiceInstanceType { get; set; }
	}
	
	/// <summary>
	/// An individual contribution made by an extension
	/// </summary>
	public class Contribution
	{
		
		/// <summary>
		/// List of constraints (filters) that should be applied to the availability of this contribution
		/// </summary>
		public ContributionConstraint[] Constraints { get; set; }
		
		/// <summary>
		/// Includes is a set of contributions that should have this contribution included in their targets list.
		/// </summary>
		public string[] Includes { get; set; }
		
		/// <summary>
		/// Represents a JSON object.
		/// </summary>
		public JObject Properties { get; set; }
		
		/// <summary>
		/// List of demanded claims in order for the user to see this contribution (like anonymous, public, member...).
		/// </summary>
		public string[] RestrictedTo { get; set; }
		
		/// <summary>
		/// The ids of the contribution(s) that this contribution targets. (parent contributions)
		/// </summary>
		public string[] Targets { get; set; }
		
		/// <summary>
		/// Id of the Contribution Type
		/// </summary>
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Specifies a constraint that can be used to dynamically include/exclude a given contribution
	/// </summary>
	public class ContributionConstraint
	{
		
		/// <summary>
		/// An optional property that can be specified to group constraints together. All constraints within a group are AND'd together (all must be evaluate to True in order for the contribution to be included). Different groups of constraints are OR'd (only one group needs to evaluate to True for the contribution to be included).
		/// </summary>
		public System.Nullable<System.Int32> Group { get; set; }
		
		/// <summary>
		/// Fully qualified identifier of a shared constraint
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// If true, negate the result of the filter (include the contribution if the applied filter returns false instead of true)
		/// </summary>
		public System.Nullable<System.Boolean> Inverse { get; set; }
		
		/// <summary>
		/// Name of the IContributionFilter plugin
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Represents a JSON object.
		/// </summary>
		public JObject Properties { get; set; }
		
		/// <summary>
		/// Constraints can be optionally be applied to one or more of the relationships defined in the contribution. If no relationships are defined then all relationships are associated with the constraint. This means the default behaviour will eliminate the contribution from the tree completely if the constraint is applied.
		/// </summary>
		public string[] Relationships { get; set; }
	}
	
	/// <summary>
	/// Base class shared by contributions and contribution types
	/// </summary>
	public class ContributionBase
	{
		
		/// <summary>
		/// Description of the contribution/type
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Fully qualified identifier of the contribution/type
		/// </summary>
		public string Id { get; set; }
		
		/// <summary>
		/// VisibleTo can be used to restrict whom can reference a given contribution/type. This value should be a list of publishers or extensions access is restricted too.  Examples: "ms" - Means only the "ms" publisher can reference this. "ms.vss-web" - Means only the "vss-web" extension from the "ms" publisher can reference this.
		/// </summary>
		public string[] VisibleTo { get; set; }
	}
	
	/// <summary>
	/// A query that can be issued for contribution nodes
	/// </summary>
	public class ContributionNodeQuery
	{
		
		/// <summary>
		/// The contribution ids of the nodes to find.
		/// </summary>
		public string[] ContributionIds { get; set; }
		
		/// <summary>
		/// Contextual information that data providers can examine when populating their data
		/// </summary>
		public DataProviderContext DataProviderContext { get; set; }
		
		/// <summary>
		/// Indicator if contribution provider details should be included in the result.
		/// </summary>
		public System.Nullable<System.Boolean> IncludeProviderDetails { get; set; }
		
		/// <summary>
		/// Query options tpo be used when fetching ContributionNodes
		/// </summary>
		public System.Nullable<ContributionNodeQueryQueryOptions> QueryOptions { get; set; }
	}
	
	/// <summary>
	/// Contextual information that data providers can examine when populating their data
	/// </summary>
	public class DataProviderContext
	{
		
		/// <summary>
		/// Generic property bag that contains context-specific properties that data providers can use when populating their data dictionary
		/// </summary>
		public System.Collections.Generic.Dictionary<string, object> Properties { get; set; }
	}
	
	public enum ContributionNodeQueryQueryOptions
	{
		
		none = 0,
		
		includeSelf = 1,
		
		includeChildren = 2,
		
		includeSubTree = 3,
		
		includeAll = 4,
		
		ignoreConstraints = 5,
	}
	
	/// <summary>
	/// Result of a contribution node query.  Wraps the resulting contribution nodes and provider details.
	/// </summary>
	public class ContributionNodeQueryResult
	{
		
		/// <summary>
		/// Map of contribution ids to corresponding node.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, ClientContributionNode> Nodes { get; set; }
		
		/// <summary>
		/// Map of provider ids to the corresponding provider details object.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, ClientContributionProviderDetails> ProviderDetails { get; set; }
	}
	
	/// <summary>
	/// Description about a property of a contribution type
	/// </summary>
	public class ContributionPropertyDescription
	{
		
		/// <summary>
		/// Description of the property
		/// </summary>
		public string Description { get; set; }
		
		/// <summary>
		/// Name of the property
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// True if this property is required
		/// </summary>
		public System.Nullable<System.Boolean> Required { get; set; }
		
		/// <summary>
		/// The type of value used for this property
		/// </summary>
		public System.Nullable<ContributionPropertyDescriptionType> Type { get; set; }
	}
	
	public enum ContributionPropertyDescriptionType
	{
		
		unknown = 0,
		
		_string = 1,
		
		uri = 2,
		
		guid = 3,
		
		boolean = 4,
		
		integer = 5,
		
		_double = 6,
		
		dateTime = 7,
		
		dictionary = 8,
		
		array = 9,
		
		_object = 10,
	}
	
	public class ContributionProviderDetails
	{
		
		/// <summary>
		/// Friendly name for the provider.
		/// </summary>
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Unique identifier for this provider. The provider name can be used to cache the contribution data and refer back to it when looking for changes
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Properties associated with the provider
		/// </summary>
		public System.Collections.Generic.Dictionary<string, string> Properties { get; set; }
		
		/// <summary>
		/// Version of contributions associated with this contribution provider.
		/// </summary>
		public string Version { get; set; }
	}
	
	/// <summary>
	/// A contribution type, given by a json schema
	/// </summary>
	public class ContributionType
	{
		
		/// <summary>
		/// Controls whether or not contributions of this type have the type indexed for queries. This allows clients to find all extensions that have a contribution of this type.  NOTE: Only TrustedPartners are allowed to specify indexed contribution types.
		/// </summary>
		public System.Nullable<System.Boolean> Indexed { get; set; }
		
		/// <summary>
		/// Friendly name of the contribution/type
		/// </summary>
		public string Name { get; set; }
		
		/// <summary>
		/// Describes the allowed properties for this contribution type
		/// </summary>
		public System.Collections.Generic.Dictionary<string, ContributionPropertyDescription> Properties { get; set; }
	}
	
	public class DataProviderExceptionDetails
	{
		
		/// <summary>
		/// The type of the exception that was thrown.
		/// </summary>
		public string ExceptionType { get; set; }
		
		/// <summary>
		/// Message that is associated with the exception.
		/// </summary>
		public string Message { get; set; }
		
		/// <summary>
		/// The StackTrace from the exception turned into a string.
		/// </summary>
		public string StackTrace { get; set; }
	}
	
	/// <summary>
	/// A query that can be issued for data provider data
	/// </summary>
	public class DataProviderQuery
	{
		
		/// <summary>
		/// Contextual information that data providers can examine when populating their data
		/// </summary>
		public DataProviderContext Context { get; set; }
		
		/// <summary>
		/// The contribution ids of the data providers to resolve
		/// </summary>
		public string[] ContributionIds { get; set; }
	}
	
	/// <summary>
	/// Result structure from calls to GetDataProviderData
	/// </summary>
	public class DataProviderResult
	{
		
		/// <summary>
		/// This is the set of data providers that were requested, but either they were defined as client providers, or as remote providers that failed and may be retried by the client.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, ClientDataProviderQuery> ClientProviders { get; set; }
		
		/// <summary>
		/// Property bag of data keyed off of the data provider contribution id
		/// </summary>
		public System.Collections.Generic.Dictionary<string, object> Data { get; set; }
		
		/// <summary>
		/// Set of exceptions that occurred resolving the data providers.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, DataProviderExceptionDetails> Exceptions { get; set; }
		
		/// <summary>
		/// List of data providers resolved in the data-provider query
		/// </summary>
		public ResolvedDataProvider[] ResolvedProviders { get; set; }
		
		/// <summary>
		/// Scope name applied to this data provider result.
		/// </summary>
		public string ScopeName { get; set; }
		
		/// <summary>
		/// Scope value applied to this data provider result.
		/// </summary>
		public string ScopeValue { get; set; }
		
		/// <summary>
		/// Property bag of shared data that was contributed to by any of the individual data providers
		/// </summary>
		public System.Collections.Generic.Dictionary<string, object> SharedData { get; set; }
	}
	
	/// <summary>
	/// Entry for a specific data provider's resulting data
	/// </summary>
	public class ResolvedDataProvider
	{
		
		/// <summary>
		/// The total time the data provider took to resolve its data (in milliseconds)
		/// </summary>
		public System.Nullable<System.Single> Duration { get; set; }
		
		public string Error { get; set; }
		
		public string Id { get; set; }
	}
	
	/// <summary>
	/// Data bag that any data provider can contribute to. This shared dictionary is returned in the data provider result.
	/// </summary>
	public class DataProviderSharedData
	{
	}
	
	/// <summary>
	/// Contract for handling the extension acquisition process
	/// </summary>
	public class ExtensionAcquisitionRequest
	{
		
		/// <summary>
		/// How the item is being assigned
		/// </summary>
		public System.Nullable<ExtensionAcquisitionRequestAssignmentType> AssignmentType { get; set; }
		
		/// <summary>
		/// The id of the subscription used for purchase
		/// </summary>
		public string BillingId { get; set; }
		
		/// <summary>
		/// The marketplace id (publisherName.extensionName) for the item
		/// </summary>
		public string ItemId { get; set; }
		
		/// <summary>
		/// The type of operation, such as install, request, purchase
		/// </summary>
		public System.Nullable<ExtensionAcquisitionRequestOperationType> OperationType { get; set; }
		
		/// <summary>
		/// Represents a JSON object.
		/// </summary>
		public JObject Properties { get; set; }
		
		/// <summary>
		/// How many licenses should be purchased
		/// </summary>
		public System.Nullable<System.Int32> Quantity { get; set; }
	}
	
	public enum ExtensionAcquisitionRequestAssignmentType
	{
		
		none = 0,
		
		me = 1,
		
		all = 2,
	}
	
	public enum ExtensionAcquisitionRequestOperationType
	{
		
		get = 0,
		
		install = 1,
		
		buy = 2,
		
		_try = 3,
		
		request = 4,
		
		none = 5,
		
		purchaseRequest = 6,
	}
	
	/// <summary>
	/// Audit log for an extension
	/// </summary>
	public class ExtensionAuditLog
	{
		
		/// <summary>
		/// Collection of audit log entries
		/// </summary>
		public ExtensionAuditLogEntry[] Entries { get; set; }
		
		/// <summary>
		/// Extension that the change was made for
		/// </summary>
		public string ExtensionName { get; set; }
		
		/// <summary>
		/// Publisher that the extension is part of
		/// </summary>
		public string PublisherName { get; set; }
	}
	
	/// <summary>
	/// An audit log entry for an extension
	/// </summary>
	public class ExtensionAuditLogEntry
	{
		
		/// <summary>
		/// Change that was made to extension
		/// </summary>
		public string AuditAction { get; set; }
		
		/// <summary>
		/// Date at which the change was made
		/// </summary>
		public System.Nullable<System.DateTimeOffset> AuditDate { get; set; }
		
		/// <summary>
		/// Extra information about the change
		/// </summary>
		public string Comment { get; set; }
		
		public IdentityRef UpdatedBy { get; set; }
	}
	
	public class IdentityRef
	{
		
		/// <summary>
		/// Deprecated - Can be retrieved by querying the Graph user referenced in the "self" entry of the IdentityRef "_links" dictionary
		/// </summary>
		public string DirectoryAlias { get; set; }
		
		public string Id { get; set; }
		
		/// <summary>
		/// Deprecated - Available in the "avatar" entry of the IdentityRef "_links" dictionary
		/// </summary>
		public string ImageUrl { get; set; }
		
		/// <summary>
		/// Deprecated - Can be retrieved by querying the Graph membership state referenced in the "membershipState" entry of the GraphUser "_links" dictionary
		/// </summary>
		public System.Nullable<System.Boolean> Inactive { get; set; }
		
		/// <summary>
		/// Deprecated - Can be inferred from the subject type of the descriptor (Descriptor.IsAadUserType/Descriptor.IsAadGroupType)
		/// </summary>
		public System.Nullable<System.Boolean> IsAadIdentity { get; set; }
		
		/// <summary>
		/// Deprecated - Can be inferred from the subject type of the descriptor (Descriptor.IsGroupType)
		/// </summary>
		public System.Nullable<System.Boolean> IsContainer { get; set; }
		
		public System.Nullable<System.Boolean> IsDeletedInOrigin { get; set; }
		
		/// <summary>
		/// Deprecated - not in use in most preexisting implementations of ToIdentityRef
		/// </summary>
		public string ProfileUrl { get; set; }
		
		/// <summary>
		/// Deprecated - use Domain+PrincipalName instead
		/// </summary>
		public string UniqueName { get; set; }
	}
	
	public class ExtensionAuthorization
	{
		
		public string Id { get; set; }
		
		public string[] Scopes { get; set; }
	}
	
	public class ExtensionBadge
	{
		
		public string Description { get; set; }
		
		public string ImgUri { get; set; }
		
		public string Link { get; set; }
	}
	
	/// <summary>
	/// Represents a single collection for extension data documents
	/// </summary>
	public class ExtensionDataCollection
	{
		
		/// <summary>
		/// The name of the collection
		/// </summary>
		public string CollectionName { get; set; }
		
		/// <summary>
		/// A list of documents belonging to the collection
		/// </summary>
		public JObject[] Documents { get; set; }
		
		/// <summary>
		/// The type of the collection's scope, such as Default or User
		/// </summary>
		public string ScopeType { get; set; }
		
		/// <summary>
		/// The value of the collection's scope, such as Current or Me
		/// </summary>
		public string ScopeValue { get; set; }
	}
	
	/// <summary>
	/// Represents a query to receive a set of extension data collections
	/// </summary>
	public class ExtensionDataCollectionQuery
	{
		
		/// <summary>
		/// A list of collections to query
		/// </summary>
		public ExtensionDataCollection[] Collections { get; set; }
	}
	
	public class ExtensionEvent
	{
		
		public PublishedExtension Extension { get; set; }
		
		/// <summary>
		/// The current version of the extension that was updated
		/// </summary>
		public string ExtensionVersion { get; set; }
		
		public ExtensionHost Host { get; set; }
		
		public ExtensionEventUrls Links { get; set; }
		
		public IdentityRef ModifiedBy { get; set; }
		
		/// <summary>
		/// The type of update that was made
		/// </summary>
		public System.Nullable<ExtensionEventUpdateType> UpdateType { get; set; }
	}
	
	public class PublishedExtension
	{
		
		public string[] Categories { get; set; }
		
		public System.Nullable<PublishedExtensionDeploymentType> DeploymentType { get; set; }
		
		public string DisplayName { get; set; }
		
		public string ExtensionId { get; set; }
		
		public string ExtensionName { get; set; }
		
		public System.Nullable<PublishedExtensionFlags> Flags { get; set; }
		
		public InstallationTarget[] InstallationTargets { get; set; }
		
		public System.Nullable<System.DateTimeOffset> LastUpdated { get; set; }
		
		public string LongDescription { get; set; }
		
		/// <summary>
		/// Date on which the extension was first uploaded.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> PublishedDate { get; set; }
		
		/// <summary>
		/// High-level information about the publisher, like id's and names
		/// </summary>
		public PublisherFacts Publisher { get; set; }
		
		/// <summary>
		/// Date on which the extension first went public.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		public ExtensionShare[] SharedWith { get; set; }
		
		public string ShortDescription { get; set; }
		
		public ExtensionStatistic[] Statistics { get; set; }
		
		public string[] Tags { get; set; }
		
		public ExtensionVersion[] Versions { get; set; }
	}
	
	public enum PublishedExtensionDeploymentType
	{
		
		exe = 0,
		
		msi = 1,
		
		vsix = 2,
		
		referralLink = 3,
	}
	
	public enum PublishedExtensionFlags
	{
		
		none = 0,
		
		disabled = 1,
		
		builtIn = 2,
		
		validated = 3,
		
		trusted = 4,
		
		paid = 5,
		
		_public = 6,
		
		multiVersion = 7,
		
		system = 8,
		
		preview = 9,
		
		unpublished = 10,
		
		trial = 11,
		
		locked = 12,
		
		hidden = 13,
	}
	
	public class InstallationTarget
	{
		
		public string Target { get; set; }
		
		public string TargetVersion { get; set; }
	}
	
	/// <summary>
	/// High-level information about the publisher, like id's and names
	/// </summary>
	public class PublisherFacts
	{
		
		public string DisplayName { get; set; }
		
		public System.Nullable<PublisherFactsFlags> Flags { get; set; }
		
		public string PublisherId { get; set; }
		
		public string PublisherName { get; set; }
	}
	
	public enum PublisherFactsFlags
	{
		
		unChanged = 0,
		
		none = 1,
		
		disabled = 2,
		
		verified = 3,
		
		certified = 4,
		
		serviceFlags = 5,
	}
	
	public class ExtensionShare
	{
		
		public string Id { get; set; }
		
		public System.Nullable<System.Boolean> IsOrg { get; set; }
		
		public string Name { get; set; }
		
		public string Type { get; set; }
	}
	
	public class ExtensionStatistic
	{
		
		public string StatisticName { get; set; }
		
		public System.Nullable<System.Double> Value { get; set; }
	}
	
	public class ExtensionVersion
	{
		
		public string AssetUri { get; set; }
		
		public ExtensionBadge[] Badges { get; set; }
		
		public string FallbackAssetUri { get; set; }
		
		public ExtensionFile[] Files { get; set; }
		
		public System.Nullable<ExtensionVersionFlags> Flags { get; set; }
		
		public System.Nullable<System.DateTimeOffset> LastUpdated { get; set; }
		
		public string[] Properties { get; set; }
		
		public string ValidationResultMessage { get; set; }
		
		public string Version { get; set; }
		
		public string VersionDescription { get; set; }
	}
	
	public class ExtensionFile
	{
		
		public string AssetType { get; set; }
		
		public string Language { get; set; }
		
		public string Source { get; set; }
	}
	
	public enum ExtensionVersionFlags
	{
		
		none = 0,
		
		validated = 1,
	}
	
	public class ExtensionHost
	{
		
		public string Id { get; set; }
		
		public string Name { get; set; }
	}
	
	public class ExtensionEventUrls
	{
		
		/// <summary>
		/// Url of the extension management page
		/// </summary>
		public string ManageExtensionsPage { get; set; }
	}
	
	public enum ExtensionEventUpdateType
	{
		
		installed = 0,
		
		uninstalled = 1,
		
		enabled = 2,
		
		disabled = 3,
		
		versionUpdated = 4,
		
		actionRequired = 5,
		
		actionResolved = 6,
	}
	
	/// <summary>
	/// Base class for an event callback for an extension
	/// </summary>
	public class ExtensionEventCallback
	{
		
		/// <summary>
		/// The uri of the endpoint that is hit when an event occurs
		/// </summary>
		public string Uri { get; set; }
	}
	
	/// <summary>
	/// Collection of event callbacks - endpoints called when particular extension events occur.
	/// </summary>
	public class ExtensionEventCallbackCollection
	{
		
		/// <summary>
		/// Base class for an event callback for an extension
		/// </summary>
		public ExtensionEventCallback PostDisable { get; set; }
		
		/// <summary>
		/// Base class for an event callback for an extension
		/// </summary>
		public ExtensionEventCallback PostEnable { get; set; }
		
		/// <summary>
		/// Base class for an event callback for an extension
		/// </summary>
		public ExtensionEventCallback PostInstall { get; set; }
		
		/// <summary>
		/// Base class for an event callback for an extension
		/// </summary>
		public ExtensionEventCallback PostUninstall { get; set; }
		
		/// <summary>
		/// Base class for an event callback for an extension
		/// </summary>
		public ExtensionEventCallback PostUpdate { get; set; }
		
		/// <summary>
		/// Base class for an event callback for an extension
		/// </summary>
		public ExtensionEventCallback PreInstall { get; set; }
		
		/// <summary>
		/// Base class for an event callback for an extension
		/// </summary>
		public ExtensionEventCallback VersionCheck { get; set; }
	}
	
	/// <summary>
	/// Represents the component pieces of an extensions fully qualified name, along with the fully qualified name.
	/// </summary>
	public class ExtensionIdentifier
	{
		
		/// <summary>
		/// The ExtensionName component part of the fully qualified ExtensionIdentifier
		/// </summary>
		public string ExtensionName { get; set; }
		
		/// <summary>
		/// The PublisherName component part of the fully qualified ExtensionIdentifier
		/// </summary>
		public string PublisherName { get; set; }
	}
	
	/// <summary>
	/// How an extension should handle including contributions based on licensing
	/// </summary>
	public class ExtensionLicensing
	{
		
		/// <summary>
		/// A list of contributions which deviate from the default licensing behavior
		/// </summary>
		public LicensingOverride[] Overrides { get; set; }
	}
	
	/// <summary>
	/// Maps a contribution to a licensing behavior
	/// </summary>
	public class LicensingOverride
	{
		
		/// <summary>
		/// How the inclusion of this contribution should change based on licensing
		/// </summary>
		public System.Nullable<LicensingOverrideBehavior> Behavior { get; set; }
		
		/// <summary>
		/// Fully qualified contribution id which we want to define licensing behavior for
		/// </summary>
		public string Id { get; set; }
	}
	
	public enum LicensingOverrideBehavior
	{
		
		onlyIfLicensed = 0,
		
		onlyIfUnlicensed = 1,
		
		alwaysInclude = 2,
	}
	
	/// <summary>
	/// Base class for extension properties which are shared by the extension manifest and the extension model
	/// </summary>
	public class ExtensionManifest
	{
		
		/// <summary>
		/// Uri used as base for other relative uri's defined in extension
		/// </summary>
		public string BaseUri { get; set; }
		
		/// <summary>
		/// List of shared constraints defined by this extension
		/// </summary>
		public ContributionConstraint[] Constraints { get; set; }
		
		/// <summary>
		/// List of contributions made by this extension
		/// </summary>
		public Contribution[] Contributions { get; set; }
		
		/// <summary>
		/// List of contribution types defined by this extension
		/// </summary>
		public ContributionType[] ContributionTypes { get; set; }
		
		/// <summary>
		/// List of explicit demands required by this extension
		/// </summary>
		public string[] Demands { get; set; }
		
		/// <summary>
		/// Collection of event callbacks - endpoints called when particular extension events occur.
		/// </summary>
		public ExtensionEventCallbackCollection EventCallbacks { get; set; }
		
		/// <summary>
		/// Secondary location that can be used as base for other relative uri's defined in extension
		/// </summary>
		public string FallbackBaseUri { get; set; }
		
		/// <summary>
		/// Language Culture Name set by the Gallery
		/// </summary>
		public string Language { get; set; }
		
		/// <summary>
		/// How an extension should handle including contributions based on licensing
		/// </summary>
		public ExtensionLicensing Licensing { get; set; }
		
		/// <summary>
		/// Version of the extension manifest format/content
		/// </summary>
		public System.Nullable<System.Double> ManifestVersion { get; set; }
		
		/// <summary>
		/// Default user claims applied to all contributions (except the ones which have been specified restrictedTo explicitly) to control the visibility of a contribution.
		/// </summary>
		public string[] RestrictedTo { get; set; }
		
		/// <summary>
		/// List of all oauth scopes required by this extension
		/// </summary>
		public string[] Scopes { get; set; }
		
		/// <summary>
		/// The ServiceInstanceType(Guid) of the VSTS service that must be available to an account in order for the extension to be installed
		/// </summary>
		public string ServiceInstanceType { get; set; }
	}
	
	/// <summary>
	/// Policy with a set of permissions on extension operations
	/// </summary>
	public class ExtensionPolicy
	{
		
		/// <summary>
		/// Permissions on 'Install' operation
		/// </summary>
		public System.Nullable<ExtensionPolicyInstall> Install { get; set; }
		
		/// <summary>
		/// Permission on 'Request' operation
		/// </summary>
		public System.Nullable<ExtensionPolicyRequest> Request { get; set; }
	}
	
	public enum ExtensionPolicyInstall
	{
		
		none = 0,
		
		_private = 1,
		
		_public = 2,
		
		preview = 3,
		
		released = 4,
		
		firstParty = 5,
		
		all = 6,
	}
	
	public enum ExtensionPolicyRequest
	{
		
		none = 0,
		
		_private = 1,
		
		_public = 2,
		
		preview = 3,
		
		released = 4,
		
		firstParty = 5,
		
		all = 6,
	}
	
	/// <summary>
	/// A request for an extension (to be installed or have a license assigned)
	/// </summary>
	public class ExtensionRequest
	{
		
		/// <summary>
		/// Required message supplied if the request is rejected
		/// </summary>
		public string RejectMessage { get; set; }
		
		/// <summary>
		/// Date at which the request was made
		/// </summary>
		public System.Nullable<System.DateTimeOffset> RequestDate { get; set; }
		
		public IdentityRef RequestedBy { get; set; }
		
		/// <summary>
		/// Optional message supplied by the requester justifying the request
		/// </summary>
		public string RequestMessage { get; set; }
		
		/// <summary>
		/// Represents the state of the request
		/// </summary>
		public System.Nullable<ExtensionRequestRequestState> RequestState { get; set; }
		
		/// <summary>
		/// Date at which the request was resolved
		/// </summary>
		public System.Nullable<System.DateTimeOffset> ResolveDate { get; set; }
		
		public IdentityRef ResolvedBy { get; set; }
	}
	
	public enum ExtensionRequestRequestState
	{
		
		open = 0,
		
		accepted = 1,
		
		rejected = 2,
	}
	
	public class ExtensionRequestEvent
	{
		
		public PublishedExtension Extension { get; set; }
		
		public ExtensionHost Host { get; set; }
		
		/// <summary>
		/// Name of the collection for which the extension was requested
		/// </summary>
		public string HostName { get; set; }
		
		public ExtensionRequestUrls Links { get; set; }
		
		/// <summary>
		/// A request for an extension (to be installed or have a license assigned)
		/// </summary>
		public ExtensionRequest Request { get; set; }
		
		/// <summary>
		/// The type of update that was made
		/// </summary>
		public System.Nullable<ExtensionRequestEventUpdateType> UpdateType { get; set; }
	}
	
	public class ExtensionRequestUrls
	{
		
		/// <summary>
		/// Link to view the extension request
		/// </summary>
		public string RequestPage { get; set; }
	}
	
	public enum ExtensionRequestEventUpdateType
	{
		
		created = 0,
		
		approved = 1,
		
		rejected = 2,
		
		deleted = 3,
	}
	
	public class ExtensionRequestsEvent
	{
		
		public PublishedExtension Extension { get; set; }
		
		public ExtensionHost Host { get; set; }
		
		public ExtensionRequestUrls Links { get; set; }
		
		/// <summary>
		/// The extension request object
		/// </summary>
		public ExtensionRequest[] Requests { get; set; }
		
		/// <summary>
		/// The type of update that was made
		/// </summary>
		public System.Nullable<ExtensionRequestsEventUpdateType> UpdateType { get; set; }
	}
	
	public enum ExtensionRequestsEventUpdateType
	{
		
		created = 0,
		
		approved = 1,
		
		rejected = 2,
		
		deleted = 3,
	}
	
	/// <summary>
	/// The state of an extension
	/// </summary>
	public class ExtensionState
	{
		
		public string ExtensionName { get; set; }
		
		/// <summary>
		/// The time at which the version was last checked
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastVersionCheck { get; set; }
		
		public string PublisherName { get; set; }
		
		public string Version { get; set; }
	}
	
	public class ExtensionUrls
	{
		
		/// <summary>
		/// Url of the extension icon
		/// </summary>
		public string ExtensionIcon { get; set; }
		
		/// <summary>
		/// Link to view the extension details page
		/// </summary>
		public string ExtensionPage { get; set; }
	}
	
	public class GraphSubjectBase
	{
		
		/// <summary>
		/// The class to represent a collection of REST reference links.
		/// </summary>
		public ReferenceLinks _links { get; set; }
		
		/// <summary>
		/// The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
		/// </summary>
		public string Descriptor { get; set; }
		
		/// <summary>
		/// This is the non-unique display name of the graph subject. To change this field, you must alter its value in the source provider.
		/// </summary>
		public string DisplayName { get; set; }
		
		/// <summary>
		/// This url is the full route to the source resource of this graph subject.
		/// </summary>
		public string Url { get; set; }
	}
	
	/// <summary>
	/// The class to represent a collection of REST reference links.
	/// </summary>
	public class ReferenceLinks
	{
		
		/// <summary>
		/// The readonly view of the links.  Because Reference links are readonly, we only want to expose them as read only.
		/// </summary>
		public System.Collections.Generic.Dictionary<string, object> Links { get; set; }
	}
	
	/// <summary>
	/// Represents a VSTS extension along with its installation state
	/// </summary>
	public class InstalledExtension
	{
		
		/// <summary>
		/// The friendly extension id for this extension - unique for a given publisher.
		/// </summary>
		public string ExtensionId { get; set; }
		
		/// <summary>
		/// The display name of the extension.
		/// </summary>
		public string ExtensionName { get; set; }
		
		/// <summary>
		/// This is the set of files available from the extension.
		/// </summary>
		public ExtensionFile[] Files { get; set; }
		
		/// <summary>
		/// Extension flags relevant to contribution consumers
		/// </summary>
		public System.Nullable<InstalledExtensionFlags> Flags { get; set; }
		
		/// <summary>
		/// The state of an installed extension
		/// </summary>
		public InstalledExtensionState InstallState { get; set; }
		
		/// <summary>
		/// This represents the date/time the extensions was last updated in the gallery. This doesnt mean this version was updated the value represents changes to any and all versions of the extension.
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastPublished { get; set; }
		
		/// <summary>
		/// Unique id of the publisher of this extension
		/// </summary>
		public string PublisherId { get; set; }
		
		/// <summary>
		/// The display name of the publisher
		/// </summary>
		public string PublisherName { get; set; }
		
		/// <summary>
		/// Unique id for this extension (the same id is used for all versions of a single extension)
		/// </summary>
		public string RegistrationId { get; set; }
		
		/// <summary>
		/// Version of this extension
		/// </summary>
		public string Version { get; set; }
	}
	
	public enum InstalledExtensionFlags
	{
		
		builtIn = 0,
		
		trusted = 1,
	}
	
	/// <summary>
	/// The state of an installed extension
	/// </summary>
	public class InstalledExtensionState
	{
		
		/// <summary>
		/// States of an installed extension
		/// </summary>
		public System.Nullable<InstalledExtensionStateFlags> Flags { get; set; }
		
		/// <summary>
		/// List of installation issues
		/// </summary>
		public InstalledExtensionStateIssue[] InstallationIssues { get; set; }
		
		/// <summary>
		/// The time at which this installation was last updated
		/// </summary>
		public System.Nullable<System.DateTimeOffset> LastUpdated { get; set; }
	}
	
	public enum InstalledExtensionStateFlags
	{
		
		none = 0,
		
		disabled = 1,
		
		builtIn = 2,
		
		multiVersion = 3,
		
		unInstalled = 4,
		
		versionCheckError = 5,
		
		trusted = 6,
		
		error = 7,
		
		needsReauthorization = 8,
		
		autoUpgradeError = 9,
		
		warning = 10,
	}
	
	/// <summary>
	/// Represents an installation issue
	/// </summary>
	public class InstalledExtensionStateIssue
	{
		
		/// <summary>
		/// The error message
		/// </summary>
		public string Message { get; set; }
		
		/// <summary>
		/// Source of the installation issue, for example  "Demands"
		/// </summary>
		public string Source { get; set; }
		
		/// <summary>
		/// Installation issue type (Warning, Error)
		/// </summary>
		public System.Nullable<InstalledExtensionStateIssueType> Type { get; set; }
	}
	
	public enum InstalledExtensionStateIssueType
	{
		
		warning = 0,
		
		error = 1,
	}
	
	public class InstalledExtensionQuery
	{
		
		public string[] AssetTypes { get; set; }
		
		public ExtensionIdentifier[] Monikers { get; set; }
	}
	
	/// <summary>
	/// A request for an extension (to be installed or have a license assigned)
	/// </summary>
	public class RequestedExtension
	{
		
		/// <summary>
		/// The unique name of the extension
		/// </summary>
		public string ExtensionName { get; set; }
		
		/// <summary>
		/// A list of each request for the extension
		/// </summary>
		public ExtensionRequest[] ExtensionRequests { get; set; }
		
		/// <summary>
		/// DisplayName of the publisher that owns the extension being published.
		/// </summary>
		public string PublisherDisplayName { get; set; }
		
		/// <summary>
		/// Represents the Publisher of the requested extension
		/// </summary>
		public string PublisherName { get; set; }
		
		/// <summary>
		/// The total number of requests for an extension
		/// </summary>
		public System.Nullable<System.Int32> RequestCount { get; set; }
	}
	
	public class Scope
	{
		
		public string Description { get; set; }
		
		public string Title { get; set; }
		
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Information about the extension
	/// </summary>
	public class SupportedExtension
	{
		
		/// <summary>
		/// Unique Identifier for this extension
		/// </summary>
		public string Extension { get; set; }
		
		/// <summary>
		/// Unique Identifier for this publisher
		/// </summary>
		public string Publisher { get; set; }
		
		/// <summary>
		/// Supported version for this extension
		/// </summary>
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Represents the extension policy applied to a given user
	/// </summary>
	public class UserExtensionPolicy
	{
		
		/// <summary>
		/// User display name that this policy refers to
		/// </summary>
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Policy with a set of permissions on extension operations
		/// </summary>
		public ExtensionPolicy Permissions { get; set; }
		
		/// <summary>
		/// User id that this policy refers to
		/// </summary>
		public string UserId { get; set; }
	}
	
	/// <summary>
	/// This class is used to serialized collections as a single JSON object on the wire, to avoid serializing JSON arrays directly to the client, which can be a security hole
	/// </summary>
	public class VssJsonCollectionWrapper
	{
		
		public string Value { get; set; }
	}
	
	public class VssJsonCollectionWrapperBase
	{
		
		public System.Nullable<System.Int32> Count { get; set; }
	}
	
	public partial class MyClient
	{
		
		private System.Net.Http.HttpClient client;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public MyClient(System.Net.Http.HttpClient client, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (client == null)
				throw new ArgumentNullException("Null HttpClient.", "client");

			if (client.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "client");

			this.client = client;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// List the installed extensions in the account / project collection.
		/// Installed_Extensions_List {organization}/_apis/extensionmanagement/installedextensions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="includeDisabledExtensions">If true (the default), include disabled extensions in the results.</param>
		/// <param name="includeErrors">If true, include installed extensions with errors.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<InstalledExtension[]> Installed_Extensions_ListAsync(string organization, bool includeDisabledExtensions, bool includeErrors, string assetTypes, bool includeInstallationIssues, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/_apis/extensionmanagement/installedextensions&includeDisabledExtensions="+includeDisabledExtensions+"&includeErrors="+includeErrors+"&assetTypes=" + (assetTypes==null? "" : System.Uri.EscapeDataString(assetTypes))+"&includeInstallationIssues="+includeInstallationIssues+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstalledExtension[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the installed extensions in the account / project collection.
		/// Installed_Extensions_List {organization}/_apis/extensionmanagement/installedextensions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="includeDisabledExtensions">If true (the default), include disabled extensions in the results.</param>
		/// <param name="includeErrors">If true, include installed extensions with errors.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public InstalledExtension[] Installed_Extensions_List(string organization, bool includeDisabledExtensions, bool includeErrors, string assetTypes, bool includeInstallationIssues, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/_apis/extensionmanagement/installedextensions&includeDisabledExtensions="+includeDisabledExtensions+"&includeErrors="+includeErrors+"&assetTypes=" + (assetTypes==null? "" : System.Uri.EscapeDataString(assetTypes))+"&includeInstallationIssues="+includeInstallationIssues+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstalledExtension[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an installed extension. Typically this API is used to enable or disable an extension.
		/// Installed_Extensions_Update {organization}/_apis/extensionmanagement/installedextensions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<InstalledExtension> Installed_Extensions_UpdateAsync(string organization, string api_version, InstalledExtension requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/_apis/extensionmanagement/installedextensions&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstalledExtension>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update an installed extension. Typically this API is used to enable or disable an extension.
		/// Installed_Extensions_Update {organization}/_apis/extensionmanagement/installedextensions
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public InstalledExtension Installed_Extensions_Update(string organization, string api_version, InstalledExtension requestBody)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/_apis/extensionmanagement/installedextensions&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstalledExtension>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get an installed extension by its publisher and extension name.
		/// Installed_Extensions_Get {organization}/_apis/extensionmanagement/installedextensionsbyname/{publisherName}/{extensionName}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="publisherName">Name of the publisher. Example: "fabrikam".</param>
		/// <param name="extensionName">Name of the extension. Example: "ops-tools".</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<InstalledExtension> Installed_Extensions_GetAsync(string organization, string publisherName, string extensionName, string assetTypes, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/_apis/extensionmanagement/installedextensionsbyname/"+ (publisherName==null? "" : System.Uri.EscapeDataString(publisherName))+"/"+ (extensionName==null? "" : System.Uri.EscapeDataString(extensionName))+"&assetTypes=" + (assetTypes==null? "" : System.Uri.EscapeDataString(assetTypes))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstalledExtension>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an installed extension by its publisher and extension name.
		/// Installed_Extensions_Get {organization}/_apis/extensionmanagement/installedextensionsbyname/{publisherName}/{extensionName}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="publisherName">Name of the publisher. Example: "fabrikam".</param>
		/// <param name="extensionName">Name of the extension. Example: "ops-tools".</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public InstalledExtension Installed_Extensions_Get(string organization, string publisherName, string extensionName, string assetTypes, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/_apis/extensionmanagement/installedextensionsbyname/"+ (publisherName==null? "" : System.Uri.EscapeDataString(publisherName))+"/"+ (extensionName==null? "" : System.Uri.EscapeDataString(extensionName))+"&assetTypes=" + (assetTypes==null? "" : System.Uri.EscapeDataString(assetTypes))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstalledExtension>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Uninstall the specified extension from the account / project collection.
		/// Installed_Extensions_Uninstall_Extension_By_Name {organization}/_apis/extensionmanagement/installedextensionsbyname/{publisherName}/{extensionName}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="publisherName">Name of the publisher. Example: "fabrikam".</param>
		/// <param name="extensionName">Name of the extension. Example: "ops-tools".</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task Installed_Extensions_Uninstall_Extension_By_NameAsync(string organization, string publisherName, string extensionName, string reason, string reasonCode, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/_apis/extensionmanagement/installedextensionsbyname/"+ (publisherName==null? "" : System.Uri.EscapeDataString(publisherName))+"/"+ (extensionName==null? "" : System.Uri.EscapeDataString(extensionName))+"&reason=" + (reason==null? "" : System.Uri.EscapeDataString(reason))+"&reasonCode=" + (reasonCode==null? "" : System.Uri.EscapeDataString(reasonCode))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Uninstall the specified extension from the account / project collection.
		/// Installed_Extensions_Uninstall_Extension_By_Name {organization}/_apis/extensionmanagement/installedextensionsbyname/{publisherName}/{extensionName}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="publisherName">Name of the publisher. Example: "fabrikam".</param>
		/// <param name="extensionName">Name of the extension. Example: "ops-tools".</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public void Installed_Extensions_Uninstall_Extension_By_Name(string organization, string publisherName, string extensionName, string reason, string reasonCode, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/_apis/extensionmanagement/installedextensionsbyname/"+ (publisherName==null? "" : System.Uri.EscapeDataString(publisherName))+"/"+ (extensionName==null? "" : System.Uri.EscapeDataString(extensionName))+"&reason=" + (reason==null? "" : System.Uri.EscapeDataString(reason))+"&reasonCode=" + (reasonCode==null? "" : System.Uri.EscapeDataString(reasonCode))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Install the specified extension into the account / project collection.
		/// Installed_Extensions_Install_Extension_By_Name {organization}/_apis/extensionmanagement/installedextensionsbyname/{publisherName}/{extensionName}/{version}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="publisherName">Name of the publisher. Example: "fabrikam".</param>
		/// <param name="extensionName">Name of the extension. Example: "ops-tools".</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public async Task<InstalledExtension> Installed_Extensions_Install_Extension_By_NameAsync(string organization, string publisherName, string extensionName, string version, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/_apis/extensionmanagement/installedextensionsbyname/"+ (publisherName==null? "" : System.Uri.EscapeDataString(publisherName))+"/"+ (extensionName==null? "" : System.Uri.EscapeDataString(extensionName))+"/"+ (version==null? "" : System.Uri.EscapeDataString(version))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstalledExtension>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Install the specified extension into the account / project collection.
		/// Installed_Extensions_Install_Extension_By_Name {organization}/_apis/extensionmanagement/installedextensionsbyname/{publisherName}/{extensionName}/{version}
		/// </summary>
		/// <param name="organization">The name of the Azure DevOps organization.</param>
		/// <param name="publisherName">Name of the publisher. Example: "fabrikam".</param>
		/// <param name="extensionName">Name of the extension. Example: "ops-tools".</param>
		/// <param name="api_version">Version of the API to use.  This should be set to '6.0-preview.1' to use this version of the api.</param>
		/// <returns>successful operation</returns>
		public InstalledExtension Installed_Extensions_Install_Extension_By_Name(string organization, string publisherName, string extensionName, string version, string api_version)
		{
			var requestUri = ""+ (organization==null? "" : System.Uri.EscapeDataString(organization))+"/_apis/extensionmanagement/installedextensionsbyname/"+ (publisherName==null? "" : System.Uri.EscapeDataString(publisherName))+"/"+ (extensionName==null? "" : System.Uri.EscapeDataString(extensionName))+"/"+ (version==null? "" : System.Uri.EscapeDataString(version))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = client.SendAsync(httpRequestMessage).Result;
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = responseMessage.Content.ReadAsStreamAsync().Result;
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstalledExtension>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
