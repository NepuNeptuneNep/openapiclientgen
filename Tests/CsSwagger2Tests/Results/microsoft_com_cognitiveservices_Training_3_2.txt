//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Bounding box that defines a region of an image.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class BoundingBox
	{
		
		/// <summary>
		/// Height.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="height")]
		public float Height { get; set; }
		
		/// <summary>
		/// Coordinate of the left boundary.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="left")]
		public float Left { get; set; }
		
		/// <summary>
		/// Coordinate of the top boundary.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="top")]
		public float Top { get; set; }
		
		/// <summary>
		/// Width.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="width")]
		public float Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class CustomVisionError
	{
		
		/// <summary>
		/// The error code.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public CustomVisionErrorCode Code { get; set; }
		
		/// <summary>
		/// A message explaining the error reported by the service.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum CustomVisionErrorCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NoError = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequest = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestExceededBatchSize = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestNotSupported = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestInvalidIds = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestProjectName = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestProjectNameNotUnique = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestProjectDescription = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestProjectUnknownDomain = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestProjectUnknownClassification = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestProjectUnsupportedDomainTypeChange = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestProjectUnsupportedExportPlatform = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestProjectImagePreprocessingSettings = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestProjectDuplicated = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestIterationName = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestIterationNameNotUnique = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestIterationDescription = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestIterationIsNotTrained = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestIterationValidationFailed = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestWorkspaceCannotBeModified = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestWorkspaceNotDeletable = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestTagName = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestTagNameNotUnique = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestTagDescription = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestTagType = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestMultipleNegativeTag = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestImageTags = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestImageRegions = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestNegativeAndRegularTagOnSameImage = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestRequiredParamIsNull = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestIterationIsPublished = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestInvalidPublishName = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestInvalidPublishTarget = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestUnpublishFailed = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestIterationNotPublished = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestSubscriptionApi = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestExceedProjectLimit = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestExceedIterationPerProjectLimit = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestExceedTagPerProjectLimit = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestExceedTagPerImageLimit = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestExceededQuota = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestCannotMigrateProjectWithName = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestNotLimitedTrial = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestImageBatch = 43,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestImageStream = 44,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestImageUrl = 45,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestImageFormat = 46,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestImageSizeBytes = 47,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestImageExceededCount = 48,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestTrainingNotNeeded = 49,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestTrainingNotNeededButTrainingPipelineUpdated = 50,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestTrainingValidationFailed = 51,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestClassificationTrainingValidationFailed = 52,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestMultiClassClassificationTrainingValidationFailed = 53,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestMultiLabelClassificationTrainingValidationFailed = 54,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestDetectionTrainingValidationFailed = 55,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestTrainingAlreadyInProgress = 56,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestDetectionTrainingNotAllowNegativeTag = 57,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestInvalidEmailAddress = 58,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestDomainNotSupportedForAdvancedTraining = 59,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestExportPlatformNotSupportedForAdvancedTraining = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestReservedBudgetInHoursNotEnoughForAdvancedTraining = 61,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestExportValidationFailed = 62,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestExportAlreadyInProgress = 63,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestPredictionIdsMissing = 64,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestPredictionIdsExceededCount = 65,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestPredictionTagsExceededCount = 66,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestPredictionResultsExceededCount = 67,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestPredictionInvalidApplicationName = 68,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestPredictionInvalidQueryParameters = 69,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestInvalidImportToken = 70,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestExportWhileTraining = 71,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BadRequestInvalid = 72,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnsupportedMediaType = 73,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Forbidden = 74,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ForbiddenUser = 75,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ForbiddenUserResource = 76,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ForbiddenUserSignupDisabled = 77,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ForbiddenUserSignupAllowanceExceeded = 78,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ForbiddenUserDoesNotExist = 79,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ForbiddenUserDisabled = 80,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ForbiddenUserInsufficientCapability = 81,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ForbiddenDRModeEnabled = 82,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ForbiddenInvalid = 83,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotFound = 84,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotFoundProject = 85,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotFoundProjectDefaultIteration = 86,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotFoundIteration = 87,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotFoundIterationPerformance = 88,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotFoundTag = 89,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotFoundImage = 90,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotFoundDomain = 91,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotFoundApimSubscription = 92,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotFoundInvalid = 93,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Conflict = 94,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ConflictInvalid = 95,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorUnknown = 96,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorIterationCopyFailed = 97,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorPreparePerformanceMigrationFailed = 98,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorProjectInvalidWorkspace = 99,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorProjectInvalidPipelineConfiguration = 100,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorProjectInvalidDomain = 101,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorProjectTrainingRequestFailed = 102,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorProjectImportRequestFailed = 103,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorProjectExportRequestFailed = 104,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorFeaturizationServiceUnavailable = 105,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorFeaturizationQueueTimeout = 106,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorFeaturizationInvalidFeaturizer = 107,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorFeaturizationAugmentationUnavailable = 108,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorFeaturizationUnrecognizedJob = 109,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorFeaturizationAugmentationError = 110,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorExporterInvalidPlatform = 111,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorExporterInvalidFeaturizer = 112,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorExporterInvalidClassifier = 113,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorPredictionServiceUnavailable = 114,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorPredictionModelNotFound = 115,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorPredictionModelNotCached = 116,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorPrediction = 117,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorPredictionStorage = 118,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorRegionProposal = 119,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorInvalid = 120,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Domain
	{
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="exportable")]
		public System.Nullable<System.Boolean> Exportable { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<DomainType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum DomainType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Classification = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ObjectDetection = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Export
	{
		
		/// <summary>
		/// URI used to download the model.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="downloadUri")]
		public string DownloadUri { get; set; }
		
		/// <summary>
		/// Flavor of the export. These are specializations of the export platform.
		///Docker platform has valid flavors: Linux, Windows, ARM.
		///Tensorflow platform has valid flavors: TensorFlowNormal, TensorFlowLite.
		///ONNX platform has valid flavors: ONNX10, ONNX12.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="flavor")]
		public System.Nullable<ExportFlavor> Flavor { get; set; }
		
		/// <summary>
		/// Indicates an updated version of the export package is available and should be re-exported for the latest changes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newerVersionAvailable")]
		public System.Nullable<System.Boolean> NewerVersionAvailable { get; set; }
		
		/// <summary>
		/// Platform of the export.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platform")]
		public System.Nullable<ExportPlatform> Platform { get; set; }
		
		/// <summary>
		/// Status of the export.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<ExportStatus> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ExportFlavor
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Linux = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Windows = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONNX10 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONNX12 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ARM = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TensorFlowNormal = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TensorFlowLite = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ExportPlatform
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CoreML = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TensorFlow = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DockerFile = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONNX = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VAIDK = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ExportStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Exporting = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Done = 2,
	}
	
	/// <summary>
	/// Image model to be sent as JSON.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Image
	{
		
		/// <summary>
		/// Date the image was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// Height of the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="height")]
		public System.Nullable<System.Int32> Height { get; set; }
		
		/// <summary>
		/// Id of the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The URI to the original uploaded image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="originalImageUri")]
		public string OriginalImageUri { get; set; }
		
		/// <summary>
		/// Regions associated with this image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public ImageRegion[] Regions { get; set; }
		
		/// <summary>
		/// The URI to the (resized) image used for training.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resizedImageUri")]
		public string ResizedImageUri { get; set; }
		
		/// <summary>
		/// Tags associated with this image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public ImageTag[] Tags { get; set; }
		
		/// <summary>
		/// The URI to the thumbnail of the original image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thumbnailUri")]
		public string ThumbnailUri { get; set; }
		
		/// <summary>
		/// Width of the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="width")]
		public System.Nullable<System.Int32> Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageRegion
	{
		
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// Height.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="height")]
		public float Height { get; set; }
		
		/// <summary>
		/// Coordinate of the left boundary.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="left")]
		public float Left { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regionId")]
		public string RegionId { get; set; }
		
		/// <summary>
		/// Id of the tag associated with this region.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tagId")]
		public string TagId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tagName")]
		public string TagName { get; set; }
		
		/// <summary>
		/// Coordinate of the top boundary.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="top")]
		public float Top { get; set; }
		
		/// <summary>
		/// Width.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="width")]
		public float Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageTag
	{
		
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tagId")]
		public string TagId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tagName")]
		public string TagName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageCreateResult
	{
		
		/// <summary>
		/// Image model to be sent as JSON.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public Image Image { get; set; }
		
		/// <summary>
		/// Source URL of the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceUrl")]
		public string SourceUrl { get; set; }
		
		/// <summary>
		/// Status of the image creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<ImageCreateResultStatus> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ImageCreateResultStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OK = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OKDuplicate = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorSource = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorImageFormat = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorImageSize = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorStorage = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorLimitExceed = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorTagLimitExceed = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorRegionLimitExceed = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorUnknown = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ErrorNegativeAndRegularTagOnSameImage = 10,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageCreateSummary
	{
		
		/// <summary>
		/// List of the image creation results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="images")]
		public ImageCreateResult[] Images { get; set; }
		
		/// <summary>
		/// True if all of the images in the batch were created successfully, otherwise false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isBatchSuccessful")]
		public System.Nullable<System.Boolean> IsBatchSuccessful { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageFileCreateBatch
	{
		
		[System.Runtime.Serialization.DataMember(Name="images")]
		public ImageFileCreateEntry[] Images { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tagIds")]
		public string[] TagIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageFileCreateEntry
	{
		
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public string Contents { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public Region[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tagIds")]
		public string[] TagIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Region
	{
		
		/// <summary>
		/// Height.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="height")]
		public float Height { get; set; }
		
		/// <summary>
		/// Coordinate of the left boundary.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="left")]
		public float Left { get; set; }
		
		/// <summary>
		/// Id of the tag associated with this region.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tagId")]
		public string TagId { get; set; }
		
		/// <summary>
		/// Coordinate of the top boundary.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="top")]
		public float Top { get; set; }
		
		/// <summary>
		/// Width.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="width")]
		public float Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageIdCreateBatch
	{
		
		[System.Runtime.Serialization.DataMember(Name="images")]
		public ImageIdCreateEntry[] Images { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tagIds")]
		public string[] TagIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageIdCreateEntry
	{
		
		/// <summary>
		/// Id of the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public Region[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tagIds")]
		public string[] TagIds { get; set; }
	}
	
	/// <summary>
	/// Image performance model.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImagePerformance
	{
		
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="height")]
		public System.Nullable<System.Int32> Height { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="imageUri")]
		public string ImageUri { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="predictions")]
		public Prediction[] Predictions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public ImageRegion[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public ImageTag[] Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="thumbnailUri")]
		public string ThumbnailUri { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="width")]
		public System.Nullable<System.Int32> Width { get; set; }
	}
	
	/// <summary>
	/// Prediction result.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Prediction
	{
		
		/// <summary>
		/// Bounding box that defines a region of an image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="boundingBox")]
		public BoundingBox BoundingBox { get; set; }
		
		/// <summary>
		/// Probability of the tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="probability")]
		public System.Nullable<System.Single> Probability { get; set; }
		
		/// <summary>
		/// Id of the predicted tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tagId")]
		public string TagId { get; set; }
		
		/// <summary>
		/// Name of the predicted tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tagName")]
		public string TagName { get; set; }
	}
	
	/// <summary>
	/// Result of an image prediction request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImagePrediction
	{
		
		/// <summary>
		/// Date this prediction was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// Prediction Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Iteration Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iteration")]
		public string Iteration { get; set; }
		
		/// <summary>
		/// List of predictions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="predictions")]
		public Prediction[] Predictions { get; set; }
		
		/// <summary>
		/// Project Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="project")]
		public string Project { get; set; }
	}
	
	/// <summary>
	/// Represents image preprocessing settings used by image augmentation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageProcessingSettings
	{
		
		/// <summary>
		/// Gets or sets enabled image transforms. The key corresponds to the transform name. If value is set to true, then correspondent transform is enabled. Otherwise this transform will not be used.
		///Augmentation will be uniformly distributed among enabled transforms.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="augmentationMethods")]
		public System.Collections.Generic.Dictionary<string, bool> AugmentationMethods { get; set; }
	}
	
	/// <summary>
	/// Batch of image region information to create.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageRegionCreateBatch
	{
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public ImageRegionCreateEntry[] Regions { get; set; }
	}
	
	/// <summary>
	/// Entry associating a region to an image.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageRegionCreateEntry
	{
		
		/// <summary>
		/// Height.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="height")]
		public float Height { get; set; }
		
		/// <summary>
		/// Id of the image.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="imageId")]
		public string ImageId { get; set; }
		
		/// <summary>
		/// Coordinate of the left boundary.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="left")]
		public float Left { get; set; }
		
		/// <summary>
		/// Id of the tag associated with this region.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tagId")]
		public string TagId { get; set; }
		
		/// <summary>
		/// Coordinate of the top boundary.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="top")]
		public float Top { get; set; }
		
		/// <summary>
		/// Width.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="width")]
		public float Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageRegionCreateResult
	{
		
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// Height.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="height")]
		public float Height { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="imageId")]
		public string ImageId { get; set; }
		
		/// <summary>
		/// Coordinate of the left boundary.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="left")]
		public float Left { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regionId")]
		public string RegionId { get; set; }
		
		/// <summary>
		/// Id of the tag associated with this region.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tagId")]
		public string TagId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tagName")]
		public string TagName { get; set; }
		
		/// <summary>
		/// Coordinate of the top boundary.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="top")]
		public float Top { get; set; }
		
		/// <summary>
		/// Width.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="width")]
		public float Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageRegionCreateSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="created")]
		public ImageRegionCreateResult[] Created { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="duplicated")]
		public ImageRegionCreateEntry[] Duplicated { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="exceeded")]
		public ImageRegionCreateEntry[] Exceeded { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageRegionProposal
	{
		
		[System.Runtime.Serialization.DataMember(Name="imageId")]
		public string ImageId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="projectId")]
		public string ProjectId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="proposals")]
		public RegionProposal[] Proposals { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RegionProposal
	{
		
		/// <summary>
		/// Bounding box that defines a region of an image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="boundingBox")]
		public BoundingBox BoundingBox { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="confidence")]
		public System.Nullable<System.Single> Confidence { get; set; }
	}
	
	/// <summary>
	/// Batch of image tags.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageTagCreateBatch
	{
		
		/// <summary>
		/// Image Tag entries to include in this batch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public ImageTagCreateEntry[] Tags { get; set; }
	}
	
	/// <summary>
	/// Entry associating a tag to an image.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageTagCreateEntry
	{
		
		/// <summary>
		/// Id of the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageId")]
		public string ImageId { get; set; }
		
		/// <summary>
		/// Id of the tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tagId")]
		public string TagId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageTagCreateSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="created")]
		public ImageTagCreateEntry[] Created { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="duplicated")]
		public ImageTagCreateEntry[] Duplicated { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="exceeded")]
		public ImageTagCreateEntry[] Exceeded { get; set; }
	}
	
	/// <summary>
	/// Image url.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageUrl
	{
		
		/// <summary>
		/// Url of the image.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageUrlCreateBatch
	{
		
		[System.Runtime.Serialization.DataMember(Name="images")]
		public ImageUrlCreateEntry[] Images { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tagIds")]
		public string[] TagIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageUrlCreateEntry
	{
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public Region[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tagIds")]
		public string[] TagIds { get; set; }
		
		/// <summary>
		/// Url of the image.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Iteration model to be sent over JSON.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Iteration
	{
		
		/// <summary>
		/// Gets the classification type of the project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="classificationType")]
		public System.Nullable<IterationClassificationType> ClassificationType { get; set; }
		
		/// <summary>
		/// Gets the time this iteration was completed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// Get or sets a guid of the domain the iteration has been trained on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domainId")]
		public string DomainId { get; set; }
		
		/// <summary>
		/// Whether the iteration can be exported to another format for download.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exportable")]
		public System.Nullable<System.Boolean> Exportable { get; set; }
		
		/// <summary>
		/// A set of platforms this iteration can export to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exportableTo")]
		public ExportPlatform[] ExportableTo { get; set; }
		
		/// <summary>
		/// Gets the id of the iteration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets the time this iteration was last modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastModified")]
		public System.Nullable<System.DateTimeOffset> LastModified { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the iteration.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Resource Provider Id this iteration was originally published to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="originalPublishResourceId")]
		public string OriginalPublishResourceId { get; set; }
		
		/// <summary>
		/// Gets the project id of the iteration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="projectId")]
		public string ProjectId { get; set; }
		
		/// <summary>
		/// Name of the published model.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publishName")]
		public string PublishName { get; set; }
		
		/// <summary>
		/// Gets the reserved advanced training budget for the iteration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservedBudgetInHours")]
		public System.Nullable<System.Int32> ReservedBudgetInHours { get; set; }
		
		/// <summary>
		/// Gets the current iteration status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// Gets the time this iteration was last modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trainedAt")]
		public System.Nullable<System.DateTimeOffset> TrainedAt { get; set; }
		
		/// <summary>
		/// Gets the training time for the iteration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trainingTimeInMinutes")]
		public System.Nullable<System.Int32> TrainingTimeInMinutes { get; set; }
		
		/// <summary>
		/// Gets the training type of the iteration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trainingType")]
		public System.Nullable<IterationTrainingType> TrainingType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum IterationClassificationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Multiclass = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Multilabel = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum IterationTrainingType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Regular = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Advanced = 1,
	}
	
	/// <summary>
	/// Represents the detailed performance data for a trained iteration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class IterationPerformance
	{
		
		/// <summary>
		/// Gets the average precision when applicable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="averagePrecision")]
		public System.Nullable<System.Single> AveragePrecision { get; set; }
		
		/// <summary>
		/// Gets the per-tag performance details for this iteration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perTagPerformance")]
		public TagPerformance[] PerTagPerformance { get; set; }
		
		/// <summary>
		/// Gets the precision.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="precision")]
		public System.Nullable<System.Single> Precision { get; set; }
		
		/// <summary>
		/// Gets the standard deviation for the precision.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="precisionStdDeviation")]
		public System.Nullable<System.Single> PrecisionStdDeviation { get; set; }
		
		/// <summary>
		/// Gets the recall.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recall")]
		public System.Nullable<System.Single> Recall { get; set; }
		
		/// <summary>
		/// Gets the standard deviation for the recall.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recallStdDeviation")]
		public System.Nullable<System.Single> RecallStdDeviation { get; set; }
	}
	
	/// <summary>
	/// Represents performance data for a particular tag in a trained iteration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class TagPerformance
	{
		
		/// <summary>
		/// Gets the average precision when applicable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="averagePrecision")]
		public System.Nullable<System.Single> AveragePrecision { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets the precision.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="precision")]
		public System.Nullable<System.Single> Precision { get; set; }
		
		/// <summary>
		/// Gets the standard deviation for the precision.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="precisionStdDeviation")]
		public System.Nullable<System.Single> PrecisionStdDeviation { get; set; }
		
		/// <summary>
		/// Gets the recall.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recall")]
		public System.Nullable<System.Single> Recall { get; set; }
		
		/// <summary>
		/// Gets the standard deviation for the recall.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recallStdDeviation")]
		public System.Nullable<System.Single> RecallStdDeviation { get; set; }
	}
	
	/// <summary>
	/// Query result of the prediction images that were sent to your prediction endpoint.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class PredictionQueryResult
	{
		
		/// <summary>
		/// Result of an prediction request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public StoredImagePrediction[] Results { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="token")]
		public PredictionQueryToken Token { get; set; }
	}
	
	/// <summary>
	/// Result of an image prediction request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class StoredImagePrediction
	{
		
		/// <summary>
		/// Date this prediction was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// Domain used for the prediction.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// Prediction Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Iteration Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iteration")]
		public string Iteration { get; set; }
		
		/// <summary>
		/// The URI to the original prediction image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="originalImageUri")]
		public string OriginalImageUri { get; set; }
		
		/// <summary>
		/// List of predictions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="predictions")]
		public Prediction[] Predictions { get; set; }
		
		/// <summary>
		/// Project Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="project")]
		public string Project { get; set; }
		
		/// <summary>
		/// The URI to the (resized) prediction image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resizedImageUri")]
		public string ResizedImageUri { get; set; }
		
		/// <summary>
		/// The URI to the thumbnail of the original prediction image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thumbnailUri")]
		public string ThumbnailUri { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class PredictionQueryToken
	{
		
		[System.Runtime.Serialization.DataMember(Name="application")]
		public string Application { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="continuation")]
		public string Continuation { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.Nullable<System.DateTimeOffset> EndTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="iterationId")]
		public string IterationId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxCount")]
		public System.Nullable<System.Int32> MaxCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="orderBy")]
		public System.Nullable<PredictionQueryTokenOrderBy> OrderBy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="session")]
		public string Session { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.Nullable<System.DateTimeOffset> StartTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public PredictionQueryTag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum PredictionQueryTokenOrderBy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Newest = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Oldest = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Suggested = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class PredictionQueryTag
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxThreshold")]
		public System.Nullable<System.Single> MaxThreshold { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="minThreshold")]
		public System.Nullable<System.Single> MinThreshold { get; set; }
	}
	
	/// <summary>
	/// Represents a project.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Project
	{
		
		/// <summary>
		/// Gets the date this project was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// Gets or sets the description of the project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Gets if the Disaster Recovery (DR) mode is on, indicating the project is temporarily read-only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="drModeEnabled")]
		public System.Nullable<System.Boolean> DrModeEnabled { get; set; }
		
		/// <summary>
		/// Gets the project id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets the date this project was last modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastModified")]
		public System.Nullable<System.DateTimeOffset> LastModified { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Represents settings associated with a project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public ProjectSettings Settings { get; set; }
		
		/// <summary>
		/// Gets the status of the project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<ProjectStatus> Status { get; set; }
		
		/// <summary>
		/// Gets the thumbnail url representing the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thumbnailUri")]
		public string ThumbnailUri { get; set; }
	}
	
	/// <summary>
	/// Represents settings associated with a project.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ProjectSettings
	{
		
		/// <summary>
		/// Gets or sets the classification type of the project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="classificationType")]
		public IterationClassificationType ClassificationType { get; set; }
		
		/// <summary>
		/// Detection parameters in use, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="detectionParameters")]
		public string DetectionParameters { get; set; }
		
		/// <summary>
		/// Gets or sets the id of the Domain to use with this project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domainId")]
		public string DomainId { get; set; }
		
		/// <summary>
		/// Represents image preprocessing settings used by image augmentation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageProcessingSettings")]
		public ImageProcessingSettings ImageProcessingSettings { get; set; }
		
		/// <summary>
		/// A list of ExportPlatform that the trained model should be able to support.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetExportPlatforms")]
		public ExportPlatform[] TargetExportPlatforms { get; set; }
		
		/// <summary>
		/// Indicates if negative set is being used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useNegativeSet")]
		public System.Nullable<System.Boolean> UseNegativeSet { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ProjectStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Succeeded = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Importing = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 2,
	}
	
	/// <summary>
	/// Represents information about a project export.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ProjectExport
	{
		
		/// <summary>
		/// Estimated time this project will take to import, can change based on network connectivity and load between
		///source and destination regions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="estimatedImportTimeInMS")]
		public System.Nullable<System.Int32> EstimatedImportTimeInMS { get; set; }
		
		/// <summary>
		/// Count of images that will be exported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageCount")]
		public System.Nullable<System.Int32> ImageCount { get; set; }
		
		/// <summary>
		/// Count of iterations that will be exported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iterationCount")]
		public System.Nullable<System.Int32> IterationCount { get; set; }
		
		/// <summary>
		/// Count of regions that will be exported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="regionCount")]
		public System.Nullable<System.Int32> RegionCount { get; set; }
		
		/// <summary>
		/// Count of tags that will be exported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tagCount")]
		public System.Nullable<System.Int32> TagCount { get; set; }
		
		/// <summary>
		/// Opaque token that should be passed to ImportProject to perform the import. This token grants access to import this
		///project to all that have the token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
	}
	
	/// <summary>
	/// Result of a suggested tags and regions request of the untagged image.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class StoredSuggestedTagAndRegion
	{
		
		/// <summary>
		/// Date this prediction was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// Domain used for the prediction.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// Height of the resized image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="height")]
		public System.Nullable<System.Int32> Height { get; set; }
		
		/// <summary>
		/// Prediction Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Iteration Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iteration")]
		public string Iteration { get; set; }
		
		/// <summary>
		/// The URI to the original prediction image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="originalImageUri")]
		public string OriginalImageUri { get; set; }
		
		/// <summary>
		/// Uncertainty (entropy) of suggested tags or regions per image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="predictionUncertainty")]
		public System.Nullable<System.Double> PredictionUncertainty { get; set; }
		
		/// <summary>
		/// List of predictions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="predictions")]
		public Prediction[] Predictions { get; set; }
		
		/// <summary>
		/// Project Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="project")]
		public string Project { get; set; }
		
		/// <summary>
		/// The URI to the (resized) prediction image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resizedImageUri")]
		public string ResizedImageUri { get; set; }
		
		/// <summary>
		/// The URI to the thumbnail of the original prediction image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thumbnailUri")]
		public string ThumbnailUri { get; set; }
		
		/// <summary>
		/// Width of the resized image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="width")]
		public System.Nullable<System.Int32> Width { get; set; }
	}
	
	/// <summary>
	/// Result of a suggested tags and regions request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class SuggestedTagAndRegion
	{
		
		/// <summary>
		/// Date this prediction was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// Prediction Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Iteration Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iteration")]
		public string Iteration { get; set; }
		
		/// <summary>
		/// Uncertainty (entropy) of suggested tags or regions per image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="predictionUncertainty")]
		public System.Nullable<System.Double> PredictionUncertainty { get; set; }
		
		/// <summary>
		/// List of predictions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="predictions")]
		public Prediction[] Predictions { get; set; }
		
		/// <summary>
		/// Project Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="project")]
		public string Project { get; set; }
	}
	
	/// <summary>
	/// The array of result images and token containing session and continuation Ids for the next query.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class SuggestedTagAndRegionQuery
	{
		
		/// <summary>
		/// Result of a suggested tags and regions request of the untagged image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public StoredSuggestedTagAndRegion[] Results { get; set; }
		
		/// <summary>
		/// Contains properties we need to fetch suggested tags for. For the first call, Session and continuation set to null.
		///Then on subsequent calls, uses the session/continuation from the previous SuggestedTagAndRegionQuery result to fetch additional results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="token")]
		public SuggestedTagAndRegionQueryToken Token { get; set; }
	}
	
	/// <summary>
	/// Contains properties we need to fetch suggested tags for. For the first call, Session and continuation set to null.
	///Then on subsequent calls, uses the session/continuation from the previous SuggestedTagAndRegionQuery result to fetch additional results.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class SuggestedTagAndRegionQueryToken
	{
		
		/// <summary>
		/// Continuation Id for database pagination. Initially null but later used to paginate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="continuation")]
		public string Continuation { get; set; }
		
		/// <summary>
		/// Maximum number of results you want to be returned in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxCount")]
		public System.Nullable<System.Int32> MaxCount { get; set; }
		
		/// <summary>
		/// SessionId for database query. Initially set to null but later used to paginate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="session")]
		public string Session { get; set; }
		
		/// <summary>
		/// OrderBy. Ordering mechanism for your results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sortBy")]
		public System.Nullable<SuggestedTagAndRegionQueryTokenSortBy> SortBy { get; set; }
		
		/// <summary>
		/// Existing TagIds in project to filter suggested tags on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tagIds")]
		public string[] TagIds { get; set; }
		
		/// <summary>
		/// Confidence threshold to filter suggested tags on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threshold")]
		public System.Nullable<System.Double> Threshold { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum SuggestedTagAndRegionQueryTokenSortBy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UncertaintyAscending = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UncertaintyDescending = 1,
	}
	
	/// <summary>
	/// Represents a Tag.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Tag
	{
		
		/// <summary>
		/// Gets or sets the description of the tag.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Gets the Tag ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Gets the number of images with this tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageCount")]
		public System.Nullable<System.Int32> ImageCount { get; set; }
		
		/// <summary>
		/// Gets or sets the name of the tag.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Gets or sets the type of the tag.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public TagType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum TagType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Regular = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Negative = 1,
	}
	
	/// <summary>
	/// Model that query for counting of images whose suggested tags match given tags and their probability are greater than or equal to the given threshold.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class TagFilter
	{
		
		/// <summary>
		/// Existing TagIds in project to get suggested tags count for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tagIds")]
		public string[] TagIds { get; set; }
		
		/// <summary>
		/// Confidence threshold to filter suggested tags on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threshold")]
		public System.Nullable<System.Double> Threshold { get; set; }
	}
	
	/// <summary>
	/// Parameters used for training.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class TrainingParameters
	{
		
		/// <summary>
		/// List of tags selected for this training session, other tags in the project will be ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selectedTags")]
		public string[] SelectedTags { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Get a list of the available domains.
		/// GetDomains domains
		/// </summary>
		/// <returns>OK</returns>
		public async Task<Domain[]> GetDomainsAsync()
		{
			var requestUri = "domains";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Domain[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get information about a specific domain.
		/// GetDomain domains/{domainId}
		/// </summary>
		/// <param name="domainId">The id of the domain to get information about.</param>
		/// <returns>OK</returns>
		public async Task<Domain> GetDomainAsync(string domainId)
		{
			var requestUri = "domains/"+ (domainId==null? "" : System.Uri.EscapeDataString(domainId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Domain>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get your projects.
		/// GetProjects projects
		/// </summary>
		/// <returns>OK</returns>
		public async Task<Project[]> GetProjectsAsync()
		{
			var requestUri = "projects";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Project[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a project.
		/// CreateProject projects
		/// </summary>
		/// <param name="name">Name of the project.</param>
		/// <param name="description">The description of the project.</param>
		/// <param name="domainId">The id of the domain to use for this project. Defaults to General.</param>
		/// <param name="classificationType">The type of classifier to create for this project.</param>
		/// <param name="targetExportPlatforms">List of platforms the trained model is intending exporting to.</param>
		/// <returns>OK</returns>
		public async Task<Project> CreateProjectAsync(string name, string description, string domainId, IterationClassificationType classificationType, ExportPlatform[] targetExportPlatforms)
		{
			var requestUri = "projects?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&description=" + (description==null? "" : System.Uri.EscapeDataString(description))+"&domainId=" + (domainId==null? "" : System.Uri.EscapeDataString(domainId))+"&classificationType=" + classificationType+"&"+string.Join("&", targetExportPlatforms.Select(z => $"targetExportPlatforms={z}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Project>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Imports a project.
		/// ImportProject projects/import
		/// </summary>
		/// <param name="token">Token generated from the export project call.</param>
		/// <returns>OK</returns>
		public async Task<Project> ImportProjectAsync(string token)
		{
			var requestUri = "projects/import?token=" + (token==null? "" : System.Uri.EscapeDataString(token));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Project>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a specific project.
		/// GetProject projects/{projectId}
		/// </summary>
		/// <param name="projectId">The id of the project to get.</param>
		/// <returns>OK</returns>
		public async Task<Project> GetProjectAsync(string projectId)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Project>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a specific project.
		/// DeleteProject projects/{projectId}
		/// </summary>
		/// <param name="projectId">The project id.</param>
		public async Task DeleteProjectAsync(string projectId)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a specific project.
		/// UpdateProject projects/{projectId}
		/// </summary>
		/// <param name="projectId">The id of the project to update.</param>
		/// <param name="requestBody">The updated project model.</param>
		/// <returns>OK</returns>
		public async Task<Project> UpdateProjectAsync(string projectId, Project requestBody)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Project>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Exports a project.
		/// ExportProject projects/{projectId}/export
		/// </summary>
		/// <param name="projectId">The project id of the project to export.</param>
		/// <returns>OK</returns>
		public async Task<ProjectExport> ExportProjectAsync(string projectId)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/export";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ProjectExport>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete images from the set of training images.
		/// DeleteImages projects/{projectId}/images
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="imageIds">Ids of the images to be deleted. Limited to 256 images per batch.</param>
		/// <param name="allImages">Flag to specify delete all images, specify this flag or a list of images. Using this flag will return a 202 response to indicate the images are being deleted.</param>
		/// <param name="allIterations">Removes these images from all iterations, not just the current workspace. Using this flag will return a 202 response to indicate the images are being deleted.</param>
		public async Task DeleteImagesAsync(string projectId, string[] imageIds, bool allImages, bool allIterations)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/images&"+string.Join("&", imageIds.Select(z => $"imageIds={System.Uri.EscapeDataString(z.ToString())}"))+"&allImages="+allImages+"&allIterations="+allIterations;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add the provided batch of images to the set of training images.
		/// This API accepts a batch of files, and optionally tags, to create images. There is a limit of 64 images and 20 tags.
		/// CreateImagesFromFiles projects/{projectId}/images/files
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="requestBody">The batch of image files to add. Limited to 64 images and 20 tags per batch.</param>
		/// <returns>OK</returns>
		public async Task<ImageCreateSummary> CreateImagesFromFilesAsync(string projectId, ImageFileCreateBatch requestBody)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/images/files";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ImageCreateSummary>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get images by id for a given project iteration.
		/// This API will return a set of Images for the specified tags and optionally iteration. If no iteration is specified the
		/// current workspace is used.
		/// GetImagesByIds projects/{projectId}/images/id
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="imageIds">The list of image ids to retrieve. Limited to 256.</param>
		/// <param name="iterationId">The iteration id. Defaults to workspace.</param>
		/// <returns>OK</returns>
		public async Task<Image[]> GetImagesByIdsAsync(string projectId, string[] imageIds, string iterationId)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/images/id&"+string.Join("&", imageIds.Select(z => $"imageIds={System.Uri.EscapeDataString(z.ToString())}"))+"&iterationId=" + (iterationId==null? "" : System.Uri.EscapeDataString(iterationId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Image[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add the specified predicted images to the set of training images.
		/// This API creates a batch of images from predicted images specified. There is a limit of 64 images and 20 tags.
		/// CreateImagesFromPredictions projects/{projectId}/images/predictions
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="requestBody">Image and tag ids. Limited to 64 images and 20 tags per batch.</param>
		/// <returns>OK</returns>
		public async Task<ImageCreateSummary> CreateImagesFromPredictionsAsync(string projectId, ImageIdCreateBatch requestBody)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/images/predictions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ImageCreateSummary>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a set of image regions.
		/// This API accepts a batch of image regions, and optionally tags, to update existing images with region information.
		/// There is a limit of 64 entries in the batch.
		/// CreateImageRegions projects/{projectId}/images/regions
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="requestBody">Batch of image regions which include a tag and bounding box. Limited to 64.</param>
		/// <returns>OK</returns>
		public async Task<ImageRegionCreateSummary> CreateImageRegionsAsync(string projectId, ImageRegionCreateBatch requestBody)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/images/regions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ImageRegionCreateSummary>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a set of image regions.
		/// DeleteImageRegions projects/{projectId}/images/regions
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="regionIds">Regions to delete. Limited to 64.</param>
		public async Task DeleteImageRegionsAsync(string projectId, string[] regionIds)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/images/regions&"+string.Join("&", regionIds.Select(z => $"regionIds={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get untagged images whose suggested tags match given tags. Returns empty array if no images are found.
		/// This API will fetch untagged images filtered by suggested tags Ids. It returns an empty array if no images are found.
		/// QuerySuggestedImages projects/{projectId}/images/suggested
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="iterationId">IterationId to use for the suggested tags and regions.</param>
		/// <param name="requestBody">Contains properties we need to query suggested images.</param>
		/// <returns>OK</returns>
		public async Task<SuggestedTagAndRegionQuery> QuerySuggestedImagesAsync(string projectId, string iterationId, SuggestedTagAndRegionQueryToken requestBody)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/images/suggested&iterationId=" + (iterationId==null? "" : System.Uri.EscapeDataString(iterationId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SuggestedTagAndRegionQuery>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get count of images whose suggested tags match given tags and their probabilities are greater than or equal to the given threshold. Returns count as 0 if none found.
		/// This API takes in tagIds to get count of untagged images per suggested tags for a given threshold.
		/// QuerySuggestedImageCount projects/{projectId}/images/suggested/count
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="iterationId">IterationId to use for the suggested tags and regions.</param>
		/// <param name="requestBody">Model that contains tagIds, threshold and projectType to query by.</param>
		/// <returns>OK</returns>
		public async Task<System.Collections.Generic.Dictionary<string, int>> QuerySuggestedImageCountAsync(string projectId, string iterationId, TagFilter requestBody)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/images/suggested/count&iterationId=" + (iterationId==null? "" : System.Uri.EscapeDataString(iterationId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<System.Collections.Generic.Dictionary<string, int>>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get tagged images for a given project iteration.
		/// This API supports batching and range selection. By default it will only return first 50 images matching images.
		/// Use the {take} and {skip} parameters to control how many images to return in a given batch.
		/// The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
		/// "Cat" tags, then only images tagged with Dog and/or Cat will be returned
		/// GetTaggedImages projects/{projectId}/images/tagged
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="iterationId">The iteration id. Defaults to workspace.</param>
		/// <param name="tagIds">A list of tags ids to filter the images. Defaults to all tagged images when null. Limited to 20.</param>
		/// <param name="orderBy">The ordering. Defaults to newest.</param>
		/// <param name="take">Maximum number of images to return. Defaults to 50, limited to 256.
		/// Minimum: 0
		/// Maximum: 256
		// </param>
		/// <param name="skip">Number of images to skip before beginning the image batch. Defaults to 0.</param>
		/// <returns>OK</returns>
		public async Task<Image[]> GetTaggedImagesAsync(string projectId, string iterationId, string[] tagIds, GetTaggedImagesOrderBy orderBy, int take, int skip)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/images/tagged&iterationId=" + (iterationId==null? "" : System.Uri.EscapeDataString(iterationId))+"&"+string.Join("&", tagIds.Select(z => $"tagIds={System.Uri.EscapeDataString(z.ToString())}"))+"&orderBy=" + orderBy+"&take="+take+"&skip="+skip;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Image[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the number of images tagged with the provided {tagIds}.
		/// The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
		/// "Cat" tags, then only images tagged with Dog and/or Cat will be returned
		/// GetTaggedImageCount projects/{projectId}/images/tagged/count
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="iterationId">The iteration id. Defaults to workspace.</param>
		/// <param name="tagIds">A list of tags ids to filter the images to count. Defaults to all tags when null.</param>
		/// <returns>OK</returns>
		public async Task<int> GetTaggedImageCountAsync(string projectId, string iterationId, string[] tagIds)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/images/tagged/count&iterationId=" + (iterationId==null? "" : System.Uri.EscapeDataString(iterationId))+"&"+string.Join("&", tagIds.Select(z => $"tagIds={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<int>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Associate a set of images with a set of tags.
		/// CreateImageTags projects/{projectId}/images/tags
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="requestBody">Batch of image tags. Limited to 128 tags per batch.</param>
		/// <returns>OK</returns>
		public async Task<ImageTagCreateSummary> CreateImageTagsAsync(string projectId, ImageTagCreateBatch requestBody)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/images/tags";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ImageTagCreateSummary>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove a set of tags from a set of images.
		/// DeleteImageTags projects/{projectId}/images/tags
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="imageIds">Image ids. Limited to 64 images.</param>
		/// <param name="tagIds">Tags to be deleted from the specified images. Limited to 20 tags.</param>
		public async Task DeleteImageTagsAsync(string projectId, string[] imageIds, string[] tagIds)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/images/tags&"+string.Join("&", imageIds.Select(z => $"imageIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", tagIds.Select(z => $"tagIds={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get untagged images for a given project iteration.
		/// This API supports batching and range selection. By default it will only return first 50 images matching images.
		/// Use the {take} and {skip} parameters to control how many images to return in a given batch.
		/// GetUntaggedImages projects/{projectId}/images/untagged
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="iterationId">The iteration id. Defaults to workspace.</param>
		/// <param name="orderBy">The ordering. Defaults to newest.</param>
		/// <param name="take">Maximum number of images to return. Defaults to 50, limited to 256.
		/// Minimum: 0
		/// Maximum: 256
		// </param>
		/// <param name="skip">Number of images to skip before beginning the image batch. Defaults to 0.</param>
		/// <returns>OK</returns>
		public async Task<Image[]> GetUntaggedImagesAsync(string projectId, string iterationId, GetTaggedImagesOrderBy orderBy, int take, int skip)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/images/untagged&iterationId=" + (iterationId==null? "" : System.Uri.EscapeDataString(iterationId))+"&orderBy=" + orderBy+"&take="+take+"&skip="+skip;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Image[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the number of untagged images.
		/// This API returns the images which have no tags for a given project and optionally an iteration. If no iteration is specified the
		/// current workspace is used.
		/// GetUntaggedImageCount projects/{projectId}/images/untagged/count
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="iterationId">The iteration id. Defaults to workspace.</param>
		/// <returns>OK</returns>
		public async Task<int> GetUntaggedImageCountAsync(string projectId, string iterationId)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/images/untagged/count&iterationId=" + (iterationId==null? "" : System.Uri.EscapeDataString(iterationId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<int>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add the provided images urls to the set of training images.
		/// This API accepts a batch of urls, and optionally tags, to create images. There is a limit of 64 images and 20 tags.
		/// CreateImagesFromUrls projects/{projectId}/images/urls
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="requestBody">Image urls and tag ids. Limited to 64 images and 20 tags per batch.</param>
		/// <returns>OK</returns>
		public async Task<ImageCreateSummary> CreateImagesFromUrlsAsync(string projectId, ImageUrlCreateBatch requestBody)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/images/urls";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ImageCreateSummary>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get region proposals for an image. Returns empty array if no proposals are found.
		/// This API will get region proposals for an image along with confidences for the region. It returns an empty array if no proposals are found.
		/// GetImageRegionProposals projects/{projectId}/images/{imageId}/regionproposals
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="imageId">The image id.</param>
		/// <returns>OK</returns>
		public async Task<ImageRegionProposal> GetImageRegionProposalsAsync(string projectId, string imageId)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/images/"+ (imageId==null? "" : System.Uri.EscapeDataString(imageId))+"/regionproposals";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ImageRegionProposal>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get iterations for the project.
		/// GetIterations projects/{projectId}/iterations
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <returns>OK</returns>
		public async Task<Iteration[]> GetIterationsAsync(string projectId)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/iterations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Iteration[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a specific iteration.
		/// GetIteration projects/{projectId}/iterations/{iterationId}
		/// </summary>
		/// <param name="projectId">The id of the project the iteration belongs to.</param>
		/// <param name="iterationId">The id of the iteration to get.</param>
		/// <returns>OK</returns>
		public async Task<Iteration> GetIterationAsync(string projectId, string iterationId)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/iterations/"+ (iterationId==null? "" : System.Uri.EscapeDataString(iterationId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Iteration>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a specific iteration of a project.
		/// DeleteIteration projects/{projectId}/iterations/{iterationId}
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="iterationId">The iteration id.</param>
		public async Task DeleteIterationAsync(string projectId, string iterationId)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/iterations/"+ (iterationId==null? "" : System.Uri.EscapeDataString(iterationId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a specific iteration.
		/// UpdateIteration projects/{projectId}/iterations/{iterationId}
		/// </summary>
		/// <param name="projectId">Project id.</param>
		/// <param name="iterationId">Iteration id.</param>
		/// <param name="requestBody">The updated iteration model.</param>
		/// <returns>OK</returns>
		public async Task<Iteration> UpdateIterationAsync(string projectId, string iterationId, Iteration requestBody)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/iterations/"+ (iterationId==null? "" : System.Uri.EscapeDataString(iterationId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Iteration>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the list of exports for a specific iteration.
		/// GetExports projects/{projectId}/iterations/{iterationId}/export
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="iterationId">The iteration id.</param>
		/// <returns>OK</returns>
		public async Task<Export[]> GetExportsAsync(string projectId, string iterationId)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/iterations/"+ (iterationId==null? "" : System.Uri.EscapeDataString(iterationId))+"/export";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Export[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Export a trained iteration.
		/// ExportIteration projects/{projectId}/iterations/{iterationId}/export
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="iterationId">The iteration id.</param>
		/// <param name="platform">The target platform.</param>
		/// <param name="flavor">The flavor of the target platform.</param>
		/// <returns>OK</returns>
		public async Task<Export> ExportIterationAsync(string projectId, string iterationId, ExportPlatform platform, ExportFlavor flavor)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/iterations/"+ (iterationId==null? "" : System.Uri.EscapeDataString(iterationId))+"/export&platform=" + platform+"&flavor=" + flavor;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Export>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get detailed performance information about an iteration.
		/// GetIterationPerformance projects/{projectId}/iterations/{iterationId}/performance
		/// </summary>
		/// <param name="projectId">The id of the project the iteration belongs to.</param>
		/// <param name="iterationId">The id of the iteration to get.</param>
		/// <param name="threshold">The threshold used to determine true predictions.</param>
		/// <param name="overlapThreshold">If applicable, the bounding box overlap threshold used to determine true predictions.</param>
		/// <returns>OK</returns>
		public async Task<IterationPerformance> GetIterationPerformanceAsync(string projectId, string iterationId, float threshold, float overlapThreshold)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/iterations/"+ (iterationId==null? "" : System.Uri.EscapeDataString(iterationId))+"/performance&threshold="+threshold+"&overlapThreshold="+overlapThreshold;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<IterationPerformance>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get image with its prediction for a given project iteration.
		/// This API supports batching and range selection. By default it will only return first 50 images matching images.
		/// Use the {take} and {skip} parameters to control how many images to return in a given batch.
		/// The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
		/// "Cat" tags, then only images tagged with Dog and/or Cat will be returned
		/// GetImagePerformances projects/{projectId}/iterations/{iterationId}/performance/images
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="iterationId">The iteration id. Defaults to workspace.</param>
		/// <param name="tagIds">A list of tags ids to filter the images. Defaults to all tagged images when null. Limited to 20.</param>
		/// <param name="orderBy">The ordering. Defaults to newest.</param>
		/// <param name="take">Maximum number of images to return. Defaults to 50, limited to 256.
		/// Minimum: 0
		/// Maximum: 256
		// </param>
		/// <param name="skip">Number of images to skip before beginning the image batch. Defaults to 0.</param>
		/// <returns>OK</returns>
		public async Task<ImagePerformance[]> GetImagePerformancesAsync(string projectId, string iterationId, string[] tagIds, GetTaggedImagesOrderBy orderBy, int take, int skip)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/iterations/"+ (iterationId==null? "" : System.Uri.EscapeDataString(iterationId))+"/performance/images&"+string.Join("&", tagIds.Select(z => $"tagIds={System.Uri.EscapeDataString(z.ToString())}"))+"&orderBy=" + orderBy+"&take="+take+"&skip="+skip;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ImagePerformance[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the number of images tagged with the provided {tagIds} that have prediction results from
		/// training for the provided iteration {iterationId}.
		/// The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
		/// "Cat" tags, then only images tagged with Dog and/or Cat will be returned
		/// GetImagePerformanceCount projects/{projectId}/iterations/{iterationId}/performance/images/count
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="iterationId">The iteration id. Defaults to workspace.</param>
		/// <param name="tagIds">A list of tags ids to filter the images to count. Defaults to all tags when null.</param>
		/// <returns>OK</returns>
		public async Task<int> GetImagePerformanceCountAsync(string projectId, string iterationId, string[] tagIds)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/iterations/"+ (iterationId==null? "" : System.Uri.EscapeDataString(iterationId))+"/performance/images/count&"+string.Join("&", tagIds.Select(z => $"tagIds={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<int>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Publish a specific iteration.
		/// PublishIteration projects/{projectId}/iterations/{iterationId}/publish
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="iterationId">The iteration id.</param>
		/// <param name="publishName">The name to give the published iteration.</param>
		/// <param name="predictionId">The id of the prediction resource to publish to.</param>
		/// <returns>OK</returns>
		public async Task<bool> PublishIterationAsync(string projectId, string iterationId, string publishName, string predictionId)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/iterations/"+ (iterationId==null? "" : System.Uri.EscapeDataString(iterationId))+"/publish&publishName=" + (publishName==null? "" : System.Uri.EscapeDataString(publishName))+"&predictionId=" + (predictionId==null? "" : System.Uri.EscapeDataString(predictionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<bool>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Unpublish a specific iteration.
		/// UnpublishIteration projects/{projectId}/iterations/{iterationId}/publish
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="iterationId">The iteration id.</param>
		public async Task UnpublishIterationAsync(string projectId, string iterationId)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/iterations/"+ (iterationId==null? "" : System.Uri.EscapeDataString(iterationId))+"/publish";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a set of predicted images and their associated prediction results.
		/// DeletePrediction projects/{projectId}/predictions
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="ids">The prediction ids. Limited to 64.</param>
		public async Task DeletePredictionAsync(string projectId, string[] ids)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/predictions&"+string.Join("&", ids.Select(z => $"ids={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get images that were sent to your prediction endpoint.
		/// QueryPredictions projects/{projectId}/predictions/query
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="requestBody">Parameters used to query the predictions. Limited to combining 2 tags.</param>
		/// <returns>OK</returns>
		public async Task<PredictionQueryResult> QueryPredictionsAsync(string projectId, PredictionQueryToken requestBody)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/predictions/query";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PredictionQueryResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Quick test an image url.
		/// QuickTestImageUrl projects/{projectId}/quicktest/url
		/// </summary>
		/// <param name="projectId">The project to evaluate against.</param>
		/// <param name="iterationId">Optional. Specifies the id of a particular iteration to evaluate against.
		///            The default iteration for the project will be used when not specified.</param>
		/// <param name="store">Optional. Specifies whether or not to store the result of this prediction. The default is true, to store.</param>
		/// <param name="requestBody">An ImageUrl that contains the url of the image to be evaluated.</param>
		/// <returns>OK</returns>
		public async Task<ImagePrediction> QuickTestImageUrlAsync(string projectId, string iterationId, bool store, ImageUrl requestBody)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/quicktest/url&iterationId=" + (iterationId==null? "" : System.Uri.EscapeDataString(iterationId))+"&store="+store;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ImagePrediction>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the tags for a given project and iteration.
		/// GetTags projects/{projectId}/tags
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="iterationId">The iteration id. Defaults to workspace.</param>
		/// <returns>OK</returns>
		public async Task<Tag[]> GetTagsAsync(string projectId, string iterationId)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/tags&iterationId=" + (iterationId==null? "" : System.Uri.EscapeDataString(iterationId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Tag[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a tag for the project.
		/// CreateTag projects/{projectId}/tags
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="name">The tag name.</param>
		/// <param name="description">Optional description for the tag.</param>
		/// <param name="type">Optional type for the tag.</param>
		/// <returns>OK</returns>
		public async Task<Tag> CreateTagAsync(string projectId, string name, string description, TagType type)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/tags&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&description=" + (description==null? "" : System.Uri.EscapeDataString(description))+"&type=" + type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Tag>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get information about a specific tag.
		/// GetTag projects/{projectId}/tags/{tagId}
		/// </summary>
		/// <param name="projectId">The project this tag belongs to.</param>
		/// <param name="tagId">The tag id.</param>
		/// <param name="iterationId">The iteration to retrieve this tag from. Optional, defaults to current training set.</param>
		/// <returns>OK</returns>
		public async Task<Tag> GetTagAsync(string projectId, string tagId, string iterationId)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/tags/"+ (tagId==null? "" : System.Uri.EscapeDataString(tagId))+"&iterationId=" + (iterationId==null? "" : System.Uri.EscapeDataString(iterationId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Tag>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a tag from the project.
		/// DeleteTag projects/{projectId}/tags/{tagId}
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="tagId">Id of the tag to be deleted.</param>
		public async Task DeleteTagAsync(string projectId, string tagId)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/tags/"+ (tagId==null? "" : System.Uri.EscapeDataString(tagId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a tag.
		/// UpdateTag projects/{projectId}/tags/{tagId}
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="tagId">The id of the target tag.</param>
		/// <param name="requestBody">The updated tag model.</param>
		/// <returns>OK</returns>
		public async Task<Tag> UpdateTagAsync(string projectId, string tagId, Tag requestBody)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/tags/"+ (tagId==null? "" : System.Uri.EscapeDataString(tagId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Tag>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Suggest tags and regions for an array/batch of untagged images. Returns empty array if no tags are found.
		/// This API will get suggested tags and regions for an array/batch of untagged images along with confidences for the tags. It returns an empty array if no tags are found.
		/// There is a limit of 64 images in the batch.
		/// SuggestTagsAndRegions projects/{projectId}/tagsandregions/suggestions
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="iterationId">IterationId to use for tag and region suggestion.</param>
		/// <param name="imageIds">Array of image ids tag suggestion are needed for. Use GetUntaggedImages API to get imageIds.</param>
		/// <returns>OK</returns>
		public async Task<SuggestedTagAndRegion[]> SuggestTagsAndRegionsAsync(string projectId, string iterationId, string[] imageIds)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/tagsandregions/suggestions&iterationId=" + (iterationId==null? "" : System.Uri.EscapeDataString(iterationId))+"&"+string.Join("&", imageIds.Select(z => $"imageIds={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SuggestedTagAndRegion[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Queues project for training.
		/// TrainProject projects/{projectId}/train
		/// </summary>
		/// <param name="projectId">The project id.</param>
		/// <param name="trainingType">The type of training to use to train the project (default: Regular).</param>
		/// <param name="reservedBudgetInHours">The number of hours reserved as budget for training (if applicable).</param>
		/// <param name="forceTrain">Whether to force train even if dataset and configuration does not change (default: false).</param>
		/// <param name="notificationEmailAddress">The email address to send notification to when training finishes (default: null).</param>
		/// <param name="requestBody">Additional training parameters passed in to control how the project is trained.</param>
		/// <returns>OK</returns>
		public async Task<Iteration> TrainProjectAsync(string projectId, IterationTrainingType trainingType, int reservedBudgetInHours, bool forceTrain, string notificationEmailAddress, TrainingParameters requestBody)
		{
			var requestUri = "projects/"+ (projectId==null? "" : System.Uri.EscapeDataString(projectId))+"/train&trainingType=" + trainingType+"&reservedBudgetInHours="+reservedBudgetInHours+"&forceTrain="+forceTrain+"&notificationEmailAddress=" + (notificationEmailAddress==null? "" : System.Uri.EscapeDataString(notificationEmailAddress));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Iteration>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum GetTaggedImagesOrderBy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Newest = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Oldest = 1,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
