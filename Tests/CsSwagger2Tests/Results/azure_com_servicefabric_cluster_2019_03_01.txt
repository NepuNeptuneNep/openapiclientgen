//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Available cluster add-on features
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum AddOnFeatures
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RepairManager = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DnsService = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BackupRestoreService = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ResourceMonitorService = 3,
	}
	
	/// <summary>
	/// Defines a delta health policy used to evaluate the health of an application or one of its child entities when upgrading the cluster.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplicationDeltaHealthPolicy
	{
		
		/// <summary>
		/// Represents the delta health policy used to evaluate the health of services belonging to a service type when upgrading the cluster.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultServiceTypeDeltaHealthPolicy")]
		public ServiceTypeDeltaHealthPolicy DefaultServiceTypeDeltaHealthPolicy { get; set; }
		
		/// <summary>
		/// Defines a map that contains specific delta health policies for different service types.
		///Each entry specifies as key the service type name and as value a ServiceTypeDeltaHealthPolicy used to evaluate the service health when upgrading the cluster.
		///The map is empty by default.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceTypeDeltaHealthPolicies")]
		public ServiceTypeDeltaHealthPolicyMap ServiceTypeDeltaHealthPolicies { get; set; }
	}
	
	/// <summary>
	/// Represents the delta health policy used to evaluate the health of services belonging to a service type when upgrading the cluster.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ServiceTypeDeltaHealthPolicy
	{
		
		/// <summary>
		/// The maximum allowed percentage of services health degradation allowed during cluster upgrades.
		///The delta is measured between the state of the services at the beginning of upgrade and the state of the services at the time of the health evaluation.
		///The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits.
		///
		/// Minimum: 0
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPercentDeltaUnhealthyServices")]
		[System.ComponentModel.DataAnnotations.Range(0, 100)]
		public System.Nullable<System.Int32> MaxPercentDeltaUnhealthyServices { get; set; }
	}
	
	/// <summary>
	/// Defines a map that contains specific delta health policies for different service types.
	///Each entry specifies as key the service type name and as value a ServiceTypeDeltaHealthPolicy used to evaluate the service health when upgrading the cluster.
	///The map is empty by default.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ServiceTypeDeltaHealthPolicyMap
	{
	}
	
	/// <summary>
	/// Defines a map that contains specific application delta health policies for different applications.
	///Each entry specifies as key the application name and as value an ApplicationDeltaHealthPolicy used to evaluate the application health when upgrading the cluster.
	///The application name should include the 'fabric:' URI scheme.
	///The map is empty by default.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplicationDeltaHealthPolicyMap
	{
	}
	
	/// <summary>
	/// Defines a health policy used to evaluate the health of an application or one of its children entities.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplicationHealthPolicy
	{
		
		/// <summary>
		/// Represents the health policy used to evaluate the health of services belonging to a service type.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultServiceTypeHealthPolicy")]
		public ServiceTypeHealthPolicy DefaultServiceTypeHealthPolicy { get; set; }
		
		/// <summary>
		/// Defines a ServiceTypeHealthPolicy per service type name.
		///
		///The entries in the map replace the default service type health policy for each specified service type.
		///For example, in an application that contains both a stateless gateway service type and a stateful engine service type, the health policies for the stateless and stateful services can be configured differently.
		///With policy per service type, there's more granular control of the health of the service.
		///
		///If no policy is specified for a service type name, the DefaultServiceTypeHealthPolicy is used for evaluation.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceTypeHealthPolicies")]
		public ServiceTypeHealthPolicyMap ServiceTypeHealthPolicies { get; set; }
	}
	
	/// <summary>
	/// Represents the health policy used to evaluate the health of services belonging to a service type.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ServiceTypeHealthPolicy
	{
		
		/// <summary>
		/// The maximum percentage of services allowed to be unhealthy before your application is considered in error.
		///
		/// Minimum: 0
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPercentUnhealthyServices")]
		[System.ComponentModel.DataAnnotations.Range(0, 100)]
		public System.Nullable<System.Int32> MaxPercentUnhealthyServices { get; set; }
	}
	
	/// <summary>
	/// Defines a ServiceTypeHealthPolicy per service type name.
	///
	///The entries in the map replace the default service type health policy for each specified service type.
	///For example, in an application that contains both a stateless gateway service type and a stateful engine service type, the health policies for the stateless and stateful services can be configured differently.
	///With policy per service type, there's more granular control of the health of the service.
	///
	///If no policy is specified for a service type name, the DefaultServiceTypeHealthPolicy is used for evaluation.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ServiceTypeHealthPolicyMap
	{
	}
	
	/// <summary>
	/// Defines a map that contains specific application health policies for different applications.
	///Each entry specifies as key the application name and as value an ApplicationHealthPolicy used to evaluate the application health.
	///The application name should include the 'fabric:' URI scheme.
	///The map is empty by default.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplicationHealthPolicyMap
	{
	}
	
	/// <summary>
	/// Operation supported by the Service Fabric resource provider
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class AvailableOperationDisplay
	{
		
		/// <summary>
		/// Operation description
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The operation that can be performed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operation")]
		public string Operation { get; set; }
		
		/// <summary>
		/// The name of the provider.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provider")]
		public string Provider { get; set; }
		
		/// <summary>
		/// The resource on which the operation is performed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
	}
	
	/// <summary>
	/// The settings to enable AAD authentication on the cluster.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class AzureActiveDirectory
	{
		
		/// <summary>
		/// Azure active directory client application id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientApplication")]
		public string ClientApplication { get; set; }
		
		/// <summary>
		/// Azure active directory cluster application id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clusterApplication")]
		public string ClusterApplication { get; set; }
		
		/// <summary>
		/// Azure active directory tenant id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tenantId")]
		public string TenantId { get; set; }
	}
	
	/// <summary>
	/// Describes the certificate details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class CertificateDescription
	{
		
		/// <summary>
		/// Thumbprint of the primary certificate.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="thumbprint")]
		public string Thumbprint { get; set; }
		
		/// <summary>
		/// Thumbprint of the secondary certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thumbprintSecondary")]
		public string ThumbprintSecondary { get; set; }
		
		/// <summary>
		/// The local certificate store location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="x509StoreName")]
		public System.Nullable<CertificateDescriptionX509StoreName> X509StoreName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum CertificateDescriptionX509StoreName
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AddressBook = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AuthRoot = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CertificateAuthority = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disallowed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		My = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Root = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TrustedPeople = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TrustedPublisher = 7,
	}
	
	/// <summary>
	/// Describes the client certificate details using common name.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ClientCertificateCommonName
	{
		
		/// <summary>
		/// The common name of the client certificate.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateCommonName")]
		public string CertificateCommonName { get; set; }
		
		/// <summary>
		/// The issuer thumbprint of the client certificate.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateIssuerThumbprint")]
		public string CertificateIssuerThumbprint { get; set; }
		
		/// <summary>
		/// Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isAdmin")]
		public bool IsAdmin { get; set; }
	}
	
	/// <summary>
	/// Describes the client certificate details using thumbprint.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ClientCertificateThumbprint
	{
		
		/// <summary>
		/// The thumbprint of the client certificate.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateThumbprint")]
		public string CertificateThumbprint { get; set; }
		
		/// <summary>
		/// Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isAdmin")]
		public bool IsAdmin { get; set; }
	}
	
	/// <summary>
	/// The cluster resource
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Cluster
	{
	}
	
	/// <summary>
	/// The list results of the Service Fabric runtime versions.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ClusterCodeVersionsListResult
	{
		
		/// <summary>
		/// The URL to use for getting the next set of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public ClusterCodeVersionsResult[] Value { get; set; }
	}
	
	/// <summary>
	/// The result of the Service Fabric runtime versions
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ClusterCodeVersionsResult
	{
		
		/// <summary>
		/// The identification of the result
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the result
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The detail of the Service Fabric runtime version result
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public ClusterVersionDetails Properties { get; set; }
		
		/// <summary>
		/// The result resource type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Cluster operating system, the default will be Windows
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ClusterEnvironment
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Windows = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Linux = 1,
	}
	
	/// <summary>
	/// Defines a health policy used to evaluate the health of the cluster or of a cluster node.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ClusterHealthPolicy
	{
		
		/// <summary>
		/// Defines a map that contains specific application health policies for different applications.
		///Each entry specifies as key the application name and as value an ApplicationHealthPolicy used to evaluate the application health.
		///The application name should include the 'fabric:' URI scheme.
		///The map is empty by default.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applicationHealthPolicies")]
		public ApplicationHealthPolicyMap ApplicationHealthPolicies { get; set; }
		
		/// <summary>
		/// The maximum allowed percentage of unhealthy applications before reporting an error. For example, to allow 10% of applications to be unhealthy, this value would be 10.
		///
		///The percentage represents the maximum tolerated percentage of applications that can be unhealthy before the cluster is considered in error.
		///If the percentage is respected but there is at least one unhealthy application, the health is evaluated as Warning.
		///This is calculated by dividing the number of unhealthy applications over the total number of application instances in the cluster, excluding applications of application types that are included in the ApplicationTypeHealthPolicyMap.
		///The computation rounds up to tolerate one failure on small numbers of applications. Default percentage is zero.
		///
		/// Minimum: 0
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPercentUnhealthyApplications")]
		[System.ComponentModel.DataAnnotations.Range(0, 100)]
		public System.Nullable<System.Int32> MaxPercentUnhealthyApplications { get; set; }
		
		/// <summary>
		/// The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to allow 10% of nodes to be unhealthy, this value would be 10.
		///
		///The percentage represents the maximum tolerated percentage of nodes that can be unhealthy before the cluster is considered in error.
		///If the percentage is respected but there is at least one unhealthy node, the health is evaluated as Warning.
		///The percentage is calculated by dividing the number of unhealthy nodes over the total number of nodes in the cluster.
		///The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
		///
		///In large clusters, some nodes will always be down or out for repairs, so this percentage should be configured to tolerate that.
		///
		/// Minimum: 0
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPercentUnhealthyNodes")]
		[System.ComponentModel.DataAnnotations.Range(0, 100)]
		public System.Nullable<System.Int32> MaxPercentUnhealthyNodes { get; set; }
	}
	
	/// <summary>
	/// Cluster list results
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ClusterListResult
	{
		
		/// <summary>
		/// The URL to use for getting the next set of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public Cluster[] Value { get; set; }
	}
	
	/// <summary>
	/// Describes the cluster resource properties.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ClusterProperties
	{
		
		/// <summary>
		/// The list of add-on features to enable in the cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addOnFeatures")]
		public AddOnFeatures[] AddOnFeatures { get; set; }
		
		/// <summary>
		/// The Service Fabric runtime versions available for this cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableClusterVersions")]
		public ClusterVersionDetails[] AvailableClusterVersions { get; set; }
		
		/// <summary>
		/// The settings to enable AAD authentication on the cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="azureActiveDirectory")]
		public AzureActiveDirectory AzureActiveDirectory { get; set; }
		
		/// <summary>
		/// Describes the certificate details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificate")]
		public CertificateDescription Certificate { get; set; }
		
		/// <summary>
		/// Describes a list of server certificates referenced by common name that are used to secure the cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateCommonNames")]
		public ServerCertificateCommonNames CertificateCommonNames { get; set; }
		
		/// <summary>
		/// The list of client certificates referenced by common name that are allowed to manage the cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientCertificateCommonNames")]
		public ClientCertificateCommonName[] ClientCertificateCommonNames { get; set; }
		
		/// <summary>
		/// The list of client certificates referenced by thumbprint that are allowed to manage the cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientCertificateThumbprints")]
		public ClientCertificateThumbprint[] ClientCertificateThumbprints { get; set; }
		
		/// <summary>
		/// The Service Fabric runtime version of the cluster. This property can only by set the user when **upgradeMode** is set to 'Manual'. To get list of available Service Fabric versions for new clusters use [ClusterVersion API](./ClusterVersion.md). To get the list of available version for existing clusters use **availableClusterVersions**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clusterCodeVersion")]
		public string ClusterCodeVersion { get; set; }
		
		/// <summary>
		/// The Azure Resource Provider endpoint. A system service in the cluster connects to this  endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clusterEndpoint")]
		public string ClusterEndpoint { get; set; }
		
		/// <summary>
		/// A service generated unique identifier for the cluster resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clusterId")]
		public string ClusterId { get; set; }
		
		/// <summary>
		/// The current state of the cluster.
		///
		///  - WaitingForNodes - Indicates that the cluster resource is created and the resource provider is waiting for Service Fabric VM extension to boot up and report to it.
		///  - Deploying - Indicates that the Service Fabric runtime is being installed on the VMs. Cluster resource will be in this state until the cluster boots up and system services are up.
		///  - BaselineUpgrade - Indicates that the cluster is upgrading to establishes the cluster version. This upgrade is automatically initiated when the cluster boots up for the first time.
		///  - UpdatingUserConfiguration - Indicates that the cluster is being upgraded with the user provided configuration.
		///  - UpdatingUserCertificate - Indicates that the cluster is being upgraded with the user provided certificate.
		///  - UpdatingInfrastructure - Indicates that the cluster is being upgraded with the latest Service Fabric runtime version. This happens only when the **upgradeMode** is set to 'Automatic'.
		///  - EnforcingClusterVersion - Indicates that cluster is on a different version than expected and the cluster is being upgraded to the expected version.
		///  - UpgradeServiceUnreachable - Indicates that the system service in the cluster is no longer polling the Resource Provider. Clusters in this state cannot be managed by the Resource Provider.
		///  - AutoScale - Indicates that the ReliabilityLevel of the cluster is being adjusted.
		///  - Ready - Indicates that the cluster is in a stable state.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clusterState")]
		public System.Nullable<ClusterPropertiesClusterState> ClusterState { get; set; }
		
		/// <summary>
		/// The storage account information for storing Service Fabric diagnostic logs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diagnosticsStorageAccountConfig")]
		public DiagnosticsStorageAccountConfig DiagnosticsStorageAccountConfig { get; set; }
		
		/// <summary>
		/// Indicates if the event store service is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventStoreServiceEnabled")]
		public System.Nullable<System.Boolean> EventStoreServiceEnabled { get; set; }
		
		/// <summary>
		/// The list of custom fabric settings to configure the cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fabricSettings")]
		public SettingsSectionDescription[] FabricSettings { get; set; }
		
		/// <summary>
		/// The http management endpoint of the cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="managementEndpoint")]
		public string ManagementEndpoint { get; set; }
		
		/// <summary>
		/// The list of node types in the cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nodeTypes")]
		public NodeTypeDescription[] NodeTypes { get; set; }
		
		/// <summary>
		/// The provisioning state of the cluster resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioningState")]
		public System.Nullable<ClusterPropertiesProvisioningState> ProvisioningState { get; set; }
		
		/// <summary>
		/// The reliability level sets the replica set size of system services. Learn about [ReliabilityLevel](https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-capacity).
		///
		///  - None - Run the System services with a target replica set count of 1. This should only be used for test clusters.
		///  - Bronze - Run the System services with a target replica set count of 3. This should only be used for test clusters.
		///  - Silver - Run the System services with a target replica set count of 5.
		///  - Gold - Run the System services with a target replica set count of 7.
		///  - Platinum - Run the System services with a target replica set count of 9.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reliabilityLevel")]
		public System.Nullable<ClusterPropertiesReliabilityLevel> ReliabilityLevel { get; set; }
		
		/// <summary>
		/// Describes the certificate details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reverseProxyCertificate")]
		public CertificateDescription ReverseProxyCertificate { get; set; }
		
		/// <summary>
		/// Describes a list of server certificates referenced by common name that are used to secure the cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reverseProxyCertificateCommonNames")]
		public ServerCertificateCommonNames ReverseProxyCertificateCommonNames { get; set; }
		
		/// <summary>
		/// Describes the policy used when upgrading the cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradeDescription")]
		public ClusterUpgradePolicy UpgradeDescription { get; set; }
		
		/// <summary>
		/// The upgrade mode of the cluster when new Service Fabric runtime version is available.
		///
		///  - Automatic - The cluster will be automatically upgraded to the latest Service Fabric runtime version as soon as it is available.
		///  - Manual - The cluster will not be automatically upgraded to the latest Service Fabric runtime version. The cluster is upgraded by setting the **clusterCodeVersion** property in the cluster resource.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradeMode")]
		public System.Nullable<ClusterPropertiesUpgradeMode> UpgradeMode { get; set; }
		
		/// <summary>
		/// The VM image VMSS has been configured with. Generic names such as Windows or Linux can be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmImage")]
		public string VmImage { get; set; }
	}
	
	/// <summary>
	/// The detail of the Service Fabric runtime version result
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ClusterVersionDetails
	{
		
		/// <summary>
		/// The Service Fabric runtime version of the cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="codeVersion")]
		public string CodeVersion { get; set; }
		
		/// <summary>
		/// Cluster operating system, the default will be Windows
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="environment")]
		public ClusterEnvironment Environment { get; set; }
		
		/// <summary>
		/// The date of expiry of support of the version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="supportExpiryUtc")]
		public string SupportExpiryUtc { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ClusterPropertiesClusterState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WaitingForNodes = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deploying = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BaselineUpgrade = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UpdatingUserConfiguration = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UpdatingUserCertificate = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UpdatingInfrastructure = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EnforcingClusterVersion = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UpgradeServiceUnreachable = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AutoScale = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Ready = 9,
	}
	
	/// <summary>
	/// Describes a section in the fabric settings of the cluster.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class SettingsSectionDescription
	{
		
		/// <summary>
		/// The section name of the fabric settings.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The collection of parameters in the section.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="parameters")]
		public SettingsParameterDescription[] Parameters { get; set; }
	}
	
	/// <summary>
	/// Describes a parameter in fabric settings of the cluster.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class SettingsParameterDescription
	{
		
		/// <summary>
		/// The parameter name of fabric setting.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The parameter value of fabric setting.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Describes a node type in the cluster, each node type represents sub set of nodes in the cluster.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class NodeTypeDescription
	{
		
		/// <summary>
		/// Port range details
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applicationPorts")]
		public EndpointRangeDescription ApplicationPorts { get; set; }
		
		/// <summary>
		/// The capacity tags applied to the nodes in the node type, the cluster resource manager uses these tags to understand how much resource a node has.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="capacities")]
		public System.Collections.Generic.Dictionary<string, string> Capacities { get; set; }
		
		/// <summary>
		/// The TCP cluster management endpoint port.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clientConnectionEndpointPort")]
		public int ClientConnectionEndpointPort { get; set; }
		
		/// <summary>
		/// The durability level of the node type. Learn about [DurabilityLevel](https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-capacity).
		///
		///  - Bronze - No privileges. This is the default.
		///  - Silver - The infrastructure jobs can be paused for a duration of 10 minutes per UD.
		///  - Gold - The infrastructure jobs can be paused for a duration of 2 hours per UD. Gold durability can be enabled only on full node VM skus like D15_V2, G5 etc.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durabilityLevel")]
		public System.Nullable<NodeTypeDescriptionDurabilityLevel> DurabilityLevel { get; set; }
		
		/// <summary>
		/// Port range details
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ephemeralPorts")]
		public EndpointRangeDescription EphemeralPorts { get; set; }
		
		/// <summary>
		/// The HTTP cluster management endpoint port.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="httpGatewayEndpointPort")]
		public int HttpGatewayEndpointPort { get; set; }
		
		/// <summary>
		/// The node type on which system services will run. Only one node type should be marked as primary. Primary node type cannot be deleted or changed for existing clusters.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isPrimary")]
		public bool IsPrimary { get; set; }
		
		/// <summary>
		/// The name of the node type.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The placement tags applied to nodes in the node type, which can be used to indicate where certain services (workload) should run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="placementProperties")]
		public System.Collections.Generic.Dictionary<string, string> PlacementProperties { get; set; }
		
		/// <summary>
		/// The endpoint used by reverse proxy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reverseProxyEndpointPort")]
		public System.Nullable<System.Int32> ReverseProxyEndpointPort { get; set; }
		
		/// <summary>
		/// The number of nodes in the node type. This count should match the capacity property in the corresponding VirtualMachineScaleSet resource.
		/// Required
		/// Minimum: 1
		/// Maximum: 2147483647
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vmInstanceCount")]
		[System.ComponentModel.DataAnnotations.Range(1, 2147483647)]
		public int VmInstanceCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum NodeTypeDescriptionDurabilityLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Bronze = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Silver = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Gold = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ClusterPropertiesProvisioningState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Updating = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Succeeded = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Canceled = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ClusterPropertiesReliabilityLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		None = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Bronze = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Silver = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Gold = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Platinum = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ClusterPropertiesUpgradeMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Automatic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Manual = 1,
	}
	
	/// <summary>
	/// Describes the cluster resource properties that can be updated during PATCH operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ClusterPropertiesUpdateParameters
	{
		
		/// <summary>
		/// The list of add-on features to enable in the cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addOnFeatures")]
		public AddOnFeatures[] AddOnFeatures { get; set; }
		
		/// <summary>
		/// Describes the certificate details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificate")]
		public CertificateDescription Certificate { get; set; }
		
		/// <summary>
		/// Describes a list of server certificates referenced by common name that are used to secure the cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateCommonNames")]
		public ServerCertificateCommonNames CertificateCommonNames { get; set; }
		
		/// <summary>
		/// The list of client certificates referenced by common name that are allowed to manage the cluster. This will overwrite the existing list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientCertificateCommonNames")]
		public ClientCertificateCommonName[] ClientCertificateCommonNames { get; set; }
		
		/// <summary>
		/// The list of client certificates referenced by thumbprint that are allowed to manage the cluster. This will overwrite the existing list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientCertificateThumbprints")]
		public ClientCertificateThumbprint[] ClientCertificateThumbprints { get; set; }
		
		/// <summary>
		/// The Service Fabric runtime version of the cluster. This property can only by set the user when **upgradeMode** is set to 'Manual'. To get list of available Service Fabric versions for new clusters use [ClusterVersion API](./ClusterVersion.md). To get the list of available version for existing clusters use **availableClusterVersions**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clusterCodeVersion")]
		public string ClusterCodeVersion { get; set; }
		
		/// <summary>
		/// Indicates if the event store service is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventStoreServiceEnabled")]
		public System.Nullable<System.Boolean> EventStoreServiceEnabled { get; set; }
		
		/// <summary>
		/// The list of custom fabric settings to configure the cluster. This will overwrite the existing list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fabricSettings")]
		public SettingsSectionDescription[] FabricSettings { get; set; }
		
		/// <summary>
		/// The list of node types in the cluster. This will overwrite the existing list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeTypes")]
		public NodeTypeDescription[] NodeTypes { get; set; }
		
		/// <summary>
		/// The reliability level sets the replica set size of system services. Learn about [ReliabilityLevel](https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-capacity).
		///
		///  - None - Run the System services with a target replica set count of 1. This should only be used for test clusters.
		///  - Bronze - Run the System services with a target replica set count of 3. This should only be used for test clusters.
		///  - Silver - Run the System services with a target replica set count of 5.
		///  - Gold - Run the System services with a target replica set count of 7.
		///  - Platinum - Run the System services with a target replica set count of 9.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reliabilityLevel")]
		public ClusterPropertiesReliabilityLevel ReliabilityLevel { get; set; }
		
		/// <summary>
		/// Describes the certificate details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reverseProxyCertificate")]
		public CertificateDescription ReverseProxyCertificate { get; set; }
		
		/// <summary>
		/// Describes the policy used when upgrading the cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradeDescription")]
		public ClusterUpgradePolicy UpgradeDescription { get; set; }
		
		/// <summary>
		/// The upgrade mode of the cluster when new Service Fabric runtime version is available.
		///
		///  - Automatic - The cluster will be automatically upgraded to the latest Service Fabric runtime version as soon as it is available.
		///  - Manual - The cluster will not be automatically upgraded to the latest Service Fabric runtime version. The cluster is upgraded by setting the **clusterCodeVersion** property in the cluster resource.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradeMode")]
		public ClusterPropertiesUpgradeMode UpgradeMode { get; set; }
	}
	
	/// <summary>
	/// The current state of the cluster.
	///
	///  - WaitingForNodes - Indicates that the cluster resource is created and the resource provider is waiting for Service Fabric VM extension to boot up and report to it.
	///  - Deploying - Indicates that the Service Fabric runtime is being installed on the VMs. Cluster resource will be in this state until the cluster boots up and system services are up.
	///  - BaselineUpgrade - Indicates that the cluster is upgrading to establishes the cluster version. This upgrade is automatically initiated when the cluster boots up for the first time.
	///  - UpdatingUserConfiguration - Indicates that the cluster is being upgraded with the user provided configuration.
	///  - UpdatingUserCertificate - Indicates that the cluster is being upgraded with the user provided certificate.
	///  - UpdatingInfrastructure - Indicates that the cluster is being upgraded with the latest Service Fabric runtime version. This happens only when the **upgradeMode** is set to 'Automatic'.
	///  - EnforcingClusterVersion - Indicates that cluster is on a different version than expected and the cluster is being upgraded to the expected version.
	///  - UpgradeServiceUnreachable - Indicates that the system service in the cluster is no longer polling the Resource Provider. Clusters in this state cannot be managed by the Resource Provider.
	///  - AutoScale - Indicates that the ReliabilityLevel of the cluster is being adjusted.
	///  - Ready - Indicates that the cluster is in a stable state.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ClusterState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WaitingForNodes = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deploying = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BaselineUpgrade = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UpdatingUserConfiguration = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UpdatingUserCertificate = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UpdatingInfrastructure = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EnforcingClusterVersion = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UpgradeServiceUnreachable = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AutoScale = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Ready = 9,
	}
	
	/// <summary>
	/// Cluster update request
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ClusterUpdateParameters
	{
		
		/// <summary>
		/// Describes the cluster resource properties that can be updated during PATCH operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public ClusterPropertiesUpdateParameters Properties { get; set; }
		
		/// <summary>
		/// Cluster update parameters
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	/// <summary>
	/// Describes the delta health policies for the cluster upgrade.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ClusterUpgradeDeltaHealthPolicy
	{
		
		/// <summary>
		/// Defines a map that contains specific application delta health policies for different applications.
		///Each entry specifies as key the application name and as value an ApplicationDeltaHealthPolicy used to evaluate the application health when upgrading the cluster.
		///The application name should include the 'fabric:' URI scheme.
		///The map is empty by default.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applicationDeltaHealthPolicies")]
		public ApplicationDeltaHealthPolicyMap ApplicationDeltaHealthPolicies { get; set; }
		
		/// <summary>
		/// The maximum allowed percentage of applications health degradation allowed during cluster upgrades.
		///The delta is measured between the state of the applications at the beginning of upgrade and the state of the applications at the time of the health evaluation.
		///The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits. System services are not included in this.
		///
		/// Required
		/// Minimum: 0
		/// Maximum: 100
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxPercentDeltaUnhealthyApplications")]
		[System.ComponentModel.DataAnnotations.Range(0, 100)]
		public int MaxPercentDeltaUnhealthyApplications { get; set; }
		
		/// <summary>
		/// The maximum allowed percentage of nodes health degradation allowed during cluster upgrades.
		///The delta is measured between the state of the nodes at the beginning of upgrade and the state of the nodes at the time of the health evaluation.
		///The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits.
		///
		/// Required
		/// Minimum: 0
		/// Maximum: 100
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxPercentDeltaUnhealthyNodes")]
		[System.ComponentModel.DataAnnotations.Range(0, 100)]
		public int MaxPercentDeltaUnhealthyNodes { get; set; }
		
		/// <summary>
		/// The maximum allowed percentage of upgrade domain nodes health degradation allowed during cluster upgrades.
		///The delta is measured between the state of the upgrade domain nodes at the beginning of upgrade and the state of the upgrade domain nodes at the time of the health evaluation.
		///The check is performed after every upgrade domain upgrade completion for all completed upgrade domains to make sure the state of the upgrade domains is within tolerated limits.
		///
		/// Required
		/// Minimum: 0
		/// Maximum: 100
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxPercentUpgradeDomainDeltaUnhealthyNodes")]
		[System.ComponentModel.DataAnnotations.Range(0, 100)]
		public int MaxPercentUpgradeDomainDeltaUnhealthyNodes { get; set; }
	}
	
	/// <summary>
	/// Describes the policy used when upgrading the cluster.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ClusterUpgradePolicy
	{
		
		/// <summary>
		/// Describes the delta health policies for the cluster upgrade.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deltaHealthPolicy")]
		public ClusterUpgradeDeltaHealthPolicy DeltaHealthPolicy { get; set; }
		
		/// <summary>
		/// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forceRestart")]
		public System.Nullable<System.Boolean> ForceRestart { get; set; }
		
		/// <summary>
		/// The amount of time to retry health evaluation when the application or cluster is unhealthy before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="healthCheckRetryTimeout")]
		public string HealthCheckRetryTimeout { get; set; }
		
		/// <summary>
		/// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="healthCheckStableDuration")]
		public string HealthCheckStableDuration { get; set; }
		
		/// <summary>
		/// The length of time to wait after completing an upgrade domain before performing health checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="healthCheckWaitDuration")]
		public string HealthCheckWaitDuration { get; set; }
		
		/// <summary>
		/// Defines a health policy used to evaluate the health of the cluster or of a cluster node.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="healthPolicy")]
		public ClusterHealthPolicy HealthPolicy { get; set; }
		
		/// <summary>
		/// The amount of time each upgrade domain has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="upgradeDomainTimeout")]
		public string UpgradeDomainTimeout { get; set; }
		
		/// <summary>
		/// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="upgradeReplicaSetCheckTimeout")]
		public string UpgradeReplicaSetCheckTimeout { get; set; }
		
		/// <summary>
		/// The amount of time the overall upgrade has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="upgradeTimeout")]
		public string UpgradeTimeout { get; set; }
	}
	
	/// <summary>
	/// The storage account information for storing Service Fabric diagnostic logs.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DiagnosticsStorageAccountConfig
	{
		
		/// <summary>
		/// The blob endpoint of the azure storage account.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blobEndpoint")]
		public string BlobEndpoint { get; set; }
		
		/// <summary>
		/// The protected diagnostics storage key name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protectedAccountKeyName")]
		public string ProtectedAccountKeyName { get; set; }
		
		/// <summary>
		/// The queue endpoint of the azure storage account.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="queueEndpoint")]
		public string QueueEndpoint { get; set; }
		
		/// <summary>
		/// The Azure storage account name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="storageAccountName")]
		public string StorageAccountName { get; set; }
		
		/// <summary>
		/// The table endpoint of the azure storage account.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tableEndpoint")]
		public string TableEndpoint { get; set; }
	}
	
	/// <summary>
	/// The durability level of the node type. Learn about [DurabilityLevel](https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-capacity).
	///
	///  - Bronze - No privileges. This is the default.
	///  - Silver - The infrastructure jobs can be paused for a duration of 10 minutes per UD.
	///  - Gold - The infrastructure jobs can be paused for a duration of 2 hours per UD. Gold durability can be enabled only on full node VM skus like D15_V2, G5 etc.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum DurabilityLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Bronze = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Silver = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Gold = 2,
	}
	
	/// <summary>
	/// Port range details
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class EndpointRangeDescription
	{
		
		/// <summary>
		/// End port of a range of ports
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endPort")]
		public int EndPort { get; set; }
		
		/// <summary>
		/// Starting port of a range of ports
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startPort")]
		public int StartPort { get; set; }
	}
	
	/// <summary>
	/// The structure of the error.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ErrorModel
	{
		
		/// <summary>
		/// The error details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public ErrorModelError Error { get; set; }
	}
	
	/// <summary>
	/// The error details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ErrorModelError
	{
		
		/// <summary>
		/// The error code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// The error message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// Describes the result of the request to list Service Fabric resource provider operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class OperationListResult
	{
		
		/// <summary>
		/// URL to get the next set of operation list results if there are any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// List of operations supported by the Service Fabric resource provider.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public OperationResult[] Value { get; set; }
	}
	
	/// <summary>
	/// Available operation list result
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class OperationResult
	{
		
		/// <summary>
		/// Operation supported by the Service Fabric resource provider
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="display")]
		public AvailableOperationDisplay Display { get; set; }
		
		/// <summary>
		/// The name of the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The URL to use for getting the next set of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// Origin result
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public string Origin { get; set; }
	}
	
	/// <summary>
	/// The reliability level sets the replica set size of system services. Learn about [ReliabilityLevel](https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-capacity).
	///
	///  - None - Run the System services with a target replica set count of 1. This should only be used for test clusters.
	///  - Bronze - Run the System services with a target replica set count of 3. This should only be used for test clusters.
	///  - Silver - Run the System services with a target replica set count of 5.
	///  - Gold - Run the System services with a target replica set count of 7.
	///  - Platinum - Run the System services with a target replica set count of 9.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ReliabilityLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		None = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Bronze = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Silver = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Gold = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Platinum = 4,
	}
	
	/// <summary>
	/// The resource model definition.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Resource
	{
		
		/// <summary>
		/// Azure resource etag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// Azure resource identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Azure resource location.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Azure resource name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Azure resource tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
		
		/// <summary>
		/// Azure resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Describes the server certificate details using common name.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ServerCertificateCommonName
	{
		
		/// <summary>
		/// The common name of the server certificate.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateCommonName")]
		public string CertificateCommonName { get; set; }
		
		/// <summary>
		/// The issuer thumbprint of the server certificate.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateIssuerThumbprint")]
		public string CertificateIssuerThumbprint { get; set; }
	}
	
	/// <summary>
	/// Describes a list of server certificates referenced by common name that are used to secure the cluster.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ServerCertificateCommonNames
	{
		
		/// <summary>
		/// The list of server certificates referenced by common name that are used to secure the cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commonNames")]
		public ServerCertificateCommonName[] CommonNames { get; set; }
		
		/// <summary>
		/// The local certificate store location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="x509StoreName")]
		public CertificateDescriptionX509StoreName X509StoreName { get; set; }
	}
	
	/// <summary>
	/// The local certificate store location.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum StoreName
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AddressBook = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AuthRoot = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CertificateAuthority = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disallowed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		My = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Root = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TrustedPeople = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TrustedPublisher = 7,
	}
	
	/// <summary>
	/// The upgrade mode of the cluster when new Service Fabric runtime version is available.
	///
	///  - Automatic - The cluster will be automatically upgraded to the latest Service Fabric runtime version as soon as it is available.
	///  - Manual - The cluster will not be automatically upgraded to the latest Service Fabric runtime version. The cluster is upgraded by setting the **clusterCodeVersion** property in the cluster resource.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum UpgradeMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Automatic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Manual = 1,
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Lists all of the available Service Fabric resource provider API operations.
		/// Get the list of available Service Fabric resource provider API operations.
		/// Operations_List providers/Microsoft.ServiceFabric/operations
		/// </summary>
		/// <param name="api_version">The version of the Service Fabric resource provider API</param>
		/// <returns>OK. The request has succeeded.</returns>
		public async Task<OperationListResult> Operations_ListAsync(string api_version)
		{
			var requestUri = "providers/Microsoft.ServiceFabric/operations?api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<OperationListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the list of Service Fabric cluster resources created in the specified subscription.
		/// Gets all Service Fabric cluster resources created or in the process of being created in the subscription.
		/// Clusters_List subscriptions/{subscriptionId}/providers/Microsoft.ServiceFabric/clusters
		/// </summary>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ClusterListResult> Clusters_ListAsync(Clusters_ListApi_version api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.ServiceFabric/clusters?api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ClusterListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the list of Service Fabric cluster code versions available for the specified location.
		/// Gets all available code versions for Service Fabric cluster resources by location.
		/// ClusterVersions_List subscriptions/{subscriptionId}/providers/Microsoft.ServiceFabric/locations/{location}/clusterVersions
		/// </summary>
		/// <param name="location">The location for the cluster code versions. This is different from cluster location.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ClusterCodeVersionsListResult> ClusterVersions_ListAsync(string location, ClusterVersions_ListApi_version api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.ServiceFabric/locations/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/clusterVersions&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ClusterCodeVersionsListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information about a Service Fabric cluster code version available in the specified location.
		/// Gets information about an available Service Fabric cluster code version.
		/// ClusterVersions_Get subscriptions/{subscriptionId}/providers/Microsoft.ServiceFabric/locations/{location}/clusterVersions/{clusterVersion}
		/// </summary>
		/// <param name="location">The location for the cluster code versions. This is different from cluster location.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="clusterVersion">The cluster code version.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ClusterCodeVersionsListResult> ClusterVersions_GetAsync(string location, ClusterVersions_GetApi_version api_version, string subscriptionId, string clusterVersion)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.ServiceFabric/locations/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/clusterVersions/"+ (clusterVersion==null? "" : System.Uri.EscapeDataString(clusterVersion))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ClusterCodeVersionsListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the list of Service Fabric cluster code versions available for the specified environment.
		/// Gets all available code versions for Service Fabric cluster resources by environment.
		/// ClusterVersions_ListByEnvironment subscriptions/{subscriptionId}/providers/Microsoft.ServiceFabric/locations/{location}/environments/{environment}/clusterVersions
		/// </summary>
		/// <param name="location">The location for the cluster code versions. This is different from cluster location.</param>
		/// <param name="environment">The operating system of the cluster. The default means all.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ClusterCodeVersionsListResult> ClusterVersions_ListByEnvironmentAsync(string location, ClusterEnvironment environment, ClusterVersions_ListByEnvironmentApi_version api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.ServiceFabric/locations/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/environments/"+environment+"/clusterVersions&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ClusterCodeVersionsListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information about a Service Fabric cluster code version available for the specified environment.
		/// Gets information about an available Service Fabric cluster code version by environment.
		/// ClusterVersions_GetByEnvironment subscriptions/{subscriptionId}/providers/Microsoft.ServiceFabric/locations/{location}/environments/{environment}/clusterVersions/{clusterVersion}
		/// </summary>
		/// <param name="location">The location for the cluster code versions. This is different from cluster location.</param>
		/// <param name="environment">The operating system of the cluster. The default means all.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="clusterVersion">The cluster code version.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ClusterCodeVersionsListResult> ClusterVersions_GetByEnvironmentAsync(string location, ClusterEnvironment environment, ClusterVersions_GetByEnvironmentApi_version api_version, string subscriptionId, string clusterVersion)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.ServiceFabric/locations/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/environments/"+environment+"/clusterVersions/"+ (clusterVersion==null? "" : System.Uri.EscapeDataString(clusterVersion))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ClusterCodeVersionsListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a Service Fabric cluster resource.
		/// Get a Service Fabric cluster resource created or in the process of being created in the specified resource group.
		/// Clusters_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<Cluster> Clusters_GetAsync(string resourceGroupName, string clusterName, Clusters_GetApi_version api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Cluster>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates or updates a Service Fabric cluster resource.
		/// Create or update a Service Fabric cluster resource with the specified name.
		/// Clusters_CreateOrUpdate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="requestBody">The cluster resource.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<Cluster> Clusters_CreateOrUpdateAsync(string resourceGroupName, string clusterName, Clusters_CreateOrUpdateApi_version api_version, string subscriptionId, Cluster requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Cluster>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a Service Fabric cluster resource.
		/// Delete a Service Fabric cluster resource with the specified name.
		/// Clusters_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task Clusters_DeleteAsync(string resourceGroupName, string clusterName, Clusters_DeleteApi_version api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the configuration of a Service Fabric cluster resource.
		/// Update the configuration of a Service Fabric cluster resource with the specified name.
		/// Clusters_Update subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="requestBody">The parameters which contains the property value and property name which used to update the cluster configuration.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<Cluster> Clusters_UpdateAsync(string resourceGroupName, string clusterName, Clusters_UpdateApi_version api_version, string subscriptionId, ClusterUpdateParameters requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Cluster>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the list of Service Fabric cluster resources created in the specified resource group.
		/// Gets all Service Fabric cluster resources created or in the process of being created in the resource group.
		/// Clusters_ListByResourceGroup subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ClusterListResult> Clusters_ListByResourceGroupAsync(string resourceGroupName, Clusters_ListByResourceGroupApi_version api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourcegroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ClusterListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum Clusters_ListApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum ClusterVersions_ListApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum ClusterVersions_GetApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum ClusterVersions_ListByEnvironmentApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum ClusterVersions_GetByEnvironmentApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum Clusters_GetApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum Clusters_CreateOrUpdateApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum Clusters_DeleteApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum Clusters_UpdateApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum Clusters_ListByResourceGroupApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
