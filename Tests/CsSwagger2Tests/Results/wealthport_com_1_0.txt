//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Archivable_Object
	{
		
		[System.Runtime.Serialization.DataMember(Name="archived")]
		public System.Nullable<System.Boolean> Archived { get; set; }
		
		/// <summary>
		/// Required
		/// Min length: 36
		/// Max length: 36
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		[System.ComponentModel.DataAnnotations.MinLength(36)]
		[System.ComponentModel.DataAnnotations.MaxLength(36)]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Existing_Folder
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Existing_Order
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Existing_Recipe
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Existing_Source
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Folder_Request
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Order_Request
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Source_Request
	{
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Retrieve Folders
		/// Retrieves all Folders in the Data Inventory.
		/// RetrieveFolders folders
		/// </summary>
		/// <returns>Folders successfully retrieved</returns>
		public async Task<Existing_Folder[]> RetrieveFoldersAsync()
		{
			var requestUri = "folders";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Existing_Folder[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create Folder
		/// Creates the specified Folder in the Data Inventory.
		/// CreateFolder folders
		/// </summary>
		/// <param name="requestBody">JSON</param>
		public async Task CreateFolderAsync(Folder_Request requestBody)
		{
			var requestUri = "folders";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve Folder
		/// Retrieves the specified Folder.
		/// RetrieveFolder folders/{id}
		/// </summary>
		/// <param name="id">Folder ID of the Folder to retrieve</param>
		/// <returns>Folder successfully retrieved</returns>
		public async Task<Existing_Folder> RetrieveFolderAsync(string id)
		{
			var requestUri = "folders/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Existing_Folder>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update Folder
		/// Updates the specified Folder.
		/// UpdateFolder folders/{id}
		/// </summary>
		/// <param name="id">Folder ID of the Folder to update</param>
		/// <param name="requestBody">JSON</param>
		/// <returns>Folder successfully updated</returns>
		public async Task UpdateFolderAsync(string id, Folder_Request requestBody)
		{
			var requestUri = "folders/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete Folder
		/// Deletes the specified Folder and all contained Sources from the Data Inventory.
		/// DeleteFolder folders/{id}
		/// </summary>
		/// <param name="id">Folder ID of the Folder to delete, including any Sources contained</param>
		public async Task DeleteFolderAsync(string id)
		{
			var requestUri = "folders/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve Sources
		/// Retrieves all Sources of the specified Folder.
		/// RetrieveFolderSources folders/{id}/sources
		/// </summary>
		/// <param name="id">Folder ID of the Folder to retrieve its Sources from</param>
		/// <returns>Sources successfully retrieved</returns>
		public async Task<Existing_Source> RetrieveFolderSourcesAsync(string id)
		{
			var requestUri = "folders/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/sources";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Existing_Source>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete Sources
		/// Deletes all Sources in the specified Folder.
		/// DeleteFolderSources folders/{id}/sources
		/// </summary>
		/// <param name="id">Folder ID of the Folder to delete all Sources from</param>
		public async Task DeleteFolderSourcesAsync(string id)
		{
			var requestUri = "folders/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/sources";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get Result
		/// Returns the result of a finished Job.
		/// GetResult jobs/{id}/result
		/// </summary>
		/// <param name="id">Job ID of the job to retrieve its result</param>
		/// <returns>Job has finished, potentially with errors, result is returned as JSON in the response</returns>
		public async Task<string> GetResultAsync(string id)
		{
			var requestUri = "jobs/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/result";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get Status
		/// Retrieves the status of a Job.
		/// GetStatus jobs/{id}/status
		/// </summary>
		/// <param name="id">Job ID of the job to retrieve its status</param>
		/// <returns>Job has finished, potentially with errors, result is available and Job ID is returned in the response</returns>
		public async Task<string> GetStatusAsync(string id)
		{
			var requestUri = "jobs/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/status";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve Orders
		/// Retrieves all previously submitted Orders.
		/// RetrieveOrders orders
		/// </summary>
		/// <returns>Orders successfully retrieved</returns>
		public async Task<Existing_Order[]> RetrieveOrdersAsync()
		{
			var requestUri = "orders";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Existing_Order[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create Order
		/// Creates a new Order to be submitted.<p>Orders reference one or more Sources, e.g. uploaded files, as well as one or more Folders (which again can contain Sources).The Recipe describes what to do with the referenced sources and where to publish the processing result to.</p>
		/// CreateOrder orders
		/// </summary>
		/// <param name="requestBody">JSON</param>
		public async Task CreateOrderAsync(Order_Request requestBody)
		{
			var requestUri = "orders";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve Order
		/// Retrieves the specified Order.
		/// RetrieveOrder orders/{id}
		/// </summary>
		/// <param name="id">Order ID of the order to retrieve</param>
		/// <returns>Order successfully retrieved</returns>
		public async Task<Existing_Order> RetrieveOrderAsync(string id)
		{
			var requestUri = "orders/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Existing_Order>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update Order
		/// Updates the specified Order.
		/// UpdateOrder orders/{id}
		/// </summary>
		/// <param name="id">Order ID of the order to update</param>
		/// <param name="requestBody">JSON</param>
		/// <returns>Order successfully updated</returns>
		public async Task UpdateOrderAsync(string id, Order_Request requestBody)
		{
			var requestUri = "orders/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete Order
		/// Deletes the specified Order.
		/// DeleteOrder orders/{id}
		/// </summary>
		/// <param name="id">Order ID of the order to delete</param>
		public async Task DeleteOrderAsync(string id)
		{
			var requestUri = "orders/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Submit Order
		/// Submits the specified Order for processing and launches a corresponding job.
		/// SubmitOrder orders/{id}/submit
		/// </summary>
		/// <param name="id">Order ID of the order to submit for processing</param>
		public async Task SubmitOrderAsync(string id)
		{
			var requestUri = "orders/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/submit";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve Recipes
		/// Retrieves all available Recipes.
		/// RetrieveRecipes recipes
		/// </summary>
		/// <returns>Recipes successfully retrieved</returns>
		public async Task<Existing_Recipe[]> RetrieveRecipesAsync()
		{
			var requestUri = "recipes";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Existing_Recipe[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve Recipe
		/// Retrieves the specified Recipe.
		/// RetrieveRecipe recipes/{id}
		/// </summary>
		/// <param name="id">Recipe ID of the recipe to retrieve</param>
		/// <returns>Recipe successfully retrieved</returns>
		public async Task<Existing_Recipe> RetrieveRecipeAsync(string id)
		{
			var requestUri = "recipes/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Existing_Recipe>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve Instructions
		/// Retrieves the instructions of the specified Recipe.
		/// RetrieveInstructions recipes/{id}/instructions
		/// </summary>
		/// <param name="id">Recipe ID of the recipe whose instructions to retrieve</param>
		/// <returns>Instructions successfully retrieved</returns>
		public async Task<string> RetrieveInstructionsAsync(string id)
		{
			var requestUri = "recipes/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/instructions";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update Instructions
		/// Updates the instructions of the specified Recipe.
		/// UpdateInstructions recipes/{id}/instructions
		/// </summary>
		/// <param name="id">Recipe ID of the recipe whose instructions to update</param>
		/// <param name="requestBody">JSON instructions to update the Recipe</param>
		/// <returns>Instructions successfully updated</returns>
		public async Task UpdateInstructionsAsync(string id, string requestBody)
		{
			var requestUri = "recipes/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/instructions";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve Sources
		/// Retrieves all Sources stored in the Data Inventory.
		/// RetrieveSources sources
		/// </summary>
		/// <returns>Sources successfully retrieved</returns>
		public async Task<Existing_Source[]> RetrieveSourcesAsync()
		{
			var requestUri = "sources";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Existing_Source[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create Source
		/// Creates the specified Source.<p>Sources are either uploaded files or a reference to a database. They are referenced in orders to specify which data needs processing.</p><p>Most clients should probably use the Upload File API which implicitly creates a new source on successful file upload.</p>
		/// CreateSource sources
		/// </summary>
		/// <param name="requestBody">JSON</param>
		public async Task CreateSourceAsync(Source_Request requestBody)
		{
			var requestUri = "sources";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Upload File
		/// Initiates a file upload and returns the URL where to upload the file to.<p>Calling this API generates a secure, unique and time-restricted URL where the file can be uploaded to. The URL is available in the <pre>Location</pre> HTTP header of the response. The temporal validity of the URL is available in the <pre>Cache-Control</pre> HTTP header of the response.Clients may perform a <pre>HTTP PUT</pre> request on the URL to upload the file using a form where a file <pre>sample.csv</pre> is passed as property <pre>file=sample.csv</pre>. For security reasons, clients must pass all HTTP headers as returned by the <pre>X-WP-Upload-Headers</pre> in the response, together with their values. This procedure ensures a secure, encrypted file upload.</p><p>Note that calling this API automatically generates a Source, there is no need to call the Create Source API.</p>
		/// GetUploadUrl sources/upload
		/// </summary>
		/// <param name="name">Name of the source to create. The name must correspond to the exact file name of the file being uploaded.</param>
		/// <param name="source">Existing source ID to create a new version from</param>
		/// <param name="folder">Folder ID where to upload source to</param>
		/// <param name="contentType">MIME type of the source file</param>
		/// <param name="encoding">Encoding of the source file</param>
		public async Task GetUploadUrlAsync(string name, string source, string folder, string contentType, string encoding)
		{
			var requestUri = "sources/upload?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&folder=" + (folder==null? "" : System.Uri.EscapeDataString(folder))+"&contentType=" + (contentType==null? "" : System.Uri.EscapeDataString(contentType))+"&encoding=" + (encoding==null? "" : System.Uri.EscapeDataString(encoding));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve Source
		/// Retrieves the specified Source.
		/// RetrieveSource sources/{id}
		/// </summary>
		/// <param name="id">Source ID of the source to retrieve</param>
		/// <returns>Source successfully retrieved</returns>
		public async Task<Existing_Source> RetrieveSourceAsync(string id)
		{
			var requestUri = "sources/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Existing_Source>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update Source
		/// Updates the specified Source.
		/// UpdateSource sources/{id}
		/// </summary>
		/// <param name="id">Source ID of Source to update</param>
		/// <param name="requestBody">JSON</param>
		/// <returns>Source successfully updated</returns>
		public async Task UpdateSourceAsync(string id, Source_Request requestBody)
		{
			var requestUri = "sources/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete Source
		/// Deletes the specified Source.
		/// DeleteSource sources/{id}
		/// </summary>
		/// <param name="id">Source ID of the Source to delete</param>
		public async Task DeleteSourceAsync(string id)
		{
			var requestUri = "sources/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Download File
		/// Initiates a file download and returns the URL where to download the file from.<p>Calling this API generates a secure, unique and time-restricted URL where the file can be downloaded from. The URL is available in the <pre>Location</pre> HTTP header of the response. The time restriction of the URL is availablein the <pre>Cache-Control</pre> HTTP header of the response.Clients may perform a <pre>HTTP GET</pre> request on the URL to download the file.</p>
		/// GetDownloadUrl sources/{id}/download
		/// </summary>
		/// <param name="id">Source ID of file to download</param>
		/// <returns>Source file download initiated</returns>
		public async Task<string> GetDownloadUrlAsync(string id)
		{
			var requestUri = "sources/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/download";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
