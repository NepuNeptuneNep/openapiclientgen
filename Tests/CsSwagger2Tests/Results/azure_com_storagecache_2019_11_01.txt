//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// REST API operation description: see https://github.com/Azure/azure-rest-api-specs/blob/master/documentation/openapi-authoring-automated-guidelines.md#r3023-operationsapiimplementation
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApiOperation
	{
		
		/// <summary>
		/// The object that represents the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="display")]
		public object Display { get; set; }
		
		/// <summary>
		/// Operation name: {provider}/{resource}/{operation}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Result of the request to list Resource Provider operations. It contains a list of operations and a URL link to get the next set of results.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApiOperationListResult
	{
		
		/// <summary>
		/// URL to get the next set of operation list results if there are any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// List of Resource Provider operations supported by the Microsoft.StorageCache resource provider.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public ApiOperation[] Value { get; set; }
	}
	
	/// <summary>
	/// A Cache instance. Follows Azure Resource Manager standards: https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Cache
	{
		
		/// <summary>
		/// A fully qualified URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Region name string.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Schema for the name of resources served by this provider. Note that objects will contain an odata @id annotation as appropriate. This will contain the complete URL of the object. These names are case-preserving, but not case sensitive.
		/// Pattern: ^[-0-9a-zA-Z_]{1,31}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[-0-9a-zA-Z_]{1,31}$")]
		public string Name { get; set; }
		
		/// <summary>
		/// Properties of the Cache.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public CacheProperties Properties { get; set; }
		
		/// <summary>
		/// SKU for the Cache.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sku")]
		public CacheSku Sku { get; set; }
		
		/// <summary>
		/// ARM tags as name/value pairs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string Tags { get; set; }
		
		/// <summary>
		/// Type of the Cache; Microsoft.StorageCache/Cache
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class CacheProperties
	{
		
		/// <summary>
		/// The size of this Cache, in GB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cacheSizeGB")]
		public System.Nullable<System.Int32> CacheSizeGB { get; set; }
		
		/// <summary>
		/// An indication of Cache health. Gives more information about health than just that related to provisioning.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="health")]
		public CacheHealth Health { get; set; }
		
		/// <summary>
		/// Array of IP addresses that can be used by clients mounting this Cache.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mountAddresses")]
		public string[] MountAddresses { get; set; }
		
		/// <summary>
		/// ARM provisioning state, see https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/Addendum.md#provisioningstate-property
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioningState")]
		public System.Nullable<CachePropertiesProvisioningState> ProvisioningState { get; set; }
		
		/// <summary>
		/// A fully qualified URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
		
		/// <summary>
		/// Properties describing the software upgrade state of the Cache.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradeStatus")]
		public CacheUpgradeStatus UpgradeStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum CachePropertiesProvisioningState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Succeeded = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cancelled = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Creating = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleting = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Updating = 5,
	}
	
	/// <summary>
	/// Properties describing the software upgrade state of the Cache.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class CacheUpgradeStatus
	{
		
		/// <summary>
		/// Version string of the firmware currently installed on this Cache.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentFirmwareVersion")]
		public string CurrentFirmwareVersion { get; set; }
		
		/// <summary>
		/// Time at which the pending firmware update will automatically be installed on the Cache.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmwareUpdateDeadline")]
		public System.Nullable<System.DateTimeOffset> FirmwareUpdateDeadline { get; set; }
		
		/// <summary>
		/// True if there is a firmware update ready to install on this Cache. The firmware will automatically be installed after firmwareUpdateDeadline if not triggered earlier via the upgrade operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmwareUpdateStatus")]
		public System.Nullable<CacheUpgradeStatusFirmwareUpdateStatus> FirmwareUpdateStatus { get; set; }
		
		/// <summary>
		/// Time of the last successful firmware update.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastFirmwareUpdate")]
		public System.Nullable<System.DateTimeOffset> LastFirmwareUpdate { get; set; }
		
		/// <summary>
		/// When firmwareUpdateAvailable is true, this field holds the version string for the update.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pendingFirmwareVersion")]
		public string PendingFirmwareVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum CacheUpgradeStatusFirmwareUpdateStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		available = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unavailable = 1,
	}
	
	public class CacheSku
	{
		
		/// <summary>
		/// SKU name for this Cache.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// An indication of Cache health. Gives more information about health than just that related to provisioning.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class CacheHealth
	{
		
		/// <summary>
		/// List of Cache health states.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<CacheHealthState> State { get; set; }
		
		/// <summary>
		/// Describes explanation of state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusDescription")]
		public string StatusDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum CacheHealthState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Healthy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Degraded = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Down = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Transitioning = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Stopping = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Stopped = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Upgrading = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Flushing = 8,
	}
	
	/// <summary>
	/// Result of the request to list Caches. It contains a list of Caches and a URL link to get the next set of results.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class CachesListResult
	{
		
		/// <summary>
		/// URL to get the next set of Cache list results, if there are any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// List of Caches.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public Cache[] Value { get; set; }
	}
	
	/// <summary>
	/// Storage container for use as a CLFS Storage Target.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ClfsTarget
	{
		
		/// <summary>
		/// A fully qualified URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
	}
	
	/// <summary>
	/// An error response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class CloudError
	{
		
		/// <summary>
		/// An error response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public CloudErrorBody Error { get; set; }
	}
	
	/// <summary>
	/// An error response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class CloudErrorBody
	{
		
		/// <summary>
		/// An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// A list of additional details about the error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public CloudErrorBody[] Details { get; set; }
		
		/// <summary>
		/// A message describing the error, intended to be suitable for display in a user interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// The target of the particular error. For example, the name of the property in error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
	}
	
	/// <summary>
	/// A namespace junction.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class NamespaceJunction
	{
		
		/// <summary>
		/// Namespace path on a Cache for a Storage Target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespacePath")]
		public string NamespacePath { get; set; }
		
		/// <summary>
		/// NFS export where targetPath exists.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nfsExport")]
		public string NfsExport { get; set; }
		
		/// <summary>
		/// Path in Storage Target to which namespacePath points.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetPath")]
		public string TargetPath { get; set; }
	}
	
	/// <summary>
	/// An NFSv3 mount point for use as a Storage Target.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Nfs3Target
	{
		
		/// <summary>
		/// IP address or host name of an NFSv3 host (e.g., 10.0.44.44).
		/// Pattern: ^[-.0-9a-zA-Z]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[-.0-9a-zA-Z]+$")]
		public string Target { get; set; }
		
		/// <summary>
		/// Identifies the primary usage model to be used for this Storage Target. Get choices from .../usageModels
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usageModel")]
		public string UsageModel { get; set; }
	}
	
	/// <summary>
	/// A resource SKU.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ResourceSku
	{
		
		/// <summary>
		/// A list of capabilities of this SKU, such as throughput or ops/sec.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="capabilities")]
		public ResourceSkuCapabilities[] Capabilities { get; set; }
		
		/// <summary>
		/// The set of locations that the SKU is available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationInfo")]
		public ResourceSkuLocationInfo[] LocationInfo { get; set; }
		
		/// <summary>
		/// The set of locations that the SKU is available. This will be supported and registered Azure Geo Regions (e.g., West US, East US, Southeast Asia, etc.).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locations")]
		public string[] Locations { get; set; }
		
		/// <summary>
		/// The name of this SKU.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The type of resource the SKU applies to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceType")]
		public string ResourceType { get; set; }
		
		/// <summary>
		/// The restrictions preventing this SKU from being used. This is empty if there are no restrictions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restrictions")]
		public Restriction[] Restrictions { get; set; }
	}
	
	/// <summary>
	/// A resource SKU capability.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ResourceSkuCapabilities
	{
		
		/// <summary>
		/// Name of a capability, such as ops/sec.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Quantity, if the capability is measured by quantity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Resource SKU location information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ResourceSkuLocationInfo
	{
		
		/// <summary>
		/// Location where this SKU is available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Zones if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zones")]
		public string[] Zones { get; set; }
	}
	
	/// <summary>
	/// The restrictions preventing this SKU from being used.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Restriction
	{
		
		/// <summary>
		/// The reason for the restriction. As of now this can be "QuotaId" or "NotAvailableForSubscription". "QuotaId" is set when the SKU has requiredQuotas parameter as the subscription does not belong to that quota. "NotAvailableForSubscription" is related to capacity at the datacenter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reasonCode")]
		public System.Nullable<RestrictionReasonCode> ReasonCode { get; set; }
		
		/// <summary>
		/// The type of restrictions. In this version, the only possible value for this is location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// The value of restrictions. If the restriction type is set to location, then this would be the different locations where the SKU is restricted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="values")]
		public string[] Values { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum RestrictionReasonCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		QuotaId = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NotAvailableForSubscription = 1,
	}
	
	/// <summary>
	/// The response from the List Cache SKUs operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ResourceSkusResult
	{
		
		/// <summary>
		/// The URI to fetch the next page of Cache SKUs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// The list of SKUs available for the subscription.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public ResourceSku[] Value { get; set; }
	}
	
	/// <summary>
	/// A storage system being cached by a Cache.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class StorageTarget
	{
		
		/// <summary>
		/// Resource ID of the Storage Target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Schema for the name of resources served by this provider. Note that objects will contain an odata @id annotation as appropriate. This will contain the complete URL of the object. These names are case-preserving, but not case sensitive.
		/// Pattern: ^[-0-9a-zA-Z_]{1,31}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[-0-9a-zA-Z_]{1,31}$")]
		public string Name { get; set; }
		
		/// <summary>
		/// Properties of the Storage Target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public StorageTargetProperties Properties { get; set; }
		
		/// <summary>
		/// Type of the Storage Target; Microsoft.StorageCache/Cache/StorageTarget
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class StorageTargetProperties
	{
		
		/// <summary>
		/// Storage container for use as a CLFS Storage Target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clfs")]
		public ClfsTarget Clfs { get; set; }
		
		/// <summary>
		/// List of Cache namespace junctions to target for namespace associations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="junctions")]
		public NamespaceJunction[] Junctions { get; set; }
		
		/// <summary>
		/// An NFSv3 mount point for use as a Storage Target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nfs3")]
		public Nfs3Target Nfs3 { get; set; }
		
		/// <summary>
		/// ARM provisioning state, see https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/Addendum.md#provisioningstate-property
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioningState")]
		public CachePropertiesProvisioningState ProvisioningState { get; set; }
		
		/// <summary>
		/// Type of the Storage Target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetType")]
		public System.Nullable<StorageTargetPropertiesTargetType> TargetType { get; set; }
		
		/// <summary>
		/// Storage container for use as an Unknown Storage Target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unknown")]
		public UnknownTarget Unknown { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum StorageTargetPropertiesTargetType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		nfs3 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		clfs = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unknown = 2,
	}
	
	/// <summary>
	/// Storage container for use as an Unknown Storage Target.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class UnknownTarget
	{
		
		/// <summary>
		/// Properties of an unknown type of Storage Target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unknownMap")]
		public UnknownProperties UnknownMap { get; set; }
	}
	
	/// <summary>
	/// Properties of an unknown type of Storage Target.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class UnknownProperties
	{
	}
	
	/// <summary>
	/// A list of Storage Targets.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class StorageTargetsResult
	{
		
		/// <summary>
		/// The URI to fetch the next page of Storage Targets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// The list of Storage Targets defined for the Cache.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public StorageTarget[] Value { get; set; }
	}
	
	/// <summary>
	/// A usage model.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class UsageModel
	{
		
		/// <summary>
		/// Localized information describing this usage model.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="display")]
		public UsageModelDisplay Display { get; set; }
		
		/// <summary>
		/// Non-localized keyword name for this usage model.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modelName")]
		public string ModelName { get; set; }
		
		/// <summary>
		/// The type of Storage Target to which this model is applicable (only nfs3 as of this version).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetType")]
		public string TargetType { get; set; }
	}
	
	public class UsageModelDisplay
	{
		
		/// <summary>
		/// String to display for this usage model.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
	}
	
	/// <summary>
	/// A list of Cache usage models.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class UsageModelsResult
	{
		
		/// <summary>
		/// The URI to fetch the next page of Cache usage models.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// The list of usage models available for the subscription.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public UsageModel[] Value { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Lists all of the available Resource Provider operations.
		/// Operations_List providers/Microsoft.StorageCache/operations
		/// </summary>
		/// <param name="api_version">Client API version.</param>
		/// <returns>The list of available Resource Provider operations.</returns>
		public async Task<ApiOperationListResult> Operations_ListAsync(string api_version)
		{
			var requestUri = "providers/Microsoft.StorageCache/operations?api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApiOperationListResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all Caches the user has access to under a subscription.
		/// Caches_List subscriptions/{subscriptionId}/providers/Microsoft.StorageCache/caches
		/// </summary>
		/// <param name="api_version">Client API version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>A list of Cache objects. Note that entity references might replace complete Cache objects, as described in http://docs.oasis-open.org/odata/odata-json-format/v4.01/cs01/odata-json-format-v4.01-cs01.html#sec_EntityReference</returns>
		public async Task<CachesListResult> Caches_ListAsync(string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.StorageCache/caches?api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CachesListResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the list of StorageCache.Cache SKUs available to this subscription.
		/// Skus_List subscriptions/{subscriptionId}/providers/Microsoft.StorageCache/skus
		/// </summary>
		/// <param name="api_version">Client API version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>A list of SKU descriptors.</returns>
		public async Task<ResourceSkusResult> Skus_ListAsync(string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.StorageCache/skus?api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ResourceSkusResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the list of Cache Usage Models available to this subscription.
		/// UsageModels_List subscriptions/{subscriptionId}/providers/Microsoft.StorageCache/usageModels
		/// </summary>
		/// <param name="api_version">Client API version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>A list of UsageModel descriptors.</returns>
		public async Task<UsageModelsResult> UsageModels_ListAsync(string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.StorageCache/usageModels?api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UsageModelsResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all Caches the user has access to under a resource group.
		/// Caches_ListByResourceGroup subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches
		/// </summary>
		/// <param name="resourceGroupName">Target resource group.</param>
		/// <param name="api_version">Client API version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>A list of Cache objects. Note that entity references might replace complete Cache objects, as described in http://docs.oasis-open.org/odata/odata-json-format/v4.01/cs01/odata-json-format-v4.01-cs01.html#sec_EntityReference</returns>
		public async Task<CachesListResult> Caches_ListByResourceGroupAsync(string resourceGroupName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourcegroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.StorageCache/caches&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CachesListResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a Cache.
		/// Caches_Get subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}
		/// </summary>
		/// <param name="resourceGroupName">Target resource group.</param>
		/// <param name="cacheName">Name of Cache.</param>
		/// <param name="api_version">Client API version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>Returns the Cache object corresponding to cacheName.</returns>
		public async Task<Cache> Caches_GetAsync(string resourceGroupName, string cacheName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourcegroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.StorageCache/caches/"+ (cacheName==null? "" : System.Uri.EscapeDataString(cacheName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Cache>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or update a Cache.
		/// Caches_CreateOrUpdate subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}
		/// </summary>
		/// <param name="resourceGroupName">Target resource group.</param>
		/// <param name="api_version">Client API version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="cacheName">Name of Cache.</param>
		/// <param name="requestBody">Object containing the user-selectable properties of the new Cache. If read-only properties are included, they must match the existing values of those properties.</param>
		/// <returns>Cache created or updated.</returns>
		public async Task<Cache> Caches_CreateOrUpdateAsync(string resourceGroupName, string api_version, string subscriptionId, string cacheName, Cache requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourcegroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.StorageCache/caches/"+ (cacheName==null? "" : System.Uri.EscapeDataString(cacheName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Cache>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Schedules a Cache for deletion.
		/// Caches_Delete subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}
		/// </summary>
		/// <param name="resourceGroupName">Target resource group.</param>
		/// <param name="cacheName">Name of Cache.</param>
		/// <param name="api_version">Client API version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>Cache deleted.</returns>
		public async Task<object> Caches_DeleteAsync(string resourceGroupName, string cacheName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourcegroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.StorageCache/caches/"+ (cacheName==null? "" : System.Uri.EscapeDataString(cacheName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a Cache instance.
		/// Caches_Update subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}
		/// </summary>
		/// <param name="resourceGroupName">Target resource group.</param>
		/// <param name="api_version">Client API version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="cacheName">Name of Cache.</param>
		/// <param name="requestBody">Object containing the user-selectable properties of the Cache. If read-only properties are included, they must match the existing values of those properties.</param>
		/// <returns>Updated the Cache.</returns>
		public async Task<Cache> Caches_UpdateAsync(string resourceGroupName, string api_version, string subscriptionId, string cacheName, Cache requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourcegroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.StorageCache/caches/"+ (cacheName==null? "" : System.Uri.EscapeDataString(cacheName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Cache>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Tells a Cache to write all dirty data to the Storage Target(s). During the flush, clients will see errors returned until the flush is complete.
		/// Caches_Flush subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/flush
		/// </summary>
		/// <param name="resourceGroupName">Target resource group.</param>
		/// <param name="api_version">Client API version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="cacheName">Name of Cache.</param>
		/// <returns>All cached data has been flushed to the Storage Target(s).</returns>
		public async Task<object> Caches_FlushAsync(string resourceGroupName, string api_version, string subscriptionId, string cacheName)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourcegroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.StorageCache/caches/"+ (cacheName==null? "" : System.Uri.EscapeDataString(cacheName))+"/flush&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Tells a Stopped state Cache to transition to Active state.
		/// Caches_Start subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/start
		/// </summary>
		/// <param name="resourceGroupName">Target resource group.</param>
		/// <param name="api_version">Client API version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="cacheName">Name of Cache.</param>
		/// <returns>Cache is Active.</returns>
		public async Task<object> Caches_StartAsync(string resourceGroupName, string api_version, string subscriptionId, string cacheName)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourcegroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.StorageCache/caches/"+ (cacheName==null? "" : System.Uri.EscapeDataString(cacheName))+"/start&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Tells an Active Cache to transition to Stopped state.
		/// Caches_Stop subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/stop
		/// </summary>
		/// <param name="resourceGroupName">Target resource group.</param>
		/// <param name="api_version">Client API version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="cacheName">Name of Cache.</param>
		/// <returns>Cache is stopped.</returns>
		public async Task<object> Caches_StopAsync(string resourceGroupName, string api_version, string subscriptionId, string cacheName)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourcegroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.StorageCache/caches/"+ (cacheName==null? "" : System.Uri.EscapeDataString(cacheName))+"/stop&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of Storage Targets for the specified Cache.
		/// StorageTargets_ListByCache subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets
		/// </summary>
		/// <param name="resourceGroupName">Target resource group.</param>
		/// <param name="api_version">Client API version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="cacheName">Name of Cache.</param>
		/// <returns>Returns the list of Storage Targets defined by cacheName.</returns>
		public async Task<StorageTargetsResult> StorageTargets_ListByCacheAsync(string resourceGroupName, string api_version, string subscriptionId, string cacheName)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourcegroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.StorageCache/caches/"+ (cacheName==null? "" : System.Uri.EscapeDataString(cacheName))+"/storageTargets&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<StorageTargetsResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a Storage Target from a Cache.
		/// StorageTargets_Get subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}
		/// </summary>
		/// <param name="resourceGroupName">Target resource group.</param>
		/// <param name="api_version">Client API version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="cacheName">Name of Cache.</param>
		/// <param name="storageTargetName">Name of the Storage Target.</param>
		/// <returns>Returns the Storage Target object corresponding to storageTargetName.</returns>
		public async Task<StorageTarget> StorageTargets_GetAsync(string resourceGroupName, string api_version, string subscriptionId, string cacheName, string storageTargetName)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourcegroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.StorageCache/caches/"+ (cacheName==null? "" : System.Uri.EscapeDataString(cacheName))+"/storageTargets/"+ (storageTargetName==null? "" : System.Uri.EscapeDataString(storageTargetName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<StorageTarget>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or update a Storage Target. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual creation/modification of the Storage Target may be delayed until the Cache is healthy again.
		/// StorageTargets_CreateOrUpdate subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}
		/// </summary>
		/// <param name="resourceGroupName">Target resource group.</param>
		/// <param name="api_version">Client API version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="cacheName">Name of Cache.</param>
		/// <param name="storageTargetName">Name of the Storage Target.</param>
		/// <param name="requestBody">Object containing the definition of a Storage Target.</param>
		/// <returns>Storage Target has been created or updated.</returns>
		public async Task<StorageTarget> StorageTargets_CreateOrUpdateAsync(string resourceGroupName, string api_version, string subscriptionId, string cacheName, string storageTargetName, StorageTarget requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourcegroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.StorageCache/caches/"+ (cacheName==null? "" : System.Uri.EscapeDataString(cacheName))+"/storageTargets/"+ (storageTargetName==null? "" : System.Uri.EscapeDataString(storageTargetName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<StorageTarget>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes a Storage Target from a Cache. This operation is allowed at any time, but if the Cache is down or unhealthy, the actual removal of the Storage Target may be delayed until the Cache is healthy again. Note that if the Cache has data to flush to the Storage Target, the data will be flushed before the Storage Target will be deleted.
		/// StorageTargets_Delete subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}
		/// </summary>
		/// <param name="resourceGroupName">Target resource group.</param>
		/// <param name="api_version">Client API version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="cacheName">Name of Cache.</param>
		/// <param name="storageTargetName">Name of Storage Target.</param>
		/// <returns>Storage target deleted.</returns>
		public async Task<object> StorageTargets_DeleteAsync(string resourceGroupName, string api_version, string subscriptionId, string cacheName, string storageTargetName)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourcegroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.StorageCache/caches/"+ (cacheName==null? "" : System.Uri.EscapeDataString(cacheName))+"/storageTargets/"+ (storageTargetName==null? "" : System.Uri.EscapeDataString(storageTargetName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<object>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Upgrade a Cache's firmware if a new version is available. Otherwise, this operation has no effect.
		/// Caches_UpgradeFirmware subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/upgrade
		/// </summary>
		/// <param name="resourceGroupName">Target resource group.</param>
		/// <param name="api_version">Client API version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="cacheName">Name of Cache.</param>
		public async Task Caches_UpgradeFirmwareAsync(string resourceGroupName, string api_version, string subscriptionId, string cacheName)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourcegroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.StorageCache/caches/"+ (cacheName==null? "" : System.Uri.EscapeDataString(cacheName))+"/upgrade&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
