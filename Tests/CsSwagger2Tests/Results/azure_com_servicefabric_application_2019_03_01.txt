//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Describes capacity information for a custom resource balancing metric. This can be used to limit the total consumption of this metric by the services of this application.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplicationMetricDescription
	{
		
		/// <summary>
		/// The maximum node capacity for Service Fabric application.
		///This is the maximum Load for an instance of this application on a single node. Even if the capacity of node is greater than this value, Service Fabric will limit the total load of services within the application on each node to this value.
		///If set to zero, capacity for this metric is unlimited on each node.
		///When creating a new application with application capacity defined, the product of MaximumNodes and this value must always be smaller than or equal to TotalApplicationCapacity.
		///When updating existing application with application capacity, the product of MaximumNodes and this value must always be smaller than or equal to TotalApplicationCapacity.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumCapacity")]
		public System.Nullable<System.Int64> MaximumCapacity { get; set; }
		
		/// <summary>
		/// The name of the metric.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The node reservation capacity for Service Fabric application.
		///This is the amount of load which is reserved on nodes which have instances of this application.
		///If MinimumNodes is specified, then the product of these values will be the capacity reserved in the cluster for the application.
		///If set to zero, no capacity is reserved for this metric.
		///When setting application capacity or when updating application capacity; this value must be smaller than or equal to MaximumCapacity for each metric.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservationCapacity")]
		public System.Nullable<System.Int64> ReservationCapacity { get; set; }
		
		/// <summary>
		/// The total metric capacity for Service Fabric application.
		///This is the total metric capacity for this application in the cluster. Service Fabric will try to limit the sum of loads of services within the application to this value.
		///When creating a new application with application capacity defined, the product of MaximumNodes and MaximumCapacity must always be smaller than or equal to this value.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalApplicationCapacity")]
		public System.Nullable<System.Int64> TotalApplicationCapacity { get; set; }
	}
	
	/// <summary>
	/// List of application parameters with overridden values from their default values specified in the application manifest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplicationParameterList
	{
	}
	
	/// <summary>
	/// The application resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplicationResource : ProxyResource
	{
		
		/// <summary>
		/// The application resource properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public ApplicationResourceProperties Properties { get; set; }
	}
	
	/// <summary>
	/// The list of application resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplicationResourceList
	{
		
		/// <summary>
		/// URL to get the next set of application list results if there are any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public ApplicationResource[] Value { get; set; }
	}
	
	/// <summary>
	/// The application resource properties.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplicationResourceProperties : ApplicationResourceUpdateProperties
	{
		
		/// <summary>
		/// The current deployment or provisioning state, which only appears in the response
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioningState")]
		public string ProvisioningState { get; set; }
		
		/// <summary>
		/// The application type name as defined in the application manifest.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="typeName")]
		public string TypeName { get; set; }
	}
	
	/// <summary>
	/// The application resource for patch operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplicationResourceUpdate : ProxyResource
	{
		
		/// <summary>
		/// The application resource properties for patch operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public ApplicationResourceUpdateProperties Properties { get; set; }
	}
	
	/// <summary>
	/// The application resource properties for patch operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplicationResourceUpdateProperties
	{
		
		/// <summary>
		/// The maximum number of nodes where Service Fabric will reserve capacity for this application. Note that this does not mean that the services of this application will be placed on all of those nodes. By default, the value of this property is zero and it means that the services can be placed on any node.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumNodes")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public System.Nullable<System.Int64> MaximumNodes { get; set; }
		
		/// <summary>
		/// List of application capacity metric description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metrics")]
		public ApplicationMetricDescription[] Metrics { get; set; }
		
		/// <summary>
		/// The minimum number of nodes where Service Fabric will reserve capacity for this application. Note that this does not mean that the services of this application will be placed on all of those nodes. If this property is set to zero, no capacity will be reserved. The value of this property cannot be more than the value of the MaximumNodes property.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumNodes")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public System.Nullable<System.Int64> MinimumNodes { get; set; }
		
		/// <summary>
		/// List of application parameters with overridden values from their default values specified in the application manifest.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parameters")]
		public ApplicationParameterList Parameters { get; set; }
		
		/// <summary>
		/// Remove the current application capacity settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="removeApplicationCapacity")]
		public System.Nullable<System.Boolean> RemoveApplicationCapacity { get; set; }
		
		/// <summary>
		/// The version of the application type as defined in the application manifest.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="typeVersion")]
		public string TypeVersion { get; set; }
		
		/// <summary>
		/// Describes the policy for a monitored application upgrade.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradePolicy")]
		public ApplicationUpgradePolicy UpgradePolicy { get; set; }
	}
	
	/// <summary>
	/// List of application type parameters that can be overridden when creating or updating the application.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplicationTypeParameterList
	{
	}
	
	/// <summary>
	/// The application type name resource
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplicationTypeResource : ProxyResource
	{
		
		/// <summary>
		/// The application type name properties
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public ApplicationTypeResourceProperties Properties { get; set; }
	}
	
	/// <summary>
	/// The list of application type names.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplicationTypeResourceList
	{
		
		/// <summary>
		/// URL to get the next set of application type list results if there are any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public ApplicationTypeResource[] Value { get; set; }
	}
	
	/// <summary>
	/// The application type name properties
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplicationTypeResourceProperties
	{
		
		/// <summary>
		/// The current deployment or provisioning state, which only appears in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioningState")]
		public string ProvisioningState { get; set; }
	}
	
	/// <summary>
	/// An application type version resource for the specified application type name resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplicationTypeVersionResource : ProxyResource
	{
		
		/// <summary>
		/// The properties of the application type version resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public ApplicationTypeVersionResourceProperties Properties { get; set; }
	}
	
	/// <summary>
	/// The list of application type version resources for the specified application type name resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplicationTypeVersionResourceList
	{
		
		/// <summary>
		/// URL to get the next set of application type version list results if there are any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public ApplicationTypeVersionResource[] Value { get; set; }
	}
	
	/// <summary>
	/// The properties of the application type version resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplicationTypeVersionResourceProperties
	{
		
		/// <summary>
		/// The URL to the application package
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="appPackageUrl")]
		public string AppPackageUrl { get; set; }
		
		/// <summary>
		/// List of application type parameters that can be overridden when creating or updating the application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultParameterList")]
		public ApplicationTypeParameterList DefaultParameterList { get; set; }
		
		/// <summary>
		/// The current deployment or provisioning state, which only appears in the response
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioningState")]
		public string ProvisioningState { get; set; }
	}
	
	/// <summary>
	/// Describes the policy for a monitored application upgrade.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplicationUpgradePolicy
	{
		
		/// <summary>
		/// Defines a health policy used to evaluate the health of an application or one of its children entities.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applicationHealthPolicy")]
		public ArmApplicationHealthPolicy ApplicationHealthPolicy { get; set; }
		
		/// <summary>
		/// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forceRestart")]
		public System.Nullable<System.Boolean> ForceRestart { get; set; }
		
		/// <summary>
		/// The policy used for monitoring the application upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rollingUpgradeMonitoringPolicy")]
		public ArmRollingUpgradeMonitoringPolicy RollingUpgradeMonitoringPolicy { get; set; }
		
		/// <summary>
		/// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradeReplicaSetCheckTimeout")]
		public string UpgradeReplicaSetCheckTimeout { get; set; }
	}
	
	/// <summary>
	/// Defines a health policy used to evaluate the health of an application or one of its children entities.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ArmApplicationHealthPolicy
	{
		
		/// <summary>
		/// Indicates whether warnings are treated with the same severity as errors.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="considerWarningAsError")]
		public System.Nullable<System.Boolean> ConsiderWarningAsError { get; set; }
		
		/// <summary>
		/// Represents the health policy used to evaluate the health of services belonging to a service type.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultServiceTypeHealthPolicy")]
		public ArmServiceTypeHealthPolicy DefaultServiceTypeHealthPolicy { get; set; }
		
		/// <summary>
		/// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
		///The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
		///This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
		///The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPercentUnhealthyDeployedApplications")]
		public System.Nullable<System.Int32> MaxPercentUnhealthyDeployedApplications { get; set; }
		
		/// <summary>
		/// Defines a ServiceTypeHealthPolicy per service type name.
		///
		///The entries in the map replace the default service type health policy for each specified service type.
		///For example, in an application that contains both a stateless gateway service type and a stateful engine service type, the health policies for the stateless and stateful services can be configured differently.
		///With policy per service type, there's more granular control of the health of the service.
		///
		///If no policy is specified for a service type name, the DefaultServiceTypeHealthPolicy is used for evaluation.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceTypeHealthPolicyMap")]
		public ArmServiceTypeHealthPolicyMap ServiceTypeHealthPolicyMap { get; set; }
	}
	
	/// <summary>
	/// Represents the health policy used to evaluate the health of services belonging to a service type.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ArmServiceTypeHealthPolicy
	{
		
		/// <summary>
		/// The maximum percentage of partitions per service allowed to be unhealthy before your application is considered in error.
		///
		/// Minimum: 0
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPercentUnhealthyPartitionsPerService")]
		[System.ComponentModel.DataAnnotations.Range(0, 100)]
		public System.Nullable<System.Int32> MaxPercentUnhealthyPartitionsPerService { get; set; }
		
		/// <summary>
		/// The maximum percentage of replicas per partition allowed to be unhealthy before your application is considered in error.
		///
		/// Minimum: 0
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPercentUnhealthyReplicasPerPartition")]
		[System.ComponentModel.DataAnnotations.Range(0, 100)]
		public System.Nullable<System.Int32> MaxPercentUnhealthyReplicasPerPartition { get; set; }
		
		/// <summary>
		/// The maximum percentage of services allowed to be unhealthy before your application is considered in error.
		///
		/// Minimum: 0
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPercentUnhealthyServices")]
		[System.ComponentModel.DataAnnotations.Range(0, 100)]
		public System.Nullable<System.Int32> MaxPercentUnhealthyServices { get; set; }
	}
	
	/// <summary>
	/// Defines a ServiceTypeHealthPolicy per service type name.
	///
	///The entries in the map replace the default service type health policy for each specified service type.
	///For example, in an application that contains both a stateless gateway service type and a stateful engine service type, the health policies for the stateless and stateful services can be configured differently.
	///With policy per service type, there's more granular control of the health of the service.
	///
	///If no policy is specified for a service type name, the DefaultServiceTypeHealthPolicy is used for evaluation.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ArmServiceTypeHealthPolicyMap
	{
	}
	
	/// <summary>
	/// The policy used for monitoring the application upgrade
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ArmRollingUpgradeMonitoringPolicy
	{
		
		/// <summary>
		/// The activation Mode of the service package
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failureAction")]
		public System.Nullable<ArmRollingUpgradeMonitoringPolicyFailureAction> FailureAction { get; set; }
		
		/// <summary>
		/// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.
		/// </summary>
		[System.ComponentModel.DefaultValue("PT0H10M0S")]
		[System.Runtime.Serialization.DataMember(Name="healthCheckRetryTimeout")]
		public string HealthCheckRetryTimeout { get; set; } = "PT0H10M0S";
		
		/// <summary>
		/// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.
		/// </summary>
		[System.ComponentModel.DefaultValue("PT0H2M0S")]
		[System.Runtime.Serialization.DataMember(Name="healthCheckStableDuration")]
		public string HealthCheckStableDuration { get; set; } = "PT0H2M0S";
		
		/// <summary>
		/// The amount of time to wait after completing an upgrade domain before applying health policies. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.
		/// </summary>
		[System.ComponentModel.DefaultValue("0")]
		[System.Runtime.Serialization.DataMember(Name="healthCheckWaitDuration")]
		public string HealthCheckWaitDuration { get; set; } = "0";
		
		/// <summary>
		/// The amount of time each upgrade domain has to complete before FailureAction is executed. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.
		/// </summary>
		[System.ComponentModel.DefaultValue("P10675199DT02H48M05.4775807S")]
		[System.Runtime.Serialization.DataMember(Name="upgradeDomainTimeout")]
		public string UpgradeDomainTimeout { get; set; } = "P10675199DT02H48M05.4775807S";
		
		/// <summary>
		/// The amount of time the overall upgrade has to complete before FailureAction is executed. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.
		/// </summary>
		[System.ComponentModel.DefaultValue("P10675199DT02H48M05.4775807S")]
		[System.Runtime.Serialization.DataMember(Name="upgradeTimeout")]
		public string UpgradeTimeout { get; set; } = "P10675199DT02H48M05.4775807S";
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ArmRollingUpgradeMonitoringPolicyFailureAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Rollback = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Manual = 1,
	}
	
	/// <summary>
	/// Operation supported by the Service Fabric resource provider
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class AvailableOperationDisplay
	{
		
		/// <summary>
		/// Operation description
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The operation that can be performed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operation")]
		public string Operation { get; set; }
		
		/// <summary>
		/// The name of the provider.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provider")]
		public string Provider { get; set; }
		
		/// <summary>
		/// The resource on which the operation is performed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
	}
	
	/// <summary>
	/// Creates a particular correlation between services.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ServiceCorrelationDescription
	{
		
		/// <summary>
		/// The service correlation scheme.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scheme")]
		public ServiceCorrelationDescriptionScheme Scheme { get; set; }
		
		/// <summary>
		/// The full name of the service with 'fabric:' URI scheme.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serviceName")]
		public string ServiceName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ServiceCorrelationDescriptionScheme
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Invalid = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Affinity = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AlignedAffinity = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NonAlignedAffinity = 3,
	}
	
	/// <summary>
	/// The structure of the error.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ErrorModel
	{
		
		/// <summary>
		/// The error details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public ErrorModelError Error { get; set; }
	}
	
	/// <summary>
	/// The error details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ErrorModelError
	{
		
		/// <summary>
		/// The error code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// The error message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// Specifies the move cost for the service.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum MoveCost
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Zero = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Low = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Medium = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		High = 3,
	}
	
	/// <summary>
	/// Describes the named partition scheme of the service.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class NamedPartitionSchemeDescription : PartitionSchemeDescription
	{
		
		/// <summary>
		/// The number of partitions.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Count { get; set; }
		
		/// <summary>
		/// Array of size specified by the ‘Count’ parameter, for the names of the partitions.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] Names { get; set; }
	}
	
	/// <summary>
	/// Describes the result of the request to list Service Fabric resource provider operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class OperationListResult
	{
		
		/// <summary>
		/// URL to get the next set of operation list results if there are any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// List of operations supported by the Service Fabric resource provider.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public OperationResult[] Value { get; set; }
	}
	
	/// <summary>
	/// Available operation list result
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class OperationResult
	{
		
		/// <summary>
		/// Operation supported by the Service Fabric resource provider
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="display")]
		public AvailableOperationDisplay Display { get; set; }
		
		/// <summary>
		/// The name of the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The URL to use for getting the next set of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// Origin result
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public string Origin { get; set; }
	}
	
	/// <summary>
	/// Enumerates the ways that a service can be partitioned.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum PartitionScheme
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Invalid = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Singleton = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UniformInt64Range = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Named = 3,
	}
	
	/// <summary>
	/// Describes how the service is partitioned.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class PartitionSchemeDescription
	{
		
		/// <summary>
		/// Enumerates the ways that a service can be partitioned.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="partitionScheme")]
		public PartitionScheme PartitionScheme { get; set; }
	}
	
	/// <summary>
	/// The resource model definition for proxy-only resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ProxyResource
	{
		
		/// <summary>
		/// Azure resource etag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// Azure resource identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// It will be deprecated in New API, resource location depends on the parent resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Azure resource name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Azure resource tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
		
		/// <summary>
		/// Azure resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// The service correlation scheme.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ServiceCorrelationScheme
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Invalid = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Affinity = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AlignedAffinity = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NonAlignedAffinity = 3,
	}
	
	/// <summary>
	/// The kind of service (Stateless or Stateful).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ServiceKind
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Invalid = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Stateless = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Stateful = 2,
	}
	
	/// <summary>
	/// Specifies a metric to load balance a service during runtime.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ServiceLoadMetricDescription
	{
		
		/// <summary>
		/// Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultLoad")]
		public System.Nullable<System.Int32> DefaultLoad { get; set; }
		
		/// <summary>
		/// The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified in Name exactly. Note that metric names are case sensitive.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primaryDefaultLoad")]
		public System.Nullable<System.Int32> PrimaryDefaultLoad { get; set; }
		
		/// <summary>
		/// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondaryDefaultLoad")]
		public System.Nullable<System.Int32> SecondaryDefaultLoad { get; set; }
		
		/// <summary>
		/// Determines the metric weight relative to the other metrics that are configured for this service. During runtime, if two metrics end up in conflict, the Cluster Resource Manager prefers the metric with the higher weight.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="weight")]
		public MoveCost Weight { get; set; }
	}
	
	/// <summary>
	/// Determines the metric weight relative to the other metrics that are configured for this service. During runtime, if two metrics end up in conflict, the Cluster Resource Manager prefers the metric with the higher weight.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ServiceLoadMetricWeight
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Zero = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Low = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Medium = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		High = 3,
	}
	
	/// <summary>
	/// Describes the policy to be used for placement of a Service Fabric service.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ServicePlacementPolicyDescription
	{
		
		/// <summary>
		/// The type of placement policy for a service fabric service. Following are the possible values.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ServicePlacementPolicyDescriptionType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ServicePlacementPolicyDescriptionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Invalid = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		InvalidDomain = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RequiredDomain = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PreferredPrimaryDomain = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RequiredDomainDistribution = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NonPartiallyPlaceService = 5,
	}
	
	/// <summary>
	/// The type of placement policy for a service fabric service. Following are the possible values.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ServicePlacementPolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Invalid = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		InvalidDomain = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RequiredDomain = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PreferredPrimaryDomain = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RequiredDomainDistribution = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NonPartiallyPlaceService = 5,
	}
	
	/// <summary>
	/// The service resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ServiceResource : ProxyResource
	{
		
		/// <summary>
		/// The service resource properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public ServiceResourceProperties Properties { get; set; }
	}
	
	/// <summary>
	/// The list of service resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ServiceResourceList
	{
		
		/// <summary>
		/// URL to get the next set of service list results if there are any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public ServiceResource[] Value { get; set; }
	}
	
	/// <summary>
	/// The service resource properties.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ServiceResourceProperties : ServiceResourcePropertiesBase
	{
		
		/// <summary>
		/// Describes how the service is partitioned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="partitionDescription")]
		public PartitionSchemeDescription PartitionDescription { get; set; }
		
		/// <summary>
		/// The current deployment or provisioning state, which only appears in the response
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioningState")]
		public string ProvisioningState { get; set; }
		
		/// <summary>
		/// The kind of service (Stateless or Stateful).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serviceKind")]
		public ServiceKind ServiceKind { get; set; }
		
		/// <summary>
		/// The activation Mode of the service package
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="servicePackageActivationMode")]
		public System.Nullable<ServiceResourcePropertiesServicePackageActivationMode> ServicePackageActivationMode { get; set; }
		
		/// <summary>
		/// The name of the service type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceTypeName")]
		public string ServiceTypeName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ServiceResourcePropertiesServicePackageActivationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SharedProcess = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ExclusiveProcess = 1,
	}
	
	/// <summary>
	/// The common service resource properties.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ServiceResourcePropertiesBase
	{
		
		/// <summary>
		/// A list that describes the correlation of the service with other services.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="correlationScheme")]
		public ServiceCorrelationDescription[] CorrelationScheme { get; set; }
		
		/// <summary>
		/// Specifies the move cost for the service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultMoveCost")]
		public MoveCost DefaultMoveCost { get; set; }
		
		/// <summary>
		/// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="placementConstraints")]
		public string PlacementConstraints { get; set; }
		
		/// <summary>
		/// The service load metrics is given as an array of ServiceLoadMetricDescription objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceLoadMetrics")]
		public ServiceLoadMetricDescription[] ServiceLoadMetrics { get; set; }
		
		/// <summary>
		/// A list that describes the correlation of the service with other services.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="servicePlacementPolicies")]
		public ServicePlacementPolicyDescription[] ServicePlacementPolicies { get; set; }
	}
	
	/// <summary>
	/// The service resource for patch operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ServiceResourceUpdate : ProxyResource
	{
		
		/// <summary>
		/// The service resource properties for patch operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public ServiceResourceUpdateProperties Properties { get; set; }
	}
	
	/// <summary>
	/// The service resource properties for patch operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ServiceResourceUpdateProperties : ServiceResourcePropertiesBase
	{
		
		/// <summary>
		/// The kind of service (Stateless or Stateful).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serviceKind")]
		public ServiceKind ServiceKind { get; set; }
	}
	
	/// <summary>
	/// Describes the partition scheme of a singleton-partitioned, or non-partitioned service.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class SingletonPartitionSchemeDescription : PartitionSchemeDescription
	{
	}
	
	/// <summary>
	/// The properties of a stateful service resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class StatefulServiceProperties : ServiceResourceProperties
	{
		
		/// <summary>
		/// A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasPersistedState")]
		public System.Nullable<System.Boolean> HasPersistedState { get; set; }
		
		/// <summary>
		/// The minimum replica set size as a number.
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minReplicaSetSize")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> MinReplicaSetSize { get; set; }
		
		/// <summary>
		/// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format (hh:mm:ss.s).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quorumLossWaitDuration")]
		public System.Nullable<System.DateTimeOffset> QuorumLossWaitDuration { get; set; }
		
		/// <summary>
		/// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format (hh:mm:ss.s).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replicaRestartWaitDuration")]
		public System.Nullable<System.DateTimeOffset> ReplicaRestartWaitDuration { get; set; }
		
		/// <summary>
		/// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format (hh:mm:ss.s).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="standByReplicaKeepDuration")]
		public System.Nullable<System.DateTimeOffset> StandByReplicaKeepDuration { get; set; }
		
		/// <summary>
		/// The target replica set size as a number.
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetReplicaSetSize")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> TargetReplicaSetSize { get; set; }
	}
	
	/// <summary>
	/// The properties of a stateful service resource for patch operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class StatefulServiceUpdateProperties : ServiceResourceUpdateProperties
	{
		
		/// <summary>
		/// The minimum replica set size as a number.
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minReplicaSetSize")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> MinReplicaSetSize { get; set; }
		
		/// <summary>
		/// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format (hh:mm:ss.s).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quorumLossWaitDuration")]
		public System.Nullable<System.DateTimeOffset> QuorumLossWaitDuration { get; set; }
		
		/// <summary>
		/// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format (hh:mm:ss.s).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replicaRestartWaitDuration")]
		public System.Nullable<System.DateTimeOffset> ReplicaRestartWaitDuration { get; set; }
		
		/// <summary>
		/// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format (hh:mm:ss.s).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="standByReplicaKeepDuration")]
		public System.Nullable<System.DateTimeOffset> StandByReplicaKeepDuration { get; set; }
		
		/// <summary>
		/// The target replica set size as a number.
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetReplicaSetSize")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> TargetReplicaSetSize { get; set; }
	}
	
	/// <summary>
	/// The properties of a stateless service resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class StatelessServiceProperties : ServiceResourceProperties
	{
		
		/// <summary>
		/// The instance count.
		/// Minimum: -1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceCount")]
		[System.ComponentModel.DataAnnotations.Range(-1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> InstanceCount { get; set; }
	}
	
	/// <summary>
	/// The properties of a stateless service resource for patch operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class StatelessServiceUpdateProperties : ServiceResourceUpdateProperties
	{
		
		/// <summary>
		/// The instance count.
		/// Minimum: -1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceCount")]
		[System.ComponentModel.DataAnnotations.Range(-1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> InstanceCount { get; set; }
	}
	
	/// <summary>
	/// Describes a partitioning scheme where an integer range is allocated evenly across a number of partitions.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class UniformInt64RangePartitionSchemeDescription : PartitionSchemeDescription
	{
		
		/// <summary>
		/// The number of partitions.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Count { get; set; }
		
		/// <summary>
		/// String indicating the upper bound of the partition key range that
		///should be split between the partition ‘Count’
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string HighKey { get; set; }
		
		/// <summary>
		/// String indicating the lower bound of the partition key range that
		///should be split between the partition ‘Count’
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string LowKey { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Lists all of the available Service Fabric resource provider API operations.
		/// Get the list of available Service Fabric resource provider API operations.
		/// Operations_List providers/Microsoft.ServiceFabric/operations
		/// </summary>
		/// <param name="api_version">The version of the Service Fabric resource provider API</param>
		/// <returns>OK. The request has succeeded.</returns>
		public async Task<OperationListResult> Operations_ListAsync(string api_version)
		{
			var requestUri = "providers/Microsoft.ServiceFabric/operations?api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OperationListResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the list of application type name resources created in the specified Service Fabric cluster resource.
		/// Gets all application type name resources created or in the process of being created in the Service Fabric cluster resource.
		/// ApplicationTypes_List subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applicationTypes
		/// </summary>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ApplicationTypeResourceList> ApplicationTypes_ListAsync(string subscriptionId, string resourceGroupName, string clusterName, ApplicationTypes_ListApi_version api_version)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"/applicationTypes&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApplicationTypeResourceList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a Service Fabric application type name resource.
		/// Get a Service Fabric application type name resource created or in the process of being created in the Service Fabric cluster resource.
		/// ApplicationTypes_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applicationTypes/{applicationTypeName}
		/// </summary>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="applicationTypeName">The name of the application type name resource.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ApplicationTypeResource> ApplicationTypes_GetAsync(string subscriptionId, string resourceGroupName, string clusterName, string applicationTypeName, ApplicationTypes_GetApi_version api_version)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"/applicationTypes/"+ (applicationTypeName==null? "" : System.Uri.EscapeDataString(applicationTypeName))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApplicationTypeResource>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates or updates a Service Fabric application type name resource.
		/// Create or update a Service Fabric application type name resource with the specified name.
		/// ApplicationTypes_CreateOrUpdate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applicationTypes/{applicationTypeName}
		/// </summary>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="applicationTypeName">The name of the application type name resource.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <param name="requestBody">The application type name resource.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ApplicationTypeResource> ApplicationTypes_CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string clusterName, string applicationTypeName, ApplicationTypes_CreateOrUpdateApi_version api_version, ApplicationTypeResource requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"/applicationTypes/"+ (applicationTypeName==null? "" : System.Uri.EscapeDataString(applicationTypeName))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApplicationTypeResource>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a Service Fabric application type name resource.
		/// Delete a Service Fabric application type name resource with the specified name.
		/// ApplicationTypes_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applicationTypes/{applicationTypeName}
		/// </summary>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="applicationTypeName">The name of the application type name resource.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		public async Task ApplicationTypes_DeleteAsync(string subscriptionId, string resourceGroupName, string clusterName, string applicationTypeName, ApplicationTypes_DeleteApi_version api_version)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"/applicationTypes/"+ (applicationTypeName==null? "" : System.Uri.EscapeDataString(applicationTypeName))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the list of application type version resources created in the specified Service Fabric application type name resource.
		/// Gets all application type version resources created or in the process of being created in the Service Fabric application type name resource.
		/// ApplicationTypeVersions_List subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applicationTypes/{applicationTypeName}/versions
		/// </summary>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="applicationTypeName">The name of the application type name resource.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ApplicationTypeVersionResourceList> ApplicationTypeVersions_ListAsync(string subscriptionId, string resourceGroupName, string clusterName, string applicationTypeName, ApplicationTypeVersions_ListApi_version api_version)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"/applicationTypes/"+ (applicationTypeName==null? "" : System.Uri.EscapeDataString(applicationTypeName))+"/versions&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApplicationTypeVersionResourceList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a Service Fabric application type version resource.
		/// Get a Service Fabric application type version resource created or in the process of being created in the Service Fabric application type name resource.
		/// ApplicationTypeVersions_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applicationTypes/{applicationTypeName}/versions/{version}
		/// </summary>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="applicationTypeName">The name of the application type name resource.</param>
		/// <param name="version">The application type version.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ApplicationTypeVersionResource> ApplicationTypeVersions_GetAsync(string subscriptionId, string resourceGroupName, string clusterName, string applicationTypeName, string version, ApplicationTypeVersions_GetApi_version api_version)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"/applicationTypes/"+ (applicationTypeName==null? "" : System.Uri.EscapeDataString(applicationTypeName))+"/versions/"+ (version==null? "" : System.Uri.EscapeDataString(version))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApplicationTypeVersionResource>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates or updates a Service Fabric application type version resource.
		/// Create or update a Service Fabric application type version resource with the specified name.
		/// ApplicationTypeVersions_CreateOrUpdate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applicationTypes/{applicationTypeName}/versions/{version}
		/// </summary>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="applicationTypeName">The name of the application type name resource.</param>
		/// <param name="version">The application type version.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <param name="requestBody">The application type version resource.</param>
		public async Task ApplicationTypeVersions_CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string clusterName, string applicationTypeName, string version, ApplicationTypeVersions_CreateOrUpdateApi_version api_version, ApplicationTypeVersionResource requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"/applicationTypes/"+ (applicationTypeName==null? "" : System.Uri.EscapeDataString(applicationTypeName))+"/versions/"+ (version==null? "" : System.Uri.EscapeDataString(version))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a Service Fabric application type version resource.
		/// Delete a Service Fabric application type version resource with the specified name.
		/// ApplicationTypeVersions_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applicationTypes/{applicationTypeName}/versions/{version}
		/// </summary>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="applicationTypeName">The name of the application type name resource.</param>
		/// <param name="version">The application type version.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		public async Task ApplicationTypeVersions_DeleteAsync(string subscriptionId, string resourceGroupName, string clusterName, string applicationTypeName, string version, ApplicationTypeVersions_DeleteApi_version api_version)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"/applicationTypes/"+ (applicationTypeName==null? "" : System.Uri.EscapeDataString(applicationTypeName))+"/versions/"+ (version==null? "" : System.Uri.EscapeDataString(version))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the list of application resources created in the specified Service Fabric cluster resource.
		/// Gets all application resources created or in the process of being created in the Service Fabric cluster resource.
		/// Applications_List subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications
		/// </summary>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ApplicationResourceList> Applications_ListAsync(string subscriptionId, string resourceGroupName, string clusterName, Applications_ListApi_version api_version)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"/applications&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApplicationResourceList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a Service Fabric application resource.
		/// Get a Service Fabric application resource created or in the process of being created in the Service Fabric cluster resource.
		/// Applications_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications/{applicationName}
		/// </summary>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="applicationName">The name of the application resource.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ApplicationResource> Applications_GetAsync(string subscriptionId, string resourceGroupName, string clusterName, string applicationName, Applications_GetApi_version api_version)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"/applications/"+ (applicationName==null? "" : System.Uri.EscapeDataString(applicationName))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApplicationResource>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates or updates a Service Fabric application resource.
		/// Create or update a Service Fabric application resource with the specified name.
		/// Applications_CreateOrUpdate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications/{applicationName}
		/// </summary>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="applicationName">The name of the application resource.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <param name="requestBody">The application resource.</param>
		public async Task Applications_CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string clusterName, string applicationName, Applications_CreateOrUpdateApi_version api_version, ApplicationResource requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"/applications/"+ (applicationName==null? "" : System.Uri.EscapeDataString(applicationName))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a Service Fabric application resource.
		/// Delete a Service Fabric application resource with the specified name.
		/// Applications_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications/{applicationName}
		/// </summary>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="applicationName">The name of the application resource.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		public async Task Applications_DeleteAsync(string subscriptionId, string resourceGroupName, string clusterName, string applicationName, Applications_DeleteApi_version api_version)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"/applications/"+ (applicationName==null? "" : System.Uri.EscapeDataString(applicationName))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a Service Fabric application resource.
		/// Update a Service Fabric application resource with the specified name.
		/// Applications_Update subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications/{applicationName}
		/// </summary>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="applicationName">The name of the application resource.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <param name="requestBody">The application resource for patch operations.</param>
		public async Task Applications_UpdateAsync(string subscriptionId, string resourceGroupName, string clusterName, string applicationName, Applications_UpdateApi_version api_version, ApplicationResourceUpdate requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"/applications/"+ (applicationName==null? "" : System.Uri.EscapeDataString(applicationName))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the list of service resources created in the specified Service Fabric application resource.
		/// Gets all service resources created or in the process of being created in the Service Fabric application resource.
		/// Services_List subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications/{applicationName}/services
		/// </summary>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="applicationName">The name of the application resource.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ServiceResourceList> Services_ListAsync(string subscriptionId, string resourceGroupName, string clusterName, string applicationName, Services_ListApi_version api_version)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"/applications/"+ (applicationName==null? "" : System.Uri.EscapeDataString(applicationName))+"/services&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ServiceResourceList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a Service Fabric service resource.
		/// Get a Service Fabric service resource created or in the process of being created in the Service Fabric application resource.
		/// Services_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications/{applicationName}/services/{serviceName}
		/// </summary>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="applicationName">The name of the application resource.</param>
		/// <param name="serviceName">The name of the service resource in the format of {applicationName}~{serviceName}.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ServiceResource> Services_GetAsync(string subscriptionId, string resourceGroupName, string clusterName, string applicationName, string serviceName, Services_GetApi_version api_version)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"/applications/"+ (applicationName==null? "" : System.Uri.EscapeDataString(applicationName))+"/services/"+ (serviceName==null? "" : System.Uri.EscapeDataString(serviceName))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ServiceResource>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates or updates a Service Fabric service resource.
		/// Create or update a Service Fabric service resource with the specified name.
		/// Services_CreateOrUpdate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications/{applicationName}/services/{serviceName}
		/// </summary>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="applicationName">The name of the application resource.</param>
		/// <param name="serviceName">The name of the service resource in the format of {applicationName}~{serviceName}.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <param name="requestBody">The service resource.</param>
		public async Task Services_CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string clusterName, string applicationName, string serviceName, Services_CreateOrUpdateApi_version api_version, ServiceResource requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"/applications/"+ (applicationName==null? "" : System.Uri.EscapeDataString(applicationName))+"/services/"+ (serviceName==null? "" : System.Uri.EscapeDataString(serviceName))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a Service Fabric service resource.
		/// Delete a Service Fabric service resource with the specified name.
		/// Services_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications/{applicationName}/services/{serviceName}
		/// </summary>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="applicationName">The name of the application resource.</param>
		/// <param name="serviceName">The name of the service resource in the format of {applicationName}~{serviceName}.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		public async Task Services_DeleteAsync(string subscriptionId, string resourceGroupName, string clusterName, string applicationName, string serviceName, Services_DeleteApi_version api_version)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"/applications/"+ (applicationName==null? "" : System.Uri.EscapeDataString(applicationName))+"/services/"+ (serviceName==null? "" : System.Uri.EscapeDataString(serviceName))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a Service Fabric service resource.
		/// Update a Service Fabric service resource with the specified name.
		/// Services_Update subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications/{applicationName}/services/{serviceName}
		/// </summary>
		/// <param name="subscriptionId">The customer subscription identifier.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="clusterName">The name of the cluster resource.</param>
		/// <param name="applicationName">The name of the application resource.</param>
		/// <param name="serviceName">The name of the service resource in the format of {applicationName}~{serviceName}.</param>
		/// <param name="api_version">The version of the Service Fabric resource provider API. This is a required parameter and it's value must be "2019-03-01" for this specification.</param>
		/// <param name="requestBody">The service resource for patch operations.</param>
		public async Task Services_UpdateAsync(string subscriptionId, string resourceGroupName, string clusterName, string applicationName, string serviceName, Services_UpdateApi_version api_version, ServiceResourceUpdate requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.ServiceFabric/clusters/"+ (clusterName==null? "" : System.Uri.EscapeDataString(clusterName))+"/applications/"+ (applicationName==null? "" : System.Uri.EscapeDataString(applicationName))+"/services/"+ (serviceName==null? "" : System.Uri.EscapeDataString(serviceName))+"&api-version=" + api_version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum ApplicationTypes_ListApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum ApplicationTypes_GetApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum ApplicationTypes_CreateOrUpdateApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum ApplicationTypes_DeleteApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum ApplicationTypeVersions_ListApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum ApplicationTypeVersions_GetApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum ApplicationTypeVersions_CreateOrUpdateApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum ApplicationTypeVersions_DeleteApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum Applications_ListApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum Applications_GetApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum Applications_CreateOrUpdateApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum Applications_DeleteApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum Applications_UpdateApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum Services_ListApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum Services_GetApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum Services_CreateOrUpdateApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum Services_DeleteApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
	
	public enum Services_UpdateApi_version
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2019-03-01")]
		_2019Minus03Minus01 = 0,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
