//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Error401
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Error401Meta Meta { get; set; }
	}
	
	public class Error401Meta
	{
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="links")]
		public string[] Links { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<System.Int32> Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Error403
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Error403Meta Meta { get; set; }
	}
	
	public class Error403Meta
	{
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="links")]
		public string[] Links { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<System.Int32> Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Error404
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Error404Meta Meta { get; set; }
	}
	
	public class Error404Meta
	{
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="links")]
		public string[] Links { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<System.Int32> Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Error410
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Error410Meta Meta { get; set; }
	}
	
	public class Error410Meta
	{
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="links")]
		public string[] Links { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<System.Int32> Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Error422
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Error422Meta Meta { get; set; }
	}
	
	public class Error422Meta
	{
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="links")]
		public string[] Links { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<System.Int32> Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Error422InvalidTimeFormat
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Error422InvalidTimeFormatMeta Meta { get; set; }
	}
	
	public class Error422InvalidTimeFormatMeta
	{
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="links")]
		public string[] Links { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<System.Int32> Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Spec
	{
		
		/// <summary>
		/// The base path on which the API is served, relative to the **host**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="basePath")]
		public string BasePath { get; set; }
		
		/// <summary>
		/// A list of MIME types that the API can consume.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="consumes")]
		public string[] Consumes { get; set; }
		
		/// <summary>
		/// The data types produced and consumed by operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="definitions")]
		public string Definitions { get; set; }
		
		/// <summary>
		/// Links to and descriptions of related external documentation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="externalDocs")]
		public string ExternalDocs { get; set; }
		
		/// <summary>
		/// The host (domain name or IP address) serving the API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// Metadata about the API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="info")]
		public string Info { get; set; }
		
		/// <summary>
		/// The paths and operations available to the API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="paths")]
		public string Paths { get; set; }
		
		/// <summary>
		/// A list of MIME types that the API can produce.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="produces")]
		public string[] Produces { get; set; }
		
		/// <summary>
		/// The transfer protocol being used by the API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schemes")]
		public string[] Schemes { get; set; }
		
		/// <summary>
		/// A list of the security schemes being used by the API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="security")]
		public string[] Security { get; set; }
		
		/// <summary>
		/// The security scheme definitions being used by the API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="securityDefinitions")]
		public string SecurityDefinitions { get; set; }
		
		/// <summary>
		/// The version of the Swagger specification that's being used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="swagger")]
		public string Swagger { get; set; }
		
		/// <summary>
		/// A list of tags used by the specification, with metadata.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// A list of the groups and tags used in the left column of the Swagger page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="x-tagGroups")]
		public string[] X_tagGroups { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Audio_codec_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Bits_in_rate_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Single> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Bits_out_rate_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Single> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Bytes_in_rate_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Single> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Bytes_out_rate_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Single> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Configured_bytes_out_rate_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Int32> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Connected_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Cpu_idle_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Int32> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Cpu_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Int32> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Custom_stream_target_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_target")]
		public Custom_stream_target_inputStream_target Stream_target { get; set; }
	}
	
	public class Custom_stream_target_inputStream_target
	{
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. The backup RTMP ingest URL of the target, without the preceding protocol and without the trailing slash (/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backup_url")]
		public string Backup_url { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong> and <em>provider</em> is <em>not</em> <strong>akamai_cupertino</strong>. The web address that the target uses to play Adobe HDS streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hds_playback_url")]
		public string Hds_playback_url { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. The web address that the target uses to play Apple HLS streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hls_playback_url")]
		public string Hls_playback_url { get; set; }
		
		/// <summary>
		/// A descriptive name for the stream target. Maximum 255 characters.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong> and <em>provider</em> is <em>not</em> **akamai_cupertino**. A <em>username</em> must also be present. The password associated with the target username for RTMP authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. The primary RTMP ingest URL, without the preceding protocol and without the trailing slash (/).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primary_url")]
		public string Primary_url { get; set; }
		
		/// <summary>
		/// The CDN for the target. <br /><br />Required for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. Valid values for <strong>CustomStreamTarget</strong> are <strong>akamai</strong>, <strong>akamai_cupertino</strong>, <strong>akamai_rtmp</strong>, <strong>limelight</strong>, <strong>rtmp</strong>, and <strong>ustream</strong>. Values can be appended with **_mock** to use in the sandbox environment. <br /><br />Valid values for <strong>WowzaStreamTarget</strong> are <strong>akamai</strong>, <strong>akamai_cupertino</strong> (default), <strong>akamai_legacy_rtmp</strong>, and <strong>wowza</strong>. <br /><br /><strong>UltraLowLatencyStreamTarget</strong> defaults to and must be <strong>wowza</strong>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="provider")]
		public string Provider { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. The web address that the target uses to play RTMP streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rtmp_playback_url")]
		public string Rtmp_playback_url { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. The name of the stream as defined in the target's ingestion settings.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_name")]
		public string Stream_name { get; set; }
		
		/// <summary>
		/// <strong>WowzaStreamTarget</strong> is a Wowza CDN target. <strong>UltraLowLatencyStreamTarget</strong> is an ultra low latency Wowza stream target. <strong>CustomStreamTarget</strong> (the default) is an external, third-party destination. <!--and <strong>FacebookStreamTarget</strong> (a Facebook Live target).-->
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong> and <em>provider</em> is <em>not</em> **akamai_cupertino**. The username or ID that the target uses for RTMP authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Frame_rate_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Int32> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Frame_size_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Geoblock
	{
		
		/// <summary>
		/// Required when <em>type</em> is <strong>allow</strong> or <strong>deny</strong>. The locations affected by the geo-blocking. Enter a comma-separated list (an array) of two-letter ISO 3166-1 country codes. For a list, see <a href='https://en.wikipedia.org/wiki/ISO_3166-1' target='_blank'>ISO 3166-1</a> on wikipedia.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="countries")]
		public string[] Countries { get; set; }
		
		/// <summary>
		/// The date and time that the geo-blocking rendition was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The state of the geo-blocking.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<GeoblockState> State { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_target_id")]
		public string Stream_target_id { get; set; }
		
		/// <summary>
		/// The type of geo-blocking to apply. The value <strong>allow</strong> permits viewing only in the locations specified by the <em>countries</em> parameter. The value <strong>deny</strong> prohibits viewing in the locations specified by the <em>countries</em> parameter. The value <strong>disabled</strong> (the default) permits viewing everywhere.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<GeoblockType> Type { get; set; }
		
		/// <summary>
		/// The date and time that the geo-blocking rendition was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// Whitelisted addresses can be viewed even if they're within a geo-blocked location. Enter a comma-separated list (an array) of IP addresses that always allow streaming.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="whitelist")]
		public string[] Whitelist { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum GeoblockState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		requested = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		activated = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		update_requested = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		delete_requested = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum GeoblockType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		allow = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deny = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Geoblock_create_input
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Geoblock_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="geoblock")]
		public Geoblock_inputGeoblock Geoblock { get; set; }
	}
	
	public class Geoblock_inputGeoblock
	{
		
		/// <summary>
		/// Required when <em>type</em> is <strong>allow</strong> or <strong>deny</strong>. The locations affected by the geo-blocking. Enter a comma-separated list (an array) of two-letter ISO 3166-1 country codes. For a list, see <a href='https://en.wikipedia.org/wiki/ISO_3166-1' target='_blank'>ISO 3166-1</a> on wikipedia.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="countries")]
		public string[] Countries { get; set; }
		
		/// <summary>
		/// The type of geo-blocking to apply. The value <strong>allow</strong> permits viewing only in the locations specified by the <em>countries</em> parameter. The value <strong>deny</strong> prohibits viewing in the locations specified by the <em>countries</em> parameter. The value <strong>disabled</strong> (the default) permits viewing everywhere.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GeoblockType Type { get; set; }
		
		/// <summary>
		/// Whitelisted addresses can be viewed even if they're within a geo-blocked location. Enter a comma-separated list (an array) of IP addresses that always allow streaming.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="whitelist")]
		public string[] Whitelist { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Geoblock_update_input
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Gpu_decoder_usage_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Int32> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Gpu_driver_version_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Gpu_encoder_usage_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Int32> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Gpu_memory_usage_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Int32> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Gpu_usage_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Int32> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Height_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Int32> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Index_stream_target
	{
		
		/// <summary>
		/// <strong>The <em>chunk_size</em> parameter is deprecated. To set the chunk size of a stream target, use the POST /stream_targets/[stream_target_id]/properties endpoint.</strong> Only for targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> and <em>provider</em> is <strong>akamai_cupertino</strong>. The segment duration for HLS encoding. The default is <strong>10</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="chunk_size")]
		public System.Nullable<Index_stream_targetChunk_size> Chunk_size { get; set; }
		
		/// <summary>
		/// A six-character, alphanumeric string that allows Wowza Streaming Engine to send a transcoded stream to a <strong>WowzaStreamTarget</strong> or for the Wowza GoCoder app to send an encoded stream to a <strong>UltraLowLatencyStreamTarget</strong>. The code can be used once and expires 24 hours after it's created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connection_code")]
		public string Connection_code { get; set; }
		
		/// <summary>
		/// The date and time that the <em>connection_code</em> expires.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connection_code_expires_at")]
		public System.Nullable<System.DateTimeOffset> Connection_code_expires_at { get; set; }
		
		/// <summary>
		/// The date and time that the stream target was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The web address that the target uses to play Adobe HDS streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hds_playback_url")]
		public string Hds_playback_url { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>provider</em> is <strong>akamai_cupertino</strong>. The web address that the target uses to play Apple HLS streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hls_playback_url")]
		public string Hls_playback_url { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> and <em>provider</em> is <em>not</em> <strong>akamai_cupertino</strong>. Choose a location as close as possible to your video source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public System.Nullable<Index_stream_targetLocation> Location { get; set; }
		
		/// <summary>
		/// A descriptive name for the stream target. Maximum 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The primary ingest URL of the target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary_url")]
		public string Primary_url { get; set; }
		
		/// <summary>
		/// The CDN for the target. <br /><br />Required for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. Valid values for <strong>CustomStreamTarget</strong> are <strong>akamai</strong>, <strong>akamai_cupertino</strong>, <strong>akamai_rtmp</strong>, <strong>limelight</strong>, <strong>rtmp</strong>, and <strong>ustream</strong>. Values can be appended with **_mock** to use in the sandbox environment. <br /><br />Valid values for <strong>WowzaStreamTarget</strong> are <strong>akamai</strong>, <strong>akamai_cupertino</strong> (default), <strong>akamai_legacy_rtmp</strong>, and <strong>wowza</strong>. <br /><br /><strong>UltraLowLatencyStreamTarget</strong> defaults to and must be <strong>wowza</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provider")]
		public string Provider { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. The web address that the target uses to play RTMP streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rtmp_playback_url")]
		public string Rtmp_playback_url { get; set; }
		
		/// <summary>
		/// The name of the stream being ingested into the target. Returned for all targets except those whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong> and whose <em>source_delivery_method</em> is **pull**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_name")]
		public string Stream_name { get; set; }
		
		/// <summary>
		/// <strong>WowzaStreamTarget</strong> is a Wowza CDN target. <strong>UltraLowLatencyStreamTarget</strong> is an ultra low latency Wowza stream target. <strong>CustomStreamTarget</strong> (the default) is an external, third-party destination. <!--and <strong>FacebookStreamTarget</strong> (a Facebook Live target).-->
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<Index_stream_targetType> Type { get; set; }
		
		/// <summary>
		/// The date and time that the stream target was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong> and <em>provider</em> is <em>not</em> **akamai_cupertino**. The username or ID that the target uses for RTMP authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Index_stream_targetChunk_size
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2")]
		_2 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4")]
		_4 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8")]
		_8 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="10")]
		_10 = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Index_stream_targetLocation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		asia_pacific_australia = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		asia_pacific_japan = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		asia_pacific_singapore = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		asia_pacific_taiwan = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eu_belgium = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eu_germany = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eu_ireland = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		south_america_brazil = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		us_central_iowa = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		us_east_s_carolina = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		us_east_virginia = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		us_west_california = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		us_west_oregon = 12,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Index_stream_targetType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WowzaStreamTarget = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UltraLowLatencyStreamTarget = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CustomStreamTarget = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Keyframe_interval_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Int32> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Live_stream
	{
		
		/// <summary>
		/// The height, in pixels, of the video source. Should correspond to a widescreen (16:9) or standard (4:3) aspect ratio and be divisible by 8.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aspect_ratio_height")]
		public System.Nullable<System.Int32> Aspect_ratio_height { get; set; }
		
		/// <summary>
		/// The width, in pixels, of the video source. Should correspond to a widescreen (16:9) or standard (4:3) aspect ratio and be divisible by 8.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aspect_ratio_width")]
		public System.Nullable<System.Int32> Aspect_ratio_width { get; set; }
		
		/// <summary>
		/// The billing mode for the stream. The default is <strong>pay_as_you_go</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="billing_mode")]
		public System.Nullable<Live_streamBilling_mode> Billing_mode { get; set; }
		
		/// <summary>
		/// The location of your stream. Choose a location as close as possible to your video source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="broadcast_location")]
		public Index_stream_targetLocation Broadcast_location { get; set; }
		
		/// <summary>
		/// The type of closed caption data being passed from the source. The default, <strong>none</strong>, indicates that no data is being provided. <strong>cea</strong> indicates that a CEA closed captioning data stream is being provided. <strong>on_text</strong> indicates that an onTextData closed captioning data stream is being provided. <strong>both</strong> indicates that both CEA and onTextData closed captioing data streams are being provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="closed_caption_type")]
		public System.Nullable<Live_streamClosed_caption_type> Closed_caption_type { get; set; }
		
		/// <summary>
		/// A six-character, alphanumeric string that allows certain encoders, including Wowza Streaming Engine and the Wowza GoCoder app, to connect with Wowza Streaming Cloud. The code can be used once and expires 24 hours after it's created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connection_code")]
		public string Connection_code { get; set; }
		
		/// <summary>
		/// The date and time that the <em>connection_code</em> expires.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connection_code_expires_at")]
		public System.Nullable<System.DateTimeOffset> Connection_code_expires_at { get; set; }
		
		/// <summary>
		/// The date and time that the live stream was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The type of connection between the video source and the transcoder. The default, <strong>pull</strong>, instructs the transcoder to pull the video from the source. <strong>push</strong> instructs the source to push the stream to the transcoder. <strong>cdn</strong> uses a stream source to deliver the stream to the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delivery_method")]
		public System.Nullable<Live_streamDelivery_method> Delivery_method { get; set; }
		
		/// <summary>
		/// <strong>The <em>delivery_protocol</em> parameter is deprecated. To set the delivery protocol of a transcoder's target, use <em>target_delivery_protocol</em>.</strong>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delivery_protocol")]
		public System.Nullable<Live_streamDelivery_protocol> Delivery_protocol { get; set; }
		
		/// <summary>
		/// An array of direct delivery protocols enabled for this live stream. By default, <strong>rtmp</strong>, <strong>rtsp</strong>, and <strong>wowz</strong> are enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delivery_protocols")]
		public string[] Delivery_protocols { get; set; }
		
		/// <summary>
		/// For streams whose <em>encoder</em> is <strong>wowza_streaming_engine</strong>. The default is <strong>multi-bitrate</strong>, which means you're sending one or more bitrate renditions from Wowza Streaming Engine directly to a Wowza CDN target without transcoding in Wowza Streaming Cloud. The value <strong>single-bitrate</strong> means you're sending a single source stream to Wowza Streaming Cloud for transcoding and/or to deliver the source stream to multiple stream targets in Wowza Streaming Cloud.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delivery_type")]
		public System.Nullable<Live_streamDelivery_type> Delivery_type { get; set; }
		
		/// <summary>
		/// An array of direct playback URLs for the live stream's delivery protocols. Each protocol has a URL for the source and a URL for each output rendition.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="direct_playback_urls")]
		public Live_streamDirect_playback_urls[] Live_streamDirect_playback_urls { get; set; }
		
		/// <summary>
		/// The video source for the live stream. Choose the type of camera or encoder you're using to connect to the Wowza Streaming Cloud transcoder. If your specific device isn't listed, choose <strong>ipcamera</strong>, <strong>other_rtmp</strong>, or <strong>other_rtsp</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encoder")]
		public System.Nullable<Live_streamEncoder> Encoder { get; set; }
		
		/// <summary>
		/// A web page hosted by Wowza Streaming Cloud that includes a player for the live stream. The default, <strong>true</strong>, creates a hosted page. Specify <strong>false</strong> to not create a hosted web page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page")]
		public System.Nullable<System.Boolean> Hosted_page { get; set; }
		
		/// <summary>
		/// A description that appears on the hosted page below the player. Can't include custom HTML, JavaScript, or other tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_description")]
		public string Hosted_page_description { get; set; }
		
		/// <summary>
		/// The path to a GIF, JPEG, or PNG logo file that appears in the upper-left corner of the hosted page. Logo file must be 2.5 MB or smaller.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_logo_image_url")]
		public string Hosted_page_logo_image_url { get; set; }
		
		/// <summary>
		/// Icons that let viewers share the stream on Facebook, Google+, Twitter, and by email. The default, <strong>true</strong>, includes sharing icons on the hosted page. Specify <strong>false</strong> to omit sharing icons.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_sharing_icons")]
		public System.Nullable<System.Boolean> Hosted_page_sharing_icons { get; set; }
		
		/// <summary>
		/// A title for the page that appears above the player. Can't include custom HTML, JavaScript, or other tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_title")]
		public string Hosted_page_title { get; set; }
		
		/// <summary>
		/// The URL of the Wowza Streaming Cloud-hosted webpage that viewers can visit to watch the stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_url")]
		public string Hosted_page_url { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the live stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// For streams whose <em>target_delivery_protocol</em> is <strong>hls-https</strong>. If <strong>true</strong>, turns off incoming and sort packet buffers and delivers smaller video packets to the player, which can reduce latency as long as networks can handle the increased overhead. The default is <strong>false</strong>. <br /><br />This parameter only affects streams played over a target whose <em>type</em> is <strong>WowzaStreamTarget</strong> and whose <em>provider</em> is <strong>akamai_cupertino</strong>. It does <em>not</em> reduce latency in streams played over a hosted page and is unrelated to Wowza ultra low latency stream targets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="low_latency")]
		public System.Nullable<System.Boolean> Low_latency { get; set; }
		
		/// <summary>
		/// A descriptive name for the live stream. Maximum 200 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A clock that appears in the player before the event and counts down to the start of the stream. Specify <strong>true</strong> to display the countdown clock. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_countdown")]
		public System.Nullable<System.Boolean> Player_countdown { get; set; }
		
		/// <summary>
		/// The date and time that the event starts, used by the countdown clock. Specify <strong>YYYY-MM-DD HH:MM:SS</strong>, where <strong>HH</strong> is a 24-hour clock in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_countdown_at")]
		public System.Nullable<System.DateTimeOffset> Player_countdown_at { get; set; }
		
		/// <summary>
		/// The HTML code that can be used in an external webpage to host the Wowza Streaming Cloud player.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_embed_code")]
		public string Player_embed_code { get; set; }
		
		/// <summary>
		/// The address that can be used to configure playback of the stream using the Adobe HDS protocol.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_hds_playback_url")]
		public string Player_hds_playback_url { get; set; }
		
		/// <summary>
		/// The address that can be used to configure playback of the stream using the Apple HLS protocol.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_hls_playback_url")]
		public string Player_hls_playback_url { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the player.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_id")]
		public string Player_id { get; set; }
		
		/// <summary>
		/// The path to a GIF, JPEG, or PNG logo file that appears partially transparent in a corner of the player throughout playback. Logo file must be 2.5 MB or smaller.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_logo_image_url")]
		public string Player_logo_image_url { get; set; }
		
		/// <summary>
		/// The corner of the player in which you want the player logo to appear. The default is <strong>top-left</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_logo_position")]
		public System.Nullable<Live_streamPlayer_logo_position> Player_logo_position { get; set; }
		
		/// <summary>
		/// A player whose size adjusts according to the device on which it's being viewed. If <strong>true</strong>, creates a responsive player. If <strong>false</strong>, specify a <em>player_width</em>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_responsive")]
		public System.Nullable<System.Boolean> Player_responsive { get; set; }
		
		/// <summary>
		/// The player you want to use. Valid values are <strong>original_html5</strong>, which provides HTML5 playback and falls back to Flash on older browsers, and <strong>wowza_player</strong>, which provides HTML5 playback over Apple HLS. <strong>wowza_player</strong> requires that <strong>target_delivery_protocol</strong> be <strong>hls-https</strong> and <strong>closed_caption_type</strong> be <strong>none</strong>. The default is <strong>original_html5</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_type")]
		public string Player_type { get; set; }
		
		/// <summary>
		/// The path to a GIF, JPEG, or PNG poster image that appears in the player before the stream begins. Poster image files must be 2.5 MB or smaller.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_video_poster_image_url")]
		public string Player_video_poster_image_url { get; set; }
		
		/// <summary>
		/// The width, in pixels, of a fixed-size player. The default is <strong>640</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_width")]
		public System.Nullable<System.Int32> Player_width { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, creates a recording of the live stream. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recording")]
		public System.Nullable<System.Boolean> Recording { get; set; }
		
		/// <summary>
		/// Details that you can use to manually configure and connect a video source to the live stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source_connection_information")]
		public string Source_connection_information { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the stream source, if a stream source is used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_source_id")]
		public string Stream_source_id { get; set; }
		
		/// <summary>
		/// An array of unique alphanumeric strings that identify the stream targets used by the live stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_targets")]
		public Live_streamStream_targets[] Live_streamStream_targets { get; set; }
		
		/// <summary>
		/// The type of stream being delivered from Wowza Streaming Cloud. The default is <strong>hls-https</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target_delivery_protocol")]
		public System.Nullable<Live_streamTarget_delivery_protocol> Target_delivery_protocol { get; set; }
		
		/// <summary>
		/// The type of transcoder, either <strong>transcoded</strong> for streams that are transcoded into adaptive bitrate renditions or <strong>passthrough</strong> for streams that aren't processed by the transcoder. The default is <strong>transcoded</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transcoder_type")]
		public System.Nullable<Live_streamTranscoder_type> Transcoder_type { get; set; }
		
		/// <summary>
		/// The date and time that the live stream was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, uses a stream source to deliver the stream to Wowza Streaming Cloud. The default, <strong>false</strong>, pushes directly to Wowza Streaming Cloud.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_stream_source")]
		public System.Nullable<System.Boolean> Use_stream_source { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, black video plays if the video source disconnects from the transcoder. If <strong>false</strong> (the default), a stream-not-available message appears. Works only with HLS stream targets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="video_fallback")]
		public System.Nullable<System.Boolean> Video_fallback { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Live_streamBilling_mode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pay_as_you_go = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		twentyfour_seven = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Live_streamClosed_caption_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cea = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		on_text = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		both = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Live_streamDelivery_method
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pull = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cdn = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		push = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Live_streamDelivery_protocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hls-https")]
		hlsMinushttps = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hls-hds")]
		hlsMinushds = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Live_streamDelivery_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="single-bitrate")]
		singleMinusbitrate = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="multi-bitrate")]
		multiMinusbitrate = 1,
	}
	
	public class Live_streamDirect_playback_urls
	{
		
		/// <summary>
		/// The name of the playback URL: <strong>source</strong>, <strong>default</strong>, <strong>passthrough</strong>, or the output rendition's resolution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Only for output rendition-based playback URLs, not source playback URLs. The unique alphanumeric string that identifies the output rendition.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="output_id")]
		public string Output_id { get; set; }
		
		/// <summary>
		/// The playback URL for the source or output rendition.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Live_streamEncoder
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wowza_streaming_engine = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wowza_gocoder = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		media_ds = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		axis = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		epiphan = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hauppauge = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		jvc = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		live_u = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		matrox = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		newtek_tricaster = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		osprey = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sony = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		telestream_wirecast = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		teradek_cube = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		vmix = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		x_split = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ipcamera = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		other_rtmp = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		other_rtsp = 18,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Live_streamPlayer_logo_position
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="top-left")]
		topMinusleft = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="top-right")]
		topMinusright = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bottom-left")]
		bottomMinusleft = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bottom-right")]
		bottomMinusright = 3,
	}
	
	public class Live_streamStream_targets
	{
		
		/// <summary>
		/// The unique alphanumeric string that identifies the stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Live_streamTarget_delivery_protocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hls-https")]
		hlsMinushttps = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hls-hds")]
		hlsMinushds = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Live_streamTranscoder_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		transcoded = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		passthrough = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Live_stream_create_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="live_stream")]
		public Live_stream_create_inputLive_stream Live_stream { get; set; }
	}
	
	public class Live_stream_create_inputLive_stream
	{
		
		/// <summary>
		/// The height, in pixels, of the video source. Should correspond to a widescreen (16:9) or standard (4:3) aspect ratio and be divisible by 8.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="aspect_ratio_height")]
		public int Aspect_ratio_height { get; set; }
		
		/// <summary>
		/// The width, in pixels, of the video source. Should correspond to a widescreen (16:9) or standard (4:3) aspect ratio and be divisible by 8.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="aspect_ratio_width")]
		public int Aspect_ratio_width { get; set; }
		
		/// <summary>
		/// The billing mode for the stream. The default is <strong>pay_as_you_go</strong>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="billing_mode")]
		public Live_streamBilling_mode Billing_mode { get; set; }
		
		/// <summary>
		/// The location of your stream. Choose a location as close as possible to your video source.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="broadcast_location")]
		public Index_stream_targetLocation Broadcast_location { get; set; }
		
		/// <summary>
		/// The type of closed caption data being passed from the source. The default, <strong>none</strong>, indicates that no data is being provided. <strong>cea</strong> indicates that a CEA closed captioning data stream is being provided. <strong>on_text</strong> indicates that an onTextData closed captioning data stream is being provided. <strong>both</strong> indicates that both CEA and onTextData closed captioing data streams are being provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="closed_caption_type")]
		public Live_streamClosed_caption_type Closed_caption_type { get; set; }
		
		/// <summary>
		/// The type of connection between the video source and the transcoder. The default, <strong>pull</strong>, instructs the transcoder to pull the video from the source. <strong>push</strong> instructs the source to push the stream to the transcoder. <strong>cdn</strong> uses a stream source to deliver the stream to the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delivery_method")]
		public Live_streamDelivery_method Delivery_method { get; set; }
		
		/// <summary>
		/// An array of direct delivery protocols enabled for this live stream. By default, <strong>rtmp</strong>, <strong>rtsp</strong>, and <strong>wowz</strong> are enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delivery_protocols")]
		public string[] Delivery_protocols { get; set; }
		
		/// <summary>
		/// For streams whose <em>encoder</em> is <strong>wowza_streaming_engine</strong>. The default is <strong>multi-bitrate</strong>, which means you're sending one or more bitrate renditions from Wowza Streaming Engine directly to a Wowza CDN target without transcoding in Wowza Streaming Cloud. The value <strong>single-bitrate</strong> means you're sending a single source stream to Wowza Streaming Cloud for transcoding and/or to deliver the source stream to multiple stream targets in Wowza Streaming Cloud.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delivery_type")]
		public System.Nullable<Live_stream_create_inputLive_streamDelivery_type> Delivery_type { get; set; }
		
		/// <summary>
		/// Authentication is required by default for RTMP and RTSP push connections from a video source to Wowza Streaming Cloud. Specify <strong>true</strong> to disable authentication with the video source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disable_authentication")]
		public System.Nullable<System.Boolean> Disable_authentication { get; set; }
		
		/// <summary>
		/// The video source for the live stream. Choose the type of camera or encoder you're using to connect to the Wowza Streaming Cloud transcoder. If your specific device isn't listed, choose <strong>ipcamera</strong>, <strong>other_rtmp</strong>, or <strong>other_rtsp</strong>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="encoder")]
		public Live_streamEncoder Encoder { get; set; }
		
		/// <summary>
		/// A web page hosted by Wowza Streaming Cloud that includes a player for the live stream. The default, <strong>true</strong>, creates a hosted page. Specify <strong>false</strong> to not create a hosted web page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page")]
		public System.Nullable<System.Boolean> Hosted_page { get; set; }
		
		/// <summary>
		/// A description that appears on the hosted page below the player. Can't include custom HTML, JavaScript, or other tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_description")]
		public string Hosted_page_description { get; set; }
		
		/// <summary>
		/// A Base64-encoded string representation of a GIF, JPEG, or PNG logo file that that appears in the upper-left corner of the hosted page. Logo file must be 2.5 MB or smaller.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_logo_image")]
		public string Hosted_page_logo_image { get; set; }
		
		/// <summary>
		/// Icons that let viewers share the stream on Facebook, Google+, Twitter, and by email. The default, <strong>true</strong>, includes sharing icons on the hosted page. Specify <strong>false</strong> to omit sharing icons.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_sharing_icons")]
		public System.Nullable<System.Boolean> Hosted_page_sharing_icons { get; set; }
		
		/// <summary>
		/// A title for the page that appears above the player. Can't include custom HTML, JavaScript, or other tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_title")]
		public string Hosted_page_title { get; set; }
		
		/// <summary>
		/// For streams whose <em>target_delivery_protocol</em> is <strong>hls-https</strong>. If <strong>true</strong>, turns off incoming and sort packet buffers and delivers smaller video packets to the player, which can reduce latency as long as networks can handle the increased overhead. The default is <strong>false</strong>. <br /><br />This parameter only affects streams played over a target whose <em>type</em> is <strong>WowzaStreamTarget</strong> and whose <em>provider</em> is <strong>akamai_cupertino</strong>. It does <em>not</em> reduce latency in streams played over a hosted page and is unrelated to Wowza ultra low latency stream targets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="low_latency")]
		public System.Nullable<System.Boolean> Low_latency { get; set; }
		
		/// <summary>
		/// A descriptive name for the live stream. Maximum 200 characters.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A password for authenticating an RTMP or RTSP push connection. Can contain only uppercase and lowercase letters; numbers; and the period (.), underscore (_), and hyphen (-) characters. No other special characters can be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// A clock that appears in the player before the event and counts down to the start of the stream. Specify <strong>true</strong> to display the countdown clock. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_countdown")]
		public System.Nullable<System.Boolean> Player_countdown { get; set; }
		
		/// <summary>
		/// The date and time that the event starts, used by the countdown clock. Specify <strong>YYYY-MM-DD HH:MM:SS</strong>, where <strong>HH</strong> is a 24-hour clock in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_countdown_at")]
		public System.Nullable<System.DateTimeOffset> Player_countdown_at { get; set; }
		
		/// <summary>
		/// A Base64-encoded string representation of a GIF, JPEG, or PNG logo file that appears partially transparent in a corner of the player throughout playback. Logo file must be 2.5 MB or smaller.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_logo_image")]
		public string Player_logo_image { get; set; }
		
		/// <summary>
		/// The corner of the player in which you want the player logo to appear. The default is <strong>top-left</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_logo_position")]
		public System.Nullable<Live_stream_create_inputLive_streamPlayer_logo_position> Player_logo_position { get; set; }
		
		/// <summary>
		/// A player whose size adjusts according to the device on which it's being viewed. If <strong>true</strong>, creates a responsive player. If <strong>false</strong>, specify a <em>player_width</em>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_responsive")]
		public System.Nullable<System.Boolean> Player_responsive { get; set; }
		
		/// <summary>
		/// The player you want to use. Valid values are <strong>original_html5</strong>, which provides HTML5 playback and falls back to Flash on older browsers, and <strong>wowza_player</strong>, which provides HTML5 playback over Apple HLS. <strong>wowza_player</strong> requires that <strong>target_delivery_protocol</strong> be <strong>hls-https</strong> and <strong>closed_caption_type</strong> be <strong>none</strong>. The default is <strong>original_html5</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_type")]
		public string Player_type { get; set; }
		
		/// <summary>
		/// A Base64-encoded string representation of a GIF, JPEG, or PNG poster image that appears in the player before the stream begins. Poster image files must be 2.5 MB or smaller.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_video_poster_image")]
		public string Player_video_poster_image { get; set; }
		
		/// <summary>
		/// The width, in pixels, of a fixed-size player. The default is <strong>640</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_width")]
		public System.Nullable<System.Int32> Player_width { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, creates a recording of the live stream. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recording")]
		public System.Nullable<System.Boolean> Recording { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, removes the logo file from the hosted page. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remove_hosted_page_logo_image")]
		public System.Nullable<System.Boolean> Remove_hosted_page_logo_image { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, removes the logo file from the player. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remove_player_logo_image")]
		public System.Nullable<System.Boolean> Remove_player_logo_image { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, removes the poster image. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remove_player_video_poster_image")]
		public System.Nullable<System.Boolean> Remove_player_video_poster_image { get; set; }
		
		/// <summary>
		/// The URL of an IP camera or video encoder using an RTMP and RTSP pull connection to Wowza Streaming Cloud. Consult the camera or encoder documentation for the URL syntax.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source_url")]
		public string Source_url { get; set; }
		
		/// <summary>
		/// The type of stream being delivered from Wowza Streaming Cloud. The default is <strong>hls-https</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target_delivery_protocol")]
		public System.Nullable<Live_stream_create_inputLive_streamTarget_delivery_protocol> Target_delivery_protocol { get; set; }
		
		/// <summary>
		/// The type of transcoder, either <strong>transcoded</strong> for streams that are transcoded into adaptive bitrate renditions or <strong>passthrough</strong> for streams that aren't processed by the transcoder. The default is <strong>transcoded</strong>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transcoder_type")]
		public Live_streamTranscoder_type Transcoder_type { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, uses a stream source to deliver the stream to Wowza Streaming Cloud. The default, <strong>false</strong>, pushes directly to Wowza Streaming Cloud.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_stream_source")]
		public System.Nullable<System.Boolean> Use_stream_source { get; set; }
		
		/// <summary>
		/// A username for authenticating an RTMP or RTSP push connection. Can contain only uppercase and lowercase letters; numbers; and the period (.), underscore (_), and hyphen (-) characters. No other special characters can be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, black video plays if the video source disconnects from the transcoder. If <strong>false</strong> (the default), a stream-not-available message appears. Works only with HLS stream targets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="video_fallback")]
		public System.Nullable<System.Boolean> Video_fallback { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Live_stream_create_inputLive_streamDelivery_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="single-bitrate")]
		singleMinusbitrate = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="multi-bitrate")]
		multiMinusbitrate = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Live_stream_create_inputLive_streamPlayer_logo_position
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="top-left")]
		topMinusleft = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="top-right")]
		topMinusright = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bottom-left")]
		bottomMinusleft = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bottom-right")]
		bottomMinusright = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Live_stream_create_inputLive_streamTarget_delivery_protocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hls-https")]
		hlsMinushttps = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hls-hds")]
		hlsMinushds = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Live_stream_update_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="live_stream")]
		public Live_stream_update_inputLive_stream Live_stream { get; set; }
	}
	
	public class Live_stream_update_inputLive_stream
	{
		
		/// <summary>
		/// The height, in pixels, of the video source. Should correspond to a widescreen (16:9) or standard (4:3) aspect ratio and be divisible by 8.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="aspect_ratio_height")]
		public int Aspect_ratio_height { get; set; }
		
		/// <summary>
		/// The width, in pixels, of the video source. Should correspond to a widescreen (16:9) or standard (4:3) aspect ratio and be divisible by 8.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="aspect_ratio_width")]
		public int Aspect_ratio_width { get; set; }
		
		/// <summary>
		/// The type of closed caption data being passed from the source. The default, <strong>none</strong>, indicates that no data is being provided. <strong>cea</strong> indicates that a CEA closed captioning data stream is being provided. <strong>on_text</strong> indicates that an onTextData closed captioning data stream is being provided. <strong>both</strong> indicates that both CEA and onTextData closed captioing data streams are being provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="closed_caption_type")]
		public Live_streamClosed_caption_type Closed_caption_type { get; set; }
		
		/// <summary>
		/// The type of connection between the video source and the transcoder. The default, <strong>pull</strong>, instructs the transcoder to pull the video from the source. <strong>push</strong> instructs the source to push the stream to the transcoder. <strong>cdn</strong> uses a stream source to deliver the stream to the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delivery_method")]
		public Live_streamDelivery_method Delivery_method { get; set; }
		
		/// <summary>
		/// An array of direct delivery protocols enabled for this live stream. By default, <strong>rtmp</strong>, <strong>rtsp</strong>, and <strong>wowz</strong> are enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delivery_protocols")]
		public string[] Delivery_protocols { get; set; }
		
		/// <summary>
		/// Authentication is required by default for RTMP and RTSP push connections from a video source to Wowza Streaming Cloud. Specify <strong>true</strong> to disable authentication with the video source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disable_authentication")]
		public System.Nullable<System.Boolean> Disable_authentication { get; set; }
		
		/// <summary>
		/// The video source for the live stream. Choose the type of camera or encoder you're using to connect to the Wowza Streaming Cloud transcoder. If your specific device isn't listed, choose <strong>ipcamera</strong>, <strong>other_rtmp</strong>, or <strong>other_rtsp</strong>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="encoder")]
		public Live_streamEncoder Encoder { get; set; }
		
		/// <summary>
		/// A description that appears on the hosted page below the player. Can't include custom HTML, JavaScript, or other tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_description")]
		public string Hosted_page_description { get; set; }
		
		/// <summary>
		/// A Base64-encoded string representation of a GIF, JPEG, or PNG logo file that that appears in the upper-left corner of the hosted page. Logo file must be 2.5 MB or smaller.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_logo_image")]
		public string Hosted_page_logo_image { get; set; }
		
		/// <summary>
		/// Icons that let viewers share the stream on Facebook, Google+, Twitter, and by email. The default, <strong>true</strong>, includes sharing icons on the hosted page. Specify <strong>false</strong> to omit sharing icons.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_sharing_icons")]
		public System.Nullable<System.Boolean> Hosted_page_sharing_icons { get; set; }
		
		/// <summary>
		/// A title for the page that appears above the player. Can't include custom HTML, JavaScript, or other tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_title")]
		public string Hosted_page_title { get; set; }
		
		/// <summary>
		/// A descriptive name for the live stream. Maximum 200 characters.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A password for authenticating an RTMP or RTSP push connection. Can contain only uppercase and lowercase letters; numbers; and the period (.), underscore (_), and hyphen (-) characters. No other special characters can be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// A clock that appears in the player before the event and counts down to the start of the stream. Specify <strong>true</strong> to display the countdown clock. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_countdown")]
		public System.Nullable<System.Boolean> Player_countdown { get; set; }
		
		/// <summary>
		/// The date and time that the event starts, used by the countdown clock. Specify <strong>YYYY-MM-DD HH:MM:SS</strong>, where <strong>HH</strong> is a 24-hour clock in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_countdown_at")]
		public System.Nullable<System.DateTimeOffset> Player_countdown_at { get; set; }
		
		/// <summary>
		/// A Base64-encoded string representation of a GIF, JPEG, or PNG logo file that appears partially transparent in a corner of the player throughout playback. Logo file must be 2.5 MB or smaller.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_logo_image")]
		public string Player_logo_image { get; set; }
		
		/// <summary>
		/// The corner of the player in which you want the player logo to appear. The default is <strong>top-left</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_logo_position")]
		public System.Nullable<Live_stream_update_inputLive_streamPlayer_logo_position> Player_logo_position { get; set; }
		
		/// <summary>
		/// A player whose size adjusts according to the device on which it's being viewed. If <strong>true</strong>, creates a responsive player. If <strong>false</strong>, specify a <em>player_width</em>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_responsive")]
		public System.Nullable<System.Boolean> Player_responsive { get; set; }
		
		/// <summary>
		/// The player you want to use. Valid values are <strong>original_html5</strong>, which provides HTML5 playback and falls back to Flash on older browsers, and <strong>wowza_player</strong>, which provides HTML5 playback over Apple HLS. <strong>wowza_player</strong> requires that <strong>target_delivery_protocol</strong> be <strong>hls-https</strong> and <strong>closed_caption_type</strong> be <strong>none</strong>. The default is <strong>original_html5</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_type")]
		public string Player_type { get; set; }
		
		/// <summary>
		/// A Base64-encoded string representation of a GIF, JPEG, or PNG poster image that appears in the player before the stream begins. Poster image files must be 2.5 MB or smaller.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_video_poster_image")]
		public string Player_video_poster_image { get; set; }
		
		/// <summary>
		/// The width, in pixels, of a fixed-size player. The default is <strong>640</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_width")]
		public System.Nullable<System.Int32> Player_width { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, creates a recording of the live stream. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recording")]
		public System.Nullable<System.Boolean> Recording { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, removes the logo file from the hosted page. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remove_hosted_page_logo_image")]
		public System.Nullable<System.Boolean> Remove_hosted_page_logo_image { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, removes the logo file from the player. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remove_player_logo_image")]
		public System.Nullable<System.Boolean> Remove_player_logo_image { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, removes the poster image. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remove_player_video_poster_image")]
		public System.Nullable<System.Boolean> Remove_player_video_poster_image { get; set; }
		
		/// <summary>
		/// The URL of an IP camera or video encoder using an RTMP and RTSP pull connection to Wowza Streaming Cloud. Consult the camera or encoder documentation for the URL syntax.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source_url")]
		public string Source_url { get; set; }
		
		/// <summary>
		/// The type of stream being delivered from Wowza Streaming Cloud. The default is <strong>hls-https</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target_delivery_protocol")]
		public System.Nullable<Live_stream_update_inputLive_streamTarget_delivery_protocol> Target_delivery_protocol { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, uses a stream source to deliver the stream to Wowza Streaming Cloud. The default, <strong>false</strong>, pushes directly to Wowza Streaming Cloud.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_stream_source")]
		public System.Nullable<System.Boolean> Use_stream_source { get; set; }
		
		/// <summary>
		/// A username for authenticating an RTMP or RTSP push connection. Can contain only uppercase and lowercase letters; numbers; and the period (.), underscore (_), and hyphen (-) characters. No other special characters can be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, black video plays if the video source disconnects from the transcoder. If <strong>false</strong> (the default), a stream-not-available message appears. Works only with HLS stream targets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="video_fallback")]
		public System.Nullable<System.Boolean> Video_fallback { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Live_stream_update_inputLive_streamPlayer_logo_position
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="top-left")]
		topMinusleft = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="top-right")]
		topMinusright = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bottom-left")]
		bottomMinusleft = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bottom-right")]
		bottomMinusright = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Live_stream_update_inputLive_streamTarget_delivery_protocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hls-https")]
		hlsMinushttps = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hls-hds")]
		hlsMinushds = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Live_streams
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="live_streams")]
		public Live_stream[] Live_streams1 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Output
	{
		
		/// <summary>
		/// The height, in pixels, of the output rendition. Should correspond to a widescreen or standard aspect ratio and be divisible by 8. The default is <strong>1080</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aspect_ratio_height")]
		public System.Nullable<System.Int32> Aspect_ratio_height { get; set; }
		
		/// <summary>
		/// The width, in pixels, of the output rendition. Should correspond to a widescreen or standard aspect ratio and be divisible by 8. The default is <strong>1980</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aspect_ratio_width")]
		public System.Nullable<System.Int32> Aspect_ratio_width { get; set; }
		
		/// <summary>
		/// The audio bitrate, in kilobits per second (Kbps). Must be between <strong>0</strong> (for passthrough audio) and <strong>1000</strong>. The default is <strong>128</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bitrate_audio")]
		public System.Nullable<System.Int32> Bitrate_audio { get; set; }
		
		/// <summary>
		/// The video bitrate, in kilobits per second (Kbps). Must be between <strong>0</strong> (for passthrough video) and <strong>10240</strong>. The default is <strong>4000</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bitrate_video")]
		public System.Nullable<System.Int32> Bitrate_video { get; set; }
		
		/// <summary>
		/// The date and time that the output rendition was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// Reduce the frame rate of the transcoded output rendition. The default, <strong>0</strong>, uses the encoded stream's frame rate without reduction.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="framerate_reduction")]
		public System.Nullable<OutputFramerate_reduction> Framerate_reduction { get; set; }
		
		/// <summary>
		/// The encoding method. Specify <strong>main</strong> for desktop streaming, <strong>baseline</strong> for playback on mobile devices, or <strong>high</strong> for HD playback. The default is <strong>high</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="h264_profile")]
		public System.Nullable<OutputH264_profile> H264_profile { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the output rendition.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The interval used to define the compression applied to a group of frames. The default, <strong>follow_source</strong>, uses the keyframe interval of the source video.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="keyframes")]
		public System.Nullable<OutputKeyframes> Keyframes { get; set; }
		
		/// <summary>
		/// A descriptive name for the output (generated, not writable).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="output_stream_targets")]
		public Output_stream_target[] Output_stream_targets { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, sends the audio track to the target without transcoding. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="passthrough_audio")]
		public System.Nullable<System.Boolean> Passthrough_audio { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, sends the video track to the target without transcoding. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="passthrough_video")]
		public System.Nullable<System.Boolean> Passthrough_video { get; set; }
		
		/// <summary>
		/// The contents of the stream. The default is both audio and video (<strong>audiovideo</strong>).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_format")]
		public System.Nullable<OutputStream_format> Stream_format { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transcoder_id")]
		public string Transcoder_id { get; set; }
		
		/// <summary>
		/// The date and time that the output rendition was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum OutputFramerate_reduction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="0")]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1/2")]
		_1_2 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1/4")]
		_1_4 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1/25")]
		_1_25 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1/30")]
		_1_30 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1/50")]
		_1_50 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1/60")]
		_1_60 = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum OutputH264_profile
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		main = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		baseline = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		high = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum OutputKeyframes
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		follow_source = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="25")]
		_25 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="30")]
		_30 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="50")]
		_50 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="60")]
		_60 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="100")]
		_100 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="120")]
		_120 = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Output_stream_target
	{
		
		/// <summary>
		/// The date and time that the output stream target was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the output stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the output rendition.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="output_id")]
		public string Output_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stream_target")]
		public Stream_target Stream_target { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_target_id")]
		public string Stream_target_id { get; set; }
		
		/// <summary>
		/// The date and time that the output stream target was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// Specifies whether to use the stream target's primary or backup URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_stream_target_backup_url")]
		public System.Nullable<System.Boolean> Use_stream_target_backup_url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Stream_target
	{
		
		/// <summary>
		/// The backup ingest URL for a target whose <em>type</em> is <strong>WowzaStreamTarget</strong> or <strong>CustomStreamTarget</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backup_url")]
		public string Backup_url { get; set; }
		
		/// <summary>
		/// <strong>The <em>chunk_size</em> parameter is deprecated. To set the chunk size of a stream target, use the POST /stream_targets/[stream_target_id]/properties endpoint.</strong> Only for targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> and <em>provider</em> is <strong>akamai_cupertino</strong>. The segment duration for HLS encoding. The default is <strong>10</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="chunk_size")]
		public System.Nullable<Stream_targetChunk_size> Chunk_size { get; set; }
		
		/// <summary>
		/// A six-character, alphanumeric string that allows Wowza Streaming Engine to send a transcoded stream to a <strong>WowzaStreamTarget</strong> or for the Wowza GoCoder app to send an encoded stream to a <strong>UltraLowLatencyStreamTarget</strong>. The code can be used once and expires 24 hours after it's created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connection_code")]
		public string Connection_code { get; set; }
		
		/// <summary>
		/// The date and time that the <em>connection_code</em> expires.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connection_code_expires_at")]
		public System.Nullable<System.DateTimeOffset> Connection_code_expires_at { get; set; }
		
		/// <summary>
		/// The date and time that the stream target was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// Returned only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong>. Indicates whether Apple HLS playback is enabled for the stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enable_hls")]
		public System.Nullable<System.Boolean> Enable_hls { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong>. If <strong>true</strong> (the default), the source stream is ready to be ingested. If **false**, the source stream won't be ingested by the target's origin server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The web address that the target uses to play Adobe HDS streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hds_playback_url")]
		public string Hds_playback_url { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>provider</em> is <strong>akamai_cupertino</strong>. The web address that the target uses to play Apple HLS streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hls_playback_url")]
		public string Hls_playback_url { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong> and <em>source_delivery_method</em> is **push**. A list of IP addresses that can be used to connect to the target's origin server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ingest_ip_whitelist")]
		public string[] Ingest_ip_whitelist { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> and <em>provider</em> is <em>not</em> <strong>akamai_cupertino</strong>. Choose a location as close as possible to your video source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Index_stream_targetLocation Location { get; set; }
		
		/// <summary>
		/// A descriptive name for the stream target. Maximum 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong> and <em>provider</em> is <em>not</em> **akamai_cupertino**. A <em>username</em> must also be present. The password associated with the target username for RTMP authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong>. A hash of **hls**, **wowz**, and **ws** URLs that can be used by the player.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="playback_urls")]
		public Stream_targetPlayback_urls Playback_urls { get; set; }
		
		/// <summary>
		/// The primary ingest URL of the target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary_url")]
		public string Primary_url { get; set; }
		
		/// <summary>
		/// The CDN for the target. <br /><br />Required for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. Valid values for <strong>CustomStreamTarget</strong> are <strong>akamai</strong>, <strong>akamai_cupertino</strong>, <strong>akamai_rtmp</strong>, <strong>limelight</strong>, <strong>rtmp</strong>, and <strong>ustream</strong>. Values can be appended with **_mock** to use in the sandbox environment. <br /><br />Valid values for <strong>WowzaStreamTarget</strong> are <strong>akamai</strong>, <strong>akamai_cupertino</strong> (default), <strong>akamai_legacy_rtmp</strong>, and <strong>wowza</strong>. <br /><br /><strong>UltraLowLatencyStreamTarget</strong> defaults to and must be <strong>wowza</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provider")]
		public string Provider { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong> and <em>source_delivery_method</em> is **pull**. The location of the stream target's origin server. If unspecified, Wowza Streaming Cloud determines the optimal region for the origin server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region_override")]
		public System.Nullable<Stream_targetRegion_override> Region_override { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. The web address that the target uses to play RTMP streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rtmp_playback_url")]
		public string Rtmp_playback_url { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>use_secure_ingest</em> is <strong>true</strong>. The query parameter needed for secure stream delivery between the transcoder and the target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secure_ingest_query_param")]
		public string Secure_ingest_query_param { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong>. The type of connection between the stream source and the stream target. **push** instructs the source to push the stream to the stream target. **pull** instructs the stream target to pull the stream from the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source_delivery_method")]
		public System.Nullable<Stream_targetSource_delivery_method> Source_delivery_method { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong> and <em>source_delivery_method</em> is **pull**. The URL of a source IP camera or encoder connecting to the stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source_url")]
		public string Source_url { get; set; }
		
		/// <summary>
		/// The name of the stream being ingested into the target. Returned for all targets except those whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong> and whose <em>source_delivery_method</em> is **pull**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_name")]
		public string Stream_name { get; set; }
		
		/// <summary>
		/// <strong>WowzaStreamTarget</strong> is a Wowza CDN target. <strong>UltraLowLatencyStreamTarget</strong> is an ultra low latency Wowza stream target. <strong>CustomStreamTarget</strong> (the default) is an external, third-party destination. <!--and <strong>FacebookStreamTarget</strong> (a Facebook Live target).-->
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Index_stream_targetType Type { get; set; }
		
		/// <summary>
		/// The date and time that the stream target was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> and <em>provider</em> is <strong>akamai_cupertino</strong>. CORS, or cross-origin resource sharing, allows streams to be sent to providers such as Peer5, Viblast, and Streamroot, which implement a peer-to-peer grid delivery system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_cors")]
		public System.Nullable<System.Boolean> Use_cors { get; set; }
		
		/// <summary>
		/// <strong>The <em>use_https</em> parameter is deprecated. Use the POST /stream_targets/[<em>stream_target_id</em>]/properties endpoint and the <em>relative_playlists</em> parameter instead.</strong>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_https")]
		public System.Nullable<System.Boolean> Use_https { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> and <em>provider</em> is <strong>akamai_cupertino</strong>. If <strong>true</strong>, generates a <em>secure_ingest_query_param</em> to securely deliver the stream from the transcoder to the provider.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_secure_ingest")]
		public System.Nullable<System.Boolean> Use_secure_ingest { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong> and <em>provider</em> is <em>not</em> **akamai_cupertino**. The username or ID that the target uses for RTMP authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Stream_targetChunk_size
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2")]
		_2 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4")]
		_4 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8")]
		_8 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="10")]
		_10 = 4,
	}
	
	public class Stream_targetPlayback_urls
	{
		
		/// <summary>
		/// The web address that the ultra low latency target can use to play the Apple HLS stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hls")]
		public string Hls { get; set; }
		
		/// <summary>
		/// The **wowz** and **wowzs** web addresses that the ultra low latency target can use to play WOWZ streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wowz")]
		public string Wowz { get; set; }
		
		/// <summary>
		/// The **ws** and **wss** web addresses that the ultra low latency target can use to play the WebSocket stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ws")]
		public string Ws { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Stream_targetRegion_override
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="azure-westus")]
		azureMinuswestus = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="azure-eastus2")]
		azureMinuseastus2 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="azure-northeurope")]
		azureMinusnortheurope = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="null")]
		_null = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Stream_targetSource_delivery_method
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		push = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pull = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum OutputStream_format
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		audiovideo = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		videoonly = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		audioonly = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Output_add_stream_target_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="output_stream_target")]
		public Output_add_stream_target_inputOutput_stream_target Output_stream_target { get; set; }
	}
	
	public class Output_add_stream_target_inputOutput_stream_target
	{
		
		/// <summary>
		/// The unique alphanumeric string that identifies the stream target.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_target_id")]
		public string Stream_target_id { get; set; }
		
		/// <summary>
		/// Use the target's backup URL. Not available for targets whose <em>provider</em> is <strong>akamai_cupertino</strong>. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_stream_target_backup_url")]
		public System.Nullable<System.Boolean> Use_stream_target_backup_url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Output_create_input
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Output_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="output")]
		public Output_inputOutput Output { get; set; }
	}
	
	public class Output_inputOutput
	{
		
		/// <summary>
		/// The height, in pixels, of the output rendition. Should correspond to a widescreen or standard aspect ratio and be divisible by 8. The default is <strong>1080</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aspect_ratio_height")]
		public System.Nullable<System.Int32> Aspect_ratio_height { get; set; }
		
		/// <summary>
		/// The width, in pixels, of the output rendition. Should correspond to a widescreen or standard aspect ratio and be divisible by 8. The default is <strong>1980</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aspect_ratio_width")]
		public System.Nullable<System.Int32> Aspect_ratio_width { get; set; }
		
		/// <summary>
		/// The audio bitrate, in kilobits per second (Kbps). Must be between <strong>0</strong> (for passthrough audio) and <strong>1000</strong>. The default is <strong>128</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bitrate_audio")]
		public System.Nullable<System.Int32> Bitrate_audio { get; set; }
		
		/// <summary>
		/// The video bitrate, in kilobits per second (Kbps). Must be between <strong>0</strong> (for passthrough video) and <strong>10240</strong>. The default is <strong>4000</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bitrate_video")]
		public System.Nullable<System.Int32> Bitrate_video { get; set; }
		
		/// <summary>
		/// Reduce the frame rate of the transcoded output rendition. The default, <strong>0</strong>, uses the encoded stream's frame rate without reduction.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="framerate_reduction")]
		public System.Nullable<Output_inputOutputFramerate_reduction> Framerate_reduction { get; set; }
		
		/// <summary>
		/// The encoding method. Specify <strong>main</strong> for desktop streaming, <strong>baseline</strong> for playback on mobile devices, or <strong>high</strong> for HD playback. The default is <strong>high</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="h264_profile")]
		public OutputH264_profile H264_profile { get; set; }
		
		/// <summary>
		/// The interval used to define the compression applied to a group of frames. The default, <strong>follow_source</strong>, uses the keyframe interval of the source video.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="keyframes")]
		public System.Nullable<Output_inputOutputKeyframes> Keyframes { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, sends the audio track to the target without transcoding. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="passthrough_audio")]
		public System.Nullable<System.Boolean> Passthrough_audio { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, sends the video track to the target without transcoding. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="passthrough_video")]
		public System.Nullable<System.Boolean> Passthrough_video { get; set; }
		
		/// <summary>
		/// The contents of the stream. The default is both audio and video (<strong>audiovideo</strong>).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_format")]
		public OutputStream_format Stream_format { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Output_inputOutputFramerate_reduction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="0")]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1/2")]
		_1_2 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1/4")]
		_1_4 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1/25")]
		_1_25 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1/30")]
		_1_30 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1/50")]
		_1_50 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1/60")]
		_1_60 = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Output_inputOutputKeyframes
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		follow_source = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="25")]
		_25 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="30")]
		_30 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="50")]
		_50 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="60")]
		_60 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="100")]
		_100 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="120")]
		_120 = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Output_remove_stream_target_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="output_stream_target")]
		public Output_remove_stream_target_inputOutput_stream_target Output_stream_target { get; set; }
	}
	
	public class Output_remove_stream_target_inputOutput_stream_target
	{
		
		/// <summary>
		/// The unique alphanumeric string that identifies the stream target.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_target_id")]
		public string Stream_target_id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Output_stream_target_create_input
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Output_stream_target_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="output_stream_target")]
		public Output_stream_target_inputOutput_stream_target Output_stream_target { get; set; }
	}
	
	public class Output_stream_target_inputOutput_stream_target
	{
		
		/// <summary>
		/// The unique alphanumeric string that identifies the stream target.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_target_id")]
		public string Stream_target_id { get; set; }
		
		/// <summary>
		/// Specifies whether to use the stream target's primary or backup URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_stream_target_backup_url")]
		public System.Nullable<System.Boolean> Use_stream_target_backup_url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Output_stream_target_update_input
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Output_stream_targets
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="output_stream_targets")]
		public Output_stream_target[] Output_stream_targets1 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Output_update_input
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Outputs
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="outputs")]
		public Output[] Outputs1 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Player
	{
		
		/// <summary>
		/// A clock that appears in the player before the event and counts down to the start of the stream. Specify <strong>true</strong> to display the countdown clock. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="countdown")]
		public System.Nullable<System.Boolean> Countdown { get; set; }
		
		/// <summary>
		/// The date and time that the event starts, used by the countdown clock. Enter <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="countdown_at")]
		public System.Nullable<System.DateTimeOffset> Countdown_at { get; set; }
		
		/// <summary>
		/// The date and time that the player was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The HTML code that can be used in an external webpage to host the Wowza Streaming Cloud player.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="embed_code")]
		public string Embed_code { get; set; }
		
		/// <summary>
		/// The address that can be used to configure playback of the stream using the Adobe HDS protocol.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hds_playback_url")]
		public string Hds_playback_url { get; set; }
		
		/// <summary>
		/// The address that can be used to configure playback of the stream using the Apple HLS protocol.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hls_playback_url")]
		public string Hls_playback_url { get; set; }
		
		/// <summary>
		/// A web page hosted by Wowza Streaming Cloud that includes a player for the live stream. The default, <strong>true</strong>, creates a hosted page. Specify <strong>false</strong> to not create a hosted web page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page")]
		public System.Nullable<System.Boolean> Hosted_page { get; set; }
		
		/// <summary>
		/// A description that appears on the hosted page below the player. Can't include custom HTML, JavaScript, or other tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_description")]
		public string Hosted_page_description { get; set; }
		
		/// <summary>
		/// The path to a GIF, JPEG, or PNG logo file that appears in the upper-left corner of the hosted page. Logo file must be 2.5 MB or smaller.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_logo_image_url")]
		public string Hosted_page_logo_image_url { get; set; }
		
		/// <summary>
		/// Icons that let viewers share the stream on Facebook, Google+, Twitter, and by email. The default, <strong>true</strong>, includes sharing icons on the hosted page. Specify <strong>false</strong> to omit sharing icons.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_sharing_icons")]
		public string Hosted_page_sharing_icons { get; set; }
		
		/// <summary>
		/// A title for the page that appears above the player. Can't include custom HTML, JavaScript, or other tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_title")]
		public string Hosted_page_title { get; set; }
		
		/// <summary>
		/// The URL of the Wowza Streaming Cloud-hosted webpage that viewers can visit to watch the stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_url")]
		public string Hosted_page_url { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the player.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The path to a GIF, JPEG, or PNG logo file that appears partially transparent in a corner of the player throughout playback. Logo file must be 2.5 MB or smaller.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logo_image_url")]
		public string Logo_image_url { get; set; }
		
		/// <summary>
		/// The corner of the player in which you want the player logo to appear. The default is <strong>top-left</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logo_position")]
		public string Logo_position { get; set; }
		
		/// <summary>
		/// A player whose size adjusts according to the device on which it's being viewed. If <strong>true</strong>, creates a responsive player. If <strong>false</strong>, specify a <strong>width</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responsive")]
		public System.Nullable<System.Boolean> Responsive { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transcoder_id")]
		public string Transcoder_id { get; set; }
		
		/// <summary>
		/// The player you want to use. Valid values are <strong>original_html5</strong>, which provides HTML5 playback and falls back to Flash on older browsers, and <strong>wowza_player</strong>, which provides HTML5 playback over Apple HLS. <strong>wowza_player</strong> requires that <em>target_delivery_protocol</em> be <strong>hls-https</strong> and <em>closed_caption_type</em> be <strong>none</strong>. The default is <strong>original_html5</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// The date and time that the player was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// The path to a GIF, JPEG, or PNG poster image that appears in the player before the stream begins. Poster image files must be 2.5 MB or smaller.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="video_poster_image_url")]
		public string Video_poster_image_url { get; set; }
		
		/// <summary>
		/// The width, in pixels, of a fixed-size player. The default is <strong>640</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="width")]
		public System.Nullable<System.Int32> Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Player_update_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="player")]
		public Player_update_inputPlayer Player { get; set; }
	}
	
	public class Player_update_inputPlayer
	{
		
		/// <summary>
		/// A clock that appears in the player before the event and counts down to the start of the stream. Specify <strong>true</strong> to display the countdown clock. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="countdown")]
		public System.Nullable<System.Boolean> Countdown { get; set; }
		
		/// <summary>
		/// The date and time that the event starts, used by the countdown clock. Enter <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="countdown_at")]
		public System.Nullable<System.DateTimeOffset> Countdown_at { get; set; }
		
		/// <summary>
		/// A web page hosted by Wowza Streaming Cloud that includes a player for the live stream. The default, <strong>true</strong>, creates a hosted page. Specify <strong>false</strong> to not create a hosted web page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page")]
		public System.Nullable<System.Boolean> Hosted_page { get; set; }
		
		/// <summary>
		/// A description that appears on the hosted page below the player. Can't include custom HTML, JavaScript, or other tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_description")]
		public string Hosted_page_description { get; set; }
		
		/// <summary>
		/// A Base64-encoded string representation of a GIF, JPEG, or PNG logo file that appears in the upper-left corner of the hosted page. Logo file must be 2.5 MB or smaller.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_logo_image")]
		public string Hosted_page_logo_image { get; set; }
		
		/// <summary>
		/// Icons that let viewers share the stream on Facebook, Google+, Twitter, and by email. The default, <strong>true</strong>, includes sharing icons on the hosted page. Specify <strong>false</strong> to omit sharing icons.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_sharing_icons")]
		public System.Nullable<System.Boolean> Hosted_page_sharing_icons { get; set; }
		
		/// <summary>
		/// A title for the page that appears above the player. Can't include custom HTML, JavaScript, or other tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosted_page_title")]
		public string Hosted_page_title { get; set; }
		
		/// <summary>
		/// A Base64-encoded string representation of a GIF, JPEG, or PNG logo file that appears partially transparent in a corner of the player throughout playback. Logo file must be 2.5 MB or smaller.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logo_image")]
		public string Logo_image { get; set; }
		
		/// <summary>
		/// The corner of the player in which you want the player logo to appear. The default is <strong>top-left</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logo_position")]
		public string Logo_position { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, removes the logo file from the output. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remove_hosted_page_logo_image")]
		public System.Nullable<System.Boolean> Remove_hosted_page_logo_image { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, removes the logo file from the output. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remove_logo_image")]
		public System.Nullable<System.Boolean> Remove_logo_image { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, removes the poster image from the output. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remove_video_poster_image")]
		public System.Nullable<System.Boolean> Remove_video_poster_image { get; set; }
		
		/// <summary>
		/// A player whose size adjusts according to the device on which it's being viewed. If <strong>true</strong>, creates a responsive player. If <strong>false</strong>, specify a <strong>width</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responsive")]
		public System.Nullable<System.Boolean> Responsive { get; set; }
		
		/// <summary>
		/// The player you want to use. Valid values are <strong>original_html5</strong>, which provides HTML5 playback and falls back to Flash on older browsers, and <strong>wowza_player</strong>, which provides HTML5 playback over Apple HLS. <strong>wowza_player</strong> requires that <em>target_delivery_protocol</em> be <strong>hls-https</strong> and <em>closed_caption_type</em> be <strong>none</strong>. The default is <strong>original_html5</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// A Base64-encoded string representation of a GIF, JPEG, or PNG poster image that appears in the player before the stream begins. Poster image files must be 2.5 MB or smaller.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="video_poster_image")]
		public string Video_poster_image { get; set; }
		
		/// <summary>
		/// The width, in pixels, of a fixed-size player. The default is <strong>640</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="width")]
		public System.Nullable<System.Int32> Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Players
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="players")]
		public Player[] Players1 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Recording
	{
		
		/// <summary>
		/// The date and time that the recording was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The URL that can be used to download the recording.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="download_url")]
		public string Download_url { get; set; }
		
		/// <summary>
		/// The length of the recording, in hours, minutes, and seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<System.Int64> Duration { get; set; }
		
		/// <summary>
		/// The file name of the recording.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="file_name")]
		public string File_name { get; set; }
		
		/// <summary>
		/// The file size of the recording.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="file_size")]
		public System.Nullable<System.Int64> File_size { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the recording.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The reason that a recording has the state <strong>failed</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
		
		/// <summary>
		/// The date and time that the recording started.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="starts_at")]
		public string Starts_at { get; set; }
		
		/// <summary>
		/// The state of the recording.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<RecordingState> State { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the transcoder that was recorded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transcoder_id")]
		public string Transcoder_id { get; set; }
		
		/// <summary>
		/// The descriptive name of the transcoder that was recorded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transcoder_name")]
		public string Transcoder_name { get; set; }
		
		/// <summary>
		/// The unique identifier associated with the transcoding uptime for this recording.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transcoding_uptime_id")]
		public System.Nullable<System.DateTimeOffset> Transcoding_uptime_id { get; set; }
		
		/// <summary>
		/// The date and time that the recording was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum RecordingState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		uploading = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		converting = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		removing = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		completed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Recordings
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="recordings")]
		public Recording[] Recordings1 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Schedule
	{
		
		/// <summary>
		/// The type of action that the schedule should trigger on the transcoder. The default is <strong>start</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="action_type")]
		public System.Nullable<ScheduleAction_type> Action_type { get; set; }
		
		/// <summary>
		/// The date and time that the schedule was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The month, day, and year that a recurring schedule should stop running. Specify <strong>YYYY-MM-DD</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end_repeat")]
		public System.Nullable<System.DateOnly> End_repeat { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the schedule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A descriptive name for the schedule. Maximum 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The day or days of the week that a recurring schedule should run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recurrence_data")]
		public System.Nullable<ScheduleRecurrence_data> Recurrence_data { get; set; }
		
		/// <summary>
		/// A schedule can run one time only (<strong>once</strong>) or repeat (<strong>recur</strong>) until a specified <em>end_repeat</em> date. The default is <strong>once</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recurrence_type")]
		public System.Nullable<ScheduleRecurrence_type> Recurrence_type { get; set; }
		
		/// <summary>
		/// The month, day, and year that the recurring schedule should go into effect. Specify <strong>YYYY-MM-DD</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_repeat")]
		public System.Nullable<System.DateOnly> Start_repeat { get; set; }
		
		/// <summary>
		/// The month, day, year, and time of day that the <em>action_type</em> <strong>start</strong> should occur. Specify <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_transcoder")]
		public System.Nullable<System.DateTimeOffset> Start_transcoder { get; set; }
		
		/// <summary>
		/// A schedule must be <strong>enabled</strong> to run. Specify <strong>enabled</strong> to run the schedule or <strong>disabled</strong> to turn off the schedule so that it doesn't run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<ScheduleState> State { get; set; }
		
		/// <summary>
		/// The month, day, year, and time of day that the <em>action_type</em> <strong>stop</strong> should occur. Specify <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stop_transcoder")]
		public System.Nullable<System.DateTimeOffset> Stop_transcoder { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the transcoder being scheduled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transcoder_id")]
		public string Transcoder_id { get; set; }
		
		/// <summary>
		/// The name of the transcoder being scheduled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transcoder_name")]
		public string Transcoder_name { get; set; }
		
		/// <summary>
		/// The date and time that the schedule was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ScheduleAction_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		start = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stop = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		start_stop = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ScheduleRecurrence_data
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sunday = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		monday = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tuesday = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wednesday = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		thursday = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		friday = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		saturday = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ScheduleRecurrence_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		once = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		recur = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ScheduleState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		expired = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Schedule_create_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public Schedule_create_inputSchedule Schedule { get; set; }
	}
	
	public class Schedule_create_inputSchedule
	{
		
		/// <summary>
		/// The type of action that the schedule should trigger on the transcoder. The default is <strong>start</strong>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action_type")]
		public ScheduleAction_type Action_type { get; set; }
		
		/// <summary>
		/// The month, day, and year that a recurring schedule should stop running. Specify <strong>YYYY-MM-DD</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end_repeat")]
		public System.Nullable<System.DateOnly> End_repeat { get; set; }
		
		/// <summary>
		/// A descriptive name for the schedule. Maximum 255 characters.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The day or days of the week that a recurring schedule should run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recurrence_data")]
		public ScheduleRecurrence_data Recurrence_data { get; set; }
		
		/// <summary>
		/// A schedule can run one time only (<strong>once</strong>) or repeat (<strong>recur</strong>) until a specified <em>end_repeat</em> date. The default is <strong>once</strong>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="recurrence_type")]
		public ScheduleRecurrence_type Recurrence_type { get; set; }
		
		/// <summary>
		/// The month, day, and year that the recurring schedule should go into effect. Specify <strong>YYYY-MM-DD</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_repeat")]
		public System.Nullable<System.DateOnly> Start_repeat { get; set; }
		
		/// <summary>
		/// The month, day, year, and time of day that the <em>action_type</em> <strong>start</strong> should occur. Specify <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_transcoder")]
		public System.Nullable<System.DateTimeOffset> Start_transcoder { get; set; }
		
		/// <summary>
		/// The month, day, year, and time of day that the <em>action_type</em> <strong>stop</strong> should occur. Specify <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stop_transcoder")]
		public System.Nullable<System.DateTimeOffset> Stop_transcoder { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the transcoder being scheduled.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transcoder_id")]
		public string Transcoder_id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Schedule_update_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public Schedule_update_inputSchedule Schedule { get; set; }
	}
	
	public class Schedule_update_inputSchedule
	{
		
		/// <summary>
		/// The type of action that the schedule should trigger on the transcoder. The default is <strong>start</strong>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action_type")]
		public ScheduleAction_type Action_type { get; set; }
		
		/// <summary>
		/// The month, day, and year that a recurring schedule should stop running. Specify <strong>YYYY-MM-DD</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end_repeat")]
		public System.Nullable<System.DateOnly> End_repeat { get; set; }
		
		/// <summary>
		/// A descriptive name for the schedule. Maximum 255 characters.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The day or days of the week that a recurring schedule should run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recurrence_data")]
		public ScheduleRecurrence_data Recurrence_data { get; set; }
		
		/// <summary>
		/// The month, day, and year that the recurring schedule should go into effect. Specify <strong>YYYY-MM-DD</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_repeat")]
		public System.Nullable<System.DateOnly> Start_repeat { get; set; }
		
		/// <summary>
		/// The month, day, year, and time of day that the <em>action_type</em> <strong>start</strong> should occur. Specify <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_transcoder")]
		public System.Nullable<System.DateTimeOffset> Start_transcoder { get; set; }
		
		/// <summary>
		/// The month, day, year, and time of day that the <em>action_type</em> <strong>stop</strong> should occur. Specify <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stop_transcoder")]
		public System.Nullable<System.DateTimeOffset> Stop_transcoder { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Schedules
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="schedules")]
		public Schedule[] Schedules1 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Shm_historic_metrics
	{
		
		[System.Runtime.Serialization.DataMember(Name="audio_codec")]
		public Audio_codec_metric Audio_codec { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="bits_in_rate")]
		public Bits_in_rate_metric Bits_in_rate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="bits_out_rate")]
		public Bits_out_rate_metric Bits_out_rate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cpu_idle")]
		public Cpu_idle_metric Cpu_idle { get; set; }
		
		/// <summary>
		/// The date and time that the stream health record was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="frame_rate")]
		public Frame_rate_metric Frame_rate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="height")]
		public Height_metric Height { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="keyframe_interval")]
		public Keyframe_interval_metric Keyframe_interval { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="video_codec")]
		public Video_codec_metric Video_codec { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="width")]
		public Width_metric Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Video_codec_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Width_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Int32> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Shm_metrics
	{
		
		[System.Runtime.Serialization.DataMember(Name="audio_codec")]
		public Audio_codec_metric Audio_codec { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="bits_in_rate")]
		public Bits_in_rate_metric Bits_in_rate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="bits_out_rate")]
		public Bits_out_rate_metric Bits_out_rate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="bytes_in_rate")]
		public Bytes_in_rate_metric Bytes_in_rate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="bytes_out_rate")]
		public Bytes_out_rate_metric Bytes_out_rate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="configured_bytes_out_rate")]
		public Configured_bytes_out_rate_metric Configured_bytes_out_rate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="connected")]
		public Connected_metric Connected { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cpu")]
		public Cpu_metric Cpu { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="frame_rate")]
		public Frame_rate_metric Frame_rate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="frame_size")]
		public Frame_size_metric Frame_size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gpu_decoder_usage")]
		public Gpu_decoder_usage_metric Gpu_decoder_usage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gpu_driver_version")]
		public Gpu_driver_version_metric Gpu_driver_version { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gpu_encoder_usage")]
		public Gpu_encoder_usage_metric Gpu_encoder_usage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gpu_memory_usage")]
		public Gpu_memory_usage_metric Gpu_memory_usage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gpu_usage")]
		public Gpu_usage_metric Gpu_usage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="height")]
		public Height_metric Height { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="keyframe_interval")]
		public Keyframe_interval_metric Keyframe_interval { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stream_target_status_OUTPUTIDX_STREAMTARGETIDX")]
		public Stream_target_status_OUTPUTIDX_STREAMTARGETIDX_metric Stream_target_status_OUTPUTIDX_STREAMTARGETIDX { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="unique_views")]
		public Unique_views_metric Unique_views { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="video_codec")]
		public Video_codec_metric Video_codec { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="width")]
		public Width_metric Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Stream_target_status_OUTPUTIDX_STREAMTARGETIDX_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Unique_views_metric
	{
		
		/// <summary>
		/// The status of the current key. Possible values are <strong>normal</strong> (everything is fine), <strong>warning</strong> (something may be misconfigured), and <strong>no_data</strong> (no data was returned, perhaps because the instance isn't running).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A message related to the value and status of the current key. Usually blank unless there's a warning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The unit of the returned value, such as <strong>Kbps</strong>, <strong>bps</strong>, <strong>%</strong>, <strong>FPS</strong>, or <strong>GOP</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
		
		/// <summary>
		/// The value of the associated key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Int32> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Stream_source
	{
		
		/// <summary>
		/// If <em>location_method</em> is <strong>ip_address</strong>, specify the backup IP address of the source encoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backup_ip_address")]
		public string Backup_ip_address { get; set; }
		
		/// <summary>
		/// The backup RTMP playback URL of the transcoded stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backup_url")]
		public string Backup_url { get; set; }
		
		/// <summary>
		/// The date and time that the stream source was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the stream source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// If <em>location_method</em> is <strong>ip_address</strong>, specify the primary IP address of the source encoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip_address")]
		public string Ip_address { get; set; }
		
		/// <summary>
		/// If <em>location_method</em> is <strong>region</strong>, specify a location as close as possible to the source encoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Index_stream_targetLocation Location { get; set; }
		
		/// <summary>
		/// The method used to determine the location of the stream source, either by <strong>region</strong> or based on the source encoder's <strong>ip_address</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location_method")]
		public System.Nullable<Stream_sourceLocation_method> Location_method { get; set; }
		
		/// <summary>
		/// A descriptive name for the stream source. Maximum 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The password that you can use to configure the source encoder to authenticate to the stream source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// The full RTMP playback URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="playback_url")]
		public string Playback_url { get; set; }
		
		/// <summary>
		/// The primary RTMP playback URL of the transcoded stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary_url")]
		public string Primary_url { get; set; }
		
		/// <summary>
		/// The provider of the Wowza Streaming Cloud stream source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provider")]
		public string Provider { get; set; }
		
		/// <summary>
		/// The name of the stream that you can use to configure the source encoder to connect to the stream source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_name")]
		public string Stream_name { get; set; }
		
		/// <summary>
		/// The date and time that the stream source was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// The username that you can use to configure the source encoder to authenticate to the stream source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Stream_sourceLocation_method
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		region = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ip_address = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Stream_source_create_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_source")]
		public Stream_source_create_inputStream_source Stream_source { get; set; }
	}
	
	public class Stream_source_create_inputStream_source
	{
		
		/// <summary>
		/// If <em>location_method</em> is <strong>ip_address</strong>, specify the backup IP address of the source encoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backup_ip_address")]
		public string Backup_ip_address { get; set; }
		
		/// <summary>
		/// If <em>location_method</em> is <strong>ip_address</strong>, specify the primary IP address of the source encoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip_address")]
		public string Ip_address { get; set; }
		
		/// <summary>
		/// If <em>location_method</em> is <strong>region</strong>, specify a location as close as possible to the source encoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Index_stream_targetLocation Location { get; set; }
		
		/// <summary>
		/// The method used to determine the location of the stream source, either by <strong>region</strong> or based on the source encoder's <strong>ip_address</strong>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location_method")]
		public Stream_sourceLocation_method Location_method { get; set; }
		
		/// <summary>
		/// A descriptive name for the stream source. Maximum 255 characters.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Stream_source_update_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_source")]
		public Stream_source_update_inputStream_source Stream_source { get; set; }
	}
	
	public class Stream_source_update_inputStream_source
	{
		
		/// <summary>
		/// A descriptive name for the stream source. Maximum 255 characters.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Stream_sources
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_sources")]
		public Stream_source[] Stream_sources1 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Stream_target_create_input
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Stream_target_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_target")]
		public Stream_target_inputStream_target Stream_target { get; set; }
	}
	
	public class Stream_target_inputStream_target
	{
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. The backup RTMP ingest URL of the target, without the preceding protocol and without the trailing slash (/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backup_url")]
		public string Backup_url { get; set; }
		
		/// <summary>
		/// <strong>The <em>chunk_size</em> parameter is deprecated. To set the chunk size of a stream target, use the POST /stream_targets/[stream_target_id]/properties endpoint.</strong> Only for targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> and <em>provider</em> is <strong>akamai_cupertino</strong>. The segment duration for HLS encoding. The default is <strong>10</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="chunk_size")]
		public System.Nullable<Stream_target_inputStream_targetChunk_size> Chunk_size { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong>. If <strong>true</strong>, creates an Apple HLS URL for playback on iOS devices (<em>hls_playback_url</em>). The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enable_hls")]
		public System.Nullable<System.Boolean> Enable_hls { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong>. If <strong>true</strong> (the default), the source stream is ready to be ingested. If **false**, the source stream won't be ingested by the target's origin server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong> and <em>provider</em> is <em>not</em> <strong>akamai_cupertino</strong>. The web address that the target uses to play Adobe HDS streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hds_playback_url")]
		public string Hds_playback_url { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. The web address that the target uses to play Apple HLS streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hls_playback_url")]
		public string Hls_playback_url { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong> and <em>source_delivery_method</em> is **push**. A list of IP addresses that can be used to connect to the target's origin server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ingest_ip_whitelist")]
		public string[] Ingest_ip_whitelist { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> and <em>provider</em> is <em>not</em> <strong>akamai_cupertino</strong>. Choose a location as close as possible to your video source.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Index_stream_targetLocation Location { get; set; }
		
		/// <summary>
		/// A descriptive name for the stream target. Maximum 255 characters.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong> and <em>provider</em> is <em>not</em> **akamai_cupertino**. A <em>username</em> must also be present. The password associated with the target username for RTMP authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. The primary RTMP ingest URL, without the preceding protocol and without the trailing slash (/).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primary_url")]
		public string Primary_url { get; set; }
		
		/// <summary>
		/// The CDN for the target. <br /><br />Required for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. Valid values for <strong>CustomStreamTarget</strong> are <strong>akamai</strong>, <strong>akamai_cupertino</strong>, <strong>akamai_rtmp</strong>, <strong>limelight</strong>, <strong>rtmp</strong>, and <strong>ustream</strong>. Values can be appended with **_mock** to use in the sandbox environment. <br /><br />Valid values for <strong>WowzaStreamTarget</strong> are <strong>akamai</strong>, <strong>akamai_cupertino</strong> (default), <strong>akamai_legacy_rtmp</strong>, and <strong>wowza</strong>. <br /><br /><strong>UltraLowLatencyStreamTarget</strong> defaults to and must be <strong>wowza</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provider")]
		public string Provider { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong> and <em>source_delivery_method</em> is **pull**. The location of the stream target's origin server. If unspecified, Wowza Streaming Cloud determines the optimal region for the origin server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region_override")]
		public System.Nullable<Stream_target_inputStream_targetRegion_override> Region_override { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. The web address that the target uses to play RTMP streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rtmp_playback_url")]
		public string Rtmp_playback_url { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong>. The type of connection between the stream source and the stream target. **push** instructs the source to push the stream to the stream target. **pull** instructs the stream target to pull the stream from the source.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source_delivery_method")]
		public Stream_targetSource_delivery_method Source_delivery_method { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong> and <em>source_delivery_method</em> is **pull**. The URL of a source IP camera or encoder connecting to the stream target.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source_url")]
		public string Source_url { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. The name of the stream as defined in the target's ingestion settings.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_name")]
		public string Stream_name { get; set; }
		
		/// <summary>
		/// <strong>WowzaStreamTarget</strong> is a Wowza CDN target. <strong>UltraLowLatencyStreamTarget</strong> is an ultra low latency Wowza stream target. <strong>CustomStreamTarget</strong> (the default) is an external, third-party destination. <!--and <strong>FacebookStreamTarget</strong> (a Facebook Live target).-->
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Index_stream_targetType Type { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> and <em>provider</em> is <strong>akamai_cupertino</strong>. CORS, or cross-origin resource sharing, allows streams to be sent to providers such as Peer5, Viblast, and Streamroot, which implement a peer-to-peer grid delivery system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_cors")]
		public System.Nullable<System.Boolean> Use_cors { get; set; }
		
		/// <summary>
		/// <strong>The <em>use_https</em> parameter is deprecated. Use the POST /stream_targets/[<em>stream_target_id</em>]/properties endpoint and the <em>relative_playlists</em> parameter instead.</strong>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_https")]
		public System.Nullable<System.Boolean> Use_https { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> and <em>provider</em> is <strong>akamai_cupertino</strong>. If <strong>true</strong>, generates a <em>secure_ingest_query_param</em> to securely deliver the stream from the transcoder to the provider.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_secure_ingest")]
		public System.Nullable<System.Boolean> Use_secure_ingest { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong> and <em>provider</em> is <em>not</em> **akamai_cupertino**. The username or ID that the target uses for RTMP authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Stream_target_inputStream_targetChunk_size
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2")]
		_2 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4")]
		_4 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8")]
		_8 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="10")]
		_10 = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Stream_target_inputStream_targetRegion_override
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="azure-westus")]
		azureMinuswestus = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="azure-eastus2")]
		azureMinuseastus2 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="azure-northeurope")]
		azureMinusnortheurope = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Stream_target_metrics
	{
		
		/// <summary>
		/// The average number of bytes transfered to the origin server by the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="average_bytes_in")]
		public System.Nullable<System.Single> Average_bytes_in { get; set; }
		
		/// <summary>
		/// The total number of current connections.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="average_total_connections")]
		public System.Nullable<System.Single> Average_total_connections { get; set; }
		
		/// <summary>
		/// The date and time, in UTC, that the metrics were recorded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The total number of dropped connections since the last interval.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dropped_connections")]
		public System.Nullable<System.Int32> Dropped_connections { get; set; }
		
		/// <summary>
		/// The maximum number of connections during the interval.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximum_total_connections")]
		public System.Nullable<System.Int32> Maximum_total_connections { get; set; }
		
		/// <summary>
		/// The minimum number of connections during the interval.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimum_total_connections")]
		public System.Nullable<System.Int32> Minimum_total_connections { get; set; }
		
		/// <summary>
		/// The total number of new connections since the last interval.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="new_connections")]
		public System.Nullable<System.Int32> New_connections { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Stream_target_properties
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public Stream_target_property[] Properties { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Stream_target_property
	{
		
		/// <summary>
		/// <strong>chunkSize</strong> defines the duration of the time-based audio and video chunks that Wowza Streaming Cloud delivers to the target. <strong>playSSL</strong> determines whether Wowza Streaming Cloud sends the stream from the target to the player by using SSL (HTTPS). <strong>relativePlaylists</strong> allows the viewer to watch the stream over HTTP and HTTPS, whichever protocol their browser calls. <strong>sendSSL</strong> determines whether Wowza Streaming Cloud sends the stream from the transcoder to the target by using SSL (HTTPS).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public System.Nullable<Stream_target_propertyKey> Key { get; set; }
		
		/// <summary>
		/// The section of the stream target configuration table that contains the property. For <strong>chunkSize</strong> and <strong>sendSSL</strong>, use <strong>hls</strong>. For <strong>playSSL</strong> and <strong>relativePlaylists</strong>, use <strong>playlist</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="section")]
		public System.Nullable<Stream_target_propertySection> Section { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_target_id")]
		public string Stream_target_id { get; set; }
		
		/// <summary>
		/// For <strong>chunkSize</strong> use <strong>2</strong>, <strong>4</strong>, <strong>6</strong>, <strong>8</strong>, or <strong>10</strong>. For <strong>playSSL</strong>, <strong>relativePlaylists</strong>, and <strong>sendSSL</strong> use <strong>true</strong> or <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<Stream_target_propertyValue> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Stream_target_propertyKey
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		chunkSize = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		playSSL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		relativePlaylists = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sendSSL = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Stream_target_propertySection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hls = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		playlist = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Stream_target_propertyValue
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2")]
		_2 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4")]
		_4 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8")]
		_8 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="10")]
		_10 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="true")]
		_true = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="false")]
		_false = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Stream_target_property_create_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="property")]
		public Stream_target_property_create_inputProperty Property { get; set; }
	}
	
	public class Stream_target_property_create_inputProperty
	{
		
		/// <summary>
		/// <strong>chunkSize</strong> defines the duration of the time-based audio and video chunks that Wowza Streaming Cloud delivers to the target. <strong>playSSL</strong> determines whether Wowza Streaming Cloud sends the stream from the target to the player by using SSL (HTTPS). <strong>relativePlaylists</strong> allows the viewer to watch the stream over HTTP and HTTPS, whichever protocol their browser calls. <strong>sendSSL</strong> determines whether Wowza Streaming Cloud sends the stream from the transcoder to the target by using SSL (HTTPS).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public Stream_target_propertyKey Key { get; set; }
		
		/// <summary>
		/// The section of the stream target configuration table that contains the property. For <strong>chunkSize</strong> and <strong>sendSSL</strong>, use <strong>hls</strong>. For <strong>playSSL</strong> and <strong>relativePlaylists</strong>, use <strong>playlist</strong>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="section")]
		public Stream_target_propertySection Section { get; set; }
		
		/// <summary>
		/// For <strong>chunkSize</strong> use <strong>2</strong>, <strong>4</strong>, <strong>6</strong>, <strong>8</strong>, or <strong>10</strong>. For <strong>playSSL</strong>, <strong>relativePlaylists</strong>, and <strong>sendSSL</strong> use <strong>true</strong> or <strong>false</strong>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public Stream_target_property_create_inputPropertyValue Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Stream_target_property_create_inputPropertyValue
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2")]
		_2 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4")]
		_4 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8")]
		_8 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="10")]
		_10 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="true")]
		_true = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="false")]
		_false = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Stream_target_update_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_target")]
		public Stream_target_update_inputStream_target Stream_target { get; set; }
	}
	
	public class Stream_target_update_inputStream_target
	{
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. The backup RTMP ingest URL of the target, without the preceding protocol and without the trailing slash (/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backup_url")]
		public string Backup_url { get; set; }
		
		/// <summary>
		/// <strong>The <em>chunk_size</em> parameter is deprecated. To set the chunk size of a stream target, use the POST /stream_targets/[stream_target_id]/properties endpoint.</strong> Only for targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> and <em>provider</em> is <strong>akamai_cupertino</strong>. The segment duration for HLS encoding. The default is <strong>10</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="chunk_size")]
		public System.Nullable<Stream_target_update_inputStream_targetChunk_size> Chunk_size { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong>. If <strong>true</strong> (the default), the source stream is ready to be ingested. If **false**, the source stream won't be ingested by the target's origin server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong> and <em>provider</em> is <em>not</em> <strong>akamai_cupertino</strong>. The web address that the target uses to play Adobe HDS streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hds_playback_url")]
		public string Hds_playback_url { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. The web address that the target uses to play Apple HLS streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hls_playback_url")]
		public string Hls_playback_url { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong> and <em>source_delivery_method</em> is **push**. A list of IP addresses that can be used to connect to the target's origin server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ingest_ip_whitelist")]
		public string[] Ingest_ip_whitelist { get; set; }
		
		/// <summary>
		/// A descriptive name for the stream target. Maximum 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong> and <em>provider</em> is <em>not</em> **akamai_cupertino**. A <em>username</em> must also be present. The password associated with the target username for RTMP authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. The primary RTMP ingest URL, without the preceding protocol and without the trailing slash (/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary_url")]
		public string Primary_url { get; set; }
		
		/// <summary>
		/// The CDN for the target. <br /><br />Required for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. Valid values for <strong>CustomStreamTarget</strong> are <strong>akamai</strong>, <strong>akamai_cupertino</strong>, <strong>akamai_rtmp</strong>, <strong>limelight</strong>, <strong>rtmp</strong>, and <strong>ustream</strong>. Values can be appended with **_mock** to use in the sandbox environment. <br /><br />Valid values for <strong>WowzaStreamTarget</strong> are <strong>akamai</strong>, <strong>akamai_cupertino</strong> (default), <strong>akamai_legacy_rtmp</strong>, and <strong>wowza</strong>. <br /><br /><strong>UltraLowLatencyStreamTarget</strong> defaults to and must be <strong>wowza</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provider")]
		public string Provider { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. The web address that the target uses to play RTMP streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rtmp_playback_url")]
		public string Rtmp_playback_url { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong> and <em>source_delivery_method</em> is **pull**. The URL of a source IP camera or encoder connecting to the stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source_url")]
		public string Source_url { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. The name of the stream as defined in the target's ingestion settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_name")]
		public string Stream_name { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>CustomStreamTarget</strong> and <em>provider</em> is <em>not</em> **akamai_cupertino**. The username or ID that the target uses for RTMP authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Stream_target_update_inputStream_targetChunk_size
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2")]
		_2 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4")]
		_4 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8")]
		_8 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="10")]
		_10 = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Stream_targets
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_targets")]
		public Index_stream_target[] Stream_targets1 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Token_auth
	{
		
		/// <summary>
		/// The date and time that the token authorization was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// Specify <strong>true</strong> to enable token authorization or <strong>false</strong> to disable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_target_id")]
		public string Stream_target_id { get; set; }
		
		/// <summary>
		/// The trusted shared secret of the token authorization. Must contain only hexadecimal characters and be an even number of total characters not exceeding 32.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trusted_shared_secret")]
		public string Trusted_shared_secret { get; set; }
		
		/// <summary>
		/// The date and time that the token authorization was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Token_auth_create_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="token_auth")]
		public Token_auth_create_inputToken_auth Token_auth { get; set; }
	}
	
	public class Token_auth_create_inputToken_auth
	{
		
		/// <summary>
		/// Specify <strong>true</strong> to enable token authorization or <strong>false</strong> to disable.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// The trusted shared secret of the token authorization. Must contain only hexadecimal characters and be an even number of total characters not exceeding 32.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trusted_shared_secret")]
		public string Trusted_shared_secret { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Token_auth_update_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="token_auth")]
		public Token_auth_update_inputToken_auth Token_auth { get; set; }
	}
	
	public class Token_auth_update_inputToken_auth
	{
		
		/// <summary>
		/// Specify <strong>true</strong> to enable token authorization or <strong>false</strong> to disable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The trusted shared secret of the token authorization. Must contain only hexadecimal characters and be an even number of total characters not exceeding 32.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trusted_shared_secret")]
		public string Trusted_shared_secret { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Transcoder
	{
		
		/// <summary>
		/// The application name from the pull stream source URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="application_name")]
		public string Application_name { get; set; }
		
		/// <summary>
		/// The billing mode for the transcoder. The default is <strong>pay_as_you_go</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="billing_mode")]
		public Live_streamBilling_mode Billing_mode { get; set; }
		
		/// <summary>
		/// The location where Wowza Streaming Cloud transcodes your stream. Choose a location as close as possible to your video source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="broadcast_location")]
		public Index_stream_targetLocation Broadcast_location { get; set; }
		
		/// <summary>
		/// The size, in milliseconds, of the incoming buffer. <strong>0</strong> means no buffer. The default is <strong>4000</strong> (4 seconds).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="buffer_size")]
		public System.Nullable<TranscoderBuffer_size> Buffer_size { get; set; }
		
		/// <summary>
		/// The type of closed caption data being passed from the source. The default, <strong>none</strong>, indicates that no data is being provided. <strong>cea</strong> indicates that a CEA closed captioning data stream is being provided. <strong>on_text</strong> indicates that an onTextData closed captioning data stream is being provided. <strong>both</strong> indicates that both CEA and onTextData closed captioing data streams are being provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="closed_caption_type")]
		public Live_streamClosed_caption_type Closed_caption_type { get; set; }
		
		/// <summary>
		/// The date and time that the transcoder was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The type of connection between the source encoder and the transcoder. The default, <strong>pull</strong>, instructs the transcoder to pull the video from the source. <strong>push</strong> instructs the source to push the stream to the transcoder. <strong>cdn</strong> uses a stream source to deliver the stream to the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delivery_method")]
		public Live_streamDelivery_method Delivery_method { get; set; }
		
		/// <summary>
		/// An array of playback protocols enabled for this transcoder. By default, <strong>rtmp</strong>, <strong>rtsp</strong>, and <strong>wowz</strong> are returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delivery_protocols")]
		public string[] Delivery_protocols { get; set; }
		
		/// <summary>
		/// An optional description of the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// An array of direct playback URLs the transcoder's delivery protocols. Each protocol has a URL for the source and a URL for each output rendition.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="direct_playback_urls")]
		public TranscoderDirect_playback_urls[] TranscoderDirect_playback_urls { get; set; }
		
		/// <summary>
		/// Authentication is required by default for RTMP and RTSP push connections from a video source to the transcoder. Specify <strong>true</strong> to disable authentication with the video source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disable_authentication")]
		public System.Nullable<System.Boolean> Disable_authentication { get; set; }
		
		/// <summary>
		/// The domain name from the pull stream source URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domain_name")]
		public string Domain_name { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The amount of idle time, in seconds, before the transcoder automatically shuts down. Valid values are the integers <strong>0</strong> (never shuts down) to <strong>172800</strong> (48 hours). The default is <strong>1200</strong> (20 minutes).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="idle_timeout")]
		public System.Nullable<System.Int32> Idle_timeout { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, turns off the sort packet buffer and speeds the time it takes to decode and deliver video data to the player. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="low_latency")]
		public System.Nullable<System.Boolean> Low_latency { get; set; }
		
		/// <summary>
		/// A descriptive name for the transcoder. Maximum 200 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output renditions associated with the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputs")]
		public Output[] Outputs { get; set; }
		
		/// <summary>
		/// A password for authenticating an RTMP or RTSP push connection. Can contain only uppercase and lowercase letters; numbers; and the period (.), underscore (_), and hyphen (-) characters. No other special characters can be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// The number of users who are allowed to connect directly to the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="play_maximum_connections")]
		public System.Nullable<TranscoderPlay_maximum_connections> Play_maximum_connections { get; set; }
		
		/// <summary>
		/// The transport protocol for the source video. The default is <strong>rtmp</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public System.Nullable<TranscoderProtocol> Protocol { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, creates a recording of the transcoded output. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recording")]
		public System.Nullable<System.Boolean> Recording { get; set; }
		
		/// <summary>
		/// The port used for RTMP pull connections to Wowza Streaming Cloud.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source_port")]
		public System.Nullable<System.Int32> Source_port { get; set; }
		
		/// <summary>
		/// For the <em>delivery_method</em> <strong>pull</strong>. Enter the source's web address without the preceding protocol or the trailing slash (/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source_url")]
		public string Source_url { get; set; }
		
		/// <summary>
		/// For the <em>delivery_method</em> <strong>push</strong>. Some encoders append an extension to their stream names. If the device you're using does this, enter the extension.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_extension")]
		public string Stream_extension { get; set; }
		
		/// <summary>
		/// The stream name from the pull stream source URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_name")]
		public string Stream_name { get; set; }
		
		/// <summary>
		/// A dynamic buffer that helps stabilize streams in rough network conditions, but adds latency. Specify <strong>true</strong> to enable stream smoothing. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_smoother")]
		public System.Nullable<System.Boolean> Stream_smoother { get; set; }
		
		/// <summary>
		/// For the <em>delivery_method</em> <strong>cdn</strong>. The alphanumeric string that identifies the stream source that you want to use to deliver the stream to the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_source_id")]
		public string Stream_source_id { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, disables stream targets when the transcoder starts. If <strong>false</strong> (the default), the targets start when the transcoder starts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="suppress_stream_target_start")]
		public System.Nullable<System.Boolean> Suppress_stream_target_start { get; set; }
		
		/// <summary>
		/// The type of transcoder, either <strong>transcoded</strong> for streams that are transcoded into adaptive bitrate renditions or <strong>passthrough</strong> for streams that aren't processed by the transcoder. The default is <strong>transcoded</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transcoder_type")]
		public Live_streamTranscoder_type Transcoder_type { get; set; }
		
		/// <summary>
		/// The date and time that the transcoder was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// A username for authenticating an RTMP or RTSP push connection. Can contain only uppercase and lowercase letters; numbers; and the period (.), underscore (_), and hyphen (-) characters. No other special characters can be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, black video plays if the video source disconnects from the transcoder. If <strong>false</strong> (the default), a stream-not-available message appears. Works only with stream targets whose <em>provider</em> is <strong>akamai_cupertino</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="video_fallback")]
		public System.Nullable<System.Boolean> Video_fallback { get; set; }
		
		/// <summary>
		/// Embeds an image into the transcoded stream for copyright protection. Specify <strong>true</strong> to embed a watermark image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="watermark")]
		public System.Nullable<System.Boolean> Watermark { get; set; }
		
		/// <summary>
		/// The height, in pixels, of the watermark image. If blank, Wowza Streaming Cloud uses the original image height.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="watermark_height")]
		public System.Nullable<System.Int32> Watermark_height { get; set; }
		
		/// <summary>
		/// The path to a GIF, JPEG, or PNG image that is embedded in all bitrate renditions of the stream. Watermark image files must be 2.5 MB or smaller.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="watermark_image_url")]
		public string Watermark_image_url { get; set; }
		
		/// <summary>
		/// The opacity, or percentage of transparency, of the watermark. <strong>0</strong> is fully transparent; <strong>100</strong> is fully opaque.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="watermark_opacity")]
		public System.Nullable<TranscoderWatermark_opacity> Watermark_opacity { get; set; }
		
		/// <summary>
		/// The corner of the video frame in which you want the watermark to appear. The default is <strong>top-left</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="watermark_position")]
		public System.Nullable<TranscoderWatermark_position> Watermark_position { get; set; }
		
		/// <summary>
		/// The width, in pixels, of the watermark image. If blank, Wowza Streaming Cloud uses the original image width.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="watermark_width")]
		public System.Nullable<System.Int32> Watermark_width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum TranscoderBuffer_size
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1000 = 1000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2000 = 2000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3000 = 3000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_4000 = 4000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_5000 = 5000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_6000 = 6000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_7000 = 7000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_8000 = 8000,
	}
	
	public class TranscoderDirect_playback_urls
	{
		
		/// <summary>
		/// The name of the playback URL: <strong>source</strong>, <strong>passthrough</strong>, or the output rendition's resolution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Only for output rendition-based playback URLs, not source playback URLs. The unique alphanumeric string that identifies the output rendition.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="output_id")]
		public string Output_id { get; set; }
		
		/// <summary>
		/// The playback URL for the source or output rendition.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum TranscoderPlay_maximum_connections
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_10 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_11 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_12 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_13 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_14 = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_15 = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_16 = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_17 = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_18 = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_19 = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_20 = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_21 = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_22 = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_23 = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_24 = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_25 = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_26 = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_27 = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_28 = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_29 = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_30 = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_31 = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_32 = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_33 = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_34 = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_35 = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_36 = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_37 = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_38 = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_39 = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_40 = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_41 = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_42 = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_43 = 43,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_44 = 44,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_45 = 45,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_46 = 46,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_47 = 47,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_48 = 48,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_49 = 49,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_50 = 50,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_51 = 51,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_52 = 52,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_53 = 53,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_54 = 54,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_55 = 55,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_56 = 56,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_57 = 57,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_58 = 58,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_59 = 59,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_60 = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_61 = 61,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_62 = 62,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_63 = 63,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_64 = 64,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_65 = 65,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_66 = 66,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_67 = 67,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_68 = 68,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_69 = 69,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_70 = 70,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_71 = 71,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_72 = 72,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_73 = 73,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_74 = 74,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_75 = 75,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_76 = 76,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_77 = 77,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_78 = 78,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_79 = 79,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_80 = 80,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_81 = 81,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_82 = 82,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_83 = 83,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_84 = 84,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_85 = 85,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_86 = 86,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_87 = 87,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_88 = 88,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_89 = 89,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_90 = 90,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_91 = 91,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_92 = 92,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_93 = 93,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_94 = 94,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_95 = 95,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_96 = 96,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_97 = 97,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_98 = 98,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_99 = 99,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_100 = 100,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum TranscoderProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rtmp = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rtsp = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum TranscoderWatermark_opacity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_4 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_5 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_6 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_7 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_8 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_9 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_10 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_11 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_12 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_13 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_14 = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_15 = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_16 = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_17 = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_18 = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_19 = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_20 = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_21 = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_22 = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_23 = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_24 = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_25 = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_26 = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_27 = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_28 = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_29 = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_30 = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_31 = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_32 = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_33 = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_34 = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_35 = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_36 = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_37 = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_38 = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_39 = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_40 = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_41 = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_42 = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_43 = 43,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_44 = 44,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_45 = 45,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_46 = 46,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_47 = 47,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_48 = 48,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_49 = 49,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_50 = 50,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_51 = 51,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_52 = 52,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_53 = 53,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_54 = 54,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_55 = 55,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_56 = 56,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_57 = 57,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_58 = 58,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_59 = 59,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_60 = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_61 = 61,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_62 = 62,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_63 = 63,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_64 = 64,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_65 = 65,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_66 = 66,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_67 = 67,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_68 = 68,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_69 = 69,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_70 = 70,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_71 = 71,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_72 = 72,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_73 = 73,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_74 = 74,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_75 = 75,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_76 = 76,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_77 = 77,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_78 = 78,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_79 = 79,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_80 = 80,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_81 = 81,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_82 = 82,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_83 = 83,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_84 = 84,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_85 = 85,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_86 = 86,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_87 = 87,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_88 = 88,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_89 = 89,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_90 = 90,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_91 = 91,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_92 = 92,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_93 = 93,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_94 = 94,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_95 = 95,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_96 = 96,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_97 = 97,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_98 = 98,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_99 = 99,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_100 = 100,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum TranscoderWatermark_position
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="top-left")]
		topMinusleft = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="top-right")]
		topMinusright = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bottom-left")]
		bottomMinusleft = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bottom-right")]
		bottomMinusright = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Transcoder_create_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transcoder")]
		public Transcoder_create_inputTranscoder Transcoder { get; set; }
	}
	
	public class Transcoder_create_inputTranscoder
	{
		
		/// <summary>
		/// The billing mode for the transcoder. The default is <strong>pay_as_you_go</strong>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="billing_mode")]
		public Live_streamBilling_mode Billing_mode { get; set; }
		
		/// <summary>
		/// The location where Wowza Streaming Cloud transcodes your stream. Choose a location as close as possible to your video source.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="broadcast_location")]
		public Index_stream_targetLocation Broadcast_location { get; set; }
		
		/// <summary>
		/// The size, in milliseconds, of the incoming buffer. <strong>0</strong> means no buffer. The default is <strong>4000</strong> (4 seconds).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="buffer_size")]
		public System.Nullable<Transcoder_create_inputTranscoderBuffer_size> Buffer_size { get; set; }
		
		/// <summary>
		/// The type of closed caption data being passed from the source. The default, <strong>none</strong>, indicates that no data is being provided. <strong>cea</strong> indicates that a CEA closed captioning data stream is being provided. <strong>on_text</strong> indicates that an onTextData closed captioning data stream is being provided. <strong>both</strong> indicates that both CEA and onTextData closed captioing data streams are being provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="closed_caption_type")]
		public Live_streamClosed_caption_type Closed_caption_type { get; set; }
		
		/// <summary>
		/// The type of connection between the source encoder and the transcoder. The default, <strong>pull</strong>, instructs the transcoder to pull the video from the source. <strong>push</strong> instructs the source to push the stream to the transcoder. <strong>cdn</strong> uses a stream source to deliver the stream to the transcoder.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delivery_method")]
		public Live_streamDelivery_method Delivery_method { get; set; }
		
		/// <summary>
		/// An array of playback protocols enabled for this transcoder. By default, <strong>rtmp</strong>, <strong>rtsp</strong>, and <strong>wowz</strong> are returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delivery_protocols")]
		public string[] Delivery_protocols { get; set; }
		
		/// <summary>
		/// An optional description of the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Authentication is required by default for RTMP and RTSP push connections from a video source to the transcoder. Specify <strong>true</strong> to disable authentication with the video source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disable_authentication")]
		public System.Nullable<System.Boolean> Disable_authentication { get; set; }
		
		/// <summary>
		/// The amount of idle time, in seconds, before the transcoder automatically shuts down. Valid values are the integers <strong>0</strong> (never shuts down) to <strong>172800</strong> (48 hours). The default is <strong>1200</strong> (20 minutes).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="idle_timeout")]
		public System.Nullable<System.Int32> Idle_timeout { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, turns off the sort packet buffer and speeds the time it takes to decode and deliver video data to the player. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="low_latency")]
		public System.Nullable<System.Boolean> Low_latency { get; set; }
		
		/// <summary>
		/// A descriptive name for the transcoder. Maximum 200 characters.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A password for authenticating an RTMP or RTSP push connection. Can contain only uppercase and lowercase letters; numbers; and the period (.), underscore (_), and hyphen (-) characters. No other special characters can be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// The number of users who are allowed to connect directly to the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="play_maximum_connections")]
		public System.Nullable<Transcoder_create_inputTranscoderPlay_maximum_connections> Play_maximum_connections { get; set; }
		
		/// <summary>
		/// The transport protocol for the source video. The default is <strong>rtmp</strong>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public TranscoderProtocol Protocol { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, creates a recording of the transcoded output. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recording")]
		public System.Nullable<System.Boolean> Recording { get; set; }
		
		/// <summary>
		/// For the <em>delivery_method</em> <strong>pull</strong>. Enter the source's web address without the preceding protocol or the trailing slash (/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source_url")]
		public string Source_url { get; set; }
		
		/// <summary>
		/// For the <em>delivery_method</em> <strong>push</strong>. Some encoders append an extension to their stream names. If the device you're using does this, enter the extension.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_extension")]
		public string Stream_extension { get; set; }
		
		/// <summary>
		/// A dynamic buffer that helps stabilize streams in rough network conditions, but adds latency. Specify <strong>true</strong> to enable stream smoothing. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_smoother")]
		public System.Nullable<System.Boolean> Stream_smoother { get; set; }
		
		/// <summary>
		/// For the <em>delivery_method</em> <strong>cdn</strong>. The alphanumeric string that identifies the stream source that you want to use to deliver the stream to the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_source_id")]
		public string Stream_source_id { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, disables stream targets when the transcoder starts. If <strong>false</strong> (the default), the targets start when the transcoder starts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="suppress_stream_target_start")]
		public System.Nullable<System.Boolean> Suppress_stream_target_start { get; set; }
		
		/// <summary>
		/// The type of transcoder, either <strong>transcoded</strong> for streams that are transcoded into adaptive bitrate renditions or <strong>passthrough</strong> for streams that aren't processed by the transcoder. The default is <strong>transcoded</strong>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transcoder_type")]
		public Live_streamTranscoder_type Transcoder_type { get; set; }
		
		/// <summary>
		/// A username for authenticating an RTMP or RTSP push connection. Can contain only uppercase and lowercase letters; numbers; and the period (.), underscore (_), and hyphen (-) characters. No other special characters can be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, black video plays if the video source disconnects from the transcoder. If <strong>false</strong> (the default), a stream-not-available message appears. Works only with stream targets whose <em>provider</em> is <strong>akamai_cupertino</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="video_fallback")]
		public System.Nullable<System.Boolean> Video_fallback { get; set; }
		
		/// <summary>
		/// Embeds an image into the transcoded stream for copyright protection. Specify <strong>true</strong> to embed a watermark image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="watermark")]
		public System.Nullable<System.Boolean> Watermark { get; set; }
		
		/// <summary>
		/// The height, in pixels, of the watermark image. If blank, Wowza Streaming Cloud uses the original image height.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="watermark_height")]
		public System.Nullable<System.Int32> Watermark_height { get; set; }
		
		/// <summary>
		/// A Base64-encoded string representation of a GIF, JPEG, or PNG image that is embedded in all bitrate renditions of the stream. Watermark image files must be 2.5 MB or smaller.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="watermark_image")]
		public string Watermark_image { get; set; }
		
		/// <summary>
		/// The opacity, or percentage of transparency, of the watermark. <strong>0</strong> is fully transparent; <strong>100</strong> is fully opaque.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="watermark_opacity")]
		public System.Nullable<Transcoder_create_inputTranscoderWatermark_opacity> Watermark_opacity { get; set; }
		
		/// <summary>
		/// The corner of the video frame in which you want the watermark to appear. The default is <strong>top-left</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="watermark_position")]
		public System.Nullable<Transcoder_create_inputTranscoderWatermark_position> Watermark_position { get; set; }
		
		/// <summary>
		/// The width, in pixels, of the watermark image. If blank, Wowza Streaming Cloud uses the original image width.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="watermark_width")]
		public System.Nullable<System.Int32> Watermark_width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Transcoder_create_inputTranscoderBuffer_size
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1000 = 1000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2000 = 2000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3000 = 3000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_4000 = 4000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_5000 = 5000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_6000 = 6000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_7000 = 7000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_8000 = 8000,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Transcoder_create_inputTranscoderPlay_maximum_connections
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_10 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_11 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_12 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_13 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_14 = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_15 = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_16 = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_17 = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_18 = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_19 = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_20 = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_21 = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_22 = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_23 = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_24 = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_25 = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_26 = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_27 = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_28 = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_29 = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_30 = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_31 = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_32 = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_33 = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_34 = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_35 = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_36 = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_37 = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_38 = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_39 = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_40 = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_41 = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_42 = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_43 = 43,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_44 = 44,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_45 = 45,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_46 = 46,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_47 = 47,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_48 = 48,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_49 = 49,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_50 = 50,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_51 = 51,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_52 = 52,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_53 = 53,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_54 = 54,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_55 = 55,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_56 = 56,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_57 = 57,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_58 = 58,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_59 = 59,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_60 = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_61 = 61,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_62 = 62,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_63 = 63,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_64 = 64,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_65 = 65,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_66 = 66,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_67 = 67,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_68 = 68,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_69 = 69,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_70 = 70,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_71 = 71,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_72 = 72,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_73 = 73,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_74 = 74,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_75 = 75,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_76 = 76,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_77 = 77,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_78 = 78,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_79 = 79,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_80 = 80,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_81 = 81,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_82 = 82,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_83 = 83,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_84 = 84,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_85 = 85,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_86 = 86,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_87 = 87,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_88 = 88,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_89 = 89,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_90 = 90,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_91 = 91,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_92 = 92,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_93 = 93,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_94 = 94,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_95 = 95,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_96 = 96,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_97 = 97,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_98 = 98,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_99 = 99,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_100 = 100,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Transcoder_create_inputTranscoderWatermark_opacity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_4 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_5 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_6 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_7 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_8 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_9 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_10 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_11 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_12 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_13 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_14 = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_15 = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_16 = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_17 = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_18 = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_19 = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_20 = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_21 = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_22 = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_23 = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_24 = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_25 = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_26 = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_27 = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_28 = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_29 = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_30 = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_31 = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_32 = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_33 = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_34 = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_35 = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_36 = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_37 = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_38 = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_39 = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_40 = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_41 = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_42 = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_43 = 43,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_44 = 44,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_45 = 45,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_46 = 46,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_47 = 47,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_48 = 48,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_49 = 49,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_50 = 50,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_51 = 51,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_52 = 52,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_53 = 53,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_54 = 54,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_55 = 55,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_56 = 56,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_57 = 57,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_58 = 58,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_59 = 59,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_60 = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_61 = 61,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_62 = 62,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_63 = 63,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_64 = 64,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_65 = 65,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_66 = 66,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_67 = 67,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_68 = 68,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_69 = 69,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_70 = 70,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_71 = 71,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_72 = 72,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_73 = 73,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_74 = 74,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_75 = 75,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_76 = 76,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_77 = 77,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_78 = 78,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_79 = 79,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_80 = 80,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_81 = 81,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_82 = 82,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_83 = 83,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_84 = 84,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_85 = 85,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_86 = 86,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_87 = 87,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_88 = 88,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_89 = 89,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_90 = 90,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_91 = 91,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_92 = 92,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_93 = 93,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_94 = 94,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_95 = 95,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_96 = 96,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_97 = 97,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_98 = 98,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_99 = 99,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_100 = 100,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Transcoder_create_inputTranscoderWatermark_position
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="top-left")]
		topMinusleft = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="top-right")]
		topMinusright = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bottom-left")]
		bottomMinusleft = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bottom-right")]
		bottomMinusright = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Transcoder_properties
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public Transcoder_property[] Properties { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Transcoder_property
	{
		
		/// <summary>
		/// The key of the property. For <strong>rtsp</strong>, valid values are <strong>debugRtspSession</strong>, <strong>maxRtcpWaitTime</strong>, <strong>avSyncMethod</strong>, <strong>rtspValidationFrequency</strong>, <strong>rtpTransportMode</strong>, <strong>rtspFilterUnknownTracks</strong>, <strong>rtpIgnoreSpropParameterSets</strong>, and <strong>rtpIgnoreProfileLevelId</strong>. For <strong>cupertino</strong>, valid values are <strong>cupertinoEnableProgramDateTime</strong>, <strong>cupertinoEnableId3ProgramDateTime</strong>, and <strong>cupertinoProgramDateTimeOffset</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// The section of the transcoder configuration table that contains the property. Valid values are <strong>rtsp</strong> and <strong>cupertino</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="section")]
		public string Section { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transcoder_id")]
		public string Transcoder_id { get; set; }
		
		/// <summary>
		/// The value of the property. For <strong>debugRtspSession</strong>, <strong>avSyncMethod</strong>, <strong>rtspFilterUnknownTracks</strong>, <strong>rtpIgnoreSpropParameterSets</strong>, <strong>rtpIgnoreProfileLevelId</strong>, <strong>cupertinoEnableProgramDateTime</strong>, and <strong>cupertinoEnableId3ProgramDateTime</strong>, valid values are <strong>true</strong> or <strong>false</strong>. <strong>maxRtcpWaitTime</strong> must be <strong>0</strong> (ms, off) or greater. The default is <strong>2000</strong>. Valid values for <strong>rtpTransportMode</strong> are <strong>udp</strong> or <strong>interleave</strong> (the default). <strong>rtspValidationFrequency</strong> must be <strong>0</strong> (ms, off) or greater. The default is <strong>15000</strong>. <strong>cupertinoProgramDateTimeOffset</strong> must be an integer, positive or negative. The default is <strong>0</strong> (ms).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Transcoder_property_create_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="property")]
		public Transcoder_property_create_inputProperty Property { get; set; }
	}
	
	public class Transcoder_property_create_inputProperty
	{
		
		/// <summary>
		/// The key of the property. For <strong>rtsp</strong>, valid values are <strong>debugRtspSession</strong>, <strong>maxRtcpWaitTime</strong>, <strong>avSyncMethod</strong>, <strong>rtspValidationFrequency</strong>, <strong>rtpTransportMode</strong>, <strong>rtspFilterUnknownTracks</strong>, <strong>rtpIgnoreSpropParameterSets</strong>, and <strong>rtpIgnoreProfileLevelId</strong>. For <strong>cupertino</strong>, valid values are <strong>cupertinoEnableProgramDateTime</strong>, <strong>cupertinoEnableId3ProgramDateTime</strong>, and <strong>cupertinoProgramDateTimeOffset</strong>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// The section of the transcoder configuration table that contains the property. Valid values are <strong>rtsp</strong> and <strong>cupertino</strong>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="section")]
		public string Section { get; set; }
		
		/// <summary>
		/// The value of the property. For <strong>debugRtspSession</strong>, <strong>avSyncMethod</strong>, <strong>rtspFilterUnknownTracks</strong>, <strong>rtpIgnoreSpropParameterSets</strong>, <strong>rtpIgnoreProfileLevelId</strong>, <strong>cupertinoEnableProgramDateTime</strong>, and <strong>cupertinoEnableId3ProgramDateTime</strong>, valid values are <strong>true</strong> or <strong>false</strong>. <strong>maxRtcpWaitTime</strong> must be <strong>0</strong> (ms, off) or greater. The default is <strong>2000</strong>. Valid values for <strong>rtpTransportMode</strong> are <strong>udp</strong> or <strong>interleave</strong> (the default). <strong>rtspValidationFrequency</strong> must be <strong>0</strong> (ms, off) or greater. The default is <strong>15000</strong>. <strong>cupertinoProgramDateTimeOffset</strong> must be an integer, positive or negative. The default is <strong>0</strong> (ms).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Transcoder_update_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transcoder")]
		public Transcoder_update_inputTranscoder Transcoder { get; set; }
	}
	
	public class Transcoder_update_inputTranscoder
	{
		
		/// <summary>
		/// The location where Wowza Streaming Cloud transcodes your stream. Choose a location as close as possible to your video source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="broadcast_location")]
		public Index_stream_targetLocation Broadcast_location { get; set; }
		
		/// <summary>
		/// The size, in milliseconds, of the incoming buffer. <strong>0</strong> means no buffer. The default is <strong>4000</strong> (4 seconds).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="buffer_size")]
		public System.Nullable<Transcoder_update_inputTranscoderBuffer_size> Buffer_size { get; set; }
		
		/// <summary>
		/// The type of closed caption data being passed from the source. The default, <strong>none</strong>, indicates that no data is being provided. <strong>cea</strong> indicates that a CEA closed captioning data stream is being provided. <strong>on_text</strong> indicates that an onTextData closed captioning data stream is being provided. <strong>both</strong> indicates that both CEA and onTextData closed captioing data streams are being provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="closed_caption_type")]
		public Live_streamClosed_caption_type Closed_caption_type { get; set; }
		
		/// <summary>
		/// The type of connection between the source encoder and the transcoder. The default, <strong>pull</strong>, instructs the transcoder to pull the video from the source. <strong>push</strong> instructs the source to push the stream to the transcoder. <strong>cdn</strong> uses a stream source to deliver the stream to the transcoder.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delivery_method")]
		public Live_streamDelivery_method Delivery_method { get; set; }
		
		/// <summary>
		/// An array of playback protocols enabled for this transcoder. By default, <strong>rtmp</strong>, <strong>rtsp</strong>, and <strong>wowz</strong> are returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delivery_protocols")]
		public string[] Delivery_protocols { get; set; }
		
		/// <summary>
		/// An optional description of the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Authentication is required by default for RTMP and RTSP push connections from a video source to the transcoder. Specify <strong>true</strong> to disable authentication with the video source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disable_authentication")]
		public System.Nullable<System.Boolean> Disable_authentication { get; set; }
		
		/// <summary>
		/// The amount of idle time, in seconds, before the transcoder automatically shuts down. Valid values are the integers <strong>0</strong> (never shuts down) to <strong>172800</strong> (48 hours). The default is <strong>1200</strong> (20 minutes).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="idle_timeout")]
		public System.Nullable<System.Int32> Idle_timeout { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, turns off the sort packet buffer and speeds the time it takes to decode and deliver video data to the player. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="low_latency")]
		public System.Nullable<System.Boolean> Low_latency { get; set; }
		
		/// <summary>
		/// A descriptive name for the transcoder. Maximum 200 characters.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A password for authenticating an RTMP or RTSP push connection. Can contain only uppercase and lowercase letters; numbers; and the period (.), underscore (_), and hyphen (-) characters. No other special characters can be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// The number of users who are allowed to connect directly to the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="play_maximum_connections")]
		public System.Nullable<Transcoder_update_inputTranscoderPlay_maximum_connections> Play_maximum_connections { get; set; }
		
		/// <summary>
		/// The transport protocol for the source video. The default is <strong>rtmp</strong>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public TranscoderProtocol Protocol { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, creates a recording of the transcoded output. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recording")]
		public System.Nullable<System.Boolean> Recording { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, removes the watermark from the output. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remove_watermark_image")]
		public System.Nullable<System.Boolean> Remove_watermark_image { get; set; }
		
		/// <summary>
		/// For the <em>delivery_method</em> <strong>pull</strong>. Enter the source's web address without the preceding protocol or the trailing slash (/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source_url")]
		public string Source_url { get; set; }
		
		/// <summary>
		/// For the <em>delivery_method</em> <strong>push</strong>. Some encoders append an extension to their stream names. If the device you're using does this, enter the extension.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_extension")]
		public string Stream_extension { get; set; }
		
		/// <summary>
		/// A dynamic buffer that helps stabilize streams in rough network conditions, but adds latency. Specify <strong>true</strong> to enable stream smoothing. The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_smoother")]
		public System.Nullable<System.Boolean> Stream_smoother { get; set; }
		
		/// <summary>
		/// For the <em>delivery_method</em> <strong>cdn</strong>. The alphanumeric string that identifies the stream source that you want to use to deliver the stream to the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_source_id")]
		public string Stream_source_id { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, disables stream targets when the transcoder starts. If <strong>false</strong> (the default), the targets start when the transcoder starts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="suppress_stream_target_start")]
		public System.Nullable<System.Boolean> Suppress_stream_target_start { get; set; }
		
		/// <summary>
		/// A username for authenticating an RTMP or RTSP push connection. Can contain only uppercase and lowercase letters; numbers; and the period (.), underscore (_), and hyphen (-) characters. No other special characters can be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
		
		/// <summary>
		/// If <strong>true</strong>, black video plays if the video source disconnects from the transcoder. If <strong>false</strong> (the default), a stream-not-available message appears. Works only with stream targets whose <em>provider</em> is <strong>akamai_cupertino</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="video_fallback")]
		public System.Nullable<System.Boolean> Video_fallback { get; set; }
		
		/// <summary>
		/// Embeds an image into the transcoded stream for copyright protection. Specify <strong>true</strong> to embed a watermark image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="watermark")]
		public System.Nullable<System.Boolean> Watermark { get; set; }
		
		/// <summary>
		/// The height, in pixels, of the watermark image. If blank, Wowza Streaming Cloud uses the original image height.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="watermark_height")]
		public System.Nullable<System.Int32> Watermark_height { get; set; }
		
		/// <summary>
		/// A Base64-encoded string representation of a GIF, JPEG, or PNG image that is embedded in all bitrate renditions of the stream. Watermark image files must be 2.5 MB or smaller.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="watermark_image")]
		public string Watermark_image { get; set; }
		
		/// <summary>
		/// The opacity, or percentage of transparency, of the watermark. <strong>0</strong> is fully transparent; <strong>100</strong> is fully opaque.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="watermark_opacity")]
		public System.Nullable<Transcoder_update_inputTranscoderWatermark_opacity> Watermark_opacity { get; set; }
		
		/// <summary>
		/// The corner of the video frame in which you want the watermark to appear. The default is <strong>top-left</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="watermark_position")]
		public System.Nullable<Transcoder_update_inputTranscoderWatermark_position> Watermark_position { get; set; }
		
		/// <summary>
		/// The width, in pixels, of the watermark image. If blank, Wowza Streaming Cloud uses the original image width.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="watermark_width")]
		public System.Nullable<System.Int32> Watermark_width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Transcoder_update_inputTranscoderBuffer_size
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1000 = 1000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2000 = 2000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3000 = 3000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_4000 = 4000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_5000 = 5000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_6000 = 6000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_7000 = 7000,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_8000 = 8000,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Transcoder_update_inputTranscoderPlay_maximum_connections
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_10 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_11 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_12 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_13 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_14 = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_15 = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_16 = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_17 = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_18 = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_19 = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_20 = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_21 = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_22 = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_23 = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_24 = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_25 = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_26 = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_27 = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_28 = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_29 = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_30 = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_31 = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_32 = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_33 = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_34 = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_35 = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_36 = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_37 = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_38 = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_39 = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_40 = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_41 = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_42 = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_43 = 43,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_44 = 44,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_45 = 45,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_46 = 46,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_47 = 47,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_48 = 48,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_49 = 49,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_50 = 50,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_51 = 51,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_52 = 52,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_53 = 53,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_54 = 54,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_55 = 55,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_56 = 56,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_57 = 57,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_58 = 58,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_59 = 59,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_60 = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_61 = 61,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_62 = 62,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_63 = 63,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_64 = 64,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_65 = 65,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_66 = 66,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_67 = 67,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_68 = 68,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_69 = 69,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_70 = 70,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_71 = 71,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_72 = 72,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_73 = 73,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_74 = 74,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_75 = 75,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_76 = 76,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_77 = 77,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_78 = 78,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_79 = 79,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_80 = 80,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_81 = 81,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_82 = 82,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_83 = 83,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_84 = 84,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_85 = 85,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_86 = 86,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_87 = 87,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_88 = 88,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_89 = 89,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_90 = 90,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_91 = 91,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_92 = 92,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_93 = 93,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_94 = 94,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_95 = 95,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_96 = 96,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_97 = 97,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_98 = 98,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_99 = 99,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_100 = 100,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Transcoder_update_inputTranscoderWatermark_opacity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_4 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_5 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_6 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_7 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_8 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_9 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_10 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_11 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_12 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_13 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_14 = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_15 = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_16 = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_17 = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_18 = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_19 = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_20 = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_21 = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_22 = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_23 = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_24 = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_25 = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_26 = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_27 = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_28 = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_29 = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_30 = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_31 = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_32 = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_33 = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_34 = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_35 = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_36 = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_37 = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_38 = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_39 = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_40 = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_41 = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_42 = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_43 = 43,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_44 = 44,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_45 = 45,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_46 = 46,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_47 = 47,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_48 = 48,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_49 = 49,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_50 = 50,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_51 = 51,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_52 = 52,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_53 = 53,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_54 = 54,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_55 = 55,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_56 = 56,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_57 = 57,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_58 = 58,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_59 = 59,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_60 = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_61 = 61,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_62 = 62,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_63 = 63,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_64 = 64,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_65 = 65,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_66 = 66,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_67 = 67,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_68 = 68,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_69 = 69,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_70 = 70,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_71 = 71,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_72 = 72,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_73 = 73,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_74 = 74,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_75 = 75,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_76 = 76,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_77 = 77,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_78 = 78,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_79 = 79,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_80 = 80,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_81 = 81,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_82 = 82,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_83 = 83,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_84 = 84,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_85 = 85,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_86 = 86,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_87 = 87,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_88 = 88,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_89 = 89,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_90 = 90,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_91 = 91,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_92 = 92,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_93 = 93,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_94 = 94,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_95 = 95,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_96 = 96,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_97 = 97,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_98 = 98,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_99 = 99,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_100 = 100,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Transcoder_update_inputTranscoderWatermark_position
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="top-left")]
		topMinusleft = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="top-right")]
		topMinusright = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bottom-left")]
		bottomMinusleft = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bottom-right")]
		bottomMinusright = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Transcoders
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transcoders")]
		public Transcoder[] Transcoders1 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Ull_stream_target_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_target")]
		public Ull_stream_target_inputStream_target Stream_target { get; set; }
	}
	
	public class Ull_stream_target_inputStream_target
	{
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong>. If <strong>true</strong>, creates an Apple HLS URL for playback on iOS devices (<em>hls_playback_url</em>). The default is <strong>false</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enable_hls")]
		public System.Nullable<System.Boolean> Enable_hls { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong>. If <strong>true</strong> (the default), the source stream is ready to be ingested. If **false**, the source stream won't be ingested by the target's origin server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong> and <em>source_delivery_method</em> is **push**. A list of IP addresses that can be used to connect to the target's origin server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ingest_ip_whitelist")]
		public string[] Ingest_ip_whitelist { get; set; }
		
		/// <summary>
		/// A descriptive name for the stream target. Maximum 255 characters.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The CDN for the target. <br /><br />Required for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. Valid values for <strong>CustomStreamTarget</strong> are <strong>akamai</strong>, <strong>akamai_cupertino</strong>, <strong>akamai_rtmp</strong>, <strong>limelight</strong>, <strong>rtmp</strong>, and <strong>ustream</strong>. Values can be appended with **_mock** to use in the sandbox environment. <br /><br />Valid values for <strong>WowzaStreamTarget</strong> are <strong>akamai</strong>, <strong>akamai_cupertino</strong> (default), <strong>akamai_legacy_rtmp</strong>, and <strong>wowza</strong>. <br /><br /><strong>UltraLowLatencyStreamTarget</strong> defaults to and must be <strong>wowza</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provider")]
		public string Provider { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong> and <em>source_delivery_method</em> is **pull**. The location of the stream target's origin server. If unspecified, Wowza Streaming Cloud determines the optimal region for the origin server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region_override")]
		public string Region_override { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong>. The type of connection between the stream source and the stream target. **push** instructs the source to push the stream to the stream target. **pull** instructs the stream target to pull the stream from the source.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source_delivery_method")]
		public string Source_delivery_method { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong> and <em>source_delivery_method</em> is **pull**. The URL of a source IP camera or encoder connecting to the stream target.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source_url")]
		public string Source_url { get; set; }
		
		/// <summary>
		/// <strong>WowzaStreamTarget</strong> is a Wowza CDN target. <strong>UltraLowLatencyStreamTarget</strong> is an ultra low latency Wowza stream target. <strong>CustomStreamTarget</strong> (the default) is an external, third-party destination. <!--and <strong>FacebookStreamTarget</strong> (a Facebook Live target).-->
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Uptime
	{
		
		/// <summary>
		/// A Boolean value that indicates if the usage generated by this uptime has been sent for billing processing.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="billed")]
		public System.Nullable<System.Boolean> Billed { get; set; }
		
		/// <summary>
		/// The date and time that the uptime record was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The date and time that the transcoder was stopped for this uptime. If this value is not present, it indicates that the transcoder is currently running.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ended_at")]
		public System.Nullable<System.DateTimeOffset> Ended_at { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the uptime record.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A Boolean value that indicates if the transcoder is still running for this uptime.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="running")]
		public System.Nullable<System.Boolean> Running { get; set; }
		
		/// <summary>
		/// The date and time that the transcoder started for this uptime.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="started_at")]
		public System.Nullable<System.DateTimeOffset> Started_at { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transcoder_id")]
		public string Transcoder_id { get; set; }
		
		/// <summary>
		/// The date and time that the uptime record was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public string Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Uptimes
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="uptimes")]
		public Uptime[] Uptimes1 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Url
	{
		
		/// <summary>
		/// The video bitrate, in kilobits per second (Kbps), of the output rendition that will be played at the URL. May correspond to the bitrate of an output rendition being used by the live stream or transcoder. Must be greater than <strong>0</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bitrate")]
		public System.Nullable<System.Int32> Bitrate { get; set; }
		
		/// <summary>
		/// The date and time that the player URL was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The height, in pixels, of the output rendition that will be played at the URL. May correspond to the height of an output rendition being used by the live stream or transcoder. Must be greater than <strong>0</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="height")]
		public System.Nullable<System.Int32> Height { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the player URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A descriptive name for the player URL. Maximum 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the player.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_id")]
		public string Player_id { get; set; }
		
		/// <summary>
		/// The date and time that the player URL was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// The URL of the player. If using a Wowza CDN target, the URL format is `http://[wowzasubdomain]-f.akamaihd.net/z/[stream_name]_[angle]@[stream_id]/manifest.f4m` for Adobe HDS playback or `http://[wowzasubdomain]-f.akamaihd.net/i/[stream_name]_[angle]@[stream_id]/master.m3u8` for Apple HLS playback.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url1 { get; set; }
		
		/// <summary>
		/// The width, in pixels, of the output rendition that will be played at the URL. May correspond to the width of an output rendition being used by the live stream or transcoder. Must be greater than <strong>0</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="width")]
		public System.Nullable<System.Int32> Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Url_create_input
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Url_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public Url_inputUrl Url { get; set; }
	}
	
	public class Url_inputUrl
	{
		
		/// <summary>
		/// The video bitrate, in kilobits per second (Kbps), of the output rendition that will be played at the URL. May correspond to the bitrate of an output rendition being used by the live stream or transcoder. Must be greater than <strong>0</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bitrate")]
		public System.Nullable<System.Int32> Bitrate { get; set; }
		
		/// <summary>
		/// The height, in pixels, of the output rendition that will be played at the URL. May correspond to the height of an output rendition being used by the live stream or transcoder. Must be greater than <strong>0</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="height")]
		public System.Nullable<System.Int32> Height { get; set; }
		
		/// <summary>
		/// A descriptive name for the player URL. Maximum 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The URL of the player. If using a Wowza CDN target, the URL format is `http://[wowzasubdomain]-f.akamaihd.net/z/[stream_name]_[angle]@[stream_id]/manifest.f4m` for Adobe HDS playback or `http://[wowzasubdomain]-f.akamaihd.net/i/[stream_name]_[angle]@[stream_id]/master.m3u8` for Apple HLS playback.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// The width, in pixels, of the output rendition that will be played at the URL. May correspond to the width of an output rendition being used by the live stream or transcoder. Must be greater than <strong>0</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="width")]
		public System.Nullable<System.Int32> Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Url_update_input
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Urls
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="urls")]
		public Url[] Urls1 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Usage_network_stream_source
	{
		
		/// <summary>
		/// The amount of usage, in bytes, that was billed for the stream source during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_billed")]
		public System.Nullable<System.Int32> Bytes_billed { get; set; }
		
		/// <summary>
		/// The amount of content, in bytes, that went through the stream source during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_used")]
		public System.Nullable<System.Int32> Bytes_used { get; set; }
		
		/// <summary>
		/// A value of <strong>true</strong> indicates that the stream source has been removed from Wowza Streaming Cloud.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deleted")]
		public System.Nullable<System.Boolean> Deleted { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the stream source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A descriptive name for the stream source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Usage_network_stream_sources
	{
		
		[System.Runtime.Serialization.DataMember(Name="stream_sources")]
		public Usage_network_stream_source[] Stream_sources { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Usage_network_stream_target
	{
		
		/// <summary>
		/// An array of stream targets and their usage by protocol and zone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_targets")]
		public Usage_network_stream_targetStream_targets Stream_targets { get; set; }
		
		/// <summary>
		/// A hash of total usage, including overall total billed and used for all targets, and totals by zone for each protocol.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public Usage_network_stream_targetTotal Total { get; set; }
	}
	
	public class Usage_network_stream_targetStream_targets
	{
		
		/// <summary>
		/// The amount of usage, in bytes, that was billed for the stream target during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_billed")]
		public System.Nullable<System.Int32> Bytes_billed { get; set; }
		
		/// <summary>
		/// The amount of content, in bytes, that went through the stream target during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_used")]
		public System.Nullable<System.Int32> Bytes_used { get; set; }
		
		/// <summary>
		/// A value of <strong>true</strong> indicates that the stream target has been removed from Wowza Streaming Cloud.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deleted")]
		public System.Nullable<System.Boolean> Deleted { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A descriptive name for the stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A hash of protocols that accrued network usage, keyed by the name of the protocol that generated the usage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocols")]
		public Usage_network_stream_targetStream_targetsProtocols Protocols { get; set; }
	}
	
	public class Usage_network_stream_targetStream_targetsProtocols
	{
		
		/// <summary>
		/// A hash of zones with network usage, keyed by the name of the billing zone where the usage was generated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zones")]
		public Usage_network_stream_targetStream_targetsProtocolsZones Zones { get; set; }
	}
	
	public class Usage_network_stream_targetStream_targetsProtocolsZones
	{
		
		/// <summary>
		/// The amount of usage, in bytes, that was billed for the stream target during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_billed")]
		public System.Nullable<System.Int32> Bytes_billed { get; set; }
		
		/// <summary>
		/// The amount of content, in bytes, that went through the stream target during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_used")]
		public System.Nullable<System.Int32> Bytes_used { get; set; }
	}
	
	public class Usage_network_stream_targetTotal
	{
		
		/// <summary>
		/// The amount of usage, in bytes, that was billed for all stream targets during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_billed")]
		public System.Nullable<System.Int32> Bytes_billed { get; set; }
		
		/// <summary>
		/// The amount of content, in bytes, that went through all stream targets during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_used")]
		public System.Nullable<System.Int32> Bytes_used { get; set; }
		
		/// <summary>
		/// A hash of protocols that accrued network usage, keyed by the name of the protocol that generated the usage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocols")]
		public Usage_network_stream_targetTotalProtocols Protocols { get; set; }
	}
	
	public class Usage_network_stream_targetTotalProtocols
	{
		
		/// <summary>
		/// A hash of zones with network usage, keyed by the name of the billing zone where the usage was generated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zones")]
		public Usage_network_stream_targetTotalProtocolsZones Zones { get; set; }
	}
	
	public class Usage_network_stream_targetTotalProtocolsZones
	{
		
		/// <summary>
		/// The amount of usage, in bytes, that was billed for the stream target during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_billed")]
		public System.Nullable<System.Int32> Bytes_billed { get; set; }
		
		/// <summary>
		/// The amount of content, in bytes, that went through the stream target during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_used")]
		public System.Nullable<System.Int32> Bytes_used { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Usage_network_stream_targets
	{
		
		/// <summary>
		/// An array of stream targets and their usage by protocol and zone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream_targets")]
		public Usage_network_stream_targetsStream_targets Stream_targets { get; set; }
		
		/// <summary>
		/// A hash of total usage, including overall total billed and used for all targets, and totals by zone for each protocol.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public Usage_network_stream_targetsTotal Total { get; set; }
	}
	
	public class Usage_network_stream_targetsStream_targets
	{
		
		/// <summary>
		/// The amount of usage, in bytes, that was billed for the stream target during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_billed")]
		public System.Nullable<System.Int32> Bytes_billed { get; set; }
		
		/// <summary>
		/// The amount of content, in bytes, that went through the stream target during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_used")]
		public System.Nullable<System.Int32> Bytes_used { get; set; }
		
		/// <summary>
		/// A value of <strong>true</strong> indicates that the stream target has been removed from Wowza Streaming Cloud.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deleted")]
		public System.Nullable<System.Boolean> Deleted { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A descriptive name for the stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A hash of protocols that accrued network usage, keyed by the name of the protocol that generated the usage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocols")]
		public Usage_network_stream_targetsStream_targetsProtocols Protocols { get; set; }
	}
	
	public class Usage_network_stream_targetsStream_targetsProtocols
	{
		
		/// <summary>
		/// A hash of zones with network usage, keyed by the name of the billing zone where the usage was generated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zones")]
		public Usage_network_stream_targetsStream_targetsProtocolsZones Zones { get; set; }
	}
	
	public class Usage_network_stream_targetsStream_targetsProtocolsZones
	{
		
		/// <summary>
		/// The amount of usage, in bytes, that was billed for the stream target during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_billed")]
		public System.Nullable<System.Int32> Bytes_billed { get; set; }
		
		/// <summary>
		/// The amount of content, in bytes, that went through the stream target during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_used")]
		public System.Nullable<System.Int32> Bytes_used { get; set; }
	}
	
	public class Usage_network_stream_targetsTotal
	{
		
		/// <summary>
		/// The amount of usage, in bytes, that was billed for all stream targets during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_billed")]
		public System.Nullable<System.Int32> Bytes_billed { get; set; }
		
		/// <summary>
		/// The amount of content, in bytes, that went through all stream targets during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_used")]
		public System.Nullable<System.Int32> Bytes_used { get; set; }
		
		/// <summary>
		/// A hash of protocols that accrued network usage, keyed by the name of the protocol that generated the usage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocols")]
		public Usage_network_stream_targetsTotalProtocols Protocols { get; set; }
	}
	
	public class Usage_network_stream_targetsTotalProtocols
	{
		
		/// <summary>
		/// A hash of zones with network usage, keyed by the name of the billing zone where the usage was generated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zones")]
		public Usage_network_stream_targetsTotalProtocolsZones Zones { get; set; }
	}
	
	public class Usage_network_stream_targetsTotalProtocolsZones
	{
		
		/// <summary>
		/// The amount of usage, in bytes, that was billed for the stream target during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_billed")]
		public System.Nullable<System.Int32> Bytes_billed { get; set; }
		
		/// <summary>
		/// The amount of content, in bytes, that went through the stream target during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_used")]
		public System.Nullable<System.Int32> Bytes_used { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Usage_network_transcoder
	{
		
		/// <summary>
		/// The amount of usage, in bytes, that was billed for the live stream or transcoder during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_billed")]
		public System.Nullable<System.Int32> Bytes_billed { get; set; }
		
		/// <summary>
		/// The amount of content, in bytes, that went through the live stream or transcoder during the selected time frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_used")]
		public System.Nullable<System.Int32> Bytes_used { get; set; }
		
		/// <summary>
		/// A value of <strong>true</strong> indicates that the live stream or transcoder has been removed from Wowza Streaming Cloud.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deleted")]
		public System.Nullable<System.Boolean> Deleted { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the live stream or transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// A descriptive name for the live stream or transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Usage_network_transcoders
	{
		
		[System.Runtime.Serialization.DataMember(Name="transcoders")]
		public Usage_network_transcoder[] Transcoders { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Usage_storage_peak_recording
	{
		
		[System.Runtime.Serialization.DataMember(Name="peak_recording")]
		public Usage_storage_peak_recordingPeak_recording Peak_recording { get; set; }
	}
	
	public class Usage_storage_peak_recordingPeak_recording
	{
		
		/// <summary>
		/// The amount, in bytes, used to store recordings during the selected time frame. If the time frame is in the past, <em>bytes_total</em> is the amount of storage that was used and billed. If the time frame includes the current billing period, <em>bytes_total</em> is the greatest amount of content stored in Wowza Streaming Cloud at any point to date in the billing period.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bytes_total")]
		public System.Nullable<System.Int32> Bytes_total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Usage_time_transcoder
	{
		
		/// <summary>
		/// A value of <strong>true</strong> indicates that the live stream or transcoder has been removed from Wowza Streaming Cloud.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deleted")]
		public System.Nullable<System.Boolean> Deleted { get; set; }
		
		/// <summary>
		/// The unique alphanumeric string that identifies the live stream or transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// A descriptive name for the live stream or transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The amount of stream processing time, in seconds, that was billed for the live stream or transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seconds_billed")]
		public System.Nullable<System.Int32> Seconds_billed { get; set; }
		
		/// <summary>
		/// The amount of time, in seconds, that it took for the live stream or transcoder to be processed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seconds_used")]
		public System.Nullable<System.Int32> Seconds_used { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Usage_time_transcoders
	{
		
		[System.Runtime.Serialization.DataMember(Name="transcoders")]
		public Usage_time_transcoder[] Transcoders { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Usage_viewer_data_countriesElement
	{
		
		[System.Runtime.Serialization.DataMember(Name="country_code")]
		public Usage_viewer_data_countriesElementCountry_code Country_code { get; set; }
	}
	
	public class Usage_viewer_data_countriesElementCountry_code
	{
		
		/// <summary>
		/// The name of the country.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Total percentage of viewers (<strong>100</strong>).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage_viewers")]
		public System.Nullable<System.Int32> Percentage_viewers { get; set; }
		
		/// <summary>
		/// The percentage of total viewing time that the protocol or rendition was viewed. Always <strong>100</strong> for <em>stream_target</em>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage_viewing_time")]
		public System.Nullable<System.Int32> Percentage_viewing_time { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="protocols")]
		public Usage_viewer_data_countriesElementCountry_codeProtocols[] Usage_viewer_data_countriesElementCountry_codeProtocols { get; set; }
		
		/// <summary>
		/// The average length of time, in seconds, that viewers played the stream at the target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seconds_avg_viewing_time")]
		public System.Nullable<System.Int32> Seconds_avg_viewing_time { get; set; }
		
		/// <summary>
		/// The total length of time, in seconds, that all viewers played the stream at the target. <em>seconds_total_viewing_time</em> may be longer than the duration of the stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seconds_total_viewing_time")]
		public System.Nullable<System.Int32> Seconds_total_viewing_time { get; set; }
		
		/// <summary>
		/// The total number of unique viewers that downloaded at least one chunk of the stream at the target (for HTTP streams) or connected to and viewed the stream (for ultra low latency streams). A unique viewer is a single IP address; multiple users that share the same IP address are counted once.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total_unique_viewers")]
		public System.Nullable<System.Int32> Total_unique_viewers { get; set; }
	}
	
	public class Usage_viewer_data_countriesElementCountry_codeProtocols
	{
		
		[System.Runtime.Serialization.DataMember(Name="protocol_name")]
		public Usage_viewer_data_countriesElementCountry_codeProtocolsProtocol_name Protocol_name { get; set; }
	}
	
	public class Usage_viewer_data_countriesElementCountry_codeProtocolsProtocol_name
	{
		
		/// <summary>
		/// The name of the protocol.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Total percentage of viewers (<strong>100</strong>).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage_viewers")]
		public System.Nullable<System.Int32> Percentage_viewers { get; set; }
		
		/// <summary>
		/// The percentage of total viewing time that the protocol or rendition was viewed. Always <strong>100</strong> for <em>stream_target</em>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage_viewing_time")]
		public System.Nullable<System.Int32> Percentage_viewing_time { get; set; }
		
		/// <summary>
		/// The average length of time, in seconds, that viewers played the stream at the target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seconds_avg_viewing_time")]
		public System.Nullable<System.Int32> Seconds_avg_viewing_time { get; set; }
		
		/// <summary>
		/// The total length of time, in seconds, that all viewers played the stream at the target. <em>seconds_total_viewing_time</em> may be longer than the duration of the stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seconds_total_viewing_time")]
		public System.Nullable<System.Int32> Seconds_total_viewing_time { get; set; }
		
		/// <summary>
		/// The total number of unique viewers that downloaded at least one chunk of the stream at the target (for HTTP streams) or connected to and viewed the stream (for ultra low latency streams). A unique viewer is a single IP address; multiple users that share the same IP address are counted once.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total_unique_viewers")]
		public System.Nullable<System.Int32> Total_unique_viewers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Usage_viewer_data_protocolsElement
	{
		
		[System.Runtime.Serialization.DataMember(Name="protocol_name")]
		public Usage_viewer_data_protocolsElementProtocol_name Protocol_name { get; set; }
	}
	
	public class Usage_viewer_data_protocolsElementProtocol_name
	{
		
		/// <summary>
		/// The name of the protocol.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Total percentage of viewers (<strong>100</strong>).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage_viewers")]
		public System.Nullable<System.Int32> Percentage_viewers { get; set; }
		
		/// <summary>
		/// The percentage of total viewing time that the protocol or rendition was viewed. Always <strong>100</strong> for <em>stream_target</em>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage_viewing_time")]
		public System.Nullable<System.Int32> Percentage_viewing_time { get; set; }
		
		/// <summary>
		/// The average length of time, in seconds, that viewers played the stream at the target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seconds_avg_viewing_time")]
		public System.Nullable<System.Int32> Seconds_avg_viewing_time { get; set; }
		
		/// <summary>
		/// The total length of time, in seconds, that all viewers played the stream at the target. <em>seconds_total_viewing_time</em> may be longer than the duration of the stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seconds_total_viewing_time")]
		public System.Nullable<System.Int32> Seconds_total_viewing_time { get; set; }
		
		/// <summary>
		/// The total number of unique viewers that downloaded at least one chunk of the stream at the target (for HTTP streams) or connected to and viewed the stream (for ultra low latency streams). A unique viewer is a single IP address; multiple users that share the same IP address are counted once.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total_unique_viewers")]
		public System.Nullable<System.Int32> Total_unique_viewers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Usage_viewer_data_renditionsElement
	{
		
		[System.Runtime.Serialization.DataMember(Name="rendition_name")]
		public Usage_viewer_data_renditionsElementRendition_name Rendition_name { get; set; }
	}
	
	public class Usage_viewer_data_renditionsElementRendition_name
	{
		
		[System.Runtime.Serialization.DataMember(Name="countries")]
		public Usage_viewer_data_countriesElement[] Countries { get; set; }
		
		/// <summary>
		/// The name of the rendition.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Total percentage of viewers (<strong>100</strong>).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage_viewers")]
		public System.Nullable<System.Int32> Percentage_viewers { get; set; }
		
		/// <summary>
		/// The percentage of total viewing time that the protocol or rendition was viewed. Always <strong>100</strong> for <em>stream_target</em>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage_viewing_time")]
		public System.Nullable<System.Int32> Percentage_viewing_time { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="protocols")]
		public Usage_viewer_data_protocolsElement[] Protocols { get; set; }
		
		/// <summary>
		/// The average length of time, in seconds, that viewers played the stream at the target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seconds_avg_viewing_time")]
		public System.Nullable<System.Int32> Seconds_avg_viewing_time { get; set; }
		
		/// <summary>
		/// The total length of time, in seconds, that all viewers played the stream at the target. <em>seconds_total_viewing_time</em> may be longer than the duration of the stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seconds_total_viewing_time")]
		public System.Nullable<System.Int32> Seconds_total_viewing_time { get; set; }
		
		/// <summary>
		/// The total number of unique viewers that downloaded at least one chunk of the stream at the target (for HTTP streams) or connected to and viewed the stream (for ultra low latency streams). A unique viewer is a single IP address; multiple users that share the same IP address are counted once.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total_unique_viewers")]
		public System.Nullable<System.Int32> Total_unique_viewers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Usage_viewer_data_stream_target
	{
		
		[System.Runtime.Serialization.DataMember(Name="stream_target")]
		public Usage_viewer_data_stream_targetStream_target Stream_target { get; set; }
	}
	
	public class Usage_viewer_data_stream_targetStream_target
	{
		
		[System.Runtime.Serialization.DataMember(Name="countries")]
		public Usage_viewer_data_countriesElement[] Countries { get; set; }
		
		/// <summary>
		/// A comma-separated list of all viewed country codes shown as strings, for quick reference.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="country_list")]
		public string[] Country_list { get; set; }
		
		/// <summary>
		/// Total percentage of viewers (<strong>100</strong>).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage_viewers")]
		public System.Nullable<System.Int32> Percentage_viewers { get; set; }
		
		/// <summary>
		/// The percentage of total viewing time that the protocol or rendition was viewed. Always <strong>100</strong> for <em>stream_target</em>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage_viewing_time")]
		public System.Nullable<System.Int32> Percentage_viewing_time { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="protocols")]
		public Usage_viewer_data_protocolsElement[] Protocols { get; set; }
		
		/// <summary>
		/// A comma-separated list of all viewed renditions shown as numbers, for quick reference.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rendition_list")]
		public string[] Rendition_list { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="renditions")]
		public Usage_viewer_data_renditionsElement[] Renditions { get; set; }
		
		/// <summary>
		/// The average length of time, in seconds, that viewers played the stream at the target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seconds_avg_viewing_time")]
		public System.Nullable<System.Int32> Seconds_avg_viewing_time { get; set; }
		
		/// <summary>
		/// The total length of time, in seconds, that all viewers played the stream at the target. <em>seconds_total_viewing_time</em> may be longer than the duration of the stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seconds_total_viewing_time")]
		public System.Nullable<System.Int32> Seconds_total_viewing_time { get; set; }
		
		/// <summary>
		/// The total number of unique viewers that downloaded at least one chunk of the stream at the target (for HTTP streams) or connected to and viewed the stream (for ultra low latency streams). A unique viewer is a single IP address; multiple users that share the same IP address are counted once.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total_unique_viewers")]
		public System.Nullable<System.Int32> Total_unique_viewers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Wowza_stream_target_input
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_target")]
		public Wowza_stream_target_inputStream_target Stream_target { get; set; }
	}
	
	public class Wowza_stream_target_inputStream_target
	{
		
		/// <summary>
		/// <strong>The <em>chunk_size</em> parameter is deprecated. To set the chunk size of a stream target, use the POST /stream_targets/[stream_target_id]/properties endpoint.</strong> Only for targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> and <em>provider</em> is <strong>akamai_cupertino</strong>. The segment duration for HLS encoding. The default is <strong>10</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="chunk_size")]
		public System.Nullable<Wowza_stream_target_inputStream_targetChunk_size> Chunk_size { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> and <em>provider</em> is <em>not</em> <strong>akamai_cupertino</strong>. Choose a location as close as possible to your video source.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Index_stream_targetLocation Location { get; set; }
		
		/// <summary>
		/// A descriptive name for the stream target. Maximum 255 characters.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The CDN for the target. <br /><br />Required for targets whose <em>type</em> is <strong>CustomStreamTarget</strong>. Valid values for <strong>CustomStreamTarget</strong> are <strong>akamai</strong>, <strong>akamai_cupertino</strong>, <strong>akamai_rtmp</strong>, <strong>limelight</strong>, <strong>rtmp</strong>, and <strong>ustream</strong>. Values can be appended with **_mock** to use in the sandbox environment. <br /><br />Valid values for <strong>WowzaStreamTarget</strong> are <strong>akamai</strong>, <strong>akamai_cupertino</strong> (default), <strong>akamai_legacy_rtmp</strong>, and <strong>wowza</strong>. <br /><br /><strong>UltraLowLatencyStreamTarget</strong> defaults to and must be <strong>wowza</strong>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provider")]
		public string Provider { get; set; }
		
		/// <summary>
		/// <strong>WowzaStreamTarget</strong> is a Wowza CDN target. <strong>UltraLowLatencyStreamTarget</strong> is an ultra low latency Wowza stream target. <strong>CustomStreamTarget</strong> (the default) is an external, third-party destination. <!--and <strong>FacebookStreamTarget</strong> (a Facebook Live target).-->
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> and <em>provider</em> is <strong>akamai_cupertino</strong>. CORS, or cross-origin resource sharing, allows streams to be sent to providers such as Peer5, Viblast, and Streamroot, which implement a peer-to-peer grid delivery system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_cors")]
		public System.Nullable<System.Boolean> Use_cors { get; set; }
		
		/// <summary>
		/// <strong>The <em>use_https</em> parameter is deprecated. Use the POST /stream_targets/[<em>stream_target_id</em>]/properties endpoint and the <em>relative_playlists</em> parameter instead.</strong>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_https")]
		public System.Nullable<System.Boolean> Use_https { get; set; }
		
		/// <summary>
		/// Only for targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> and <em>provider</em> is <strong>akamai_cupertino</strong>. If <strong>true</strong>, generates a <em>secure_ingest_query_param</em> to securely deliver the stream from the transcoder to the provider.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_secure_ingest")]
		public System.Nullable<System.Boolean> Use_secure_ingest { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Wowza_stream_target_inputStream_targetChunk_size
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2")]
		_2 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4")]
		_4 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8")]
		_8 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="10")]
		_10 = 4,
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Fetch Swagger information
		/// This operation shows the details of the Swagger specification.
		/// 
		/// Specs api/v1/specs
		/// </summary>
		/// <returns>OK</returns>
		public async Task<Spec> SpecsAsync()
		{
			var requestUri = "api/v1/specs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Spec>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch all live streams
		/// This operation shows the details of all of your live streams.
		/// ListLiveStreams live_streams
		/// </summary>
		/// <param name="page">Returns a paginated view of results from the HTTP request. Specify a positive integer to indicate which page of the results should be displayed first. <strong>Next</strong> and <strong>Previous</strong> links allow you to navigate multiple pages of results. Omit the <em>page</em> parameter or specify an integer that's less than or equal to <strong>0</strong> to view all (unpaginated) results.</param>
		/// <param name="per_page">For use with the <em>page</em> parameter. Indicates how many records should be included on each page of results. A valid value is any positive integer. The default is <strong>10</strong>.</param>
		/// <returns>Success</returns>
		public async Task<Live_streams> ListLiveStreamsAsync(int page, int per_page)
		{
			var requestUri = "live_streams?page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Live_streams>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a live stream
		/// This operation creates a live stream.
		/// CreateLiveStream live_streams
		/// </summary>
		/// <param name="requestBody">Provide the details of the live stream to create in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<CreateLiveStreamReturn> CreateLiveStreamAsync(Live_stream_create_input requestBody)
		{
			var requestUri = "live_streams";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateLiveStreamReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a live stream
		/// This operation shows the details of a specific live stream.
		/// ShowLiveStream live_streams/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the live stream.</param>
		/// <returns>Success</returns>
		public async Task<ShowLiveStreamReturn> ShowLiveStreamAsync(string id)
		{
			var requestUri = "live_streams/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowLiveStreamReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a live stream
		/// This operation deletes a live stream, including all assigned outputs and targets.
		/// DeleteLiveStream live_streams/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the live stream.</param>
		public async Task DeleteLiveStreamAsync(string id)
		{
			var requestUri = "live_streams/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a live stream
		/// This operation updates a live stream.
		/// UpdateLiveStream live_streams/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the live stream.</param>
		/// <param name="requestBody">Provide the details of the live stream to update in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<UpdateLiveStreamReturn> UpdateLiveStreamAsync(string id, Live_stream_update_input requestBody)
		{
			var requestUri = "live_streams/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdateLiveStreamReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Regenerate the connection code for a live stream
		/// This operation regenerates the connection code of a live stream.
		/// RegenerateConnectionCodeLiveStream live_streams/{id}/regenerate_connection_code
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the live stream.</param>
		/// <returns>Success</returns>
		public async Task<RegenerateConnectionCodeLiveStreamReturn> RegenerateConnectionCodeLiveStreamAsync(string id)
		{
			var requestUri = "live_streams/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/regenerate_connection_code";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RegenerateConnectionCodeLiveStreamReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reset a live stream
		/// This operation resets a live stream.
		/// ResetLiveStream live_streams/{id}/reset
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the live stream.</param>
		/// <returns>Success</returns>
		public async Task<ResetLiveStreamReturn> ResetLiveStreamAsync(string id)
		{
			var requestUri = "live_streams/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/reset";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ResetLiveStreamReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Start a live stream
		/// This operation starts a live stream.
		/// StartLiveStream live_streams/{id}/start
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the live stream.</param>
		/// <returns>Success</returns>
		public async Task<StartLiveStreamReturn> StartLiveStreamAsync(string id)
		{
			var requestUri = "live_streams/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/start";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<StartLiveStreamReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch the state of a live stream
		/// This operation shows the current state of a live stream.
		/// ShowLiveStreamState live_streams/{id}/state
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the live stream.</param>
		/// <returns>Success</returns>
		public async Task<ShowLiveStreamStateReturn> ShowLiveStreamStateAsync(string id)
		{
			var requestUri = "live_streams/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/state";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowLiveStreamStateReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch metrics for an active live stream
		/// This operation returns a hash of metrics keys, each of which identifies a status, text description, unit, and value.
		/// ShowLiveStreamStats live_streams/{id}/stats
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the live stream.</param>
		/// <returns>Success</returns>
		public async Task<ShowLiveStreamStatsReturn> ShowLiveStreamStatsAsync(string id)
		{
			var requestUri = "live_streams/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/stats";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowLiveStreamStatsReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Stop a live stream
		/// This operation stops a live stream.
		/// StopLiveStream live_streams/{id}/stop
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the live stream.</param>
		/// <returns>Success</returns>
		public async Task<StopLiveStreamReturn> StopLiveStreamAsync(string id)
		{
			var requestUri = "live_streams/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/stop";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<StopLiveStreamReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch the thumbnail URL of a live stream
		/// This operation shows the thumbnail URL of a started live stream.
		/// ShowLiveStreamThumbnailUrl live_streams/{id}/thumbnail_url
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the live stream.</param>
		/// <returns>Success</returns>
		public async Task<ShowLiveStreamThumbnailUrlReturn> ShowLiveStreamThumbnailUrlAsync(string id)
		{
			var requestUri = "live_streams/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/thumbnail_url";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowLiveStreamThumbnailUrlReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch all players
		/// This operation shows the details of all of your players.
		/// ListPlayers players
		/// </summary>
		/// <param name="page">Returns a paginated view of results from the HTTP request. Specify a positive integer to indicate which page of the results should be displayed first. <strong>Next</strong> and <strong>Previous</strong> links allow you to navigate multiple pages of results. Omit the <em>page</em> parameter or specify an integer that's less than or equal to <strong>0</strong> to view all (unpaginated) results.</param>
		/// <param name="per_page">For use with the <em>page</em> parameter. Indicates how many records should be included on each page of results. A valid value is any positive integer. The default is <strong>10</strong>.</param>
		/// <returns>Success</returns>
		public async Task<Players> ListPlayersAsync(int page, int per_page)
		{
			var requestUri = "players?page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Players>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a player
		/// This operation shows details of a specific player.
		/// ShowPlayer players/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the player.</param>
		/// <returns>Success</returns>
		public async Task<ShowPlayerReturn> ShowPlayerAsync(string id)
		{
			var requestUri = "players/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowPlayerReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a player
		/// This operation updates a player.
		/// UpdatePlayer players/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the player.</param>
		/// <param name="requestBody">Provide the details of the player to update in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<UpdatePlayerReturn> UpdatePlayerAsync(string id, Player_update_input requestBody)
		{
			var requestUri = "players/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdatePlayerReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Rebuild player code
		/// This operation rebuilds the player with the current configuration.
		/// RequestPlayerRebuild players/{id}/rebuild
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the player.</param>
		/// <returns>Success</returns>
		public async Task<RequestPlayerRebuildReturn> RequestPlayerRebuildAsync(string id)
		{
			var requestUri = "players/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/rebuild";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RequestPlayerRebuildReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch the state of a player
		/// This operation shows the current state of a player.
		/// ShowPlayerState players/{id}/state
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the player.</param>
		/// <returns>Success</returns>
		public async Task<ShowPlayerStateReturn> ShowPlayerStateAsync(string id)
		{
			var requestUri = "players/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/state";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowPlayerStateReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch all player URLs
		/// This operation shows the details of all player URLs.
		/// ListPlayerUrls players/{player_id}/urls
		/// </summary>
		/// <param name="player_id">The unique alphanumeric string that identifies the player.</param>
		/// <returns>Success</returns>
		public async Task<Urls> ListPlayerUrlsAsync(string player_id)
		{
			var requestUri = "players/"+ (player_id==null? "" : System.Uri.EscapeDataString(player_id))+"/urls";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Urls>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a player URL
		/// This operation creates a new player URL.
		/// CreatePlayerUrl players/{player_id}/urls
		/// </summary>
		/// <param name="player_id">The unique alphanumeric string that identifies the player.</param>
		/// <param name="requestBody">Provide the details of the player URL to create in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<CreatePlayerUrlReturn> CreatePlayerUrlAsync(string player_id, Url_create_input requestBody)
		{
			var requestUri = "players/"+ (player_id==null? "" : System.Uri.EscapeDataString(player_id))+"/urls";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreatePlayerUrlReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a player URL
		/// This operation shows the details of a player URL.
		/// ShowPlayerUrl players/{player_id}/urls/{id}
		/// </summary>
		/// <param name="player_id">The unique alphanumeric string that identifies the player.</param>
		/// <param name="id">The unique alphanumeric string that identifies the player URL.</param>
		/// <returns>Success</returns>
		public async Task<ShowPlayerUrlReturn> ShowPlayerUrlAsync(string player_id, string id)
		{
			var requestUri = "players/"+ (player_id==null? "" : System.Uri.EscapeDataString(player_id))+"/urls/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowPlayerUrlReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a player URL
		/// This operation deletes a player URL.
		/// DeletePlayerUrl players/{player_id}/urls/{id}
		/// </summary>
		/// <param name="player_id">The unique alphanumeric string that identifies the player.</param>
		/// <param name="id">The unique alphanumeric string that identifies the player URL.</param>
		public async Task DeletePlayerUrlAsync(string player_id, string id)
		{
			var requestUri = "players/"+ (player_id==null? "" : System.Uri.EscapeDataString(player_id))+"/urls/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a player URL
		/// This operation updates a player URL.
		/// UpdatePlayerUrl players/{player_id}/urls/{id}
		/// </summary>
		/// <param name="player_id">The unique alphanumeric string that identifies the player.</param>
		/// <param name="id">The unique alphanumeric string that identifies the player URL.</param>
		/// <param name="requestBody">Provide the details of the player URL to update in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<UpdatePlayerUrlReturn> UpdatePlayerUrlAsync(string player_id, string id, Url_update_input requestBody)
		{
			var requestUri = "players/"+ (player_id==null? "" : System.Uri.EscapeDataString(player_id))+"/urls/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdatePlayerUrlReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch all recordings
		/// This operation shows the details of all of your recordings.
		/// ListRecordings recordings
		/// </summary>
		/// <param name="page">Returns a paginated view of results from the HTTP request. Specify a positive integer to indicate which page of the results should be displayed first. <strong>Next</strong> and <strong>Previous</strong> links allow you to navigate multiple pages of results. Omit the <em>page</em> parameter or specify an integer that's less than or equal to <strong>0</strong> to view all (unpaginated) results.</param>
		/// <param name="per_page">For use with the <em>page</em> parameter. Indicates how many records should be included on each page of results. A valid value is any positive integer. The default is <strong>10</strong>.</param>
		/// <returns>Success</returns>
		public async Task<Recordings> ListRecordingsAsync(int page, int per_page)
		{
			var requestUri = "recordings?page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Recordings>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a recording
		/// This operation shows the details of a specific recording.
		/// ShowRecording recordings/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the recording.</param>
		/// <returns>Success</returns>
		public async Task<ShowRecordingReturn> ShowRecordingAsync(string id)
		{
			var requestUri = "recordings/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowRecordingReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a recording
		/// This operation deletes a recording.
		/// DeleteRecording recordings/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the recording.</param>
		public async Task DeleteRecordingAsync(string id)
		{
			var requestUri = "recordings/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch the state of a recording
		/// This operation shows the current state of a recording.
		/// ShowRecordingState recordings/{id}/state
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the recording.</param>
		/// <returns>Success</returns>
		public async Task<ShowRecordingStateReturn> ShowRecordingStateAsync(string id)
		{
			var requestUri = "recordings/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/state";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowRecordingStateReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch all schedules
		/// This operation shows the details of all of your schedules.
		/// ListSchedules schedules
		/// </summary>
		/// <param name="page">Returns a paginated view of results from the HTTP request. Specify a positive integer to indicate which page of the results should be displayed first. <strong>Next</strong> and <strong>Previous</strong> links allow you to navigate multiple pages of results. Omit the <em>page</em> parameter or specify an integer that's less than or equal to <strong>0</strong> to view all (unpaginated) results.</param>
		/// <param name="per_page">For use with the <em>page</em> parameter. Indicates how many records should be included on each page of results. A valid value is any positive integer. The default is <strong>10</strong>.</param>
		/// <returns>Success</returns>
		public async Task<Schedules> ListSchedulesAsync(int page, int per_page)
		{
			var requestUri = "schedules?page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Schedules>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a schedule
		/// This operation creates a schedule.
		/// CreateSchedule schedules
		/// </summary>
		/// <param name="requestBody">Provide the details of the schedule to create in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<CreateScheduleReturn> CreateScheduleAsync(Schedule_create_input requestBody)
		{
			var requestUri = "schedules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateScheduleReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a schedule
		/// This operation shows the details of a specific schedule.
		/// ShowSchedule schedules/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the schedule.</param>
		/// <returns>Success</returns>
		public async Task<ShowScheduleReturn> ShowScheduleAsync(string id)
		{
			var requestUri = "schedules/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowScheduleReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a schedule
		/// This operation deletes a schedule.
		/// DeleteSchedule schedules/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the schedule.</param>
		public async Task DeleteScheduleAsync(string id)
		{
			var requestUri = "schedules/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a schedule
		/// This operation updates a schedule.
		/// UpdateSchedule schedules/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the schedule.</param>
		/// <param name="requestBody">Provide the details of the schedule to update in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<UpdateScheduleReturn> UpdateScheduleAsync(string id, Schedule_update_input requestBody)
		{
			var requestUri = "schedules/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdateScheduleReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Disable a schedule
		/// This operation disables a schedule.
		/// DisableSchedule schedules/{id}/disable
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the schedule.</param>
		/// <returns>Success</returns>
		public async Task<DisableScheduleReturn> DisableScheduleAsync(string id)
		{
			var requestUri = "schedules/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/disable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DisableScheduleReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Enable a schedule
		/// This operation enables a schedule.
		/// EnableSchedule schedules/{id}/enable
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the schedule.</param>
		/// <returns>Success</returns>
		public async Task<EnableScheduleReturn> EnableScheduleAsync(string id)
		{
			var requestUri = "schedules/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/enable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<EnableScheduleReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch the state of a schedule
		/// This operation shows the current state of a schedule.
		/// ShowScheduleState schedules/{id}/state
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the schedule.</param>
		/// <returns>Success</returns>
		public async Task<ShowScheduleStateReturn> ShowScheduleStateAsync(string id)
		{
			var requestUri = "schedules/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/state";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowScheduleStateReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch all stream sources
		/// This operation shows the details of all of your stream sources.
		/// ListStreamSources stream_sources
		/// </summary>
		/// <param name="page">Returns a paginated view of results from the HTTP request. Specify a positive integer to indicate which page of the results should be displayed first. <strong>Next</strong> and <strong>Previous</strong> links allow you to navigate multiple pages of results. Omit the <em>page</em> parameter or specify an integer that's less than or equal to <strong>0</strong> to view all (unpaginated) results.</param>
		/// <param name="per_page">For use with the <em>page</em> parameter. Indicates how many records should be included on each page of results. A valid value is any positive integer. The default is <strong>10</strong>.</param>
		/// <returns>Success</returns>
		public async Task<Stream_sources> ListStreamSourcesAsync(int page, int per_page)
		{
			var requestUri = "stream_sources?page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Stream_sources>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a stream source
		/// This operation adds a stream source.
		/// CreateStreamSource stream_sources
		/// </summary>
		/// <param name="requestBody">Provide the details of the stream source to add in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<CreateStreamSourceReturn> CreateStreamSourceAsync(Stream_source_create_input requestBody)
		{
			var requestUri = "stream_sources";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateStreamSourceReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deprecated operation
		/// POST /stream_sources/add/ is deprecated. To add a stream source, use POST /stream_sources instead.
		/// AddStreamSource stream_sources/add
		/// </summary>
		/// <param name="requestBody">Provide the details of the stream source to add in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<AddStreamSourceReturn> AddStreamSourceAsync(Stream_source_create_input requestBody)
		{
			var requestUri = "stream_sources/add";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<AddStreamSourceReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a stream source
		/// This operation shows details of a specific stream source.
		/// ShowStreamSource stream_sources/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the stream source.</param>
		/// <returns>Success</returns>
		public async Task<ShowStreamSourceReturn> ShowStreamSourceAsync(string id)
		{
			var requestUri = "stream_sources/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowStreamSourceReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a stream source
		/// This operation deletes a stream source.
		/// DeleteStreamSource stream_sources/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the stream source.</param>
		public async Task DeleteStreamSourceAsync(string id)
		{
			var requestUri = "stream_sources/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a stream source
		/// This operation updates a stream source.
		/// UpdateStreamSource stream_sources/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the stream source.</param>
		/// <param name="requestBody">Provide the details of the stream source to update in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<UpdateStreamSourceReturn> UpdateStreamSourceAsync(string id, Stream_source_update_input requestBody)
		{
			var requestUri = "stream_sources/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdateStreamSourceReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch all stream targets
		/// This operation lists the details of all of your stream targets.
		/// ListStreamTargets stream_targets
		/// </summary>
		/// <param name="page">Returns a paginated view of results from the HTTP request. Specify a positive integer to indicate which page of the results should be displayed first. <strong>Next</strong> and <strong>Previous</strong> links allow you to navigate multiple pages of results. Omit the <em>page</em> parameter or specify an integer that's less than or equal to <strong>0</strong> to view all (unpaginated) results.</param>
		/// <param name="per_page">For use with the <em>page</em> parameter. Indicates how many records should be included on each page of results. A valid value is any positive integer. The default is <strong>10</strong>.</param>
		/// <returns>Success</returns>
		public async Task<Stream_targets> ListStreamTargetsAsync(int page, int per_page)
		{
			var requestUri = "stream_targets?page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Stream_targets>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a stream target
		/// This operation creates a stream target. There are three types of targets that you can create: <strong>CustomStreamTarget</strong> for an an external, third-party destination; <strong>WowzaStreamTarget</strong> for a Wowza CDN target; or <strong>UltraLowLatencyStreamTarget</strong> for an ultra low latency Wowza CDN target. The availability of many parameters depends on the type of target you create.
		/// CreateStreamTarget stream_targets
		/// </summary>
		/// <param name="requestBody">Provide the details of the stream target to create in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<CreateStreamTargetReturn> CreateStreamTargetAsync(Stream_target_create_input requestBody)
		{
			var requestUri = "stream_targets";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateStreamTargetReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deprecated operation
		/// POST /stream_targets/add/ is deprecated. To add a stream target, use POST /stream_targets instead.
		/// AddStreamTarget stream_targets/add
		/// </summary>
		/// <param name="requestBody">Provide the details of the stream target to add in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<AddStreamTargetReturn> AddStreamTargetAsync(Wowza_stream_target_input requestBody)
		{
			var requestUri = "stream_targets/add";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<AddStreamTargetReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a stream target
		/// This operation shows details of a specific stream target.
		/// ShowStreamTarget stream_targets/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the stream target.</param>
		/// <returns>Success</returns>
		public async Task<ShowStreamTargetReturn> ShowStreamTargetAsync(string id)
		{
			var requestUri = "stream_targets/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowStreamTargetReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a stream target
		/// This operation deletes a stream target.
		/// DeleteStreamTarget stream_targets/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the stream target.</param>
		public async Task DeleteStreamTargetAsync(string id)
		{
			var requestUri = "stream_targets/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a stream target
		/// This operation updates a stream target.
		/// UpdateStreamTarget stream_targets/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the stream target.</param>
		/// <param name="requestBody">Provide the details of the stream target to update in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<UpdateStreamTargetReturn> UpdateStreamTargetAsync(string id, Stream_target_update_input requestBody)
		{
			var requestUri = "stream_targets/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdateStreamTargetReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch current health metrics for an active Wowza ultra low latency stream target
		/// This operation returns a snapshot of the current connection and throughput details for an active target whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong>. The interval for current metrics is 30 seconds from the moment of the query.
		/// ShowStreamTargetMetricsCurrent stream_targets/{id}/metrics/current
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the stream target.</param>
		/// <returns>Success</returns>
		public async Task<ShowStreamTargetMetricsCurrentReturn> ShowStreamTargetMetricsCurrentAsync(string id)
		{
			var requestUri = "stream_targets/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/metrics/current";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowStreamTargetMetricsCurrentReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch historic health metrics for a Wowza ultra low latency stream target
		/// This operation shows historic connection and throughput details for target whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong>.
		/// ShowStreamTargetMetricsHistoric stream_targets/{id}/metrics/historic
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the stream target.</param>
		/// <param name="from">The start of the range of time used to aggregate the metrics. Express the value by using the ISO 8601 standard of <strong>YYYY-MM-DDTHH:MM:SSZ</strong> where <strong>HH</strong> is a 24-hour clock in UTC.</param>
		/// <param name="to">The end of the range of time used to aggregate the metrics. Express the value by using the ISO 8601 standard of <strong>YYYY-MM-DDTHH:MM:SSZ</strong> where <strong>HH</strong> is a 24-hour clock in UTC.</param>
		/// <param name="interval">The length of time for a block of metrics. The default is **10m** (10 minutes).</param>
		/// <returns>Success</returns>
		public async Task<ShowStreamTargetMetricsHistoricReturn> ShowStreamTargetMetricsHistoricAsync(string id, string from, string to, ShowStreamTargetMetricsHistoricInterval interval)
		{
			var requestUri = "stream_targets/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/metrics/historic&from=" + (from==null? "" : System.Uri.EscapeDataString(from))+"&to=" + (to==null? "" : System.Uri.EscapeDataString(to))+"&interval=" + interval;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowStreamTargetMetricsHistoricReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Regenerate the connection code for a stream target
		/// This operation regenerates the connection code of a stream target.
		/// RegenerateConnectionCodeStreamTarget stream_targets/{id}/regenerate_connection_code
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the stream target.</param>
		/// <returns>Success</returns>
		public async Task<RegenerateConnectionCodeStreamTargetReturn> RegenerateConnectionCodeStreamTargetAsync(string id)
		{
			var requestUri = "stream_targets/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/regenerate_connection_code";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RegenerateConnectionCodeStreamTargetReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch geo-blocking for a stream target
		/// This operation shows the details of geo-blocking applied to a specific stream target. Only stream targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> can be geo-blocked.
		/// ShowStreamTargetGeoblock stream_targets/{stream_target_id}/geoblock
		/// </summary>
		/// <param name="stream_target_id">The unique alphanumeric string that identifies the stream target.</param>
		/// <returns>Success</returns>
		public async Task<ShowStreamTargetGeoblockReturn> ShowStreamTargetGeoblockAsync(string stream_target_id)
		{
			var requestUri = "stream_targets/"+ (stream_target_id==null? "" : System.Uri.EscapeDataString(stream_target_id))+"/geoblock";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowStreamTargetGeoblockReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create geo-blocking for a stream target
		/// This operation allows you to block or whitelist viewing of a stream target by geographic location. Only stream targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> can be geo-blocked. For more information see the technical article [How to geo-block stream targets by using the Wowza Streaming Cloud REST API](https://www.wowza.com/docs/how-to-geo-block-stream-targets-by-using-the-wowza-streaming-cloud-rest-api).
		/// CreateStreamTargetGeoblock stream_targets/{stream_target_id}/geoblock
		/// </summary>
		/// <param name="stream_target_id">The unique alphanumeric string that identifies the stream target.</param>
		/// <param name="requestBody">Provide the details of the geo-blocking to create in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<CreateStreamTargetGeoblockReturn> CreateStreamTargetGeoblockAsync(string stream_target_id, Geoblock_create_input requestBody)
		{
			var requestUri = "stream_targets/"+ (stream_target_id==null? "" : System.Uri.EscapeDataString(stream_target_id))+"/geoblock";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateStreamTargetGeoblockReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update geo-blocking for a stream target
		/// This operation updates the geo-blocking applied to a stream target. Only stream targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> can be geo-blocked.
		/// UpdateStreamTargetGeoblock stream_targets/{stream_target_id}/geoblock
		/// </summary>
		/// <param name="stream_target_id">The unique alphanumeric string that identifies the stream target.</param>
		/// <param name="requestBody">Provide the details of the geo-blocking to update in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<UpdateStreamTargetGeoblockReturn> UpdateStreamTargetGeoblockAsync(string stream_target_id, Geoblock_update_input requestBody)
		{
			var requestUri = "stream_targets/"+ (stream_target_id==null? "" : System.Uri.EscapeDataString(stream_target_id))+"/geoblock";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdateStreamTargetGeoblockReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch all properties of a stream target
		/// This operation shows the details of all of the properties assigned to a specific stream target. Properties can be applied to a <strong>CustomStreamTarget</strong> or <strong>WowzaStreamTarget</strong> whose <em>provider</em> is <strong>akamai_cupertino</strong>.
		/// ListStreamTargetProperties stream_targets/{stream_target_id}/properties
		/// </summary>
		/// <param name="stream_target_id">The unique alphanumeric string that identifies the stream target.</param>
		/// <returns>Success</returns>
		public async Task<Stream_target_properties> ListStreamTargetPropertiesAsync(string stream_target_id)
		{
			var requestUri = "stream_targets/"+ (stream_target_id==null? "" : System.Uri.EscapeDataString(stream_target_id))+"/properties";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Stream_target_properties>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a property for a stream target
		/// This operation creates a property for a stream target. Properties can be applied to a <strong>CustomStreamTarget</strong> or <strong>WowzaStreamTarget</strong> whose <em>provider</em> is <strong>akamai_cupertino</strong>. For more information see the technical article [How to set advanced properties by using the Wowza Streaming Cloud REST API](https://www.wowza.com/docs/how-to-set-advanced-properties-by-using-the-wowza-streaming-cloud-rest-api).
		/// CreateStreamTargetProperty stream_targets/{stream_target_id}/properties
		/// </summary>
		/// <param name="stream_target_id">The unique alphanumeric string that identifies the stream target.</param>
		/// <param name="requestBody">Provide the details of the property to create in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<CreateStreamTargetPropertyReturn> CreateStreamTargetPropertyAsync(string stream_target_id, Stream_target_property_create_input requestBody)
		{
			var requestUri = "stream_targets/"+ (stream_target_id==null? "" : System.Uri.EscapeDataString(stream_target_id))+"/properties";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateStreamTargetPropertyReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a property of a stream target
		/// This operation shows the details of a specific property assigned to a specific stream target. Properties can be applied to a <strong>CustomStreamTarget</strong> or <strong>WowzaStreamTarget</strong> whose <em>provider</em> is <strong>akamai_cupertino</strong>.
		/// ShowStreamTargetProperty stream_targets/{stream_target_id}/properties/{id}
		/// </summary>
		/// <param name="stream_target_id">The unique alphanumeric string that identifies the stream target.</param>
		/// <param name="id">The unique string that identifies the stream target property. The string contains the <em>section</em> and the <em>key</em>, connected by a dash. For example, <strong>hls-chunkSize</strong>.</param>
		/// <returns>Success</returns>
		public async Task<ShowStreamTargetPropertyReturn> ShowStreamTargetPropertyAsync(string stream_target_id, string id)
		{
			var requestUri = "stream_targets/"+ (stream_target_id==null? "" : System.Uri.EscapeDataString(stream_target_id))+"/properties/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowStreamTargetPropertyReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a stream target property
		/// This operation removes a property from a stream target.
		/// DeleteStreamTargetProperty stream_targets/{stream_target_id}/properties/{id}
		/// </summary>
		/// <param name="stream_target_id">The unique alphanumeric string that identifies the stream target.</param>
		/// <param name="id">The unique string that identifies the stream target property. The string contains the <em>section</em> and the <em>key</em>, connected by a dash. For example, <strong>hls-chunkSize</strong>.</param>
		public async Task DeleteStreamTargetPropertyAsync(string stream_target_id, string id)
		{
			var requestUri = "stream_targets/"+ (stream_target_id==null? "" : System.Uri.EscapeDataString(stream_target_id))+"/properties/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch token authorization for a stream target
		/// This operation shows the details of the token authorization applied to a stream target. Only stream targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> can use token authorization.
		/// ShowStreamTargetTokenAuth stream_targets/{stream_target_id}/token_auth
		/// </summary>
		/// <param name="stream_target_id">The unique alphanumeric string that identifies the stream target.</param>
		/// <returns>Success</returns>
		public async Task<ShowStreamTargetTokenAuthReturn> ShowStreamTargetTokenAuthAsync(string stream_target_id)
		{
			var requestUri = "stream_targets/"+ (stream_target_id==null? "" : System.Uri.EscapeDataString(stream_target_id))+"/token_auth";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowStreamTargetTokenAuthReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create token authorization for a stream target
		/// This operation creates token authorization for a stream target. Only stream targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> can use token authorization. For more information see the technical article [How to protect stream targets with token authorization by using the Wowza Streaming Cloud REST API](https://www.wowza.com/docs/how-to-protect-streams-with-token-authorization-by-using-the-wowza-streaming-cloud-rest-api).
		/// CreateStreamTargetTokenAuth stream_targets/{stream_target_id}/token_auth
		/// </summary>
		/// <param name="stream_target_id">The unique alphanumeric string that identifies the stream target.</param>
		/// <param name="requestBody">Provide the details of the token authorization to create in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<CreateStreamTargetTokenAuthReturn> CreateStreamTargetTokenAuthAsync(string stream_target_id, Token_auth_create_input requestBody)
		{
			var requestUri = "stream_targets/"+ (stream_target_id==null? "" : System.Uri.EscapeDataString(stream_target_id))+"/token_auth";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateStreamTargetTokenAuthReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update token authorization for a stream target
		/// This operation updates the token authorization applied to a stream target. Only stream targets whose <em>type</em> is <strong>WowzaStreamTarget</strong> can use token authorization.
		/// UpdateStreamTargetTokenAuth stream_targets/{stream_target_id}/token_auth
		/// </summary>
		/// <param name="stream_target_id">The unique alphanumeric string that identifies the stream target.</param>
		/// <param name="requestBody">Provide the details of the token authorization to update in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<UpdateStreamTargetTokenAuthReturn> UpdateStreamTargetTokenAuthAsync(string stream_target_id, Token_auth_update_input requestBody)
		{
			var requestUri = "stream_targets/"+ (stream_target_id==null? "" : System.Uri.EscapeDataString(stream_target_id))+"/token_auth";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdateStreamTargetTokenAuthReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch all transcoders
		/// This operation shows the details of all of your transcoders.
		/// ListTranscoders transcoders
		/// </summary>
		/// <param name="page">Returns a paginated view of results from the HTTP request. Specify a positive integer to indicate which page of the results should be displayed first. <strong>Next</strong> and <strong>Previous</strong> links allow you to navigate multiple pages of results. Omit the <em>page</em> parameter or specify an integer that's less than or equal to <strong>0</strong> to view all (unpaginated) results.</param>
		/// <param name="per_page">For use with the <em>page</em> parameter. Indicates how many records should be included on each page of results. A valid value is any positive integer. The default is <strong>10</strong>.</param>
		/// <returns>Success</returns>
		public async Task<Transcoders> ListTranscodersAsync(int page, int per_page)
		{
			var requestUri = "transcoders?page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Transcoders>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a transcoder
		/// This operation creates a transcoder.
		/// CreateTranscoder transcoders
		/// </summary>
		/// <param name="requestBody">Provide the details of the transcoder to create in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<CreateTranscoderReturn> CreateTranscoderAsync(Transcoder_create_input requestBody)
		{
			var requestUri = "transcoders";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateTranscoderReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a transcoder
		/// This operation shows the details of a specific transcoder.
		/// ShowTranscoder transcoders/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <returns>Success</returns>
		public async Task<ShowTranscoderReturn> ShowTranscoderAsync(string id)
		{
			var requestUri = "transcoders/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowTranscoderReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a transcoder
		/// This operation deletes a transcoder, including all of its assigned output renditions and stream targets.
		/// DeleteTranscoder transcoders/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the transcoder.</param>
		public async Task DeleteTranscoderAsync(string id)
		{
			var requestUri = "transcoders/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a transcoder
		/// This operation updates a transcoder.
		/// UpdateTranscoder transcoders/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="requestBody">Provide the details of the transcoder to update in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<UpdateTranscoderReturn> UpdateTranscoderAsync(string id, Transcoder_update_input requestBody)
		{
			var requestUri = "transcoders/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdateTranscoderReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Disable a transcoder's stream targets
		/// This operation disables all of the stream targets assigned to a specific transcoder.
		/// DisableAllStreamTargetsTranscoder transcoders/{id}/disable_all_stream_targets
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <returns>Success</returns>
		public async Task<DisableAllStreamTargetsTranscoderReturn> DisableAllStreamTargetsTranscoderAsync(string id)
		{
			var requestUri = "transcoders/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/disable_all_stream_targets";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DisableAllStreamTargetsTranscoderReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Enable a transcoder's stream targets
		/// This operation enables all of the stream targets assigned to a specific transcoder.
		/// EnableAllStreamTargetsTranscoder transcoders/{id}/enable_all_stream_targets
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <returns>Success</returns>
		public async Task<EnableAllStreamTargetsTranscoderReturn> EnableAllStreamTargetsTranscoderAsync(string id)
		{
			var requestUri = "transcoders/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/enable_all_stream_targets";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<EnableAllStreamTargetsTranscoderReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a transcoder's recordings
		/// This operation shows the details of all of the recordings for a specific transcoder.
		/// ListTranscoderRecordings transcoders/{id}/recordings
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <returns>Success</returns>
		public async Task<ListTranscoderRecordingsReturn> ListTranscoderRecordingsAsync(string id)
		{
			var requestUri = "transcoders/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/recordings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListTranscoderRecordingsReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reset a transcoder
		/// This operation resets a transcoder.
		/// ResetTranscoder transcoders/{id}/reset
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <returns>Success</returns>
		public async Task<ResetTranscoderReturn> ResetTranscoderAsync(string id)
		{
			var requestUri = "transcoders/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/reset";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ResetTranscoderReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch transcoder's schedules
		/// This operation shows the details of all of the schedules for a specific transcoder.
		/// ListTranscoderSchedules transcoders/{id}/schedules
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <returns>Success</returns>
		public async Task<ListTranscoderSchedulesReturn> ListTranscoderSchedulesAsync(string id)
		{
			var requestUri = "transcoders/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/schedules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListTranscoderSchedulesReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Start a transcoder
		/// This operation starts a transcoder.
		/// StartTranscoder transcoders/{id}/start
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <returns>Success</returns>
		public async Task<StartTranscoderReturn> StartTranscoderAsync(string id)
		{
			var requestUri = "transcoders/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/start";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<StartTranscoderReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch the state and uptime ID of a transcoder
		/// This operation shows the current state and uptime ID of a transcoder.
		/// ShowTranscoderState transcoders/{id}/state
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <returns>Success</returns>
		public async Task<ShowTranscoderStateReturn> ShowTranscoderStateAsync(string id)
		{
			var requestUri = "transcoders/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/state";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowTranscoderStateReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch statistics for a current transcoder
		/// This operation responds with a hash of metrics (keys) for a currently running transcoder. Each key has a <strong>status</strong>, <strong>text</strong> (description), <strong>units</strong>, and <strong>value</strong>.
		/// ShowTranscoderStats transcoders/{id}/stats
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <returns>Success</returns>
		public async Task<ShowTranscoderStatsReturn> ShowTranscoderStatsAsync(string id)
		{
			var requestUri = "transcoders/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/stats";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowTranscoderStatsReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Stop a transcoder
		/// This operation stops a transcoder.
		/// StopTranscoder transcoders/{id}/stop
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <returns>Success</returns>
		public async Task<StopTranscoderReturn> StopTranscoderAsync(string id)
		{
			var requestUri = "transcoders/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/stop";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<StopTranscoderReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch the thumbnail URL of a transcoder
		/// This operation shows the thumbnail URL of a started transcoder.
		/// ShowTranscoderThumbnailUrl transcoders/{id}/thumbnail_url
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <returns>Success</returns>
		public async Task<ShowTranscoderThumbnailUrlReturn> ShowTranscoderThumbnailUrlAsync(string id)
		{
			var requestUri = "transcoders/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/thumbnail_url";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowTranscoderThumbnailUrlReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch all outputs of a transcoder
		/// This operation shows the details of all of the output renditions of a specific transcoder.
		/// ListTranscoderOutputs transcoders/{transcoder_id}/outputs
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <returns>Success</returns>
		public async Task<Outputs> ListTranscoderOutputsAsync(string transcoder_id)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/outputs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Outputs>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an output
		/// This operation creates an output rendition for a specific transcoder.
		/// CreateTranscoderOutput transcoders/{transcoder_id}/outputs
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="requestBody">Provide the details of the output rendition to create in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<CreateTranscoderOutputReturn> CreateTranscoderOutputAsync(string transcoder_id, Output_create_input requestBody)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/outputs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateTranscoderOutputReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch an output
		/// This operation shows the details of a specific output rendition for a specific transcoder.
		/// ShowTranscoderOutput transcoders/{transcoder_id}/outputs/{id}
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="id">The unique alphanumeric string that identifies the output rendition.</param>
		/// <returns>Success</returns>
		public async Task<ShowTranscoderOutputReturn> ShowTranscoderOutputAsync(string transcoder_id, string id)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/outputs/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowTranscoderOutputReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an output
		/// This operation deletes an output, including all of its assigned targets.
		/// DeleteTranscoderOutput transcoders/{transcoder_id}/outputs/{id}
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="id">The unique alphanumeric string that identifies the output rendition.</param>
		public async Task DeleteTranscoderOutputAsync(string transcoder_id, string id)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/outputs/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an output
		/// This operation updates an output rendition.
		/// UpdateTranscoderOutput transcoders/{transcoder_id}/outputs/{id}
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="id">The unique alphanumeric string that identifies the output rendition.</param>
		/// <param name="requestBody">Provide the details of the output rendition to update in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<UpdateTranscoderOutputReturn> UpdateTranscoderOutputAsync(string transcoder_id, string id, Output_update_input requestBody)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/outputs/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdateTranscoderOutputReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deprecated operation
		/// The operation POST /transcoders/{transcoder_id}/outputs/{id}/add_stream_target is deprecated. Use POST /transcoders/{transcoder_id}/outputs/{output_id}/output_stream_targets to add an existing stream target to an output.
		/// AddStreamTargetToTranscoderOutput transcoders/{transcoder_id}/outputs/{id}/add_stream_target
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="id">The unique alphanumeric string that identifies the output rendition.</param>
		/// <param name="requestBody">Provide the details of the stream target to add in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<AddStreamTargetToTranscoderOutputReturn> AddStreamTargetToTranscoderOutputAsync(string transcoder_id, string id, Output_add_stream_target_input requestBody)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/outputs/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/add_stream_target";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<AddStreamTargetToTranscoderOutputReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deprecated operation
		/// The operation DELETE /transcoders/{transcoder_id}/outputs/{id}/remove_stream_target is deprecated. Use DELETE /transcoders/{transcoder_id}/outputs/{output_id}/output_stream_targets/{id} to remove a stream target from an output.
		/// RemoveStreamTargetToTranscoderOutput transcoders/{transcoder_id}/outputs/{id}/remove_stream_target
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="id">The unique alphanumeric string that identifies the output rendition.</param>
		public async Task RemoveStreamTargetToTranscoderOutputAsync(string transcoder_id, string id)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/outputs/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/remove_stream_target";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch all output stream targets of an output of a transcoder
		/// This operation shows the details of all of the output stream targets of an output of a transcoder.
		/// ListTranscoderOutputOutputStreamTargets transcoders/{transcoder_id}/outputs/{output_id}/output_stream_targets
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="output_id">The unique alphanumeric string that identifies the output rendition.</param>
		/// <returns>Success</returns>
		public async Task<Output_stream_target> ListTranscoderOutputOutputStreamTargetsAsync(string transcoder_id, string output_id)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/outputs/"+ (output_id==null? "" : System.Uri.EscapeDataString(output_id))+"/output_stream_targets";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Output_stream_target>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an output stream target
		/// This operation creates an output stream target. Targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong> can't be added to output renditions.
		/// CreateTranscoderOutputOutputStreamTarget transcoders/{transcoder_id}/outputs/{output_id}/output_stream_targets
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="output_id">The unique alphanumeric string that identifies the output rendition.</param>
		/// <param name="requestBody">Provide the details of the output stream target to create in the body of the request. Targets whose <em>type</em> is <strong>UltraLowLatencyStreamTarget</strong> can't be added to output renditions.</param>
		/// <returns>Success</returns>
		public async Task<CreateTranscoderOutputOutputStreamTargetReturn> CreateTranscoderOutputOutputStreamTargetAsync(string transcoder_id, string output_id, Output_stream_target_create_input requestBody)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/outputs/"+ (output_id==null? "" : System.Uri.EscapeDataString(output_id))+"/output_stream_targets";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateTranscoderOutputOutputStreamTargetReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch an output stream target
		/// This operation shows the details of an output stream target.
		/// ShowTranscoderOutputOutputStreamTarget transcoders/{transcoder_id}/outputs/{output_id}/output_stream_targets/{stream_target_id}
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="output_id">The unique alphanumeric string that identifies the output rendition.</param>
		/// <param name="stream_target_id">The unique alphanumeric string that identifies the stream target.</param>
		/// <returns>Success</returns>
		public async Task<ShowTranscoderOutputOutputStreamTargetReturn> ShowTranscoderOutputOutputStreamTargetAsync(string transcoder_id, string output_id, string stream_target_id)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/outputs/"+ (output_id==null? "" : System.Uri.EscapeDataString(output_id))+"/output_stream_targets/"+ (stream_target_id==null? "" : System.Uri.EscapeDataString(stream_target_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowTranscoderOutputOutputStreamTargetReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an output stream target
		/// This operation deletes an output stream target, including all of its assigned targets.
		/// DeleteTranscoderOutputOutputStreamTarget transcoders/{transcoder_id}/outputs/{output_id}/output_stream_targets/{stream_target_id}
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="output_id">The unique alphanumeric string that identifies the output rendition.</param>
		/// <param name="stream_target_id">The unique alphanumeric string that identifies the stream target.</param>
		public async Task DeleteTranscoderOutputOutputStreamTargetAsync(string transcoder_id, string output_id, string stream_target_id)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/outputs/"+ (output_id==null? "" : System.Uri.EscapeDataString(output_id))+"/output_stream_targets/"+ (stream_target_id==null? "" : System.Uri.EscapeDataString(stream_target_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an output stream target
		/// This operation updates an output stream target.
		/// UpdateTranscoderOutputOutputStreamTarget transcoders/{transcoder_id}/outputs/{output_id}/output_stream_targets/{stream_target_id}
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="output_id">The unique alphanumeric string that identifies the output rendition.</param>
		/// <param name="stream_target_id">The unique alphanumeric string that identifies the stream target.</param>
		/// <param name="requestBody">Provide the details of the output stream target to update in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<UpdateTranscoderOutputOutputStreamTargetReturn> UpdateTranscoderOutputOutputStreamTargetAsync(string transcoder_id, string output_id, string stream_target_id, Output_stream_target_update_input requestBody)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/outputs/"+ (output_id==null? "" : System.Uri.EscapeDataString(output_id))+"/output_stream_targets/"+ (stream_target_id==null? "" : System.Uri.EscapeDataString(stream_target_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdateTranscoderOutputOutputStreamTargetReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Disable an output stream target
		/// This operation disables an output stream target.
		/// DisableTranscoderOutputOutputStreamTarget transcoders/{transcoder_id}/outputs/{output_id}/output_stream_targets/{stream_target_id}/disable
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="output_id">The unique alphanumeric string that identifies the output rendition.</param>
		/// <param name="stream_target_id">The unique alphanumeric string that identifies the stream target.</param>
		/// <returns>Success</returns>
		public async Task<DisableTranscoderOutputOutputStreamTargetReturn> DisableTranscoderOutputOutputStreamTargetAsync(string transcoder_id, string output_id, string stream_target_id)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/outputs/"+ (output_id==null? "" : System.Uri.EscapeDataString(output_id))+"/output_stream_targets/"+ (stream_target_id==null? "" : System.Uri.EscapeDataString(stream_target_id))+"/disable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DisableTranscoderOutputOutputStreamTargetReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Enable an output stream target
		/// This operation enables an output stream target.
		/// EnableTranscoderOutputOutputStreamTarget transcoders/{transcoder_id}/outputs/{output_id}/output_stream_targets/{stream_target_id}/enable
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="output_id">The unique alphanumeric string that identifies the output rendition.</param>
		/// <param name="stream_target_id">The unique alphanumeric string that identifies the stream target.</param>
		/// <returns>Success</returns>
		public async Task<EnableTranscoderOutputOutputStreamTargetReturn> EnableTranscoderOutputOutputStreamTargetAsync(string transcoder_id, string output_id, string stream_target_id)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/outputs/"+ (output_id==null? "" : System.Uri.EscapeDataString(output_id))+"/output_stream_targets/"+ (stream_target_id==null? "" : System.Uri.EscapeDataString(stream_target_id))+"/enable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<EnableTranscoderOutputOutputStreamTargetReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Restart an output stream target
		/// This operation restarts an output stream target.
		/// RestartTranscoderOutputOutputStreamTarget transcoders/{transcoder_id}/outputs/{output_id}/output_stream_targets/{stream_target_id}/restart
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="output_id">The unique alphanumeric string that identifies the output rendition.</param>
		/// <param name="stream_target_id">The unique alphanumeric string that identifies the stream target.</param>
		/// <returns>Success</returns>
		public async Task<RestartTranscoderOutputOutputStreamTargetReturn> RestartTranscoderOutputOutputStreamTargetAsync(string transcoder_id, string output_id, string stream_target_id)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/outputs/"+ (output_id==null? "" : System.Uri.EscapeDataString(output_id))+"/output_stream_targets/"+ (stream_target_id==null? "" : System.Uri.EscapeDataString(stream_target_id))+"/restart";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RestartTranscoderOutputOutputStreamTargetReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a transcoder's properties
		/// This operation shows all of the properties of a specific transcoder.
		/// ListTranscoderProperties transcoders/{transcoder_id}/properties
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <returns>Success</returns>
		public async Task<Transcoder_properties> ListTranscoderPropertiesAsync(string transcoder_id)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/properties";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Transcoder_properties>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a property for a transcoder
		/// This operation creates a property for a transcoder. For more information see the technical article [How to set advanced properties by using the Wowza Streaming Cloud REST API](https://www.wowza.com/docs/how-to-set-advanced-properties-by-using-the-wowza-streaming-cloud-rest-api).
		/// CreateTranscoderProperty transcoders/{transcoder_id}/properties
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="requestBody">Provide the details of the property to create in the body of the request.</param>
		/// <returns>Success</returns>
		public async Task<CreateTranscoderPropertyReturn> CreateTranscoderPropertyAsync(string transcoder_id, Transcoder_property_create_input requestBody)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/properties";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateTranscoderPropertyReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a property for a transcoder
		/// This operation shows the details of a specific property for a specific transcoder.
		/// ShowTranscoderProperty transcoders/{transcoder_id}/properties/{id}
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="id">The unique string that identifies the transcoder property. The string contains the section and the key, connected by a dash. For example, cupertino-cupertinoProgramDateTimeOffset.</param>
		/// <returns>Success</returns>
		public async Task<ShowTranscoderPropertyReturn> ShowTranscoderPropertyAsync(string transcoder_id, string id)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/properties/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowTranscoderPropertyReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a transcoder's property
		/// This operation deletes a specific property from a specific transcoder.
		/// DeleteTranscoderProperty transcoders/{transcoder_id}/properties/{id}
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="id">The unique string that identifies the transcoder property. The string contains the section and the key, connected by a dash. For example, cupertino-cupertinoProgramDateTimeOffset.</param>
		public async Task DeleteTranscoderPropertyAsync(string transcoder_id, string id)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/properties/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch all uptime records for a transcoder
		/// This operation shows all of the uptime records for a specific transcoder. An <em>uptime record</em> identifies a specific transcoding session.
		/// IndexUptimes transcoders/{transcoder_id}/uptimes
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="page">Returns a paginated view of results from the HTTP request. Specify a positive integer to indicate which page of the results should be displayed first. <strong>Next</strong> and <strong>Previous</strong> links allow you to navigate multiple pages of results. Omit the <em>page</em> parameter or specify an integer that's less than or equal to <strong>0</strong> to view all (unpaginated) results.</param>
		/// <param name="per_page">For use with the <em>page</em> parameter. Indicates how many records should be included on each page of results. A valid value is any positive integer. The default is <strong>10</strong>.</param>
		/// <returns>Success</returns>
		public async Task<Uptimes> IndexUptimesAsync(string transcoder_id, int page, int per_page)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/uptimes&page="+page+"&per_page="+per_page;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Uptimes>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch an uptime record
		/// This operation shows the details of a specific uptime record for a specific transcoder. An <em>uptime record</em> identifies a transcoding session.
		/// ShowUptime transcoders/{transcoder_id}/uptimes/{id}
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="id">The unique alphanumeric string that identifies the uptime record.</param>
		/// <returns>Success</returns>
		public async Task<Uptime> ShowUptimeAsync(string transcoder_id, string id)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/uptimes/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Uptime>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch current stream health metrics for an active transcoder
		/// This operation returns a snapshot of the current source connection and processing details of an active (running) transcoder.
		/// ShowUptimeMetricsCurrent transcoders/{transcoder_id}/uptimes/{id}/metrics/current
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="id">The unique alphanumeric string that identifies the uptime record.</param>
		/// <param name="fields">A comma-separated list of fields to return.</param>
		/// <returns>Success</returns>
		public async Task<ShowUptimeMetricsCurrentReturn> ShowUptimeMetricsCurrentAsync(string transcoder_id, string id, string fields)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/uptimes/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/metrics/current&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowUptimeMetricsCurrentReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch historic stream health metrics for a transcoder
		/// This operation shows the historic source connection and processing details for a transcoding session (uptime record). The transcoder can be running or stopped. Metrics are recorded every 20 seconds.
		/// ShowUptimeMetricsHistoric transcoders/{transcoder_id}/uptimes/{id}/metrics/historic
		/// </summary>
		/// <param name="transcoder_id">The unique alphanumeric string that identifies the transcoder.</param>
		/// <param name="id">The unique alphanumeric string that identifies the uptime record.</param>
		/// <param name="fields">A comma-separated list of fields to return.</param>
		/// <param name="from">The start of the range of time used to aggregate the metrics. Express the value by using the ISO 8601 standard of <strong>YYYY-MM-DDTHH:MM:SSZ</strong> where <strong>HH</strong> is a 24-hour clock in UTC.</param>
		/// <param name="to">The end of the range of time used to aggregate the metrics. Express the value by using the ISO 8601 standard of <strong>YYYY-MM-DDTHH:MM:SSZ</strong> where <strong>HH</strong> is a 24-hour clock in UTC.</param>
		/// <returns>Success</returns>
		public async Task<ShowUptimeMetricsHistoricReturn> ShowUptimeMetricsHistoricAsync(string transcoder_id, string id, string fields, string from, string to)
		{
			var requestUri = "transcoders/"+ (transcoder_id==null? "" : System.Uri.EscapeDataString(transcoder_id))+"/uptimes/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/metrics/historic&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields))+"&from=" + (from==null? "" : System.Uri.EscapeDataString(from))+"&to=" + (to==null? "" : System.Uri.EscapeDataString(to));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ShowUptimeMetricsHistoricReturn>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch network usage for all stream sources
		/// This operation shows the amount of network usage for all stream sources in the account. The default time frame is <em>from</em> the last billing date <em>to</em> the end of the current day.
		/// UsageNetworkStreamSourcesIndex usage/network/stream_sources
		/// </summary>
		/// <param name="from">The start of the range of time you want to view. Specify <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC. The <em>from</em> default is the last billing date.</param>
		/// <param name="to">The end of the range of time you want to view. Specify <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC. The <em>to</em> default is the end of the current day.</param>
		/// <returns>Success</returns>
		public async Task<Usage_network_stream_sources> UsageNetworkStreamSourcesIndexAsync(System.DateTimeOffset from, System.DateTimeOffset to)
		{
			var requestUri = "usage/network/stream_sources?from=" + from.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&to=" + to.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Usage_network_stream_sources>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch network usage for all stream targets
		/// This operation shows the amount of network usage for all stream targets in the account cumulatively and individually. The default time frame is <em>from</em> the last billing date <em>to</em> the end of the current day.
		/// UsageNetworkStreamTargetsIndex usage/network/stream_targets
		/// </summary>
		/// <param name="from">The start of the range of time you want to view. Specify <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC. The <em>from</em> default is the last billing date.</param>
		/// <param name="to">The end of the range of time you want to view. Specify <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC. The <em>to</em> default is the end of the current day.</param>
		/// <returns>Success</returns>
		public async Task<Usage_network_stream_targets> UsageNetworkStreamTargetsIndexAsync(System.DateTimeOffset from, System.DateTimeOffset to)
		{
			var requestUri = "usage/network/stream_targets?from=" + from.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&to=" + to.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Usage_network_stream_targets>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch network usage for all transcoders
		/// This operation shows the amount of network usage (egress) for all transcoders in the account. The default time frame is <em>from</em> the last billing date <em>to</em> the end of the current day.
		/// UsageNetworkTranscodersIndex usage/network/transcoders
		/// </summary>
		/// <param name="from">The start of the range of time you want to view. Specify <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC. The <em>from</em> default is the last billing date.</param>
		/// <param name="to">The end of the range of time you want to view. Specify <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC. The <em>to</em> default is the end of the current day.</param>
		/// <param name="transcoder_type">The type of transcoder. The default is <strong>transcoded</strong>.</param>
		/// <param name="billing_mode">The billing mode for the transcoder. The default is <strong>pay_as_you_go</strong>.</param>
		/// <returns>Success</returns>
		public async Task<Usage_network_transcoders> UsageNetworkTranscodersIndexAsync(System.DateTimeOffset from, System.DateTimeOffset to, Live_streamTranscoder_type transcoder_type, Live_streamBilling_mode billing_mode)
		{
			var requestUri = "usage/network/transcoders?from=" + from.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&to=" + to.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&transcoder_type=" + transcoder_type+"&billing_mode=" + billing_mode;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Usage_network_transcoders>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch peak recording storage
		/// This operation shows the amount of peak recording storage used for the account. The default time frame is <em>from</em> the last billing date <em>to</em> the end of the current day.
		/// UsageStoragePeakRecordingIndex usage/storage/peak_recording
		/// </summary>
		/// <param name="from">The start of the range of time you want to view. Specify <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC. The <em>from</em> default is the last billing date.</param>
		/// <param name="to">The end of the range of time you want to view. Specify <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC. The <em>to</em> default is the end of the current day.</param>
		/// <returns>Success</returns>
		public async Task<Usage_storage_peak_recording> UsageStoragePeakRecordingIndexAsync(System.DateTimeOffset from, System.DateTimeOffset to)
		{
			var requestUri = "usage/storage/peak_recording?from=" + from.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&to=" + to.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Usage_storage_peak_recording>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch stream processing time
		/// This operation shows the amount of stream processing time used by all transcoders in the account. The default time frame is <em>from</em> the last billing date <em>to</em> the end of the current day.
		/// UsageTimeTranscodersIndex usage/time/transcoders
		/// </summary>
		/// <param name="from">The start of the range of time you want to view. Specify <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC. The <em>from</em> default is the last billing date.</param>
		/// <param name="to">The end of the range of time you want to view. Specify <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC. The <em>to</em> default is the end of the current day.</param>
		/// <param name="transcoder_type">The type of transcoder. The default is <strong>transcoded</strong>.</param>
		/// <param name="billing_mode">The billing mode for the transcoder. The default is <strong>pay_as_you_go</strong>.</param>
		/// <returns>Success</returns>
		public async Task<Usage_time_transcoders> UsageTimeTranscodersIndexAsync(System.DateTimeOffset from, System.DateTimeOffset to, Live_streamTranscoder_type transcoder_type, Live_streamBilling_mode billing_mode)
		{
			var requestUri = "usage/time/transcoders?from=" + from.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&to=" + to.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&transcoder_type=" + transcoder_type+"&billing_mode=" + billing_mode;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Usage_time_transcoders>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch viewer data for a stream target
		/// This operation shows viewer data for a specific stream target. The default time frame is <em>from</em> the last billing date <em>to</em> the end of the current day.
		/// ShowViewerDataStreamTarget usage/viewer_data/stream_targets/{id}
		/// </summary>
		/// <param name="id">The unique alphanumeric string that identifies the stream target.</param>
		/// <param name="from">The start of the range of time you want to view. Specify <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC. The <em>from</em> default is the last billing date.</param>
		/// <param name="to">The end of the range of time you want to view. Specify <strong>YYYY-MM-DD HH:MM:SS</strong> where <strong>HH</strong> is a 24-hour clock in UTC. The <em>to</em> default is the end of the current day.</param>
		/// <returns>Success</returns>
		public async Task<Usage_viewer_data_stream_target> ShowViewerDataStreamTargetAsync(string id, System.DateTimeOffset from, System.DateTimeOffset to)
		{
			var requestUri = "usage/viewer_data/stream_targets/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"&from=" + from.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&to=" + to.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Usage_viewer_data_stream_target>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public class CreateLiveStreamReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="live_stream")]
		public Live_stream Live_stream { get; set; }
	}
	
	public class ShowLiveStreamReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="live_stream")]
		public Live_stream Live_stream { get; set; }
	}
	
	public class UpdateLiveStreamReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="live_stream")]
		public Live_stream Live_stream { get; set; }
	}
	
	public class RegenerateConnectionCodeLiveStreamReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="live_stream")]
		public RegenerateConnectionCodeLiveStreamReturnLive_stream Live_stream { get; set; }
	}
	
	public class RegenerateConnectionCodeLiveStreamReturnLive_stream
	{
		
		/// <summary>
		/// A six-character, alphanumeric string that allows certain encoders, including Wowza Streaming Engine and the Wowza GoCoder app, to connect with Wowza Streaming Cloud. The code can be used once and expires 24 hours after it's created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connection_code")]
		public string Connection_code { get; set; }
	}
	
	public class ResetLiveStreamReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="live_stream")]
		public ResetLiveStreamReturnLive_stream Live_stream { get; set; }
	}
	
	public class ResetLiveStreamReturnLive_stream
	{
		
		/// <summary>
		/// The state of the live stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<ResetLiveStreamReturnLive_streamState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ResetLiveStreamReturnLive_streamState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		started = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stopped = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		starting = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stopping = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		resetting = 4,
	}
	
	public class StartLiveStreamReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="live_stream")]
		public StartLiveStreamReturnLive_stream Live_stream { get; set; }
	}
	
	public class StartLiveStreamReturnLive_stream
	{
		
		/// <summary>
		/// The state of the live stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ResetLiveStreamReturnLive_streamState State { get; set; }
	}
	
	public class ShowLiveStreamStateReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="live_stream")]
		public ShowLiveStreamStateReturnLive_stream Live_stream { get; set; }
	}
	
	public class ShowLiveStreamStateReturnLive_stream
	{
		
		/// <summary>
		/// The state of the live stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ResetLiveStreamReturnLive_streamState State { get; set; }
	}
	
	public class ShowLiveStreamStatsReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="live_stream")]
		public Shm_metrics Live_stream { get; set; }
	}
	
	public class StopLiveStreamReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="live_stream")]
		public StopLiveStreamReturnLive_stream Live_stream { get; set; }
	}
	
	public class StopLiveStreamReturnLive_stream
	{
		
		/// <summary>
		/// The state of the live stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ResetLiveStreamReturnLive_streamState State { get; set; }
	}
	
	public class ShowLiveStreamThumbnailUrlReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="live_stream")]
		public ShowLiveStreamThumbnailUrlReturnLive_stream Live_stream { get; set; }
	}
	
	public class ShowLiveStreamThumbnailUrlReturnLive_stream
	{
		
		/// <summary>
		/// The URL to receive the preview thumbnail.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thumbnail_url")]
		public string Thumbnail_url { get; set; }
	}
	
	public class ShowPlayerReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="player")]
		public Player Player { get; set; }
	}
	
	public class UpdatePlayerReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="player")]
		public Player Player { get; set; }
	}
	
	public class RequestPlayerRebuildReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="player")]
		public RequestPlayerRebuildReturnPlayer Player { get; set; }
	}
	
	public class RequestPlayerRebuildReturnPlayer
	{
		
		/// <summary>
		/// The state of the player.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<RequestPlayerRebuildReturnPlayerState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum RequestPlayerRebuildReturnPlayerState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		requested = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		already_requested = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		activated = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		archived = 3,
	}
	
	public class ShowPlayerStateReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="player")]
		public ShowPlayerStateReturnPlayer Player { get; set; }
	}
	
	public class ShowPlayerStateReturnPlayer
	{
		
		/// <summary>
		/// The state of the player.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public RequestPlayerRebuildReturnPlayerState State { get; set; }
	}
	
	public class CreatePlayerUrlReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public Url Url { get; set; }
	}
	
	public class ShowPlayerUrlReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public Url Url { get; set; }
	}
	
	public class UpdatePlayerUrlReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public Url Url { get; set; }
	}
	
	public class ShowRecordingReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="recording")]
		public Recording Recording { get; set; }
	}
	
	public class ShowRecordingStateReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="recording")]
		public ShowRecordingStateReturnRecording Recording { get; set; }
	}
	
	public class ShowRecordingStateReturnRecording
	{
		
		/// <summary>
		/// The state of the recording.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public RecordingState State { get; set; }
	}
	
	public class CreateScheduleReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public Schedule Schedule { get; set; }
	}
	
	public class ShowScheduleReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public Schedule Schedule { get; set; }
	}
	
	public class UpdateScheduleReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public Schedule Schedule { get; set; }
	}
	
	public class DisableScheduleReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public DisableScheduleReturnSchedule Schedule { get; set; }
	}
	
	public class DisableScheduleReturnSchedule
	{
		
		/// <summary>
		/// A schedule must be <strong>enabled</strong> to run. Specify <strong>enabled</strong> to run the schedule or <strong>disabled</strong> to turn off the schedule so that it doesn't run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ScheduleState State { get; set; }
	}
	
	public class EnableScheduleReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public EnableScheduleReturnSchedule Schedule { get; set; }
	}
	
	public class EnableScheduleReturnSchedule
	{
		
		/// <summary>
		/// A schedule must be <strong>enabled</strong> to run. Specify <strong>enabled</strong> to run the schedule or <strong>disabled</strong> to turn off the schedule so that it doesn't run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ScheduleState State { get; set; }
	}
	
	public class ShowScheduleStateReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public ShowScheduleStateReturnSchedule Schedule { get; set; }
	}
	
	public class ShowScheduleStateReturnSchedule
	{
		
		/// <summary>
		/// A schedule must be <strong>enabled</strong> to run. Specify <strong>enabled</strong> to run the schedule or <strong>disabled</strong> to turn off the schedule so that it doesn't run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ScheduleState State { get; set; }
	}
	
	public class CreateStreamSourceReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_source")]
		public Stream_source Stream_source { get; set; }
	}
	
	public class AddStreamSourceReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_source")]
		public Stream_source Stream_source { get; set; }
	}
	
	public class ShowStreamSourceReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_source")]
		public Stream_source Stream_source { get; set; }
	}
	
	public class UpdateStreamSourceReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_source")]
		public Stream_source Stream_source { get; set; }
	}
	
	public class CreateStreamTargetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_target")]
		public Stream_target Stream_target { get; set; }
	}
	
	public class AddStreamTargetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_target")]
		public Stream_target Stream_target { get; set; }
	}
	
	public class ShowStreamTargetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_target")]
		public Stream_target Stream_target { get; set; }
	}
	
	public class UpdateStreamTargetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_target")]
		public Stream_target Stream_target { get; set; }
	}
	
	public class ShowStreamTargetMetricsCurrentReturn
	{
		
		/// <summary>
		/// The unique alphanumeric string that identifies the stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="metrics")]
		public Stream_target_metrics Metrics { get; set; }
	}
	
	public enum ShowStreamTargetMetricsHistoricInterval
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		second = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		minute = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hour = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		day = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		month = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="#s")]
		_s = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="#m")]
		_m = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="#h")]
		_h = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="#d")]
		_d = 8,
	}
	
	public class ShowStreamTargetMetricsHistoricReturn
	{
		
		/// <summary>
		/// The unique alphanumeric string that identifies the stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The length of time for a block of metrics. The default is **10m** (10 minutes).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interval")]
		public string Interval { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="metrics")]
		public Stream_target_metrics[] Metrics { get; set; }
	}
	
	public class RegenerateConnectionCodeStreamTargetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_target")]
		public RegenerateConnectionCodeStreamTargetReturnStream_target Stream_target { get; set; }
	}
	
	public class RegenerateConnectionCodeStreamTargetReturnStream_target
	{
		
		/// <summary>
		/// A six-character, alphanumeric string that allows Wowza Streaming Engine to send a transcoded stream to a <strong>WowzaStreamTarget</strong> or for the Wowza GoCoder app to send an encoded stream to a <strong>UltraLowLatencyStreamTarget</strong>. The code can be used once and expires 24 hours after it's created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connection_code")]
		public string Connection_code { get; set; }
	}
	
	public class ShowStreamTargetGeoblockReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="geoblock")]
		public Geoblock Geoblock { get; set; }
	}
	
	public class CreateStreamTargetGeoblockReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="geoblock")]
		public Geoblock Geoblock { get; set; }
	}
	
	public class UpdateStreamTargetGeoblockReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="geoblock")]
		public Geoblock Geoblock { get; set; }
	}
	
	public class CreateStreamTargetPropertyReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="property")]
		public Stream_target_property Property { get; set; }
	}
	
	public class ShowStreamTargetPropertyReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="property")]
		public Stream_target_property Property { get; set; }
	}
	
	public class ShowStreamTargetTokenAuthReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="token_auth")]
		public Token_auth Token_auth { get; set; }
	}
	
	public class CreateStreamTargetTokenAuthReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="token_auth")]
		public Token_auth Token_auth { get; set; }
	}
	
	public class UpdateStreamTargetTokenAuthReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="token_auth")]
		public Token_auth Token_auth { get; set; }
	}
	
	public class CreateTranscoderReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transcoder")]
		public Transcoder Transcoder { get; set; }
	}
	
	public class ShowTranscoderReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transcoder")]
		public Transcoder Transcoder { get; set; }
	}
	
	public class UpdateTranscoderReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transcoder")]
		public Transcoder Transcoder { get; set; }
	}
	
	public class DisableAllStreamTargetsTranscoderReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transcoder")]
		public DisableAllStreamTargetsTranscoderReturnTranscoder Transcoder { get; set; }
	}
	
	public class DisableAllStreamTargetsTranscoderReturnTranscoder
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_targets")]
		public DisableAllStreamTargetsTranscoderReturnTranscoderStream_targets Stream_targets { get; set; }
	}
	
	public class DisableAllStreamTargetsTranscoderReturnTranscoderStream_targets
	{
		
		/// <summary>
		/// The state of the transcoder's stream targets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<DisableAllStreamTargetsTranscoderReturnTranscoderStream_targetsState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum DisableAllStreamTargetsTranscoderReturnTranscoderStream_targetsState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
	}
	
	public class EnableAllStreamTargetsTranscoderReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transcoder")]
		public EnableAllStreamTargetsTranscoderReturnTranscoder Transcoder { get; set; }
	}
	
	public class EnableAllStreamTargetsTranscoderReturnTranscoder
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_targets")]
		public EnableAllStreamTargetsTranscoderReturnTranscoderStream_targets Stream_targets { get; set; }
	}
	
	public class EnableAllStreamTargetsTranscoderReturnTranscoderStream_targets
	{
		
		/// <summary>
		/// The state of the transcoder's stream targets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public DisableAllStreamTargetsTranscoderReturnTranscoderStream_targetsState State { get; set; }
	}
	
	public class ListTranscoderRecordingsReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transcoder")]
		public ListTranscoderRecordingsReturnTranscoder Transcoder { get; set; }
	}
	
	public class ListTranscoderRecordingsReturnTranscoder
	{
		
		/// <summary>
		/// Array of recordings of this transcoder. See /recordings for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recordings")]
		public Recording[] Recordings { get; set; }
	}
	
	public class ResetTranscoderReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transcoder")]
		public ResetTranscoderReturnTranscoder Transcoder { get; set; }
	}
	
	public class ResetTranscoderReturnTranscoder
	{
		
		/// <summary>
		/// The state of the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<ResetTranscoderReturnTranscoderState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ResetTranscoderReturnTranscoderState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		starting = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stopping = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		started = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stopped = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		resetting = 4,
	}
	
	public class ListTranscoderSchedulesReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transcoder")]
		public ListTranscoderSchedulesReturnTranscoder Transcoder { get; set; }
	}
	
	public class ListTranscoderSchedulesReturnTranscoder
	{
		
		/// <summary>
		/// Array of schedules of this transcoder. See /schedules for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedules")]
		public Schedule[] Schedules { get; set; }
	}
	
	public class StartTranscoderReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transcoder")]
		public StartTranscoderReturnTranscoder Transcoder { get; set; }
	}
	
	public class StartTranscoderReturnTranscoder
	{
		
		/// <summary>
		/// The state of the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ResetTranscoderReturnTranscoderState State { get; set; }
		
		/// <summary>
		/// <strong>The <em>transcoding_uptime_id</em> parameter is deprecated and is replaced by <em>uptime_id</em>.</strong> The unique identifier associated with a specific uptime period of a transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transcoding_uptime_id")]
		public string Transcoding_uptime_id { get; set; }
	}
	
	public class ShowTranscoderStateReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transcoder")]
		public ShowTranscoderStateReturnTranscoder Transcoder { get; set; }
	}
	
	public class ShowTranscoderStateReturnTranscoder
	{
		
		/// <summary>
		/// The state of the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ResetTranscoderReturnTranscoderState State { get; set; }
		
		/// <summary>
		/// <strong>The <em>transcoding_uptime_id</em> parameter is deprecated and is replaced by <em>uptime_id</em>.</strong> The unique identifier associated with a specific uptime period of a transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transcoding_uptime_id")]
		public string Transcoding_uptime_id { get; set; }
		
		/// <summary>
		/// The unique identifier associated with a specific uptime period of a transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uptime_id")]
		public string Uptime_id { get; set; }
	}
	
	public class ShowTranscoderStatsReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transcoder")]
		public Shm_metrics Transcoder { get; set; }
	}
	
	public class StopTranscoderReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transcoder")]
		public StopTranscoderReturnTranscoder Transcoder { get; set; }
	}
	
	public class StopTranscoderReturnTranscoder
	{
		
		/// <summary>
		/// The state of the transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ResetTranscoderReturnTranscoderState State { get; set; }
		
		/// <summary>
		/// <strong>The <em>transcoding_uptime_id</em> parameter is deprecated and is replaced by <em>uptime_id</em>.</strong> The unique identifier associated with a specific uptime period of a transcoder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transcoding_uptime_id")]
		public string Transcoding_uptime_id { get; set; }
	}
	
	public class ShowTranscoderThumbnailUrlReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transcoder")]
		public ShowTranscoderThumbnailUrlReturnTranscoder Transcoder { get; set; }
	}
	
	public class ShowTranscoderThumbnailUrlReturnTranscoder
	{
		
		/// <summary>
		/// The URL to receive the preview thumbnail.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thumbnail_url")]
		public string Thumbnail_url { get; set; }
	}
	
	public class CreateTranscoderOutputReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="output")]
		public Output Output { get; set; }
	}
	
	public class ShowTranscoderOutputReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="output")]
		public Output Output { get; set; }
	}
	
	public class UpdateTranscoderOutputReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="output")]
		public Output Output { get; set; }
	}
	
	public class AddStreamTargetToTranscoderOutputReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="output_stream_target")]
		public Output_stream_target Output_stream_target { get; set; }
	}
	
	public class CreateTranscoderOutputOutputStreamTargetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="output_stream_target")]
		public Output_stream_target Output_stream_target { get; set; }
	}
	
	public class ShowTranscoderOutputOutputStreamTargetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="output_stream_target")]
		public Output_stream_target Output_stream_target { get; set; }
	}
	
	public class UpdateTranscoderOutputOutputStreamTargetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="output_stream_target")]
		public Output_stream_target Output_stream_target { get; set; }
	}
	
	public class DisableTranscoderOutputOutputStreamTargetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_target")]
		public DisableTranscoderOutputOutputStreamTargetReturnStream_target Stream_target { get; set; }
	}
	
	public class DisableTranscoderOutputOutputStreamTargetReturnStream_target
	{
		
		/// <summary>
		/// The state of the output stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<DisableTranscoderOutputOutputStreamTargetReturnStream_targetState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum DisableTranscoderOutputOutputStreamTargetReturnStream_targetState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		restarted = 2,
	}
	
	public class EnableTranscoderOutputOutputStreamTargetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_target")]
		public EnableTranscoderOutputOutputStreamTargetReturnStream_target Stream_target { get; set; }
	}
	
	public class EnableTranscoderOutputOutputStreamTargetReturnStream_target
	{
		
		/// <summary>
		/// The state of the output stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public DisableTranscoderOutputOutputStreamTargetReturnStream_targetState State { get; set; }
	}
	
	public class RestartTranscoderOutputOutputStreamTargetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stream_target")]
		public RestartTranscoderOutputOutputStreamTargetReturnStream_target Stream_target { get; set; }
	}
	
	public class RestartTranscoderOutputOutputStreamTargetReturnStream_target
	{
		
		/// <summary>
		/// The state of the output stream target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public DisableTranscoderOutputOutputStreamTargetReturnStream_targetState State { get; set; }
	}
	
	public class CreateTranscoderPropertyReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="property")]
		public Transcoder_property Property { get; set; }
	}
	
	public class ShowTranscoderPropertyReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="property")]
		public Transcoder_property Property { get; set; }
	}
	
	public class ShowUptimeMetricsCurrentReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="current")]
		public Shm_metrics Current { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="limits")]
		public ShowUptimeMetricsCurrentReturnLimits Limits { get; set; }
	}
	
	public class ShowUptimeMetricsCurrentReturnLimits
	{
		
		/// <summary>
		/// A comma-separated list of fields that were returned in the request.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fields")]
		public string Fields { get; set; }
	}
	
	public class ShowUptimeMetricsHistoricReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="historic")]
		public Shm_historic_metrics[] Historic { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="limits")]
		public ShowUptimeMetricsHistoricReturnLimits Limits { get; set; }
	}
	
	public class ShowUptimeMetricsHistoricReturnLimits
	{
		
		/// <summary>
		/// A comma-separated list of fields that were returned in the request.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fields")]
		public string Fields { get; set; }
		
		/// <summary>
		/// The start of range of time when the metrics were aggregated for the query.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="from")]
		public System.DateTimeOffset From { get; set; }
		
		/// <summary>
		/// The end of the range of time when the metrics were aggregated for the query.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="to")]
		public System.DateTimeOffset To { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
