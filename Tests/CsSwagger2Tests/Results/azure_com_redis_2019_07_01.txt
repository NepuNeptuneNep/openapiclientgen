//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Parameters body to pass for resource name availability check.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class CheckNameAvailabilityParameters
	{
		
		/// <summary>
		/// Resource name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Resource type. The only legal value of this property for checking redis cache name availability is 'Microsoft.Cache/redis'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Parameters for Redis export operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ExportRDBParameters
	{
		
		/// <summary>
		/// Container name to export to.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="container")]
		public string Container { get; set; }
		
		/// <summary>
		/// File format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
		
		/// <summary>
		/// Prefix to use for exported files.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
	}
	
	/// <summary>
	/// Parameters for Redis import operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImportRDBParameters
	{
		
		/// <summary>
		/// files to import.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="files")]
		public string[] Files { get; set; }
		
		/// <summary>
		/// File format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
	}
	
	/// <summary>
	/// The response of listUpgradeNotifications.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class NotificationListResponse
	{
		
		/// <summary>
		/// Link for next set of notifications.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// List of all notifications.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public UpgradeNotification[] Value { get; set; }
	}
	
	/// <summary>
	/// Properties of upgrade notification.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class UpgradeNotification
	{
		
		/// <summary>
		/// Name of upgrade notification.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Timestamp when upgrade notification occurred.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public System.Nullable<System.DateTimeOffset> Timestamp { get; set; }
		
		/// <summary>
		/// Details about this upgrade notification
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upsellNotification")]
		public System.Collections.Generic.Dictionary<string, string> UpsellNotification { get; set; }
	}
	
	/// <summary>
	/// REST API operation
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Operation
	{
		
		/// <summary>
		/// The object that describes the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="display")]
		public object Display { get; set; }
		
		/// <summary>
		/// Operation name: {provider}/{resource}/{operation}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Result of the request to list REST API operations. It contains a list of operations and a URL nextLink to get the next set of results.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class OperationListResult
	{
		
		/// <summary>
		/// URL to get the next set of operation list results if there are any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// List of operations supported by the resource provider.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public Operation[] Value { get; set; }
	}
	
	/// <summary>
	/// The resource model definition for a ARM proxy resource. It will have everything other than required location and tags
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ProxyResource
	{
	}
	
	/// <summary>
	/// Redis cache access keys.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisAccessKeys
	{
		
		/// <summary>
		/// The current primary key that clients can use to authenticate with Redis cache.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primaryKey")]
		public string PrimaryKey { get; set; }
		
		/// <summary>
		/// The current secondary key that clients can use to authenticate with Redis cache.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondaryKey")]
		public string SecondaryKey { get; set; }
	}
	
	/// <summary>
	/// Create/Update/Get common properties of the redis cache.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisCommonProperties
	{
		
		/// <summary>
		/// Specifies whether the non-ssl Redis server port (6379) is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableNonSslPort")]
		public System.Nullable<System.Boolean> EnableNonSslPort { get; set; }
		
		/// <summary>
		/// Optional: requires clients to use a specified TLS version (or higher) to connect (e,g, '1.0', '1.1', '1.2')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumTlsVersion")]
		public System.Nullable<RedisCommonPropertiesMinimumTlsVersion> MinimumTlsVersion { get; set; }
		
		/// <summary>
		/// All Redis Settings. Few possible keys: rdb-backup-enabled,rdb-storage-connection-string,rdb-backup-frequency,maxmemory-delta,maxmemory-policy,notify-keyspace-events,maxmemory-samples,slowlog-log-slower-than,slowlog-max-len,list-max-ziplist-entries,list-max-ziplist-value,hash-max-ziplist-entries,hash-max-ziplist-value,set-max-intset-entries,zset-max-ziplist-entries,zset-max-ziplist-value etc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redisConfiguration")]
		public System.Collections.Generic.Dictionary<string, string> RedisConfiguration { get; set; }
		
		/// <summary>
		/// The number of replicas to be created per master.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replicasPerMaster")]
		public System.Nullable<System.Int32> ReplicasPerMaster { get; set; }
		
		/// <summary>
		/// The number of shards to be created on a Premium Cluster Cache.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shardCount")]
		public System.Nullable<System.Int32> ShardCount { get; set; }
		
		/// <summary>
		/// A dictionary of tenant settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tenantSettings")]
		public System.Collections.Generic.Dictionary<string, string> TenantSettings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum RedisCommonPropertiesMinimumTlsVersion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1.0")]
		_1_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1.1")]
		_1_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1.2")]
		_1_2 = 2,
	}
	
	/// <summary>
	/// Parameters supplied to the Create Redis operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisCreateParameters
	{
		
		/// <summary>
		/// The geo-location where the resource lives
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Properties supplied to Create Redis operation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public RedisCreateProperties Properties { get; set; }
		
		/// <summary>
		/// Resource tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
		
		/// <summary>
		/// A list of availability zones denoting where the resource needs to come from.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zones")]
		public string[] Zones { get; set; }
	}
	
	/// <summary>
	/// Properties supplied to Create Redis operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisCreateProperties : RedisCommonProperties
	{
		
		/// <summary>
		/// SKU parameters supplied to the create Redis operation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sku")]
		public Sku Sku { get; set; }
		
		/// <summary>
		/// Static IP address. Required when deploying a Redis cache inside an existing Azure Virtual Network.
		/// Pattern: ^\d+\.\d+\.\d+\.\d+$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticIP")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^\d+\.\d+\.\d+\.\d+$")]
		public string StaticIP { get; set; }
		
		/// <summary>
		/// The full resource ID of a subnet in a virtual network to deploy the Redis cache in. Example format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/Microsoft.{Network|ClassicNetwork}/VirtualNetworks/vnet1/subnets/subnet1
		/// Pattern: ^/subscriptions/[^/]*/resourceGroups/[^/]*/providers/Microsoft.(ClassicNetwork|Network)/virtualNetworks/[^/]*/subnets/[^/]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetId")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^/subscriptions/[^/]*/resourceGroups/[^/]*/providers/Microsoft.(ClassicNetwork|Network)/virtualNetworks/[^/]*/subnets/[^/]*$")]
		public string SubnetId { get; set; }
	}
	
	/// <summary>
	/// A firewall rule on a redis cache has a name, and describes a contiguous range of IP addresses permitted to connect
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisFirewallRule : ProxyResource
	{
		
		/// <summary>
		/// Specifies a range of IP addresses permitted to connect to the cache
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public RedisFirewallRuleProperties Properties { get; set; }
	}
	
	/// <summary>
	/// Parameters required for creating a firewall rule on redis cache.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisFirewallRuleCreateParameters
	{
		
		/// <summary>
		/// Specifies a range of IP addresses permitted to connect to the cache
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public RedisFirewallRuleProperties Properties { get; set; }
	}
	
	/// <summary>
	/// The response of list firewall rules Redis operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisFirewallRuleListResult
	{
		
		/// <summary>
		/// Link for next page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// Results of the list firewall rules operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public RedisFirewallRule[] Value { get; set; }
	}
	
	/// <summary>
	/// Specifies a range of IP addresses permitted to connect to the cache
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisFirewallRuleProperties
	{
		
		/// <summary>
		/// highest IP address included in the range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endIP")]
		public string EndIP { get; set; }
		
		/// <summary>
		/// lowest IP address included in the range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startIP")]
		public string StartIP { get; set; }
	}
	
	/// <summary>
	/// Response to force reboot for Redis cache.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisForceRebootResponse
	{
		
		/// <summary>
		/// Status message
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// Details of single instance of redis.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisInstanceDetails
	{
		
		/// <summary>
		/// If enableNonSslPort is true, provides Redis instance Non-SSL port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nonSslPort")]
		public System.Nullable<System.Int32> NonSslPort { get; set; }
		
		/// <summary>
		/// If clustering is enabled, the Shard ID of Redis Instance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shardId")]
		public System.Nullable<System.Int32> ShardId { get; set; }
		
		/// <summary>
		/// Redis instance SSL port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sslPort")]
		public System.Nullable<System.Int32> SslPort { get; set; }
		
		/// <summary>
		/// If the Cache uses availability zones, specifies availability zone where this instance is located.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	/// <summary>
	/// Linked server Id
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisLinkedServer
	{
		
		/// <summary>
		/// Linked server Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	/// <summary>
	/// Parameter required for creating a linked server to redis cache.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisLinkedServerCreateParameters
	{
		
		/// <summary>
		/// Create properties for a linked server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public RedisLinkedServerCreateProperties Properties { get; set; }
	}
	
	/// <summary>
	/// Create properties for a linked server
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisLinkedServerCreateProperties
	{
		
		/// <summary>
		/// Fully qualified resourceId of the linked redis cache.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="linkedRedisCacheId")]
		public string LinkedRedisCacheId { get; set; }
		
		/// <summary>
		/// Location of the linked redis cache.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="linkedRedisCacheLocation")]
		public string LinkedRedisCacheLocation { get; set; }
		
		/// <summary>
		/// Role of the linked server.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serverRole")]
		public RedisLinkedServerCreatePropertiesServerRole ServerRole { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum RedisLinkedServerCreatePropertiesServerRole
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Primary = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Secondary = 1,
	}
	
	/// <summary>
	/// Properties of a linked server to be returned in get/put response
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisLinkedServerProperties : RedisLinkedServerCreateProperties
	{
		
		/// <summary>
		/// Terminal state of the link between primary and secondary redis cache.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioningState")]
		public string ProvisioningState { get; set; }
	}
	
	/// <summary>
	/// Response to put/get linked server (with properties) for Redis cache.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisLinkedServerWithProperties : ProxyResource
	{
		
		/// <summary>
		/// Properties of a linked server to be returned in get/put response
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public RedisLinkedServerProperties Properties { get; set; }
	}
	
	/// <summary>
	/// List of linked servers (with properties) of a Redis cache.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisLinkedServerWithPropertiesList
	{
		
		/// <summary>
		/// Link for next set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// List of linked servers (with properties) of a Redis cache.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public RedisLinkedServerWithProperties[] Value { get; set; }
	}
	
	/// <summary>
	/// The response of list Redis operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisListResult
	{
		
		/// <summary>
		/// Link for next page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// List of Redis cache instances.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public RedisResource[] Value { get; set; }
	}
	
	/// <summary>
	/// A single Redis item in List or Get Operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisResource : TrackedResource
	{
		
		/// <summary>
		/// Properties of the redis cache.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public RedisProperties Properties { get; set; }
		
		/// <summary>
		/// A list of availability zones denoting where the resource needs to come from.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zones")]
		public string[] Zones { get; set; }
	}
	
	/// <summary>
	/// Response to put/get patch schedules for Redis cache.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisPatchSchedule : ProxyResource
	{
		
		/// <summary>
		/// List of patch schedules for a Redis cache.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public ScheduleEntries Properties { get; set; }
	}
	
	/// <summary>
	/// The response of list patch schedules Redis operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisPatchScheduleListResult
	{
		
		/// <summary>
		/// Link for next page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// Results of the list patch schedules operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public RedisPatchSchedule[] Value { get; set; }
	}
	
	/// <summary>
	/// Properties of the redis cache.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisProperties : RedisCreateProperties
	{
		
		/// <summary>
		/// Redis cache access keys.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessKeys")]
		public RedisAccessKeys AccessKeys { get; set; }
		
		/// <summary>
		/// Redis host name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostName")]
		public string HostName { get; set; }
		
		/// <summary>
		/// List of the Redis instances associated with the cache
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public RedisInstanceDetails[] Instances { get; set; }
		
		/// <summary>
		/// List of the linked servers associated with the cache
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkedServers")]
		public RedisLinkedServer[] LinkedServers { get; set; }
		
		/// <summary>
		/// Redis non-SSL port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Redis instance provisioning status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioningState")]
		public System.Nullable<RedisPropertiesProvisioningState> ProvisioningState { get; set; }
		
		/// <summary>
		/// Redis version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redisVersion")]
		public string RedisVersion { get; set; }
		
		/// <summary>
		/// Redis SSL port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sslPort")]
		public System.Nullable<System.Int32> SslPort { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum RedisPropertiesProvisioningState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Creating = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deleting = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disabled = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Failed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Linking = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Provisioning = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RecoveringScaleFailure = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Scaling = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Succeeded = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unlinking = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unprovisioning = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Updating = 11,
	}
	
	/// <summary>
	/// Specifies which Redis node(s) to reboot.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisRebootParameters
	{
		
		/// <summary>
		/// Which Redis node(s) to reboot. Depending on this value data loss is possible.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rebootType")]
		public RedisRebootParametersRebootType RebootType { get; set; }
		
		/// <summary>
		/// If clustering is enabled, the ID of the shard to be rebooted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shardId")]
		public System.Nullable<System.Int32> ShardId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum RedisRebootParametersRebootType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PrimaryNode = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SecondaryNode = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AllNodes = 2,
	}
	
	/// <summary>
	/// Specifies which Redis access keys to reset.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisRegenerateKeyParameters
	{
		
		/// <summary>
		/// The Redis access key to regenerate.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keyType")]
		public RedisLinkedServerCreatePropertiesServerRole KeyType { get; set; }
	}
	
	/// <summary>
	/// Parameters supplied to the Update Redis operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisUpdateParameters
	{
		
		/// <summary>
		/// Patchable properties of the redis cache.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public RedisUpdateProperties Properties { get; set; }
		
		/// <summary>
		/// Resource tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	/// <summary>
	/// Patchable properties of the redis cache.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RedisUpdateProperties : RedisCommonProperties
	{
		
		/// <summary>
		/// SKU parameters supplied to the create Redis operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sku")]
		public Sku Sku { get; set; }
	}
	
	/// <summary>
	/// The Resource definition.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Resource
	{
		
		/// <summary>
		/// Resource ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Resource name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// List of patch schedules for a Redis cache.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ScheduleEntries
	{
		
		/// <summary>
		/// List of patch schedules for a Redis cache.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scheduleEntries")]
		public ScheduleEntry[] ScheduleEntries1 { get; set; }
	}
	
	/// <summary>
	/// Patch schedule entry for a Premium Redis Cache.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ScheduleEntry
	{
		
		/// <summary>
		/// Day of the week when a cache can be patched.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dayOfWeek")]
		public ScheduleEntryDayOfWeek DayOfWeek { get; set; }
		
		/// <summary>
		/// ISO8601 timespan specifying how much time cache patching can take. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maintenanceWindow")]
		public string MaintenanceWindow { get; set; }
		
		/// <summary>
		/// Start hour after which cache patching can start.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startHourUtc")]
		public int StartHourUtc { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ScheduleEntryDayOfWeek
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Monday = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Tuesday = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Wednesday = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Thursday = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Friday = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Saturday = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Sunday = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Everyday = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Weekend = 8,
	}
	
	/// <summary>
	/// SKU parameters supplied to the create Redis operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Sku
	{
		
		/// <summary>
		/// The size of the Redis cache to deploy. Valid values: for C (Basic/Standard) family (0, 1, 2, 3, 4, 5, 6), for P (Premium) family (1, 2, 3, 4).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="capacity")]
		public int Capacity { get; set; }
		
		/// <summary>
		/// The SKU family to use. Valid values: (C, P). (C = Basic/Standard, P = Premium).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="family")]
		public SkuFamily Family { get; set; }
		
		/// <summary>
		/// The type of Redis cache to deploy. Valid values: (Basic, Standard, Premium)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public SkuName Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum SkuFamily
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		C = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		P = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum SkuName
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Basic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Premium = 2,
	}
	
	/// <summary>
	/// The resource model definition for a ARM tracked top level resource
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class TrackedResource : Resource
	{
		
		/// <summary>
		/// The geo-location where the resource lives
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Resource tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Lists all of the available REST API operations of the Microsoft.Cache provider.
		/// Operations_List providers/Microsoft.Cache/operations
		/// </summary>
		/// <param name="api_version">Client Api Version.</param>
		/// <returns>Success. The response describes the list of operations.</returns>
		public async Task<OperationListResult> Operations_ListAsync(string api_version)
		{
			var requestUri = "providers/Microsoft.Cache/operations?api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OperationListResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Checks that the redis cache name is valid and is not already in use.
		/// Redis_CheckNameAvailability subscriptions/{subscriptionId}/providers/Microsoft.Cache/CheckNameAvailability
		/// </summary>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the CheckNameAvailability Redis operation. The only supported resource type is 'Microsoft.Cache/redis'</param>
		/// <returns>Name is available</returns>
		public async Task Redis_CheckNameAvailabilityAsync(string api_version, string subscriptionId, CheckNameAvailabilityParameters requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Cache/CheckNameAvailability?api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all Redis caches in the specified subscription.
		/// Redis_List subscriptions/{subscriptionId}/providers/Microsoft.Cache/Redis
		/// </summary>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		public async Task<RedisListResult> Redis_ListAsync(string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Cache/Redis?api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RedisListResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all Redis caches in a resource group.
		/// Redis_ListByResourceGroup subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		public async Task<RedisListResult> Redis_ListByResourceGroupAsync(string resourceGroupName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RedisListResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all firewall rules in the specified redis cache.
		/// FirewallRules_ListByRedisResource subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{cacheName}/firewallRules
		/// </summary>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="cacheName">The name of the Redis cache.</param>
		/// <returns>Successfully got the current rules</returns>
		public async Task<RedisFirewallRuleListResult> FirewallRules_ListByRedisResourceAsync(string api_version, string subscriptionId, string resourceGroupName, string cacheName)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (cacheName==null? "" : System.Uri.EscapeDataString(cacheName))+"/firewallRules?api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RedisFirewallRuleListResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a single firewall rule in a specified redis cache.
		/// FirewallRules_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{cacheName}/firewallRules/{ruleName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="cacheName">The name of the Redis cache.</param>
		/// <param name="ruleName">The name of the firewall rule.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>Successfully found the rule</returns>
		public async Task<RedisFirewallRule> FirewallRules_GetAsync(string resourceGroupName, string cacheName, string ruleName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (cacheName==null? "" : System.Uri.EscapeDataString(cacheName))+"/firewallRules/"+ (ruleName==null? "" : System.Uri.EscapeDataString(ruleName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RedisFirewallRule>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or update a redis cache firewall rule
		/// FirewallRules_CreateOrUpdate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{cacheName}/firewallRules/{ruleName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="cacheName">The name of the Redis cache.</param>
		/// <param name="ruleName">The name of the firewall rule.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the create or update redis firewall rule operation.</param>
		/// <returns>Resource was successfully updated</returns>
		public async Task<RedisFirewallRule> FirewallRules_CreateOrUpdateAsync(string resourceGroupName, string cacheName, string ruleName, string api_version, string subscriptionId, RedisFirewallRuleCreateParameters requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (cacheName==null? "" : System.Uri.EscapeDataString(cacheName))+"/firewallRules/"+ (ruleName==null? "" : System.Uri.EscapeDataString(ruleName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RedisFirewallRule>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a single firewall rule in a specified redis cache.
		/// FirewallRules_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{cacheName}/firewallRules/{ruleName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="cacheName">The name of the Redis cache.</param>
		/// <param name="ruleName">The name of the firewall rule.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>Successfully deleted the rule</returns>
		public async Task FirewallRules_DeleteAsync(string resourceGroupName, string cacheName, string ruleName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (cacheName==null? "" : System.Uri.EscapeDataString(cacheName))+"/firewallRules/"+ (ruleName==null? "" : System.Uri.EscapeDataString(ruleName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all patch schedules in the specified redis cache (there is only one).
		/// PatchSchedules_ListByRedisResource subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{cacheName}/patchSchedules
		/// </summary>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="cacheName">The name of the Redis cache.</param>
		/// <returns>Successfully got the current patch schedules</returns>
		public async Task<RedisPatchScheduleListResult> PatchSchedules_ListByRedisResourceAsync(string api_version, string subscriptionId, string resourceGroupName, string cacheName)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (cacheName==null? "" : System.Uri.EscapeDataString(cacheName))+"/patchSchedules?api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RedisPatchScheduleListResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a Redis cache (resource description).
		/// Redis_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{name}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="name">The name of the Redis cache.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>The redis cache was successfully found.</returns>
		public async Task<RedisResource> Redis_GetAsync(string resourceGroupName, string name, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RedisResource>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or replace (overwrite/recreate, with potential downtime) an existing Redis cache.
		/// Redis_Create subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{name}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="name">The name of the Redis cache.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Create Redis operation.</param>
		/// <returns>The existing redis cache was successfully updated. Check provisioningState to see detailed status.</returns>
		public async Task<RedisResource> Redis_CreateAsync(string resourceGroupName, string name, string api_version, string subscriptionId, RedisCreateParameters requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RedisResource>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a Redis cache.
		/// Redis_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{name}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="name">The name of the Redis cache.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>The redis cache was successfully deleted.</returns>
		public async Task Redis_DeleteAsync(string resourceGroupName, string name, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an existing Redis cache.
		/// Redis_Update subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{name}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="name">The name of the Redis cache.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Update Redis operation.</param>
		/// <returns>The existing redis cache was successfully updated. Check provisioningState to see detailed status.</returns>
		public async Task<RedisResource> Redis_UpdateAsync(string resourceGroupName, string name, string api_version, string subscriptionId, RedisUpdateParameters requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RedisResource>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Export data from the redis cache to blobs in a container.
		/// Redis_ExportData subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{name}/export
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="name">The name of the Redis cache.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters for Redis export operation.</param>
		/// <returns>Export operation succeeded.</returns>
		public async Task Redis_ExportDataAsync(string resourceGroupName, string name, string api_version, string subscriptionId, ExportRDBParameters requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/export&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reboot specified Redis node(s). This operation requires write permission to the cache resource. There can be potential data loss.
		/// Redis_ForceReboot subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{name}/forceReboot
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="name">The name of the Redis cache.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Specifies which Redis node(s) to reboot.</param>
		/// <returns>Reboot operation successfully enqueued</returns>
		public async Task<RedisForceRebootResponse> Redis_ForceRebootAsync(string resourceGroupName, string name, string api_version, string subscriptionId, RedisRebootParameters requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/forceReboot&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RedisForceRebootResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Import data into Redis cache.
		/// Redis_ImportData subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{name}/import
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="name">The name of the Redis cache.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters for Redis import operation.</param>
		/// <returns>Import operation succeeded.</returns>
		public async Task Redis_ImportDataAsync(string resourceGroupName, string name, string api_version, string subscriptionId, ImportRDBParameters requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/import&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the list of linked servers associated with this redis cache (requires Premium SKU).
		/// LinkedServer_List subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{name}/linkedServers
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="name">The name of the redis cache.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>Response of get linked servers.</returns>
		public async Task<RedisLinkedServerWithPropertiesList> LinkedServer_ListAsync(string resourceGroupName, string name, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/linkedServers&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RedisLinkedServerWithPropertiesList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the detailed information about a linked server of a redis cache (requires Premium SKU).
		/// LinkedServer_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{name}/linkedServers/{linkedServerName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="name">The name of the redis cache.</param>
		/// <param name="linkedServerName">The name of the linked server.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>Response of get linked server.</returns>
		public async Task<RedisLinkedServerWithProperties> LinkedServer_GetAsync(string resourceGroupName, string name, string linkedServerName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/linkedServers/"+ (linkedServerName==null? "" : System.Uri.EscapeDataString(linkedServerName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RedisLinkedServerWithProperties>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a linked server to the Redis cache (requires Premium SKU).
		/// LinkedServer_Create subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{name}/linkedServers/{linkedServerName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="name">The name of the Redis cache.</param>
		/// <param name="linkedServerName">The name of the linked server that is being added to the Redis cache.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Create Linked server operation.</param>
		/// <returns>The linked server was successfully added.</returns>
		public async Task<RedisLinkedServerWithProperties> LinkedServer_CreateAsync(string resourceGroupName, string name, string linkedServerName, string api_version, string subscriptionId, RedisLinkedServerCreateParameters requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/linkedServers/"+ (linkedServerName==null? "" : System.Uri.EscapeDataString(linkedServerName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RedisLinkedServerWithProperties>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the linked server from a redis cache (requires Premium SKU).
		/// LinkedServer_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{name}/linkedServers/{linkedServerName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="name">The name of the redis cache.</param>
		/// <param name="linkedServerName">The name of the linked server that is being added to the Redis cache.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>Linked server was successfully deleted.</returns>
		public async Task LinkedServer_DeleteAsync(string resourceGroupName, string name, string linkedServerName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/linkedServers/"+ (linkedServerName==null? "" : System.Uri.EscapeDataString(linkedServerName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a Redis cache's access keys. This operation requires write permission to the cache resource.
		/// Redis_ListKeys subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{name}/listKeys
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="name">The name of the Redis cache.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>Lists the keys for the specified Redis cache.</returns>
		public async Task<RedisAccessKeys> Redis_ListKeysAsync(string resourceGroupName, string name, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/listKeys&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RedisAccessKeys>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets any upgrade notifications for a Redis cache.
		/// Redis_ListUpgradeNotifications subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{name}/listUpgradeNotifications
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="name">The name of the Redis cache.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="history">how many minutes in past to look for upgrade notifications</param>
		/// <returns>All upgrade notifications in given time range</returns>
		public async Task<NotificationListResponse> Redis_ListUpgradeNotificationsAsync(string resourceGroupName, string name, string api_version, string subscriptionId, double history)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/listUpgradeNotifications&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&history="+history;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<NotificationListResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the patching schedule of a redis cache (requires Premium SKU).
		/// PatchSchedules_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{name}/patchSchedules/{default}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="name">The name of the redis cache.</param>
		/// <param name="_default">Default string modeled as parameter for auto generation to work correctly.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>Response of get patch schedules.</returns>
		public async Task<RedisPatchSchedule> PatchSchedules_GetAsync(string resourceGroupName, string name, PatchSchedules_GetDefault _default, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/patchSchedules/"+_default+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RedisPatchSchedule>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or replace the patching schedule for Redis cache (requires Premium SKU).
		/// PatchSchedules_CreateOrUpdate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{name}/patchSchedules/{default}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="name">The name of the Redis cache.</param>
		/// <param name="_default">Default string modeled as parameter for auto generation to work correctly.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters to set the patching schedule for Redis cache.</param>
		/// <returns>The patch schedule was successfully updated.</returns>
		public async Task<RedisPatchSchedule> PatchSchedules_CreateOrUpdateAsync(string resourceGroupName, string name, PatchSchedules_CreateOrUpdateDefault _default, string api_version, string subscriptionId, RedisPatchSchedule requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/patchSchedules/"+_default+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RedisPatchSchedule>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the patching schedule of a redis cache (requires Premium SKU).
		/// PatchSchedules_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{name}/patchSchedules/{default}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="name">The name of the redis cache.</param>
		/// <param name="_default">Default string modeled as parameter for auto generation to work correctly.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>Success.</returns>
		public async Task PatchSchedules_DeleteAsync(string resourceGroupName, string name, PatchSchedules_DeleteDefault _default, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/patchSchedules/"+_default+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Regenerate Redis cache's access keys. This operation requires write permission to the cache resource.
		/// Redis_RegenerateKey subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/Redis/{name}/regenerateKey
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="name">The name of the Redis cache.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Gets subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Specifies which key to regenerate.</param>
		/// <returns>Lists the regenerated keys for Redis Cache</returns>
		public async Task<RedisAccessKeys> Redis_RegenerateKeyAsync(string resourceGroupName, string name, string api_version, string subscriptionId, RedisRegenerateKeyParameters requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Cache/Redis/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/regenerateKey&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RedisAccessKeys>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum PatchSchedules_GetDefault
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default")]
		_default = 0,
	}
	
	public enum PatchSchedules_CreateOrUpdateDefault
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default")]
		_default = 0,
	}
	
	public enum PatchSchedules_DeleteDefault
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default")]
		_default = 0,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
