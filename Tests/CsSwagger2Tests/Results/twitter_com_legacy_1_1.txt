//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Returns settings (including
		/// current trend, geo and sleep time information) for the authenticating user.
		/// Account_settings_get account/settings.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Account_settings_getAsync()
		{
			var requestUri = "account/settings.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the
		/// authenticating user's settings.
		/// Account_settings_post account/settings.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Account_settings_postAsync()
		{
			var requestUri = "account/settings.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets which
		/// device Twitter delivers updates to for the authenticating user. Sending none as the device parameter
		/// will disable SMS updates.
		/// Account_update_delivery_device account/update_delivery_device.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Account_update_delivery_deviceAsync()
		{
			var requestUri = "account/update_delivery_device.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets values that
		/// users are able to set under the Account tab of their settings page. Only the parameters specified
		/// will be updated.
		/// Account_update_profile account/update_profile.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Account_update_profileAsync()
		{
			var requestUri = "account/update_profile.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the authenticating user's profile background image. This method can also be used to enable
		/// or disable the profile background image. Although each parameter is marked as optional, at least one
		/// of image, tile or use must be provided when making this request.
		/// Accounts_update_profile_background_image account/update_profile_background_image.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Accounts_update_profile_background_imageAsync()
		{
			var requestUri = "account/update_profile_background_image.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets one or
		/// more hex values that control the color scheme of the authenticating user's profile page on
		/// twitter.com.
		/// Each parameter's value must be a valid hexidecimal value, and may be either three or six characters
		/// (ex: #fff or #ffffff).
		/// Accounts_update_profile_colors account/update_profile_colors.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Accounts_update_profile_colorsAsync()
		{
			var requestUri = "account/update_profile_colors.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the
		/// authenticating user's profile image. Note that this method expects raw multipart data, not a URL to
		/// an image. This method asynchronously processes the uploaded file before updating the user's profile
		/// image URL. You can either update your local cache the next time you request the user's information,
		/// or, at least 5 seconds after uploading the image, ask for the updated URL using GET
		/// users/profile_image/:screen_name
		/// (https://dev.twitter.com/docs/api/1/get/users/profile_image/:screen_name).
		/// Accounts_update_profile_image account/update_profile_image.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Accounts_update_profile_imageAsync()
		{
			var requestUri = "account/update_profile_image.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the
		/// current rate limits for
		/// methods belonging to the specified resource families.
		/// 
		/// Each 1.1 API resource belongs to a "resource family" which is indicated in its method documentation.
		/// You can typically determine a method's resource family from the first component of the path after
		/// the resource version.
		/// 
		/// This method responds with a map of methods belonging to the families specified by the resources
		/// parameter, the current remaining uses for each of those resources within the current rate limiting
		/// window, and its expiration time in epoch time. It also includes a rate_limit_context field that
		/// indicates the current access token context.
		/// 
		/// You may also issue requests to this method without any parameters to receive a map of all rate
		/// limited GET methods. If your application only uses a few of methods, please explicitly provide a
		/// resources parameter with the specified resource families you work with.
		/// Application_rate_limit_status application/rate_limit_status.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Application_rate_limit_statusAsync()
		{
			var requestUri = "application/rate_limit_status.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Blocks the specified user from
		/// following the authenticating user. In addition the blocked user will not show in the authenticating
		/// users mentions or timeline (unless retweeted by another user). If a follow or friend relationship
		/// exists it is destroyed.
		/// Blocks_create blocks/create.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Blocks_createAsync()
		{
			var requestUri = "blocks/create.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Un-blocks the user specified
		/// in the ID parameter for the authenticating user. Returns the un-blocked user in the requested format
		/// when successful. If relationships existed before the block was instated, they will not be restored.
		/// Blocks_destroy blocks/destroy.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Blocks_destroyAsync()
		{
			var requestUri = "blocks/destroy.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns an array of numeric user
		/// ids the authenticating user is blocking.
		/// Blocks_ids blocks/ids.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Blocks_idsAsync()
		{
			var requestUri = "blocks/ids.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Allows one to enable or
		/// disable retweets and device notifications from the specified user.
		/// Blocks_list blocks/list.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Blocks_listAsync()
		{
			var requestUri = "blocks/list.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the 20 most recent
		/// direct messages sent to the authenticating user. Includes detailed information about the sender and
		/// recipient user. You can request up to 200 direct messages per call, up to a maximum of 800 incoming
		/// DMs.
		/// 
		/// Important: This method requires an access token with RWD (read, write and direct message)
		/// permissions.
		/// Consult The Application Permission Model for more information.
		/// Direct_messages direct_messages.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Direct_messagesAsync()
		{
			var requestUri = "direct_messages.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Destroys the direct
		/// message specified in the required ID parameter. The authenticating user must be the recipient of the
		/// specified direct message.
		/// 
		/// Important: This method requires an access token with RWD (read, write and direct message)
		/// permissions.
		/// Consult The Application Permission Model for more information.
		/// Direct_messages_destroy direct_messages/destroy.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Direct_messages_destroyAsync()
		{
			var requestUri = "direct_messages/destroy.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sends a new direct
		/// message to the specified user from the authenticating user. Requires both the user and text
		/// parameters and must be a POST. Returns the sent message in the requested format if successful.
		/// Direct_messages_new direct_messages/new.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Direct_messages_newAsync()
		{
			var requestUri = "direct_messages/new.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the 20 most
		/// recent direct messages sent by the authenticating user. Includes detailed information about the
		/// sender and recipient user. You can request up to 200 direct messages per call, up to a maximum of
		/// 800 outgoing DMs.
		/// 
		/// Important: This method requires an access token with RWD (read, write and direct message)
		/// permissions. Consult The Application Permission Model for more information.
		/// Direct_messages_sent direct_messages/sent.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Direct_messages_sentAsync()
		{
			var requestUri = "direct_messages/sent.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a single direct
		/// message, specified by an id parameter. Like the /1.1/direct_messages.format request, this method
		/// will include the user objects of the sender and recipient.
		/// 
		/// Important: This method requires an access token with RWD (read, write and direct message)
		/// permissions.
		/// Consult The Application Permission Model for more information.
		/// Direct_messages_show direct_messages/show.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Direct_messages_showAsync()
		{
			var requestUri = "direct_messages/show.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Favorites the status
		/// specified in the ID parameter as the authenticating user. Returns the favorite status when
		/// successful.
		/// 
		/// This process invoked by this method is asynchronous. The immediately returned status may not
		/// indicate the resultant favorited status of the tweet. A 200 OK response from this method will
		/// indicate whether the intended action was successful or not.
		/// Favorites_create favorites/create.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Favorites_createAsync()
		{
			var requestUri = "favorites/create.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Un-favorites the status
		/// specified in the ID parameter as the authenticating user. Returns the un-favorited status in the
		/// requested format when successful.
		/// 
		/// This process invoked by this method is asynchronous. The immediately returned status may not
		/// indicate the resultant favorited status of the tweet. A 200 OK response from this method will
		/// indicate whether the intended action was successful or not.
		/// Favorites_destroy favorites/destroy.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Favorites_destroyAsync()
		{
			var requestUri = "favorites/destroy.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the 20 most recent
		/// Tweets favorited by the authenticating or specified user.
		/// Favorites_list favorites/list.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Favorites_listAsync()
		{
			var requestUri = "favorites/list.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a cursored collection
		/// of user IDs for every user following the specified user.
		/// 
		/// At this time, results are ordered with the most recent following first — however, this ordering is
		/// subject to unannounced change and eventual consistency issues. Results are given in groups of 5,000
		/// user IDs and multiple "pages" of results can be navigated through using the next_cursor value in
		/// subsequent requests. See Using cursors to navigate collections for more information.
		/// 
		/// This method is especially powerful when used in conjunction with GET users/lookup, a method that
		/// allows you to convert user IDs into full user objects in bulk.
		/// Followers_ids followers/ids.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Followers_idsAsync()
		{
			var requestUri = "followers/ids.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a cursored collection of
		/// user IDs for every user the specified user is following (otherwise known as their "friends").
		/// 
		/// At this time, results are ordered with the most recent following first — however, this ordering is
		/// subject to unannounced change and eventual consistency issues. Results are given in groups of 5,000
		/// user IDs and multiple "pages" of results can be navigated through using the next_cursor value in
		/// subsequent requests. See Using cursors to navigate collections for more information.
		/// 
		/// This method is especially powerful when used in conjunction with GET users/lookup, a method that
		/// allows you to convert user IDs into full user objects in bulk.
		/// Friends_ids friends/ids.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Friends_idsAsync()
		{
			var requestUri = "friends/ids.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Allows the authenticating
		/// users to follow the user specified in the ID parameter.
		/// 
		/// Returns the befriended user in the requested format when successful. Returns a string describing the
		/// failure condition when unsuccessful. If you are already friends with the user a HTTP 403 may be
		/// returned, though for performance reasons you may get a 200 OK message even if the friendship already
		/// exists.
		/// 
		/// Actions taken in this method are asynchronous and changes will be eventually consistent.
		/// Friendships_create friendships/create.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Friendships_createAsync()
		{
			var requestUri = "friendships/create.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Allows the
		/// authenticating
		/// user to unfollow the user specified in the ID parameter.
		/// 
		/// Returns the unfollowed user in the requested format when successful. Returns a string describing the
		/// failure condition when unsuccessful.
		/// 
		/// Actions taken in this method are asynchronous and changes will be eventually consistent.
		/// Friendships_destroy friendships/destroy.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Friendships_destroyAsync()
		{
			var requestUri = "friendships/destroy.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the
		/// relationships
		/// of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids
		/// provided. Values for connections can be: following, following_requested, followed_by, none.
		/// Friendships_incoming friendships/incoming.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Friendships_incomingAsync()
		{
			var requestUri = "friendships/incoming.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the relationships
		/// of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids
		/// provided. Values for connections can be: following, following_requested, followed_by, none.
		/// Friendships_lookup friendships/lookup.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Friendships_lookupAsync()
		{
			var requestUri = "friendships/lookup.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a collection of
		/// numeric IDs for every protected user for whom the authenticating user has a pending follow request.
		/// Friendships_outgoing friendships/outgoing.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Friendships_outgoingAsync()
		{
			var requestUri = "friendships/outgoing.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns detailed information
		/// about the relationship between two arbitrary users.
		/// Friendships_show friendships/show.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Friendships_showAsync()
		{
			var requestUri = "friendships/show.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Allows one to enable or
		/// disable retweets and device notifications from the specified user.
		/// Friendships_update friendships/update.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Friendships_updateAsync()
		{
			var requestUri = "friendships/update.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all the
		/// information about a known place.Example Values: df51dec6f4ee2b2c
		/// Geo_place_id geo/id/{place_id}.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Geo_place_idAsync()
		{
			var requestUri = "geo/id/{place_id}.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new place object at the
		/// given latitude and longitude.
		/// 
		/// Before creating a place you need to query GET geo/similar_places with the latitude, longitude and
		/// name of the place you wish to create. The query will return an array of places which are similar to
		/// the one you wish to create, and a token. If the place you wish to create isn't in the returned array
		/// you can use the token with this method to create a new one.
		/// Geo_places geo/places.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Geo_placesAsync()
		{
			var requestUri = "geo/places.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Given a latitude and a
		/// longitude, searches for up to 20 places that can be used as a place_id when updating a status.
		/// 
		/// This request is an informative call and will deliver generalized results about geography
		/// Geo_reverse_geocode geo/reverse_geocode.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Geo_reverse_geocodeAsync()
		{
			var requestUri = "geo/reverse_geocode.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search for places that can be
		/// attached to a statuses/update. Given a latitude and a longitude pair, an IP address, or a name, this
		/// request will return a list of all the valid places that can be used as the place_id when updating a
		/// status.
		/// 
		/// Conceptually, a query can be made from the user's location, retrieve a list of places, have the user
		/// validate the location he or she is at, and then send the ID of this location with a call to POST
		/// statuses/update.
		/// 
		/// This is the recommended method to use find places that can be attached to statuses/update. Unlike
		/// GET geo/reverse_geocode which provides raw data access, this endpoint can potentially re-order
		/// places with regards to the user who is authenticated. This approach is also preferred for
		/// interactive place matching with the user.
		/// Geo_search geo/search.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Geo_searchAsync()
		{
			var requestUri = "geo/search.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Locates places near the
		/// given coordinates which are similar in name.
		/// 
		/// Conceptually you would use this method to get a list of known places to choose from first. Then, if
		/// the desired place doesn't exist, make a request to POST geo/place to create a new one.
		/// 
		/// The token contained in the response is the token needed to be able to create a new place.
		/// Geo_similar_places geo/similar_places.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Geo_similar_placesAsync()
		{
			var requestUri = "geo/similar_places.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the current
		/// configuration used by Twitter including twitter.com slugs which are not usernames, maximum photo
		/// resolutions, and t.co URL lengths.
		/// 
		/// It is recommended applications request this endpoint when they are loaded, but no more than once a
		/// day.
		/// Help_configurations help/configuration.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Help_configurationsAsync()
		{
			var requestUri = "help/configuration.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the list of languages
		/// supported by Twitter along with their ISO 639-1 code. The ISO 639-1 code is the two letter value to
		/// use if you include lang with any of your requests.
		/// Help_languages help/languages.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Help_languagesAsync()
		{
			var requestUri = "help/languages.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns Twitter's Privacy Policy
		/// Help_privacy help/privacy.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Help_privacyAsync()
		{
			var requestUri = "help/privacy.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the Twitter Terms of Service
		/// in the requested format. These are not the same as the Developer Rules of the Road.
		/// Help_tos help/tos.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Help_tosAsync()
		{
			var requestUri = "help/tos.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new list for the
		/// authenticated user. Note that you can't create more than 20 lists per account.
		/// Lists_create lists/create.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Lists_createAsync()
		{
			var requestUri = "lists/create.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified list.
		/// The authenticated user must own the list to be able to destroy it.
		/// Lists_destroy lists/destroy.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Lists_destroyAsync()
		{
			var requestUri = "lists/destroy.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all lists the
		/// authenticating or specified user subscribes to, including their own. The user is specified using the
		/// user_id or screen_name parameters. If no user is given, the authenticating user is used.
		/// 
		/// This method used to be GET lists in version 1.0 of the API and has been renamed for consistency with
		/// other call.
		/// Lists_list lists/list.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Lists_listAsync()
		{
			var requestUri = "lists/list.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the members of the
		/// specified list. Private list members will only be shown if the authenticated user owns the specified
		/// list.
		/// Lists_members lists/members.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Lists_membersAsync()
		{
			var requestUri = "lists/members.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a member to a list.
		/// The authenticated user must own the list to be able to add members to it. Note that lists can't have
		/// more than 500 members.
		/// Lists_members_create lists/members/create.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Lists_members_createAsync()
		{
			var requestUri = "lists/members/create.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds multiple
		/// members to a list, by specifying a comma-separated list of member ids or screen names. The
		/// authenticated user must own the list to be able to add members to it. Note that lists can't have
		/// more than 500 members, and you are limited to adding up to 100 members to a list at a time with this
		/// method.
		/// 
		/// Please note that there can be issues with lists that rapidly remove and add memberships. Take care
		/// when using these methods such that you are not too rapidly switching between removals and adds on
		/// the same list.
		/// Lists_members_create_all lists/members/create_all.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Lists_members_create_allAsync()
		{
			var requestUri = "lists/members/create_all.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes the specified
		/// member from the list. The authenticated user must be the list's owner to remove members from the
		/// list.
		/// Lists_members_destroy lists/members/destroy.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Lists_members_destroyAsync()
		{
			var requestUri = "lists/members/destroy.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes multiple
		/// members from a list, by specifying a comma-separated list of member ids or screen names. The
		/// authenticated user must own the list to be able to remove members from it. Note that lists can't
		/// have more than 500 members, and you are limited to removing up to 100 members to a list at a time
		/// with this method.
		/// 
		/// Please note that there can be issues with lists that rapidly remove and add memberships. Take care
		/// when using these methods such that you are not too rapidly switching between removals and adds on
		/// the same list.
		/// Lists_members_destroy_all lists/members/destroy_all.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Lists_members_destroy_allAsync()
		{
			var requestUri = "lists/members/destroy_all.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check if the specified
		/// user is a member of the specified list.
		/// Lists_members_show lists/members/show.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Lists_members_showAsync()
		{
			var requestUri = "lists/members/show.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the lists the
		/// specified user has been added to. If user_id or screen_name are not provided the memberships for the
		/// authenticating user are returned.
		/// Lists_memberships lists/memberships.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Lists_membershipsAsync()
		{
			var requestUri = "lists/memberships.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified list.
		/// Private lists will only be shown if the authenticated user owns the specified list.
		/// Lists_show lists/show.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Lists_showAsync()
		{
			var requestUri = "lists/show.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns tweet timeline for
		/// members of the specified list. Retweets are included by default. You can use the include_rts=false
		/// parameter to omit retweet objects.
		/// Lists_statuses lists/statuses.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Lists_statusesAsync()
		{
			var requestUri = "lists/statuses.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the subscribers of
		/// the specified list. Private list subscribers will only be shown if the authenticated user owns the
		/// specified list.
		/// Lists_subscribers lists/subscribers.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Lists_subscribersAsync()
		{
			var requestUri = "lists/subscribers.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Subscribes the
		/// authenticated user to the specified list.
		/// Lists_subscribers_create lists/subscribers/create.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Lists_subscribers_createAsync()
		{
			var requestUri = "lists/subscribers/create.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Unsubscribes the
		/// authenticated user from the specified list.
		/// Lists_subscribers_destroy lists/subscribers/destroy.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Lists_subscribers_destroyAsync()
		{
			var requestUri = "lists/subscribers/destroy.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check if the specified
		/// user is a subscriber of the specified list. Returns the user if they are subscriber.
		/// Lists_subscribers_show lists/subscribers/show.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Lists_subscribers_showAsync()
		{
			var requestUri = "lists/subscribers/show.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Obtain a collection of
		/// the lists the specified user is subscribed to, 20 lists per page by default. Does not include the
		/// user's own lists.
		/// Lists_subscriptions lists/subscriptions.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Lists_subscriptionsAsync()
		{
			var requestUri = "lists/subscriptions.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the specified list. The
		/// authenticated user must own the list to be able to update it.
		/// Lists_update lists/update.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Lists_updateAsync()
		{
			var requestUri = "lists/update.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new saved
		/// search for the authenticated user. A user may only have 25 saved searches.
		/// Saved_searches_create saved_searches/create.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Saved_searches_createAsync()
		{
			var requestUri = "saved_searches/create.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Destroys a
		/// saved
		/// search for the authenticating user. The authenticating user must be the owner of saved search id
		/// being destroyed.
		/// Saved_searches_destroy saved_searches/destroy/{id}.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Saved_searches_destroyAsync()
		{
			var requestUri = "saved_searches/destroy/{id}.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the authenticated
		/// user's saved search queries.
		/// Saved_searches_list saved_searches/list.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Saved_searches_listAsync()
		{
			var requestUri = "saved_searches/list.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the
		/// authenticated user's saved search queries.
		/// Savedsearchesid saved_searches/show/{id}.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task SavedsearchesidAsync()
		{
			var requestUri = "saved_searches/show/{id}.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a collection of
		/// relevant Tweets matching a specified query.
		/// 
		/// Please note that Twitter's search service and, by extension, the Search API is not meant to be an
		/// exhaustive source of Tweets. Not all Tweets will be indexed or made available via the search
		/// interface.
		/// 
		/// In API v1.1, the response format of the Search API has been improved to return Tweet objects more
		/// similar to the objects you'll find across the REST API and platform. You may need to tolerate some
		/// inconsistencies and variance in perspectival values (fields that pertain to the perspective of the
		/// authenticating user) and embedded user objects.
		/// Search_tweets search/tweets.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Search_tweetsAsync()
		{
			var requestUri = "search/tweets.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Destroys the status
		/// specified by the required ID parameter. The authenticating user must be the author of the specified
		/// status. Returns the destroyed status if successful.
		/// Statuses_destroy statuses/destroy/{id}.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Statuses_destroyAsync()
		{
			var requestUri = "statuses/destroy/{id}.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a collection
		/// of the most recent Tweets and retweets posted by the authenticating user and the users they follow.
		/// The home timeline is central to how most users interact with the Twitter service.
		/// 
		/// Up to 800 Tweets are obtainable on the home timeline. It is more volatile for users that follow many
		/// users or follow users who tweet frequently.
		/// Statuses_home_timeline statuses/home_timeline.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Statuses_home_timelineAsync()
		{
			var requestUri = "statuses/home_timeline.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the 20
		/// most recent mentions (tweets containing a users's @screen_name) for the authenticating user.The
		/// timeline returned is the equivalent of the one seen when you view your mentions on twitter.com.This
		/// method can only return up to 800 statuses.This method will include retweets in the JSON response
		/// regardless of whether the include_rts parameter is set.
		/// Statuses_mentions_timeline statuses/mentions_timeline.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Statuses_mentions_timelineAsync()
		{
			var requestUri = "statuses/mentions_timeline.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns information allowing
		/// the creation of an embedded representation of a Tweet on third party sites. See the oEmbed
		/// specification (http://oembed.com) for information about the response format. Either the id or url
		/// parameters must be specified in a request, it is not necessary to include both. While this endpoint
		/// allows a bit of customization for the final appearance of the embedded Tweet, be aware that the
		/// appearance of the rendered Tweet may change over time to be consistent with Twitter's Display
		/// Guidelines (https://dev.twitter.com/terms/display-guidelines). Do not rely on any class or id
		/// parameters to stay constant in the returned markup.
		/// Statuses_oembed statuses/oembed.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Statuses_oembedAsync()
		{
			var requestUri = "statuses/oembed.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retweets a tweet.
		/// Returns
		/// the original tweet with retweet details embedded.
		/// Statusesretweetid statuses/retweet/{id}.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task StatusesretweetidAsync()
		{
			var requestUri = "statuses/retweet/{id}.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns up to 100 of
		/// the
		/// first retweets of a given tweet.
		/// Statuses_retweets statuses/retweets/{id}.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Statuses_retweetsAsync()
		{
			var requestUri = "statuses/retweets/{id}.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a single status,
		/// specified by the id parameter below. The status's author will be returned inline.
		/// Statuses_show statuses/show/{id}.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Statuses_showAsync(string id)
		{
			var requestUri = "statuses/show/"+ (id==null? "" : System.Uri.EscapeDataString(id))+".json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the authenticating
		/// user's status, also known as tweeting. To upload an image to accompany the tweet, use POST
		/// statuses/update_with_media (https://dev.twitter.com/docs/api/1/post/statuses/update_with_media). For
		/// each update attempt, the update text is compared with the authenticating user's recent tweets. Any
		/// attempt that would result in duplication will be blocked, resulting in a 403 error. Therefore, a
		/// user cannot submit the same status twice in a row. While not rate limited by the API a user is
		/// limited in the number of tweets they can create at a time. If the number of updates posted by the
		/// user reaches the current allowed limit this method will return an HTTP 403 error.
		/// Statuses_update statuses/update.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Statuses_updateAsync()
		{
			var requestUri = "statuses/update.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the
		/// authenticating user's status and attaches media for upload. Unlike POST statuses/update
		/// (https://dev.twitter.com/docs/api/1.1/post/statuses/update), this method expects raw multipart data.
		/// Your POST request's Content-Type should be set to multipart/form-data with the media[] parameter.
		/// The Tweet text will be rewritten to include the media URL(s), which will reduce the number of
		/// characters allowed in the Tweet text. If the URL(s) cannot be appended without text truncation, the
		/// tweet will be rejected and this method will return an HTTP 403 error. Important: Make sure that
		/// you're using upload.twitter.com as your host while posting statuses with media. It is strongly
		/// recommended to use SSL with this method.
		/// Statuses_update_with_media statuses/update_with_media.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Statuses_update_with_mediaAsync()
		{
			var requestUri = "statuses/update_with_media.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the 20 most
		/// recent statuses posted by the authenticating user. It is also possible to request another user's
		/// timeline by using the screen_name or user_id parameter. The other users timeline will only be
		/// visible if they are not protected, or if the authenticating user's follow request was accepted by
		/// the protected user. The timeline returned is the equivalent of the one seen when you view a user's
		/// profile on twitter.com. This method can only return up to 3,200 of a user's most recent statuses.
		/// Native retweets of other statuses by the user is included in this total, regardless of whether
		/// include_rts is specified when requesting this resource. This method will not include retweets in the
		/// XML and JSON responses unless the include_rts parameter is set. The RSS and Atom responses will
		/// always include retweets as statuses prefixed with RT, regardless of provided parameters. Always
		/// specify either an user_id or screen_name when requesting a user timeline.
		/// Statuses_user_timeline statuses/user_timeline.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Statuses_user_timelineAsync()
		{
			var requestUri = "statuses/user_timeline.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the locations that
		/// Twitter has trending topic information for.
		/// 
		/// The response is an array of "locations" that encode the location's WOEID and some other
		/// human-readable information such as a canonical name and country the location belongs in.
		/// 
		/// A WOEID is a Yahoo! Where On Earth ID.
		/// Trends_available trends/available.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Trends_availableAsync()
		{
			var requestUri = "trends/available.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the locations that
		/// Twitter has trending topic information for, closest to a specified location.
		/// 
		/// The response is an array of "locations" that encode the location's WOEID and some other
		/// human-readable information such as a canonical name and country the location belongs in.
		/// 
		/// A WOEID is a Yahoo! Where On Earth ID.
		/// Trends_closest trends/closest.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Trends_closestAsync()
		{
			var requestUri = "trends/closest.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the top 10 trending
		/// topics for a specific WOEID, if trending information is available for it.
		/// 
		/// The response is an array of "trend" objects that encode the name of the trending topic, the query
		/// parameter that can be used to search for the topic on Twitter Search, and the Twitter Search URL.
		/// 
		/// This information is cached for 5 minutes. Requesting more frequently than that will not return any
		/// more data, and will count against your rate limit usage.
		/// Trends_place trends/place.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Trends_placeAsync()
		{
			var requestUri = "trends/place.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a collection of
		/// users that the specified user can contribute to.
		/// Users_contributees users/contributees.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Users_contributeesAsync()
		{
			var requestUri = "users/contributees.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a collection of
		/// users who can contribute to the specified account.
		/// Users_contributors users/contributors.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Users_contributorsAsync()
		{
			var requestUri = "users/contributors.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns fully-hydrated user
		/// objects for up to 100 users per request, as specified by comma-separated values passed to the
		/// user_id and/or screen_name parameters.
		/// 
		/// This method is especially useful when used in conjunction with collections of user IDs returned from
		/// GET friends/ids and GET followers/ids.
		/// 
		/// GET users/show is used to retrieve a single user object.
		/// Users_lookup users/lookup.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Users_lookupAsync()
		{
			var requestUri = "users/lookup.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The user
		/// specified in the id is blocked by the authenticated user and reported as a spammer.
		/// Users_report_spam users/report_spam.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Users_report_spamAsync()
		{
			var requestUri = "users/report_spam.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Provides a simple,
		/// relevance-based search interface to public user accounts on Twitter. Try querying by topical
		/// interest, full name, company name, location, or other criteria. Exact match searches are not
		/// supported.
		/// 
		/// Only the first 1,000 matching results are available.
		/// Users_search users/search.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Users_searchAsync()
		{
			var requestUri = "users/search.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a variety of information
		/// about the user specified by the required user_id or screen_name parameter. The author's most recent
		/// Tweet will be returned inline when possible.
		/// 
		/// GET users/lookup is used to retrieve a bulk collection of user objects.
		/// Users_show users/show.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Users_showAsync()
		{
			var requestUri = "users/show.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Access to Twitter's
		/// suggested user list. This returns the list of suggested user categories. The category can be used in
		/// GET users/suggestions/:slug to get the users in that category.
		/// Users_suggestions users/suggestions.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Users_suggestionsAsync()
		{
			var requestUri = "users/suggestions.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Access the users in
		/// a given category of the Twitter suggested user list. It is recommended that applications cache this
		/// data for no more than one hour.
		/// Users_suggestions_slug users/suggestions/{slug}.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Users_suggestions_slugAsync()
		{
			var requestUri = "users/suggestions/{slug}.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Access the
		/// users in a given category of the Twitter suggested user list and return their most recent status if
		/// they are not a protected user.
		/// Users_suggestionsslugmembers users/suggestions/{slug}/members.json
		/// </summary>
		/// <returns>Successful Response</returns>
		public async Task Users_suggestionsslugmembersAsync()
		{
			var requestUri = "users/suggestions/{slug}/members.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
