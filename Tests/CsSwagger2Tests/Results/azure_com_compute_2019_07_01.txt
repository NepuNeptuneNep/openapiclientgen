//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Enables or disables a capability on the virtual machine or virtual machine scale set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class AdditionalCapabilities
	{
		
		/// <summary>
		/// The flag that enables or disables a capability to have one or more managed data disks with UltraSSD_LRS storage account type on the VM or VMSS. Managed disks with storage account type UltraSSD_LRS can be added to a virtual machine or virtual machine scale set only if this property is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ultraSSDEnabled")]
		public System.Nullable<System.Boolean> UltraSSDEnabled { get; set; }
	}
	
	/// <summary>
	/// Specifies additional XML formatted information that can be included in the Unattend.xml file, which is used by Windows Setup. Contents are defined by setting name, component name, and the pass in which the content is applied.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class AdditionalUnattendContent
	{
		
		/// <summary>
		/// The component name. Currently, the only allowable value is Microsoft-Windows-Shell-Setup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="componentName")]
		public System.Nullable<AdditionalUnattendContentComponentName> ComponentName { get; set; }
		
		/// <summary>
		/// Specifies the XML formatted content that is added to the unattend.xml file for the specified path and component. The XML must be less than 4KB and must include the root element for the setting or feature that is being inserted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// The pass name. Currently, the only allowable value is OobeSystem.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="passName")]
		public System.Nullable<AdditionalUnattendContentPassName> PassName { get; set; }
		
		/// <summary>
		/// Specifies the name of the setting to which the content applies. Possible values are: FirstLogonCommands and AutoLogon.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settingName")]
		public System.Nullable<AdditionalUnattendContentSettingName> SettingName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum AdditionalUnattendContentComponentName
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Microsoft-Windows-Shell-Setup")]
		MicrosoftMinusWindowsMinusShellMinusSetup = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum AdditionalUnattendContentPassName
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OobeSystem = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum AdditionalUnattendContentSettingName
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AutoLogon = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FirstLogonCommands = 1,
	}
	
	/// <summary>
	/// The API entity reference.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApiEntityReference
	{
		
		/// <summary>
		/// The ARM resource id in the form of /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/...
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	/// <summary>
	/// Api error.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApiError
	{
		
		/// <summary>
		/// The error code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// The Api error details
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public ApiErrorBase[] Details { get; set; }
		
		/// <summary>
		/// Inner error details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="innererror")]
		public InnerError Innererror { get; set; }
		
		/// <summary>
		/// The error message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// The target of the particular error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
	}
	
	/// <summary>
	/// Api error base.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApiErrorBase
	{
		
		/// <summary>
		/// The error code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// The error message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// The target of the particular error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
	}
	
	/// <summary>
	/// The configuration parameters used for performing automatic OS upgrade.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class AutomaticOSUpgradePolicy
	{
		
		/// <summary>
		/// Whether OS image rollback feature should be disabled. Default value is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disableAutomaticRollback")]
		public System.Nullable<System.Boolean> DisableAutomaticRollback { get; set; }
		
		/// <summary>
		/// Indicates whether OS upgrades should automatically be applied to scale set instances in a rolling fashion when a newer version of the OS image becomes available. Default value is false. <br><br> If this is set to true for Windows based scale sets, [enableAutomaticUpdates](https://docs.microsoft.com/dotnet/api/microsoft.azure.management.compute.models.windowsconfiguration.enableautomaticupdates?view=azure-dotnet) is automatically set to false and cannot be set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableAutomaticOSUpgrade")]
		public System.Nullable<System.Boolean> EnableAutomaticOSUpgrade { get; set; }
	}
	
	/// <summary>
	/// Describes automatic OS upgrade properties on the image.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class AutomaticOSUpgradeProperties
	{
		
		/// <summary>
		/// Specifies whether automatic OS upgrade is supported on the image.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="automaticOSUpgradeSupported")]
		public bool AutomaticOSUpgradeSupported { get; set; }
	}
	
	/// <summary>
	/// Specifies the configuration parameters for automatic repairs on the virtual machine scale set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class AutomaticRepairsPolicy
	{
		
		/// <summary>
		/// Specifies whether automatic repairs should be enabled on the virtual machine scale set. The default value is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The amount of time for which automatic repairs are suspended due to a state change on VM. The grace time starts after the state change has completed. This helps avoid premature or accidental repairs. The time duration should be specified in ISO 8601 format. The minimum allowed grace period is 30 minutes (PT30M), which is also the default value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gracePeriod")]
		public string GracePeriod { get; set; }
	}
	
	/// <summary>
	/// Specifies information about the availability set that the virtual machine should be assigned to. Virtual machines specified in the same availability set are allocated to different nodes to maximize availability. For more information about availability sets, see [Manage the availability of virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-manage-availability?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json). <br><br> For more information on Azure planned maintenance, see [Planned maintenance for virtual machines in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-planned-maintenance?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> Currently, a VM can only be added to availability set at creation time. An existing VM cannot be added to an availability set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class AvailabilitySet : Resource
	{
		
		/// <summary>
		/// The instance view of a resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public AvailabilitySetProperties Properties { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set sku.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sku")]
		public Sku Sku { get; set; }
	}
	
	/// <summary>
	/// The List Availability Set operation response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class AvailabilitySetListResult
	{
		
		/// <summary>
		/// The URI to fetch the next page of AvailabilitySets. Call ListNext() with this URI to fetch the next page of AvailabilitySets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// The list of availability sets
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public AvailabilitySet[] Value { get; set; }
	}
	
	/// <summary>
	/// The instance view of a resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class AvailabilitySetProperties
	{
		
		/// <summary>
		/// Fault Domain count.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platformFaultDomainCount")]
		public System.Nullable<System.Int32> PlatformFaultDomainCount { get; set; }
		
		/// <summary>
		/// Update Domain count.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platformUpdateDomainCount")]
		public System.Nullable<System.Int32> PlatformUpdateDomainCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="proximityPlacementGroup")]
		public SubResource ProximityPlacementGroup { get; set; }
		
		/// <summary>
		/// The resource status information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statuses")]
		public InstanceViewStatus[] Statuses { get; set; }
		
		/// <summary>
		/// A list of references to all virtual machines in the availability set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualMachines")]
		public SubResource[] VirtualMachines { get; set; }
	}
	
	/// <summary>
	/// Instance view status.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class InstanceViewStatus
	{
		
		/// <summary>
		/// The status code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// The short localizable label for the status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayStatus")]
		public string DisplayStatus { get; set; }
		
		/// <summary>
		/// The level code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="level")]
		public System.Nullable<InstanceViewStatusLevel> Level { get; set; }
		
		/// <summary>
		/// The detailed status message, including for alerts and error messages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// The time of the status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum InstanceViewStatusLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Info = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Warning = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Error = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class SubResource
	{
		
		/// <summary>
		/// Resource Id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	/// <summary>
	/// Specifies the sku of an Availability Set. Use 'Aligned' for virtual machines with managed disks and 'Classic' for virtual machines with unmanaged disks. Default value is 'Classic'.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum AvailabilitySetSkuType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Classic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Aligned = 1,
	}
	
	/// <summary>
	/// Specifies information about the availability set that the virtual machine should be assigned to. Only tags may be updated.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class AvailabilitySetUpdate : UpdateResource
	{
		
		/// <summary>
		/// The instance view of a resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public AvailabilitySetProperties Properties { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set sku.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sku")]
		public Sku Sku { get; set; }
	}
	
	/// <summary>
	/// Specifies the billing related details of a Azure Spot VM or VMSS. <br><br>Minimum api-version: 2019-03-01.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class BillingProfile
	{
		
		/// <summary>
		/// Specifies the maximum price you are willing to pay for a Azure Spot VM/VMSS. This price is in US Dollars. <br><br> This price will be compared with the current Azure Spot price for the VM size. Also, the prices are compared at the time of create/update of Azure Spot VM/VMSS and the operation will only succeed if  the maxPrice is greater than the current Azure Spot price. <br><br> The maxPrice will also be used for evicting a Azure Spot VM/VMSS if the current Azure Spot price goes beyond the maxPrice after creation of VM/VMSS. <br><br> Possible values are: <br><br> - Any decimal value greater than zero. Example: 0.01538 <br><br> -1 – indicates default price to be up-to on-demand. <br><br> You can set the maxPrice to -1 to indicate that the Azure Spot VM/VMSS should not be evicted for price reasons. Also, the default max price is -1 if it is not provided by you. <br><br>Minimum api-version: 2019-03-01.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPrice")]
		public System.Nullable<System.Double> MaxPrice { get; set; }
	}
	
	/// <summary>
	/// Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to diagnose VM status. <br><br> You can easily view the output of your console log. <br><br> Azure also enables you to see a screenshot of the VM from the hypervisor.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class BootDiagnostics
	{
		
		/// <summary>
		/// Whether boot diagnostics should be enabled on the Virtual Machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Uri of the storage account to use for placing the console output and screenshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageUri")]
		public string StorageUri { get; set; }
	}
	
	/// <summary>
	/// The instance view of a virtual machine boot diagnostics.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class BootDiagnosticsInstanceView
	{
		
		/// <summary>
		/// The console screenshot blob URI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="consoleScreenshotBlobUri")]
		public string ConsoleScreenshotBlobUri { get; set; }
		
		/// <summary>
		/// The Linux serial console log blob Uri.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serialConsoleLogBlobUri")]
		public string SerialConsoleLogBlobUri { get; set; }
		
		/// <summary>
		/// Instance view status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public InstanceViewStatus Status { get; set; }
	}
	
	/// <summary>
	/// Specifies the caching requirements. <br><br> Possible values are: <br><br> **None** <br><br> **ReadOnly** <br><br> **ReadWrite** <br><br> Default: **None for Standard storage. ReadOnly for Premium storage**
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Caching
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		None = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ReadOnly = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ReadWrite = 2,
	}
	
	/// <summary>
	/// An error response from the Compute service.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class CloudError
	{
		
		/// <summary>
		/// Api error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public ApiError Error { get; set; }
	}
	
	/// <summary>
	/// The List Compute Operation operation response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ComputeOperationListResult
	{
		
		/// <summary>
		/// The list of compute operations
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public ComputeOperationValue[] Value { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of a Compute Operation value.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ComputeOperationValue
	{
		
		/// <summary>
		/// Describes the properties of a Compute Operation Value Display.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="display")]
		public ComputeOperationValueDisplay Display { get; set; }
		
		/// <summary>
		/// The name of the compute operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The origin of the compute operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public string Origin { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of a Compute Operation Value Display.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ComputeOperationValueDisplay
	{
		
		/// <summary>
		/// The description of the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The display name of the compute operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operation")]
		public string Operation { get; set; }
		
		/// <summary>
		/// The resource provider for the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provider")]
		public string Provider { get; set; }
		
		/// <summary>
		/// The display name of the resource the operation applies to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
	}
	
	/// <summary>
	/// Specifies how the virtual machine should be created.<br><br> Possible values are:<br><br> **Attach** \u2013 This value is used when you are using a specialized disk to create the virtual machine.<br><br> **FromImage** \u2013 This value is used when you are using an image to create the virtual machine. If you are using a platform image, you also use the imageReference element described above. If you are using a marketplace image, you  also use the plan element previously described.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum CreateOption
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FromImage = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Empty = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Attach = 2,
	}
	
	/// <summary>
	/// Describes a data disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DataDisk
	{
		
		/// <summary>
		/// Specifies the caching requirements. <br><br> Possible values are: <br><br> **None** <br><br> **ReadOnly** <br><br> **ReadWrite** <br><br> Default: **None for Standard storage. ReadOnly for Premium storage**
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caching")]
		public Caching Caching { get; set; }
		
		/// <summary>
		/// Specifies how the virtual machine should be created.<br><br> Possible values are:<br><br> **Attach** \u2013 This value is used when you are using a specialized disk to create the virtual machine.<br><br> **FromImage** \u2013 This value is used when you are using an image to create the virtual machine. If you are using a platform image, you also use the imageReference element described above. If you are using a marketplace image, you  also use the plan element previously described.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createOption")]
		public CreateOption CreateOption { get; set; }
		
		/// <summary>
		/// Specifies the Read-Write IOPS for the managed disk when StorageAccountType is UltraSSD_LRS. Returned only for VirtualMachine ScaleSet VM disks. Can be updated only via updates to the VirtualMachine Scale Set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskIOPSReadWrite")]
		public System.Nullable<System.Int64> DiskIOPSReadWrite { get; set; }
		
		/// <summary>
		/// Specifies the bandwidth in MB per second for the managed disk when StorageAccountType is UltraSSD_LRS. Returned only for VirtualMachine ScaleSet VM disks. Can be updated only via updates to the VirtualMachine Scale Set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskMBpsReadWrite")]
		public System.Nullable<System.Int64> DiskMBpsReadWrite { get; set; }
		
		/// <summary>
		/// Specifies the size of an empty data disk in gigabytes. This element can be used to overwrite the size of the disk in a virtual machine image. <br><br> This value cannot be larger than 1023 GB
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskSizeGB")]
		public System.Nullable<System.Int32> DiskSizeGB { get; set; }
		
		/// <summary>
		/// Describes the uri of a disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public VirtualHardDisk Image { get; set; }
		
		/// <summary>
		/// Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lun")]
		public int Lun { get; set; }
		
		/// <summary>
		/// The parameters of a managed disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managedDisk")]
		public ManagedDiskParameters ManagedDisk { get; set; }
		
		/// <summary>
		/// The disk name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Specifies whether the data disk is in process of detachment from the VirtualMachine/VirtualMachineScaleset
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toBeDetached")]
		public System.Nullable<System.Boolean> ToBeDetached { get; set; }
		
		/// <summary>
		/// Describes the uri of a disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vhd")]
		public VirtualHardDisk Vhd { get; set; }
		
		/// <summary>
		/// Specifies whether writeAccelerator should be enabled or disabled on the disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="writeAcceleratorEnabled")]
		public System.Nullable<System.Boolean> WriteAcceleratorEnabled { get; set; }
	}
	
	/// <summary>
	/// Contains the data disk images information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DataDiskImage
	{
		
		/// <summary>
		/// Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lun")]
		public System.Nullable<System.Int32> Lun { get; set; }
	}
	
	/// <summary>
	/// Specifies information about the Dedicated host.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DedicatedHost : Resource
	{
		
		/// <summary>
		/// Properties of the dedicated host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public DedicatedHostProperties Properties { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set sku.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sku")]
		public Sku Sku { get; set; }
	}
	
	/// <summary>
	/// Represents the dedicated host unutilized capacity in terms of a specific VM size.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DedicatedHostAllocatableVM
	{
		
		/// <summary>
		/// Maximum number of VMs of size vmSize that can fit in the dedicated host's remaining capacity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public System.Nullable<System.Double> Count { get; set; }
		
		/// <summary>
		/// VM size in terms of which the unutilized capacity is represented.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmSize")]
		public string VmSize { get; set; }
	}
	
	/// <summary>
	/// Dedicated host unutilized capacity.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DedicatedHostAvailableCapacity
	{
		
		/// <summary>
		/// The unutilized capacity of the dedicated host represented in terms of each VM size that is allowed to be deployed to the dedicated host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allocatableVMs")]
		public DedicatedHostAllocatableVM[] AllocatableVMs { get; set; }
	}
	
	/// <summary>
	/// Specifies information about the dedicated host group that the dedicated hosts should be assigned to. <br><br> Currently, a dedicated host can only be added to a dedicated host group at creation time. An existing dedicated host cannot be added to another dedicated host group.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DedicatedHostGroup : Resource
	{
		
		/// <summary>
		/// Dedicated Host Group Properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public DedicatedHostGroupProperties Properties { get; set; }
		
		/// <summary>
		/// Availability Zone to use for this host group. Only single zone is supported. The zone can be assigned only during creation. If not provided, the group supports all zones in the region. If provided, enforces each host in the group to be in the same zone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zones")]
		public string[] Zones { get; set; }
	}
	
	/// <summary>
	/// The List Dedicated Host Group with resource group response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DedicatedHostGroupListResult
	{
		
		/// <summary>
		/// The URI to fetch the next page of Dedicated Host Groups. Call ListNext() with this URI to fetch the next page of Dedicated Host Groups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// The list of dedicated host groups
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public DedicatedHostGroup[] Value { get; set; }
	}
	
	/// <summary>
	/// Dedicated Host Group Properties.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DedicatedHostGroupProperties
	{
		
		/// <summary>
		/// A list of references to all dedicated hosts in the dedicated host group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosts")]
		public SubResourceReadOnly[] Hosts { get; set; }
		
		/// <summary>
		/// Number of fault domains that the host group can span.
		/// Required
		/// Minimum: 1
		/// Maximum: 3
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="platformFaultDomainCount")]
		[System.ComponentModel.DataAnnotations.Range(1, 3)]
		public int PlatformFaultDomainCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class SubResourceReadOnly
	{
		
		/// <summary>
		/// Resource Id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	/// <summary>
	/// Specifies information about the dedicated host group that the dedicated host should be assigned to. Only tags may be updated.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DedicatedHostGroupUpdate : UpdateResource
	{
		
		/// <summary>
		/// Dedicated Host Group Properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public DedicatedHostGroupProperties Properties { get; set; }
		
		/// <summary>
		/// Availability Zone to use for this host group. Only single zone is supported. The zone can be assigned only during creation. If not provided, the group supports all zones in the region. If provided, enforces each host in the group to be in the same zone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zones")]
		public string[] Zones { get; set; }
	}
	
	/// <summary>
	/// The instance view of a dedicated host.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DedicatedHostInstanceView
	{
		
		/// <summary>
		/// Specifies the unique id of the dedicated physical machine on which the dedicated host resides.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetId")]
		public string AssetId { get; set; }
		
		/// <summary>
		/// Dedicated host unutilized capacity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableCapacity")]
		public DedicatedHostAvailableCapacity AvailableCapacity { get; set; }
		
		/// <summary>
		/// The resource status information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statuses")]
		public InstanceViewStatus[] Statuses { get; set; }
	}
	
	/// <summary>
	/// Specifies the software license type that will be applied to the VMs deployed on the dedicated host. <br><br> Possible values are: <br><br> **None** <br><br> **Windows_Server_Hybrid** <br><br> **Windows_Server_Perpetual** <br><br> Default: **None**
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum DedicatedHostLicenseType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		None = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Windows_Server_Hybrid = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Windows_Server_Perpetual = 2,
	}
	
	/// <summary>
	/// The list dedicated host operation response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DedicatedHostListResult
	{
		
		/// <summary>
		/// The URI to fetch the next page of dedicated hosts. Call ListNext() with this URI to fetch the next page of dedicated hosts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// The list of dedicated hosts
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public DedicatedHost[] Value { get; set; }
	}
	
	/// <summary>
	/// Properties of the dedicated host.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DedicatedHostProperties
	{
		
		/// <summary>
		/// Specifies whether the dedicated host should be replaced automatically in case of a failure. The value is defaulted to 'true' when not provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoReplaceOnFailure")]
		public System.Nullable<System.Boolean> AutoReplaceOnFailure { get; set; }
		
		/// <summary>
		/// A unique id generated and assigned to the dedicated host by the platform. <br><br> Does not change throughout the lifetime of the host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostId")]
		public string HostId { get; set; }
		
		/// <summary>
		/// The instance view of a dedicated host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceView")]
		public DedicatedHostInstanceView InstanceView { get; set; }
		
		/// <summary>
		/// Specifies the software license type that will be applied to the VMs deployed on the dedicated host. <br><br> Possible values are: <br><br> **None** <br><br> **Windows_Server_Hybrid** <br><br> **Windows_Server_Perpetual** <br><br> Default: **None**
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseType")]
		public DedicatedHostLicenseType LicenseType { get; set; }
		
		/// <summary>
		/// Fault domain of the dedicated host within a dedicated host group.
		/// Minimum: 0
		/// Maximum: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platformFaultDomain")]
		[System.ComponentModel.DataAnnotations.Range(0, 2)]
		public System.Nullable<System.Int32> PlatformFaultDomain { get; set; }
		
		/// <summary>
		/// The provisioning state, which only appears in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioningState")]
		public string ProvisioningState { get; set; }
		
		/// <summary>
		/// The date when the host was first provisioned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioningTime")]
		public System.Nullable<System.DateTimeOffset> ProvisioningTime { get; set; }
		
		/// <summary>
		/// A list of references to all virtual machines in the Dedicated Host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualMachines")]
		public SubResourceReadOnly[] VirtualMachines { get; set; }
	}
	
	/// <summary>
	/// Specifies information about the dedicated host. Only tags, autoReplaceOnFailure and licenseType may be updated.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DedicatedHostUpdate : UpdateResource
	{
		
		/// <summary>
		/// Properties of the dedicated host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public DedicatedHostProperties Properties { get; set; }
	}
	
	/// <summary>
	/// Specifies the boot diagnostic settings state. <br><br>Minimum api-version: 2015-06-15.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DiagnosticsProfile
	{
		
		/// <summary>
		/// Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to diagnose VM status. <br><br> You can easily view the output of your console log. <br><br> Azure also enables you to see a screenshot of the VM from the hypervisor.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bootDiagnostics")]
		public BootDiagnostics BootDiagnostics { get; set; }
	}
	
	/// <summary>
	/// Specifies the ephemeral disk option for operating system disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum DiffDiskOption
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Local = 0,
	}
	
	/// <summary>
	/// Describes the parameters of ephemeral disk settings that can be specified for operating system disk. <br><br> NOTE: The ephemeral disk settings can only be specified for managed disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DiffDiskSettings
	{
		
		/// <summary>
		/// Specifies the ephemeral disk option for operating system disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="option")]
		public DiffDiskOption Option { get; set; }
	}
	
	/// <summary>
	/// Describes the parameter of customer managed disk encryption set resource id that can be specified for disk. <br><br> NOTE: The disk encryption set resource id can only be specified for managed disk. Please refer https://aka.ms/mdssewithcmkoverview for more details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DiskEncryptionSetParameters
	{
	}
	
	/// <summary>
	/// Describes a Encryption Settings for a Disk
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DiskEncryptionSettings
	{
		
		/// <summary>
		/// Describes a reference to Key Vault Secret
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskEncryptionKey")]
		public KeyVaultSecretReference DiskEncryptionKey { get; set; }
		
		/// <summary>
		/// Specifies whether disk encryption should be enabled on the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Describes a reference to Key Vault Key
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="keyEncryptionKey")]
		public KeyVaultKeyReference KeyEncryptionKey { get; set; }
	}
	
	/// <summary>
	/// The instance view of the disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DiskInstanceView
	{
		
		/// <summary>
		/// Specifies the encryption settings for the OS Disk. <br><br> Minimum api-version: 2015-06-15
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptionSettings")]
		public DiskEncryptionSettings[] EncryptionSettings { get; set; }
		
		/// <summary>
		/// The disk name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The resource status information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statuses")]
		public InstanceViewStatus[] Statuses { get; set; }
	}
	
	/// <summary>
	/// Specifies the hardware settings for the virtual machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class HardwareProfile
	{
		
		/// <summary>
		/// Specifies the size of the virtual machine. For more information about virtual machine sizes, see [Sizes for virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-sizes?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json). <br><br> The available VM sizes depend on region and availability set. For a list of available sizes use these APIs:  <br><br> [List all available virtual machine sizes in an availability set](https://docs.microsoft.com/rest/api/compute/availabilitysets/listavailablesizes) <br><br> [List all available virtual machine sizes in a region](https://docs.microsoft.com/rest/api/compute/virtualmachinesizes/list) <br><br> [List all available virtual machine sizes for resizing](https://docs.microsoft.com/rest/api/compute/virtualmachines/listavailablesizes)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmSize")]
		public System.Nullable<HardwareProfileVmSize> VmSize { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum HardwareProfileVmSize
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Basic_A0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Basic_A1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Basic_A2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Basic_A3 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Basic_A4 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_A0 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_A1 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_A2 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_A3 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_A4 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_A5 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_A6 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_A7 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_A8 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_A9 = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_A10 = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_A11 = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_A1_v2 = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_A2_v2 = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_A4_v2 = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_A8_v2 = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_A2m_v2 = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_A4m_v2 = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_A8m_v2 = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_B1s = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_B1ms = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_B2s = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_B2ms = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_B4ms = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_B8ms = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D1 = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D2 = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D3 = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D4 = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D11 = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D12 = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D13 = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D14 = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D1_v2 = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D2_v2 = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D3_v2 = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D4_v2 = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D5_v2 = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D2_v3 = 43,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D4_v3 = 44,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D8_v3 = 45,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D16_v3 = 46,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D32_v3 = 47,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D64_v3 = 48,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D2s_v3 = 49,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D4s_v3 = 50,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D8s_v3 = 51,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D16s_v3 = 52,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D32s_v3 = 53,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D64s_v3 = 54,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D11_v2 = 55,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D12_v2 = 56,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D13_v2 = 57,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D14_v2 = 58,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_D15_v2 = 59,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_DS1 = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_DS2 = 61,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_DS3 = 62,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_DS4 = 63,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_DS11 = 64,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_DS12 = 65,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_DS13 = 66,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_DS14 = 67,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_DS1_v2 = 68,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_DS2_v2 = 69,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_DS3_v2 = 70,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_DS4_v2 = 71,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_DS5_v2 = 72,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_DS11_v2 = 73,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_DS12_v2 = 74,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_DS13_v2 = 75,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_DS14_v2 = 76,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_DS15_v2 = 77,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Standard_DS13-4_v2")]
		Standard_DS13Minus4_v2 = 78,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Standard_DS13-2_v2")]
		Standard_DS13Minus2_v2 = 79,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Standard_DS14-8_v2")]
		Standard_DS14Minus8_v2 = 80,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Standard_DS14-4_v2")]
		Standard_DS14Minus4_v2 = 81,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_E2_v3 = 82,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_E4_v3 = 83,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_E8_v3 = 84,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_E16_v3 = 85,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_E32_v3 = 86,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_E64_v3 = 87,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_E2s_v3 = 88,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_E4s_v3 = 89,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_E8s_v3 = 90,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_E16s_v3 = 91,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_E32s_v3 = 92,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_E64s_v3 = 93,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Standard_E32-16_v3")]
		Standard_E32Minus16_v3 = 94,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Standard_E32-8s_v3")]
		Standard_E32Minus8s_v3 = 95,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Standard_E64-32s_v3")]
		Standard_E64Minus32s_v3 = 96,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Standard_E64-16s_v3")]
		Standard_E64Minus16s_v3 = 97,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_F1 = 98,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_F2 = 99,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_F4 = 100,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_F8 = 101,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_F16 = 102,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_F1s = 103,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_F2s = 104,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_F4s = 105,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_F8s = 106,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_F16s = 107,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_F2s_v2 = 108,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_F4s_v2 = 109,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_F8s_v2 = 110,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_F16s_v2 = 111,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_F32s_v2 = 112,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_F64s_v2 = 113,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_F72s_v2 = 114,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_G1 = 115,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_G2 = 116,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_G3 = 117,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_G4 = 118,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_G5 = 119,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_GS1 = 120,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_GS2 = 121,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_GS3 = 122,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_GS4 = 123,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_GS5 = 124,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Standard_GS4-8")]
		Standard_GS4Minus8 = 125,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Standard_GS4-4")]
		Standard_GS4Minus4 = 126,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Standard_GS5-16")]
		Standard_GS5Minus16 = 127,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Standard_GS5-8")]
		Standard_GS5Minus8 = 128,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_H8 = 129,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_H16 = 130,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_H8m = 131,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_H16m = 132,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_H16r = 133,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_H16mr = 134,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_L4s = 135,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_L8s = 136,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_L16s = 137,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_L32s = 138,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_M64s = 139,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_M64ms = 140,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_M128s = 141,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_M128ms = 142,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Standard_M64-32ms")]
		Standard_M64Minus32ms = 143,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Standard_M64-16ms")]
		Standard_M64Minus16ms = 144,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Standard_M128-64ms")]
		Standard_M128Minus64ms = 145,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Standard_M128-32ms")]
		Standard_M128Minus32ms = 146,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_NC6 = 147,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_NC12 = 148,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_NC24 = 149,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_NC24r = 150,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_NC6s_v2 = 151,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_NC12s_v2 = 152,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_NC24s_v2 = 153,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_NC24rs_v2 = 154,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_NC6s_v3 = 155,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_NC12s_v3 = 156,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_NC24s_v3 = 157,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_NC24rs_v3 = 158,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_ND6s = 159,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_ND12s = 160,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_ND24s = 161,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_ND24rs = 162,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_NV6 = 163,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_NV12 = 164,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_NV24 = 165,
	}
	
	/// <summary>
	/// Specifies the HyperVGeneration Type
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum HyperVGenerationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		V1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		V2 = 1,
	}
	
	/// <summary>
	/// The source user image virtual hard disk. The virtual hard disk will be copied before being attached to the virtual machine. If SourceImage is provided, the destination virtual hard drive must not exist.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Image : Resource
	{
		
		/// <summary>
		/// Describes the properties of an Image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public ImageProperties Properties { get; set; }
	}
	
	/// <summary>
	/// Describes a data disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageDataDisk : ImageDisk
	{
		
		/// <summary>
		/// Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lun")]
		public int Lun { get; set; }
	}
	
	/// <summary>
	/// Describes a image disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageDisk
	{
		
		/// <summary>
		/// The Virtual Hard Disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blobUri")]
		public string BlobUri { get; set; }
		
		/// <summary>
		/// Specifies the caching requirements. <br><br> Possible values are: <br><br> **None** <br><br> **ReadOnly** <br><br> **ReadWrite** <br><br> Default: **None for Standard storage. ReadOnly for Premium storage**
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caching")]
		public Caching Caching { get; set; }
		
		/// <summary>
		/// Describes the parameter of customer managed disk encryption set resource id that can be specified for disk. <br><br> NOTE: The disk encryption set resource id can only be specified for managed disk. Please refer https://aka.ms/mdssewithcmkoverview for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskEncryptionSet")]
		public DiskEncryptionSetParameters DiskEncryptionSet { get; set; }
		
		/// <summary>
		/// Specifies the size of empty data disks in gigabytes. This element can be used to overwrite the name of the disk in a virtual machine image. <br><br> This value cannot be larger than 1023 GB
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskSizeGB")]
		public System.Nullable<System.Int32> DiskSizeGB { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="managedDisk")]
		public SubResource ManagedDisk { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="snapshot")]
		public SubResource Snapshot { get; set; }
		
		/// <summary>
		/// Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with data disks. It cannot be used with OS Disk. Standard_LRS uses Standard HDD. StandardSSD_LRS uses Standard SSD. Premium_LRS uses Premium SSD. UltraSSD_LRS uses Ultra disk. For more information regarding disks supported for Windows Virtual Machines, refer to https://docs.microsoft.com/en-us/azure/virtual-machines/windows/disks-types and, for Linux Virtual Machines, refer to https://docs.microsoft.com/en-us/azure/virtual-machines/linux/disks-types
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageAccountType")]
		public System.Nullable<ImageDiskStorageAccountType> StorageAccountType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ImageDiskStorageAccountType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_LRS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Premium_LRS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StandardSSD_LRS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UltraSSD_LRS = 3,
	}
	
	/// <summary>
	/// The List Image operation response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageListResult
	{
		
		/// <summary>
		/// The uri to fetch the next page of Images. Call ListNext() with this to fetch the next page of Images.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// The list of Images.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public Image[] Value { get; set; }
	}
	
	/// <summary>
	/// Describes an Operating System disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageOSDisk : ImageDisk
	{
		
		/// <summary>
		/// The OS State.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="osState")]
		public ImageOSDiskOsState OsState { get; set; }
		
		/// <summary>
		/// This property allows you to specify the type of the OS that is included in the disk if creating a VM from a custom image. <br><br> Possible values are: <br><br> **Windows** <br><br> **Linux**
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="osType")]
		public ImageOSDiskOsType OsType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ImageOSDiskOsState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Generalized = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Specialized = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ImageOSDiskOsType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Windows = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Linux = 1,
	}
	
	/// <summary>
	/// Describes the properties of an Image.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageProperties
	{
		
		/// <summary>
		/// Specifies the HyperVGeneration Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hyperVGeneration")]
		public HyperVGenerationType HyperVGeneration { get; set; }
		
		/// <summary>
		/// The provisioning state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioningState")]
		public string ProvisioningState { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceVirtualMachine")]
		public SubResource SourceVirtualMachine { get; set; }
		
		/// <summary>
		/// Describes a storage profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageProfile")]
		public ImageStorageProfile StorageProfile { get; set; }
	}
	
	/// <summary>
	/// Specifies information about the image to use. You can specify information about platform images, marketplace images, or virtual machine images. This element is required when you want to use a platform image, marketplace image, or virtual machine image, but is not used in other creation operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageReference : SubResource
	{
		
		/// <summary>
		/// Specifies in decimal numbers, the version of platform image or marketplace image used to create the virtual machine. This readonly field differs from 'version', only if the value specified in 'version' field is 'latest'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exactVersion")]
		public string ExactVersion { get; set; }
		
		/// <summary>
		/// Specifies the offer of the platform image or marketplace image used to create the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="offer")]
		public string Offer { get; set; }
		
		/// <summary>
		/// The image publisher.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publisher")]
		public string Publisher { get; set; }
		
		/// <summary>
		/// The image SKU.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sku")]
		public string Sku { get; set; }
		
		/// <summary>
		/// Specifies the version of the platform image or marketplace image used to create the virtual machine. The allowed formats are Major.Minor.Build or 'latest'. Major, Minor, and Build are decimal numbers. Specify 'latest' to use the latest version of an image available at deploy time. Even if you use 'latest', the VM image will not automatically update after deploy time even if a new version becomes available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Describes a storage profile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageStorageProfile
	{
		
		/// <summary>
		/// Specifies the parameters that are used to add a data disk to a virtual machine. <br><br> For more information about disks, see [About disks and VHDs for Azure virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataDisks")]
		public ImageDataDisk[] DataDisks { get; set; }
		
		/// <summary>
		/// Describes an Operating System disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osDisk")]
		public ImageOSDisk OsDisk { get; set; }
		
		/// <summary>
		/// Specifies whether an image is zone resilient or not. Default is false. Zone resilient images can be created only in regions that provide Zone Redundant Storage (ZRS).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zoneResilient")]
		public System.Nullable<System.Boolean> ZoneResilient { get; set; }
	}
	
	/// <summary>
	/// The source user image virtual hard disk. Only tags may be updated.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageUpdate : UpdateResource
	{
		
		/// <summary>
		/// Describes the properties of an Image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public ImageProperties Properties { get; set; }
	}
	
	/// <summary>
	/// Inner error details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class InnerError
	{
		
		/// <summary>
		/// The internal error message or exception dump.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errordetail")]
		public string Errordetail { get; set; }
		
		/// <summary>
		/// The exception type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exceptiontype")]
		public string Exceptiontype { get; set; }
	}
	
	/// <summary>
	/// Describes a reference to Key Vault Key
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class KeyVaultKeyReference
	{
		
		/// <summary>
		/// The URL referencing a key encryption key in Key Vault.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keyUrl")]
		public string KeyUrl { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceVault")]
		public SubResource SourceVault { get; set; }
	}
	
	/// <summary>
	/// Describes a reference to Key Vault Secret
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class KeyVaultSecretReference
	{
		
		/// <summary>
		/// The URL referencing a secret in a Key Vault.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secretUrl")]
		public string SecretUrl { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceVault")]
		public SubResource SourceVault { get; set; }
	}
	
	/// <summary>
	/// Specifies the Linux operating system settings on the virtual machine. <br><br>For a list of supported Linux distributions, see [Linux on Azure-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-endorsed-distros?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json) <br><br> For running non-endorsed distributions, see [Information for Non-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-create-upload-generic?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class LinuxConfiguration
	{
		
		/// <summary>
		/// Specifies whether password authentication should be disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disablePasswordAuthentication")]
		public System.Nullable<System.Boolean> DisablePasswordAuthentication { get; set; }
		
		/// <summary>
		/// Indicates whether virtual machine agent should be provisioned on the virtual machine. <br><br> When this property is not specified in the request body, default behavior is to set it to true.  This will ensure that VM Agent is installed on the VM so that extensions can be added to the VM later.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisionVMAgent")]
		public System.Nullable<System.Boolean> ProvisionVMAgent { get; set; }
		
		/// <summary>
		/// SSH configuration for Linux based VMs running on Azure
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssh")]
		public SshConfiguration Ssh { get; set; }
	}
	
	/// <summary>
	/// The List Usages operation response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ListUsagesResult
	{
		
		/// <summary>
		/// The URI to fetch the next page of compute resource usage information. Call ListNext() with this to fetch the next page of compute resource usage information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// The list of compute resource usages.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public Usage[] Value { get; set; }
	}
	
	/// <summary>
	/// Describes Compute Resource Usage.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Usage
	{
		
		/// <summary>
		/// The current usage of the resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="currentValue")]
		public int CurrentValue { get; set; }
		
		/// <summary>
		/// The maximum permitted usage of the resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="limit")]
		public long Limit { get; set; }
		
		/// <summary>
		/// The Usage Names.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public UsageName Name { get; set; }
		
		/// <summary>
		/// An enum describing the unit of usage measurement.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="unit")]
		public UsageUnit Unit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum UsageUnit
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Count = 0,
	}
	
	/// <summary>
	/// Api input base class for LogAnalytics Api.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class LogAnalyticsInputBase
	{
		
		/// <summary>
		/// SAS Uri of the logging blob container to which LogAnalytics Api writes output logs to.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blobContainerSasUri")]
		public string BlobContainerSasUri { get; set; }
		
		/// <summary>
		/// From time of the query
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fromTime")]
		public System.DateTimeOffset FromTime { get; set; }
		
		/// <summary>
		/// Group query result by Operation Name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupByOperationName")]
		public System.Nullable<System.Boolean> GroupByOperationName { get; set; }
		
		/// <summary>
		/// Group query result by Resource Name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupByResourceName")]
		public System.Nullable<System.Boolean> GroupByResourceName { get; set; }
		
		/// <summary>
		/// Group query result by Throttle Policy applied.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupByThrottlePolicy")]
		public System.Nullable<System.Boolean> GroupByThrottlePolicy { get; set; }
		
		/// <summary>
		/// To time of the query
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="toTime")]
		public System.DateTimeOffset ToTime { get; set; }
	}
	
	/// <summary>
	/// LogAnalytics operation status response
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class LogAnalyticsOperationResult
	{
		
		/// <summary>
		/// LogAnalytics output properties
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public LogAnalyticsOutput Properties { get; set; }
	}
	
	/// <summary>
	/// LogAnalytics output properties
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class LogAnalyticsOutput
	{
		
		/// <summary>
		/// Output file Uri path to blob container.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="output")]
		public string Output { get; set; }
	}
	
	/// <summary>
	/// Maintenance Operation Status.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class MaintenanceRedeployStatus
	{
		
		/// <summary>
		/// True, if customer is allowed to perform Maintenance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isCustomerInitiatedMaintenanceAllowed")]
		public System.Nullable<System.Boolean> IsCustomerInitiatedMaintenanceAllowed { get; set; }
		
		/// <summary>
		/// Message returned for the last Maintenance Operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastOperationMessage")]
		public string LastOperationMessage { get; set; }
		
		/// <summary>
		/// The Last Maintenance Operation Result Code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastOperationResultCode")]
		public System.Nullable<MaintenanceRedeployStatusLastOperationResultCode> LastOperationResultCode { get; set; }
		
		/// <summary>
		/// End Time for the Maintenance Window.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maintenanceWindowEndTime")]
		public System.Nullable<System.DateTimeOffset> MaintenanceWindowEndTime { get; set; }
		
		/// <summary>
		/// Start Time for the Maintenance Window.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maintenanceWindowStartTime")]
		public System.Nullable<System.DateTimeOffset> MaintenanceWindowStartTime { get; set; }
		
		/// <summary>
		/// End Time for the Pre Maintenance Window.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preMaintenanceWindowEndTime")]
		public System.Nullable<System.DateTimeOffset> PreMaintenanceWindowEndTime { get; set; }
		
		/// <summary>
		/// Start Time for the Pre Maintenance Window.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preMaintenanceWindowStartTime")]
		public System.Nullable<System.DateTimeOffset> PreMaintenanceWindowStartTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum MaintenanceRedeployStatusLastOperationResultCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		None = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RetryLater = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MaintenanceAborted = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MaintenanceCompleted = 3,
	}
	
	/// <summary>
	/// The parameters of a managed disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ManagedDiskParameters : SubResource
	{
		
		/// <summary>
		/// Describes the parameter of customer managed disk encryption set resource id that can be specified for disk. <br><br> NOTE: The disk encryption set resource id can only be specified for managed disk. Please refer https://aka.ms/mdssewithcmkoverview for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskEncryptionSet")]
		public DiskEncryptionSetParameters DiskEncryptionSet { get; set; }
		
		/// <summary>
		/// Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with data disks. It cannot be used with OS Disk. Standard_LRS uses Standard HDD. StandardSSD_LRS uses Standard SSD. Premium_LRS uses Premium SSD. UltraSSD_LRS uses Ultra disk. For more information regarding disks supported for Windows Virtual Machines, refer to https://docs.microsoft.com/en-us/azure/virtual-machines/windows/disks-types and, for Linux Virtual Machines, refer to https://docs.microsoft.com/en-us/azure/virtual-machines/linux/disks-types
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageAccountType")]
		public ImageDiskStorageAccountType StorageAccountType { get; set; }
	}
	
	/// <summary>
	/// Describes a network interface reference.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class NetworkInterfaceReference : SubResource
	{
		
		/// <summary>
		/// Describes a network interface reference properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public NetworkInterfaceReferenceProperties Properties { get; set; }
	}
	
	/// <summary>
	/// Describes a network interface reference properties.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class NetworkInterfaceReferenceProperties
	{
		
		/// <summary>
		/// Specifies the primary network interface in case the virtual machine has more than 1 network interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary")]
		public System.Nullable<System.Boolean> Primary { get; set; }
	}
	
	/// <summary>
	/// Specifies the network interfaces of the virtual machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class NetworkProfile
	{
		
		/// <summary>
		/// Specifies the list of resource Ids for the network interfaces associated with the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkInterfaces")]
		public NetworkInterfaceReference[] NetworkInterfaces { get; set; }
	}
	
	/// <summary>
	/// Specifies information about the operating system disk used by the virtual machine. <br><br> For more information about disks, see [About disks and VHDs for Azure virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class OSDisk
	{
		
		/// <summary>
		/// Specifies the caching requirements. <br><br> Possible values are: <br><br> **None** <br><br> **ReadOnly** <br><br> **ReadWrite** <br><br> Default: **None for Standard storage. ReadOnly for Premium storage**
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caching")]
		public Caching Caching { get; set; }
		
		/// <summary>
		/// Specifies how the virtual machine should be created.<br><br> Possible values are:<br><br> **Attach** \u2013 This value is used when you are using a specialized disk to create the virtual machine.<br><br> **FromImage** \u2013 This value is used when you are using an image to create the virtual machine. If you are using a platform image, you also use the imageReference element described above. If you are using a marketplace image, you  also use the plan element previously described.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createOption")]
		public CreateOption CreateOption { get; set; }
		
		/// <summary>
		/// Describes the parameters of ephemeral disk settings that can be specified for operating system disk. <br><br> NOTE: The ephemeral disk settings can only be specified for managed disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diffDiskSettings")]
		public DiffDiskSettings DiffDiskSettings { get; set; }
		
		/// <summary>
		/// Specifies the size of an empty data disk in gigabytes. This element can be used to overwrite the size of the disk in a virtual machine image. <br><br> This value cannot be larger than 1023 GB
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskSizeGB")]
		public System.Nullable<System.Int32> DiskSizeGB { get; set; }
		
		/// <summary>
		/// Describes a Encryption Settings for a Disk
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptionSettings")]
		public DiskEncryptionSettings EncryptionSettings { get; set; }
		
		/// <summary>
		/// Describes the uri of a disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public VirtualHardDisk Image { get; set; }
		
		/// <summary>
		/// The parameters of a managed disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managedDisk")]
		public ManagedDiskParameters ManagedDisk { get; set; }
		
		/// <summary>
		/// The disk name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// This property allows you to specify the type of the OS that is included in the disk if creating a VM from user-image or a specialized VHD. <br><br> Possible values are: <br><br> **Windows** <br><br> **Linux**
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osType")]
		public ImageOSDiskOsType OsType { get; set; }
		
		/// <summary>
		/// Describes the uri of a disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vhd")]
		public VirtualHardDisk Vhd { get; set; }
		
		/// <summary>
		/// Specifies whether writeAccelerator should be enabled or disabled on the disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="writeAcceleratorEnabled")]
		public System.Nullable<System.Boolean> WriteAcceleratorEnabled { get; set; }
	}
	
	/// <summary>
	/// Contains the os disk image information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class OSDiskImage
	{
		
		/// <summary>
		/// The operating system of the osDiskImage.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operatingSystem")]
		public ImageOSDiskOsType OperatingSystem { get; set; }
	}
	
	/// <summary>
	/// Specifies the operating system settings for the virtual machine. Some of the settings cannot be changed once VM is provisioned.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class OSProfile
	{
		
		/// <summary>
		/// Specifies the password of the administrator account. <br><br> **Minimum-length (Windows):** 8 characters <br><br> **Minimum-length (Linux):** 6 characters <br><br> **Max-length (Windows):** 123 characters <br><br> **Max-length (Linux):** 72 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:** "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1", "Password22", "iloveyou!" <br><br> For resetting the password, see [How to reset the Remote Desktop service or its login password in a Windows VM](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-reset-rdp?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> For resetting root password, see [Manage users, SSH, and check or repair disks on Azure Linux VMs using the VMAccess Extension](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-vmaccess-extension?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json#reset-root-password)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adminPassword")]
		public string AdminPassword { get; set; }
		
		/// <summary>
		/// Specifies the name of the administrator account. <br><br> This property cannot be updated after the VM is created. <br><br> **Windows-only restriction:** Cannot end in "." <br><br> **Disallowed values:** "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server", "sql", "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5". <br><br> **Minimum-length (Linux):** 1  character <br><br> **Max-length (Linux):** 64 characters <br><br> **Max-length (Windows):** 20 characters  <br><br><li> For root access to the Linux VM, see [Using root privileges on Linux virtual machines in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-use-root-privileges?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)<br><li> For a list of built-in system users on Linux that should not be used in this field, see [Selecting User Names for Linux on Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-usernames?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adminUsername")]
		public string AdminUsername { get; set; }
		
		/// <summary>
		/// Specifies whether extension operations should be allowed on the virtual machine. <br><br>This may only be set to False when no extensions are present on the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowExtensionOperations")]
		public System.Nullable<System.Boolean> AllowExtensionOperations { get; set; }
		
		/// <summary>
		/// Specifies the host OS name of the virtual machine. <br><br> This name cannot be updated after the VM is created. <br><br> **Max-length (Windows):** 15 characters <br><br> **Max-length (Linux):** 64 characters. <br><br> For naming conventions and restrictions see [Azure infrastructure services implementation guidelines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-infrastructure-subscription-accounts-guidelines?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json#1-naming-conventions).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computerName")]
		public string ComputerName { get; set; }
		
		/// <summary>
		/// Specifies a base-64 encoded string of custom data. The base-64 encoded string is decoded to a binary array that is saved as a file on the Virtual Machine. The maximum length of the binary array is 65535 bytes. <br><br> **Note: Do not pass any secrets or passwords in customData property** <br><br> This property cannot be updated after the VM is created. <br><br> customData is passed to the VM to be saved as a file, for more information see [Custom Data on Azure VMs](https://azure.microsoft.com/en-us/blog/custom-data-and-cloud-init-on-windows-azure/) <br><br> For using cloud-init for your Linux VM, see [Using cloud-init to customize a Linux VM during creation](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-cloud-init?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customData")]
		public string CustomData { get; set; }
		
		/// <summary>
		/// Specifies the Linux operating system settings on the virtual machine. <br><br>For a list of supported Linux distributions, see [Linux on Azure-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-endorsed-distros?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json) <br><br> For running non-endorsed distributions, see [Information for Non-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-create-upload-generic?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linuxConfiguration")]
		public LinuxConfiguration LinuxConfiguration { get; set; }
		
		/// <summary>
		/// Specifies whether the guest provision signal is required to infer provision success of the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requireGuestProvisionSignal")]
		public System.Nullable<System.Boolean> RequireGuestProvisionSignal { get; set; }
		
		/// <summary>
		/// Specifies set of certificates that should be installed onto the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secrets")]
		public VaultSecretGroup[] Secrets { get; set; }
		
		/// <summary>
		/// Specifies Windows operating system settings on the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="windowsConfiguration")]
		public WindowsConfiguration WindowsConfiguration { get; set; }
	}
	
	/// <summary>
	/// Describes a set of certificates which are all in the same Key Vault.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VaultSecretGroup
	{
		
		[System.Runtime.Serialization.DataMember(Name="sourceVault")]
		public SubResource SourceVault { get; set; }
		
		/// <summary>
		/// The list of key vault references in SourceVault which contain certificates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vaultCertificates")]
		public VaultCertificate[] VaultCertificates { get; set; }
	}
	
	/// <summary>
	/// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VaultCertificate
	{
		
		/// <summary>
		/// For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name &lt;UppercaseThumbprint&gt;.crt for the X509 certificate file and &lt;UppercaseThumbprint&gt;.prv for private key. Both of these files are .pem formatted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateStore")]
		public string CertificateStore { get; set; }
		
		/// <summary>
		/// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateUrl")]
		public string CertificateUrl { get; set; }
	}
	
	/// <summary>
	/// Specifies information about the marketplace image used to create the virtual machine. This element is only used for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic use.  In the Azure portal, find the marketplace image that you want to use and then click **Want to deploy programmatically, Get Started ->**. Enter any required information and then click **Save**.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Plan
	{
		
		/// <summary>
		/// The plan ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="product")]
		public string Product { get; set; }
		
		/// <summary>
		/// The promotion code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="promotionCode")]
		public string PromotionCode { get; set; }
		
		/// <summary>
		/// The publisher ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publisher")]
		public string Publisher { get; set; }
	}
	
	/// <summary>
	/// Specifies information about the proximity placement group.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ProximityPlacementGroup : Resource
	{
		
		/// <summary>
		/// Describes the properties of a Proximity Placement Group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public ProximityPlacementGroupProperties Properties { get; set; }
	}
	
	/// <summary>
	/// The List Proximity Placement Group operation response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ProximityPlacementGroupListResult
	{
		
		/// <summary>
		/// The URI to fetch the next page of proximity placement groups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// The list of proximity placement groups
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public ProximityPlacementGroup[] Value { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of a Proximity Placement Group.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ProximityPlacementGroupProperties
	{
		
		/// <summary>
		/// A list of references to all availability sets in the proximity placement group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availabilitySets")]
		public SubResourceWithColocationStatus[] AvailabilitySets { get; set; }
		
		/// <summary>
		/// Instance view status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="colocationStatus")]
		public InstanceViewStatus ColocationStatus { get; set; }
		
		/// <summary>
		/// Specifies the type of the proximity placement group. <br><br> Possible values are: <br><br> **Standard** : Co-locate resources within an Azure region or Availability Zone. <br><br> **Ultra** : For future use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="proximityPlacementGroupType")]
		public System.Nullable<ProximityPlacementGroupPropertiesProximityPlacementGroupType> ProximityPlacementGroupType { get; set; }
		
		/// <summary>
		/// A list of references to all virtual machine scale sets in the proximity placement group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualMachineScaleSets")]
		public SubResourceWithColocationStatus[] VirtualMachineScaleSets { get; set; }
		
		/// <summary>
		/// A list of references to all virtual machines in the proximity placement group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualMachines")]
		public SubResourceWithColocationStatus[] VirtualMachines { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class SubResourceWithColocationStatus : SubResource
	{
		
		/// <summary>
		/// Instance view status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="colocationStatus")]
		public InstanceViewStatus ColocationStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ProximityPlacementGroupPropertiesProximityPlacementGroupType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Ultra = 1,
	}
	
	/// <summary>
	/// Specifies information about the proximity placement group.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ProximityPlacementGroupUpdate
	{
	}
	
	/// <summary>
	/// Used for establishing the purchase context of any 3rd Party artifact through MarketPlace.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class PurchasePlan
	{
		
		/// <summary>
		/// The plan ID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="product")]
		public string Product { get; set; }
		
		/// <summary>
		/// The publisher ID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="publisher")]
		public string Publisher { get; set; }
	}
	
	/// <summary>
	/// Response after calling a manual recovery walk
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RecoveryWalkResponse
	{
		
		/// <summary>
		/// The next update domain that needs to be walked. Null means walk spanning all update domains has been completed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPlatformUpdateDomain")]
		public System.Nullable<System.Int32> NextPlatformUpdateDomain { get; set; }
		
		/// <summary>
		/// Whether the recovery walk was performed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="walkPerformed")]
		public System.Nullable<System.Boolean> WalkPerformed { get; set; }
	}
	
	/// <summary>
	/// Api request input for LogAnalytics getRequestRateByInterval Api.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RequestRateByIntervalInput : LogAnalyticsInputBase
	{
		
		/// <summary>
		/// Interval value in minutes used to create LogAnalytics call rate logs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="intervalLength")]
		public RequestRateByIntervalInputIntervalLength IntervalLength { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum RequestRateByIntervalInputIntervalLength
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ThreeMins = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FiveMins = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ThirtyMins = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SixtyMins = 3,
	}
	
	/// <summary>
	/// The Resource model definition.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Resource
	{
		
		/// <summary>
		/// Resource Id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Resource location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Resource name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Resource tags
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
		
		/// <summary>
		/// Resource type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Information about rollback on failed VM instances after a OS Upgrade operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RollbackStatusInfo
	{
		
		/// <summary>
		/// The number of instances which failed to rollback.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failedRolledbackInstanceCount")]
		public System.Nullable<System.Int32> FailedRolledbackInstanceCount { get; set; }
		
		/// <summary>
		/// Api error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rollbackError")]
		public ApiError RollbackError { get; set; }
		
		/// <summary>
		/// The number of instances which have been successfully rolled back.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="successfullyRolledbackInstanceCount")]
		public System.Nullable<System.Int32> SuccessfullyRolledbackInstanceCount { get; set; }
	}
	
	/// <summary>
	/// The configuration parameters used while performing a rolling upgrade.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RollingUpgradePolicy
	{
		
		/// <summary>
		/// The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability. The default value for this parameter is 20%.
		/// Minimum: 5
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxBatchInstancePercent")]
		[System.ComponentModel.DataAnnotations.Range(5, 100)]
		public System.Nullable<System.Int32> MaxBatchInstancePercent { get; set; }
		
		/// <summary>
		/// The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch. The default value for this parameter is 20%.
		/// Minimum: 5
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxUnhealthyInstancePercent")]
		[System.ComponentModel.DataAnnotations.Range(5, 100)]
		public System.Nullable<System.Int32> MaxUnhealthyInstancePercent { get; set; }
		
		/// <summary>
		/// The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts. The default value for this parameter is 20%.
		/// Minimum: 0
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxUnhealthyUpgradedInstancePercent")]
		[System.ComponentModel.DataAnnotations.Range(0, 100)]
		public System.Nullable<System.Int32> MaxUnhealthyUpgradedInstancePercent { get; set; }
		
		/// <summary>
		/// The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format. The default value is 0 seconds (PT0S).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pauseTimeBetweenBatches")]
		public string PauseTimeBetweenBatches { get; set; }
	}
	
	/// <summary>
	/// Information about the number of virtual machine instances in each upgrade state.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RollingUpgradeProgressInfo
	{
		
		/// <summary>
		/// The number of instances that have failed to be upgraded successfully.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failedInstanceCount")]
		public System.Nullable<System.Int32> FailedInstanceCount { get; set; }
		
		/// <summary>
		/// The number of instances that are currently being upgraded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inProgressInstanceCount")]
		public System.Nullable<System.Int32> InProgressInstanceCount { get; set; }
		
		/// <summary>
		/// The number of instances that have not yet begun to be upgraded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pendingInstanceCount")]
		public System.Nullable<System.Int32> PendingInstanceCount { get; set; }
		
		/// <summary>
		/// The number of instances that have been successfully upgraded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="successfulInstanceCount")]
		public System.Nullable<System.Int32> SuccessfulInstanceCount { get; set; }
	}
	
	/// <summary>
	/// Information about the current running state of the overall upgrade.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RollingUpgradeRunningStatus
	{
		
		/// <summary>
		/// Code indicating the current status of the upgrade.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<RollingUpgradeRunningStatusCode> Code { get; set; }
		
		/// <summary>
		/// The last action performed on the rolling upgrade.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastAction")]
		public System.Nullable<RollingUpgradeRunningStatusLastAction> LastAction { get; set; }
		
		/// <summary>
		/// Last action time of the upgrade.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastActionTime")]
		public System.Nullable<System.DateTimeOffset> LastActionTime { get; set; }
		
		/// <summary>
		/// Start time of the upgrade.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.Nullable<System.DateTimeOffset> StartTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum RollingUpgradeRunningStatusCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RollingForward = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cancelled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Completed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Faulted = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum RollingUpgradeRunningStatusLastAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Start = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cancel = 1,
	}
	
	/// <summary>
	/// The status of the latest virtual machine scale set rolling upgrade.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RollingUpgradeStatusInfo : Resource
	{
		
		/// <summary>
		/// The status of the latest virtual machine scale set rolling upgrade.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public RollingUpgradeStatusInfoProperties Properties { get; set; }
	}
	
	/// <summary>
	/// The status of the latest virtual machine scale set rolling upgrade.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RollingUpgradeStatusInfoProperties
	{
		
		/// <summary>
		/// Api error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public ApiError Error { get; set; }
		
		/// <summary>
		/// The configuration parameters used while performing a rolling upgrade.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public RollingUpgradePolicy Policy { get; set; }
		
		/// <summary>
		/// Information about the number of virtual machine instances in each upgrade state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public RollingUpgradeProgressInfo Progress { get; set; }
		
		/// <summary>
		/// Information about the current running state of the overall upgrade.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runningStatus")]
		public RollingUpgradeRunningStatus RunningStatus { get; set; }
	}
	
	/// <summary>
	/// Describes a scale-in policy for a virtual machine scale set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ScaleInPolicy
	{
		
		/// <summary>
		/// The rules to be followed when scaling-in a virtual machine scale set. <br><br> Possible values are: <br><br> **Default** When a virtual machine scale set is scaled in, the scale set will first be balanced across zones if it is a zonal scale set. Then, it will be balanced across Fault Domains as far as possible. Within each Fault Domain, the virtual machines chosen for removal will be the newest ones that are not protected from scale-in. <br><br> **OldestVM** When a virtual machine scale set is being scaled-in, the oldest virtual machines that are not protected from scale-in will be chosen for removal. For zonal virtual machine scale sets, the scale set will first be balanced across zones. Within each zone, the oldest virtual machines that are not protected will be chosen for removal. <br><br> **NewestVM** When a virtual machine scale set is being scaled-in, the newest virtual machines that are not protected from scale-in will be chosen for removal. For zonal virtual machine scale sets, the scale set will first be balanced across zones. Within each zone, the newest virtual machines that are not protected will be chosen for removal. <br><br>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public string[] Rules { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ScheduledEventsProfile
	{
		
		[System.Runtime.Serialization.DataMember(Name="terminateNotificationProfile")]
		public TerminateNotificationProfile TerminateNotificationProfile { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class TerminateNotificationProfile
	{
		
		/// <summary>
		/// Specifies whether the Terminate Scheduled event is enabled or disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enable")]
		public System.Nullable<System.Boolean> Enable { get; set; }
		
		/// <summary>
		/// Configurable length of time a Virtual Machine being deleted will have to potentially approve the Terminate Scheduled Event before the event is auto approved (timed out). The configuration must be specified in ISO 8601 format, the default value is 5 minutes (PT5M)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notBeforeTimeout")]
		public string NotBeforeTimeout { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set sku.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Sku
	{
		
		/// <summary>
		/// Specifies the number of virtual machines in the scale set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="capacity")]
		public System.Nullable<System.Int64> Capacity { get; set; }
		
		/// <summary>
		/// The sku name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Specifies the tier of virtual machines in a scale set.<br /><br /> Possible Values:<br /><br /> **Standard**<br /><br /> **Basic**
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tier")]
		public string Tier { get; set; }
	}
	
	/// <summary>
	/// SSH configuration for Linux based VMs running on Azure
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class SshConfiguration
	{
		
		/// <summary>
		/// The list of SSH public keys used to authenticate with linux based VMs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicKeys")]
		public SshPublicKey[] PublicKeys { get; set; }
	}
	
	/// <summary>
	/// Contains information about SSH certificate public key and the path on the Linux VM where the public key is placed.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class SshPublicKey
	{
		
		/// <summary>
		/// SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Linux VMs in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="keyData")]
		public string KeyData { get; set; }
		
		/// <summary>
		/// Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with data disks. It cannot be used with OS Disk. Standard_LRS uses Standard HDD. StandardSSD_LRS uses Standard SSD. Premium_LRS uses Premium SSD. UltraSSD_LRS uses Ultra disk. For more information regarding disks supported for Windows Virtual Machines, refer to https://docs.microsoft.com/en-us/azure/virtual-machines/windows/disks-types and, for Linux Virtual Machines, refer to https://docs.microsoft.com/en-us/azure/virtual-machines/linux/disks-types
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum StorageAccountType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard_LRS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Premium_LRS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		StandardSSD_LRS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UltraSSD_LRS = 3,
	}
	
	/// <summary>
	/// Specifies the storage settings for the virtual machine disks.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class StorageProfile
	{
		
		/// <summary>
		/// Specifies the parameters that are used to add a data disk to a virtual machine. <br><br> For more information about disks, see [About disks and VHDs for Azure virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataDisks")]
		public DataDisk[] DataDisks { get; set; }
		
		/// <summary>
		/// Specifies information about the image to use. You can specify information about platform images, marketplace images, or virtual machine images. This element is required when you want to use a platform image, marketplace image, or virtual machine image, but is not used in other creation operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageReference")]
		public ImageReference ImageReference { get; set; }
		
		/// <summary>
		/// Specifies information about the operating system disk used by the virtual machine. <br><br> For more information about disks, see [About disks and VHDs for Azure virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osDisk")]
		public OSDisk OsDisk { get; set; }
	}
	
	/// <summary>
	/// Api request input for LogAnalytics getThrottledRequests Api.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ThrottledRequestsInput
	{
	}
	
	/// <summary>
	/// The Update Resource model definition.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class UpdateResource
	{
		
		/// <summary>
		/// Resource tags
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	/// <summary>
	/// Virtual Machine Scale Set OS Upgrade History operation response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class UpgradeOperationHistoricalStatusInfo
	{
		
		/// <summary>
		/// Resource location
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Describes each OS upgrade on the Virtual Machine Scale Set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public UpgradeOperationHistoricalStatusInfoProperties Properties { get; set; }
		
		/// <summary>
		/// Resource type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Describes each OS upgrade on the Virtual Machine Scale Set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class UpgradeOperationHistoricalStatusInfoProperties
	{
		
		/// <summary>
		/// Api error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public ApiError Error { get; set; }
		
		/// <summary>
		/// Information about the number of virtual machine instances in each upgrade state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public RollingUpgradeProgressInfo Progress { get; set; }
		
		/// <summary>
		/// Information about rollback on failed VM instances after a OS Upgrade operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rollbackInfo")]
		public RollbackStatusInfo RollbackInfo { get; set; }
		
		/// <summary>
		/// Information about the current running state of the overall upgrade.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runningStatus")]
		public UpgradeOperationHistoryStatus RunningStatus { get; set; }
		
		/// <summary>
		/// Invoker of the Upgrade Operation
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startedBy")]
		public System.Nullable<UpgradeOperationHistoricalStatusInfoPropertiesStartedBy> StartedBy { get; set; }
		
		/// <summary>
		/// Specifies information about the image to use. You can specify information about platform images, marketplace images, or virtual machine images. This element is required when you want to use a platform image, marketplace image, or virtual machine image, but is not used in other creation operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetImageReference")]
		public ImageReference TargetImageReference { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum UpgradeOperationHistoricalStatusInfoPropertiesStartedBy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		User = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Platform = 2,
	}
	
	/// <summary>
	/// Information about the current running state of the overall upgrade.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class UpgradeOperationHistoryStatus
	{
		
		/// <summary>
		/// Code indicating the current status of the upgrade.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public RollingUpgradeRunningStatusCode Code { get; set; }
		
		/// <summary>
		/// End time of the upgrade.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.Nullable<System.DateTimeOffset> EndTime { get; set; }
		
		/// <summary>
		/// Start time of the upgrade.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.Nullable<System.DateTimeOffset> StartTime { get; set; }
	}
	
	/// <summary>
	/// Describes an upgrade policy - automatic, manual, or rolling.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class UpgradePolicy
	{
		
		/// <summary>
		/// The configuration parameters used for performing automatic OS upgrade.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="automaticOSUpgradePolicy")]
		public AutomaticOSUpgradePolicy AutomaticOSUpgradePolicy { get; set; }
		
		/// <summary>
		/// Specifies the mode of an upgrade to virtual machines in the scale set.<br /><br /> Possible values are:<br /><br /> **Manual** - You  control the application of updates to virtual machines in the scale set. You do this by using the manualUpgrade action.<br /><br /> **Automatic** - All virtual machines in the scale set are  automatically updated at the same time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public System.Nullable<UpgradePolicyMode> Mode { get; set; }
		
		/// <summary>
		/// The configuration parameters used while performing a rolling upgrade.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rollingUpgradePolicy")]
		public RollingUpgradePolicy RollingUpgradePolicy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum UpgradePolicyMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Automatic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Manual = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Rolling = 2,
	}
	
	/// <summary>
	/// The Usage Names.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class UsageName
	{
		
		/// <summary>
		/// The localized name of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localizedValue")]
		public string LocalizedValue { get; set; }
		
		/// <summary>
		/// The name of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VMScaleSetConvertToSinglePlacementGroupInput
	{
		
		/// <summary>
		/// Id of the placement group in which you want future virtual machine instances to be placed. To query placement group Id, please use Virtual Machine Scale Set VMs - Get API. If not provided, the platform will choose one with maximum number of virtual machine instances.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="activePlacementGroupId")]
		public string ActivePlacementGroupId { get; set; }
	}
	
	/// <summary>
	/// Describes the uri of a disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualHardDisk
	{
		
		/// <summary>
		/// Specifies the virtual hard disk's uri.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
	}
	
	/// <summary>
	/// Describes a Virtual Machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachine : Resource
	{
		
		/// <summary>
		/// Identity for the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="identity")]
		public VirtualMachineIdentity Identity { get; set; }
		
		/// <summary>
		/// Specifies information about the marketplace image used to create the virtual machine. This element is only used for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic use.  In the Azure portal, find the marketplace image that you want to use and then click **Want to deploy programmatically, Get Started ->**. Enter any required information and then click **Save**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="plan")]
		public Plan Plan { get; set; }
		
		/// <summary>
		/// Describes the properties of a Virtual Machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public VirtualMachineProperties Properties { get; set; }
		
		/// <summary>
		/// The virtual machine child extension resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public VirtualMachineExtension[] Resources { get; set; }
		
		/// <summary>
		/// The virtual machine zones.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zones")]
		public string[] Zones { get; set; }
	}
	
	/// <summary>
	/// Describes a Virtual Machine Extension.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineExtension : Resource
	{
		
		/// <summary>
		/// Describes the properties of a Virtual Machine Extension.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public VirtualMachineExtensionProperties Properties { get; set; }
	}
	
	/// <summary>
	/// The instance view of the VM Agent running on the virtual machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineAgentInstanceView
	{
		
		/// <summary>
		/// The virtual machine extension handler instance view.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extensionHandlers")]
		public VirtualMachineExtensionHandlerInstanceView[] ExtensionHandlers { get; set; }
		
		/// <summary>
		/// The resource status information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statuses")]
		public InstanceViewStatus[] Statuses { get; set; }
		
		/// <summary>
		/// The VM Agent full version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmAgentVersion")]
		public string VmAgentVersion { get; set; }
	}
	
	/// <summary>
	/// The instance view of a virtual machine extension handler.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineExtensionHandlerInstanceView
	{
		
		/// <summary>
		/// Instance view status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public InstanceViewStatus Status { get; set; }
		
		/// <summary>
		/// Specifies the type of the extension; an example is "CustomScriptExtension".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Specifies the version of the script handler.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="typeHandlerVersion")]
		public string TypeHandlerVersion { get; set; }
	}
	
	/// <summary>
	/// Capture Virtual Machine parameters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineCaptureParameters
	{
		
		/// <summary>
		/// The destination container name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationContainerName")]
		public string DestinationContainerName { get; set; }
		
		/// <summary>
		/// Specifies whether to overwrite the destination virtual hard disk, in case of conflict.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="overwriteVhds")]
		public bool OverwriteVhds { get; set; }
		
		/// <summary>
		/// The captured virtual hard disk's name prefix.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vhdPrefix")]
		public string VhdPrefix { get; set; }
	}
	
	/// <summary>
	/// Output of virtual machine capture operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineCaptureResult : SubResource
	{
		
		/// <summary>
		/// the schema of the captured virtual machine
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="$schema")]
		public string Schema { get; set; }
		
		/// <summary>
		/// the version of the content
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentVersion")]
		public string ContentVersion { get; set; }
		
		/// <summary>
		/// parameters of the captured virtual machine
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parameters")]
		public string Parameters { get; set; }
		
		/// <summary>
		/// a list of resource items of the captured virtual machine
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public string[] Resources { get; set; }
	}
	
	/// <summary>
	/// Describes a Virtual Machine Extension Image.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineExtensionImage : Resource
	{
		
		/// <summary>
		/// Describes the properties of a Virtual Machine Extension Image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public VirtualMachineExtensionImageProperties Properties { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of a Virtual Machine Extension Image.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineExtensionImageProperties
	{
		
		/// <summary>
		/// The type of role (IaaS or PaaS) this extension supports.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="computeRole")]
		public string ComputeRole { get; set; }
		
		/// <summary>
		/// The schema defined by publisher, where extension consumers should provide settings in a matching schema.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="handlerSchema")]
		public string HandlerSchema { get; set; }
		
		/// <summary>
		/// The operating system this extension supports.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operatingSystem")]
		public string OperatingSystem { get; set; }
		
		/// <summary>
		/// Whether the handler can support multiple extensions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="supportsMultipleExtensions")]
		public System.Nullable<System.Boolean> SupportsMultipleExtensions { get; set; }
		
		/// <summary>
		/// Whether the extension can be used on xRP VMScaleSets. By default existing extensions are usable on scalesets, but there might be cases where a publisher wants to explicitly indicate the extension is only enabled for CRP VMs but not VMSS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmScaleSetEnabled")]
		public System.Nullable<System.Boolean> VmScaleSetEnabled { get; set; }
	}
	
	/// <summary>
	/// The instance view of a virtual machine extension.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineExtensionInstanceView
	{
		
		/// <summary>
		/// The virtual machine extension name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The resource status information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statuses")]
		public InstanceViewStatus[] Statuses { get; set; }
		
		/// <summary>
		/// The resource status information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="substatuses")]
		public InstanceViewStatus[] Substatuses { get; set; }
		
		/// <summary>
		/// Specifies the type of the extension; an example is "CustomScriptExtension".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Specifies the version of the script handler.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="typeHandlerVersion")]
		public string TypeHandlerVersion { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of a Virtual Machine Extension.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineExtensionProperties
	{
		
		/// <summary>
		/// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoUpgradeMinorVersion")]
		public System.Nullable<System.Boolean> AutoUpgradeMinorVersion { get; set; }
		
		/// <summary>
		/// How the extension handler should be forced to update even if the extension configuration has not changed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forceUpdateTag")]
		public string ForceUpdateTag { get; set; }
		
		/// <summary>
		/// The instance view of a virtual machine extension.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceView")]
		public VirtualMachineExtensionInstanceView InstanceView { get; set; }
		
		/// <summary>
		/// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protectedSettings")]
		public string ProtectedSettings { get; set; }
		
		/// <summary>
		/// The provisioning state, which only appears in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioningState")]
		public string ProvisioningState { get; set; }
		
		/// <summary>
		/// The name of the extension handler publisher.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publisher")]
		public string Publisher { get; set; }
		
		/// <summary>
		/// Json formatted public settings for the extension.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public string Settings { get; set; }
		
		/// <summary>
		/// Specifies the type of the extension; an example is "CustomScriptExtension".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Specifies the version of the script handler.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="typeHandlerVersion")]
		public string TypeHandlerVersion { get; set; }
	}
	
	/// <summary>
	/// Describes a Virtual Machine Extension.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineExtensionUpdate : UpdateResource
	{
		
		/// <summary>
		/// Describes the properties of a Virtual Machine Extension.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public VirtualMachineExtensionUpdateProperties Properties { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of a Virtual Machine Extension.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineExtensionUpdateProperties
	{
		
		/// <summary>
		/// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoUpgradeMinorVersion")]
		public System.Nullable<System.Boolean> AutoUpgradeMinorVersion { get; set; }
		
		/// <summary>
		/// How the extension handler should be forced to update even if the extension configuration has not changed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forceUpdateTag")]
		public string ForceUpdateTag { get; set; }
		
		/// <summary>
		/// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protectedSettings")]
		public string ProtectedSettings { get; set; }
		
		/// <summary>
		/// The name of the extension handler publisher.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publisher")]
		public string Publisher { get; set; }
		
		/// <summary>
		/// Json formatted public settings for the extension.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public string Settings { get; set; }
		
		/// <summary>
		/// Specifies the type of the extension; an example is "CustomScriptExtension".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Specifies the version of the script handler.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="typeHandlerVersion")]
		public string TypeHandlerVersion { get; set; }
	}
	
	/// <summary>
	/// The List Extension operation response
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineExtensionsListResult
	{
		
		/// <summary>
		/// The list of extensions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public VirtualMachineExtension[] Value { get; set; }
	}
	
	/// <summary>
	/// The health status of the VM.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineHealthStatus
	{
		
		/// <summary>
		/// Instance view status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public InstanceViewStatus Status { get; set; }
	}
	
	/// <summary>
	/// Identity for the virtual machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineIdentity
	{
		
		/// <summary>
		/// The principal id of virtual machine identity. This property will only be provided for a system assigned identity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="principalId")]
		public string PrincipalId { get; set; }
		
		/// <summary>
		/// The tenant id associated with the virtual machine. This property will only be provided for a system assigned identity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tenantId")]
		public string TenantId { get; set; }
		
		/// <summary>
		/// The type of identity used for the virtual machine. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<VirtualMachineIdentityType> Type { get; set; }
		
		/// <summary>
		/// The list of user identities associated with the Virtual Machine. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userAssignedIdentities")]
		public System.Collections.Generic.Dictionary<string, VirtualMachineIdentityUserAssignedIdentities> UserAssignedIdentities { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum VirtualMachineIdentityType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SystemAssigned = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UserAssigned = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SystemAssigned, UserAssigned")]
		SystemAssigned_UserAssigned = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		None = 3,
	}
	
	public class VirtualMachineIdentityUserAssignedIdentities
	{
		
		/// <summary>
		/// The client id of user assigned identity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientId")]
		public string ClientId { get; set; }
		
		/// <summary>
		/// The principal id of user assigned identity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="principalId")]
		public string PrincipalId { get; set; }
	}
	
	/// <summary>
	/// Describes a Virtual Machine Image.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineImage : VirtualMachineImageResource
	{
		
		/// <summary>
		/// Describes the properties of a Virtual Machine Image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public VirtualMachineImageProperties Properties { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of a Virtual Machine Image.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineImageProperties
	{
		
		/// <summary>
		/// Describes automatic OS upgrade properties on the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="automaticOSUpgradeProperties")]
		public AutomaticOSUpgradeProperties AutomaticOSUpgradeProperties { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dataDiskImages")]
		public DataDiskImage[] DataDiskImages { get; set; }
		
		/// <summary>
		/// Specifies the HyperVGeneration Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hyperVGeneration")]
		public HyperVGenerationType HyperVGeneration { get; set; }
		
		/// <summary>
		/// Contains the os disk image information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osDiskImage")]
		public OSDiskImage OsDiskImage { get; set; }
		
		/// <summary>
		/// Used for establishing the purchase context of any 3rd Party artifact through MarketPlace.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="plan")]
		public PurchasePlan Plan { get; set; }
	}
	
	/// <summary>
	/// Virtual machine image resource information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineImageResource : SubResource
	{
		
		/// <summary>
		/// The supported Azure location of the resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// The name of the resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Specifies the tags that are assigned to the virtual machine. For more information about using tags, see [Using tags to organize your Azure resources](https://docs.microsoft.com/azure/azure-resource-manager/resource-group-using-tags.md).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	/// <summary>
	/// The instance view of a virtual machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineInstanceView
	{
		
		/// <summary>
		/// The instance view of a virtual machine boot diagnostics.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bootDiagnostics")]
		public BootDiagnosticsInstanceView BootDiagnostics { get; set; }
		
		/// <summary>
		/// The computer name assigned to the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computerName")]
		public string ComputerName { get; set; }
		
		/// <summary>
		/// The virtual machine disk information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public DiskInstanceView[] Disks { get; set; }
		
		/// <summary>
		/// The extensions information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extensions")]
		public VirtualMachineExtensionInstanceView[] Extensions { get; set; }
		
		/// <summary>
		/// Specifies the HyperVGeneration Type associated with a resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hyperVGeneration")]
		public HyperVGenerationType HyperVGeneration { get; set; }
		
		/// <summary>
		/// Maintenance Operation Status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maintenanceRedeployStatus")]
		public MaintenanceRedeployStatus MaintenanceRedeployStatus { get; set; }
		
		/// <summary>
		/// The Operating System running on the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osName")]
		public string OsName { get; set; }
		
		/// <summary>
		/// The version of Operating System running on the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osVersion")]
		public string OsVersion { get; set; }
		
		/// <summary>
		/// Specifies the fault domain of the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platformFaultDomain")]
		public System.Nullable<System.Int32> PlatformFaultDomain { get; set; }
		
		/// <summary>
		/// Specifies the update domain of the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platformUpdateDomain")]
		public System.Nullable<System.Int32> PlatformUpdateDomain { get; set; }
		
		/// <summary>
		/// The Remote desktop certificate thumbprint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rdpThumbPrint")]
		public string RdpThumbPrint { get; set; }
		
		/// <summary>
		/// The resource status information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statuses")]
		public InstanceViewStatus[] Statuses { get; set; }
		
		/// <summary>
		/// The instance view of the VM Agent running on the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmAgent")]
		public VirtualMachineAgentInstanceView VmAgent { get; set; }
	}
	
	/// <summary>
	/// The List Virtual Machine operation response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineListResult
	{
		
		/// <summary>
		/// The URI to fetch the next page of VMs. Call ListNext() with this URI to fetch the next page of Virtual Machines.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// The list of virtual machines.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public VirtualMachine[] Value { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of a Virtual Machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineProperties
	{
		
		/// <summary>
		/// Enables or disables a capability on the virtual machine or virtual machine scale set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalCapabilities")]
		public AdditionalCapabilities AdditionalCapabilities { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="availabilitySet")]
		public SubResource AvailabilitySet { get; set; }
		
		/// <summary>
		/// Specifies the billing related details of a Azure Spot VM or VMSS. <br><br>Minimum api-version: 2019-03-01.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="billingProfile")]
		public BillingProfile BillingProfile { get; set; }
		
		/// <summary>
		/// Specifies the boot diagnostic settings state. <br><br>Minimum api-version: 2015-06-15.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diagnosticsProfile")]
		public DiagnosticsProfile DiagnosticsProfile { get; set; }
		
		/// <summary>
		/// Specifies the eviction policy for the Azure Spot VM/VMSS
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="evictionPolicy")]
		public System.Nullable<VirtualMachinePropertiesEvictionPolicy> EvictionPolicy { get; set; }
		
		/// <summary>
		/// Specifies the hardware settings for the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hardwareProfile")]
		public HardwareProfile HardwareProfile { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="host")]
		public SubResource Host { get; set; }
		
		/// <summary>
		/// The instance view of a virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceView")]
		public VirtualMachineInstanceView InstanceView { get; set; }
		
		/// <summary>
		/// Specifies that the image or disk that is being used was licensed on-premises. This element is only used for images that contain the Windows Server operating system. <br><br> Possible values are: <br><br> Windows_Client <br><br> Windows_Server <br><br> If this element is included in a request for an update, the value must match the initial value. This value cannot be updated. <br><br> For more information, see [Azure Hybrid Use Benefit for Windows Server](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-hybrid-use-benefit-licensing?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> Minimum api-version: 2015-06-15
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseType")]
		public string LicenseType { get; set; }
		
		/// <summary>
		/// Specifies the network interfaces of the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkProfile")]
		public NetworkProfile NetworkProfile { get; set; }
		
		/// <summary>
		/// Specifies the operating system settings for the virtual machine. Some of the settings cannot be changed once VM is provisioned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osProfile")]
		public OSProfile OsProfile { get; set; }
		
		/// <summary>
		/// Specifies the priority for a standalone virtual machine or the virtual machines in the scale set. <br><br> 'Low' enum will be deprecated in the future, please use 'Spot' as the enum to deploy Azure Spot VM/VMSS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public System.Nullable<VirtualMachinePropertiesPriority> Priority { get; set; }
		
		/// <summary>
		/// The provisioning state, which only appears in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioningState")]
		public string ProvisioningState { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="proximityPlacementGroup")]
		public SubResource ProximityPlacementGroup { get; set; }
		
		/// <summary>
		/// Specifies the storage settings for the virtual machine disks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageProfile")]
		public StorageProfile StorageProfile { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="virtualMachineScaleSet")]
		public SubResource VirtualMachineScaleSet { get; set; }
		
		/// <summary>
		/// Specifies the VM unique ID which is a 128-bits identifier that is encoded and stored in all Azure IaaS VMs SMBIOS and can be read using platform BIOS commands.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmId")]
		public string VmId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum VirtualMachinePropertiesEvictionPolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deallocate = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Delete = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum VirtualMachinePropertiesPriority
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Regular = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Low = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Spot = 2,
	}
	
	/// <summary>
	/// Parameters for Reimaging Virtual Machine. NOTE: Virtual Machine OS disk will always be reimaged
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineReimageParameters
	{
		
		/// <summary>
		/// Specifies whether to reimage temp disk. Default value: false. Note: This temp disk reimage parameter is only supported for VM/VMSS with Ephemeral OS disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tempDisk")]
		public System.Nullable<System.Boolean> TempDisk { get; set; }
	}
	
	/// <summary>
	/// Describes a Virtual Machine Scale Set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSet : Resource
	{
		
		/// <summary>
		/// Identity for the virtual machine scale set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="identity")]
		public VirtualMachineScaleSetIdentity Identity { get; set; }
		
		/// <summary>
		/// Specifies information about the marketplace image used to create the virtual machine. This element is only used for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic use.  In the Azure portal, find the marketplace image that you want to use and then click **Want to deploy programmatically, Get Started ->**. Enter any required information and then click **Save**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="plan")]
		public Plan Plan { get; set; }
		
		/// <summary>
		/// Describes the properties of a Virtual Machine Scale Set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public VirtualMachineScaleSetProperties Properties { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set sku.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sku")]
		public Sku Sku { get; set; }
		
		/// <summary>
		/// The virtual machine scale set zones.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zones")]
		public string[] Zones { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set data disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetDataDisk
	{
		
		/// <summary>
		/// Specifies the caching requirements. <br><br> Possible values are: <br><br> **None** <br><br> **ReadOnly** <br><br> **ReadWrite** <br><br> Default: **None for Standard storage. ReadOnly for Premium storage**
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caching")]
		public Caching Caching { get; set; }
		
		/// <summary>
		/// Specifies how the virtual machine should be created.<br><br> Possible values are:<br><br> **Attach** \u2013 This value is used when you are using a specialized disk to create the virtual machine.<br><br> **FromImage** \u2013 This value is used when you are using an image to create the virtual machine. If you are using a platform image, you also use the imageReference element described above. If you are using a marketplace image, you  also use the plan element previously described.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createOption")]
		public CreateOption CreateOption { get; set; }
		
		/// <summary>
		/// Specifies the Read-Write IOPS for the managed disk. Should be used only when StorageAccountType is UltraSSD_LRS. If not specified, a default value would be assigned based on diskSizeGB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskIOPSReadWrite")]
		public System.Nullable<System.Int64> DiskIOPSReadWrite { get; set; }
		
		/// <summary>
		/// Specifies the bandwidth in MB per second for the managed disk. Should be used only when StorageAccountType is UltraSSD_LRS. If not specified, a default value would be assigned based on diskSizeGB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskMBpsReadWrite")]
		public System.Nullable<System.Int64> DiskMBpsReadWrite { get; set; }
		
		/// <summary>
		/// Specifies the size of an empty data disk in gigabytes. This element can be used to overwrite the size of the disk in a virtual machine image. <br><br> This value cannot be larger than 1023 GB
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskSizeGB")]
		public System.Nullable<System.Int32> DiskSizeGB { get; set; }
		
		/// <summary>
		/// Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lun")]
		public int Lun { get; set; }
		
		/// <summary>
		/// Describes the parameters of a ScaleSet managed disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managedDisk")]
		public VirtualMachineScaleSetManagedDiskParameters ManagedDisk { get; set; }
		
		/// <summary>
		/// The disk name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Specifies whether writeAccelerator should be enabled or disabled on the disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="writeAcceleratorEnabled")]
		public System.Nullable<System.Boolean> WriteAcceleratorEnabled { get; set; }
	}
	
	/// <summary>
	/// Describes a Virtual Machine Scale Set Extension.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetExtension : SubResourceReadOnly
	{
		
		/// <summary>
		/// The name of the extension.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Describes the properties of a Virtual Machine Scale Set Extension.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public VirtualMachineScaleSetExtensionProperties Properties { get; set; }
		
		/// <summary>
		/// Resource type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// The List VM scale set extension operation response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetExtensionListResult
	{
		
		/// <summary>
		/// The uri to fetch the next page of VM scale set extensions. Call ListNext() with this to fetch the next page of VM scale set extensions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// The list of VM scale set extensions.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public VirtualMachineScaleSetExtension[] Value { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set extension profile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetExtensionProfile
	{
		
		/// <summary>
		/// The virtual machine scale set child extension resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extensions")]
		public VirtualMachineScaleSetExtension[] Extensions { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of a Virtual Machine Scale Set Extension.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetExtensionProperties
	{
		
		/// <summary>
		/// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoUpgradeMinorVersion")]
		public System.Nullable<System.Boolean> AutoUpgradeMinorVersion { get; set; }
		
		/// <summary>
		/// If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forceUpdateTag")]
		public string ForceUpdateTag { get; set; }
		
		/// <summary>
		/// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protectedSettings")]
		public string ProtectedSettings { get; set; }
		
		/// <summary>
		/// Collection of extension names after which this extension needs to be provisioned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisionAfterExtensions")]
		public string[] ProvisionAfterExtensions { get; set; }
		
		/// <summary>
		/// The provisioning state, which only appears in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioningState")]
		public string ProvisioningState { get; set; }
		
		/// <summary>
		/// The name of the extension handler publisher.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publisher")]
		public string Publisher { get; set; }
		
		/// <summary>
		/// Json formatted public settings for the extension.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public string Settings { get; set; }
		
		/// <summary>
		/// Specifies the type of the extension; an example is "CustomScriptExtension".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Specifies the version of the script handler.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="typeHandlerVersion")]
		public string TypeHandlerVersion { get; set; }
	}
	
	/// <summary>
	/// Describes a Virtual Machine Scale Set Extension.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetExtensionUpdate : SubResourceReadOnly
	{
		
		/// <summary>
		/// The name of the extension.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Describes the properties of a Virtual Machine Scale Set Extension.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public VirtualMachineScaleSetExtensionProperties Properties { get; set; }
		
		/// <summary>
		/// Resource type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set network profile's IP configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetIPConfiguration : SubResource
	{
		
		/// <summary>
		/// The IP configuration name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set network profile's IP configuration properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public VirtualMachineScaleSetIPConfigurationProperties Properties { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set network profile's IP configuration properties.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetIPConfigurationProperties
	{
		
		/// <summary>
		/// Specifies an array of references to backend address pools of application gateways. A scale set can reference backend address pools of multiple application gateways. Multiple scale sets cannot use the same application gateway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applicationGatewayBackendAddressPools")]
		public SubResource[] ApplicationGatewayBackendAddressPools { get; set; }
		
		/// <summary>
		/// Specifies an array of references to application security group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applicationSecurityGroups")]
		public SubResource[] ApplicationSecurityGroups { get; set; }
		
		/// <summary>
		/// Specifies an array of references to backend address pools of load balancers. A scale set can reference backend address pools of one public and one internal load balancer. Multiple scale sets cannot use the same load balancer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loadBalancerBackendAddressPools")]
		public SubResource[] LoadBalancerBackendAddressPools { get; set; }
		
		/// <summary>
		/// Specifies an array of references to inbound Nat pools of the load balancers. A scale set can reference inbound nat pools of one public and one internal load balancer. Multiple scale sets cannot use the same load balancer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loadBalancerInboundNatPools")]
		public SubResource[] LoadBalancerInboundNatPools { get; set; }
		
		/// <summary>
		/// Specifies the primary network interface in case the virtual machine has more than 1 network interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary")]
		public System.Nullable<System.Boolean> Primary { get; set; }
		
		/// <summary>
		/// Available from Api-Version 2017-03-30 onwards, it represents whether the specific ipconfiguration is IPv4 or IPv6. Default is taken as IPv4.  Possible values are: 'IPv4' and 'IPv6'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateIPAddressVersion")]
		public System.Nullable<VirtualMachineScaleSetIPConfigurationPropertiesPrivateIPAddressVersion> PrivateIPAddressVersion { get; set; }
		
		/// <summary>
		/// Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicIPAddressConfiguration")]
		public VirtualMachineScaleSetPublicIPAddressConfiguration PublicIPAddressConfiguration { get; set; }
		
		/// <summary>
		/// The API entity reference.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public ApiEntityReference Subnet { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum VirtualMachineScaleSetIPConfigurationPropertiesPrivateIPAddressVersion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IPv4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IPv6 = 1,
	}
	
	/// <summary>
	/// Identity for the virtual machine scale set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetIdentity
	{
		
		/// <summary>
		/// The principal id of virtual machine scale set identity. This property will only be provided for a system assigned identity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="principalId")]
		public string PrincipalId { get; set; }
		
		/// <summary>
		/// The tenant id associated with the virtual machine scale set. This property will only be provided for a system assigned identity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tenantId")]
		public string TenantId { get; set; }
		
		/// <summary>
		/// The type of identity used for the virtual machine scale set. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual machine scale set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<VirtualMachineScaleSetIdentityType> Type { get; set; }
		
		/// <summary>
		/// The list of user identities associated with the virtual machine scale set. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userAssignedIdentities")]
		public System.Collections.Generic.Dictionary<string, VirtualMachineScaleSetIdentityUserAssignedIdentities> UserAssignedIdentities { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum VirtualMachineScaleSetIdentityType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SystemAssigned = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UserAssigned = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SystemAssigned, UserAssigned")]
		SystemAssigned_UserAssigned = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		None = 3,
	}
	
	public class VirtualMachineScaleSetIdentityUserAssignedIdentities
	{
		
		/// <summary>
		/// The client id of user assigned identity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientId")]
		public string ClientId { get; set; }
		
		/// <summary>
		/// The principal id of user assigned identity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="principalId")]
		public string PrincipalId { get; set; }
	}
	
	/// <summary>
	/// The instance view of a virtual machine scale set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetInstanceView
	{
		
		/// <summary>
		/// The extensions information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extensions")]
		public VirtualMachineScaleSetVMExtensionsSummary[] Extensions { get; set; }
		
		/// <summary>
		/// The resource status information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statuses")]
		public InstanceViewStatus[] Statuses { get; set; }
		
		/// <summary>
		/// Instance view statuses summary for virtual machines of a virtual machine scale set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualMachine")]
		public VirtualMachineScaleSetInstanceViewStatusesSummary VirtualMachine { get; set; }
	}
	
	/// <summary>
	/// Extensions summary for virtual machines of a virtual machine scale set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetVMExtensionsSummary
	{
		
		/// <summary>
		/// The extension name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The extensions information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusesSummary")]
		public VirtualMachineStatusCodeCount[] StatusesSummary { get; set; }
	}
	
	/// <summary>
	/// The status code and count of the virtual machine scale set instance view status summary.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineStatusCodeCount
	{
		
		/// <summary>
		/// The instance view status code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// The number of instances having a particular status code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public System.Nullable<System.Int32> Count { get; set; }
	}
	
	/// <summary>
	/// Instance view statuses summary for virtual machines of a virtual machine scale set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetInstanceViewStatusesSummary
	{
		
		/// <summary>
		/// The extensions information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusesSummary")]
		public VirtualMachineStatusCodeCount[] StatusesSummary { get; set; }
	}
	
	/// <summary>
	/// Contains the IP tag associated with the public IP address.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetIpTag
	{
		
		/// <summary>
		/// IP tag type. Example: FirstPartyUsage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipTagType")]
		public string IpTagType { get; set; }
		
		/// <summary>
		/// IP tag associated with the public IP. Example: SQL, Storage etc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public string Tag { get; set; }
	}
	
	/// <summary>
	/// List of Virtual Machine Scale Set OS Upgrade History operation response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetListOSUpgradeHistory
	{
		
		/// <summary>
		/// The uri to fetch the next page of OS Upgrade History. Call ListNext() with this to fetch the next page of history of upgrades.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// The list of OS upgrades performed on the virtual machine scale set.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public UpgradeOperationHistoricalStatusInfo[] Value { get; set; }
	}
	
	/// <summary>
	/// The List Virtual Machine operation response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetListResult
	{
		
		/// <summary>
		/// The uri to fetch the next page of Virtual Machine Scale Sets. Call ListNext() with this to fetch the next page of VMSS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// The list of virtual machine scale sets.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public VirtualMachineScaleSet[] Value { get; set; }
	}
	
	/// <summary>
	/// The Virtual Machine Scale Set List Skus operation response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetListSkusResult
	{
		
		/// <summary>
		/// The uri to fetch the next page of Virtual Machine Scale Set Skus. Call ListNext() with this to fetch the next page of VMSS Skus.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// The list of skus available for the virtual machine scale set.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public VirtualMachineScaleSetSku[] Value { get; set; }
	}
	
	/// <summary>
	/// Describes an available virtual machine scale set sku.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetSku
	{
		
		/// <summary>
		/// Describes scaling information of a sku.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="capacity")]
		public VirtualMachineScaleSetSkuCapacity Capacity { get; set; }
		
		/// <summary>
		/// The type of resource the sku applies to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceType")]
		public string ResourceType { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set sku.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sku")]
		public Sku Sku { get; set; }
	}
	
	/// <summary>
	/// The List Virtual Machine operation response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetListWithLinkResult
	{
		
		/// <summary>
		/// The uri to fetch the next page of Virtual Machine Scale Sets. Call ListNext() with this to fetch the next page of Virtual Machine Scale Sets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// The list of virtual machine scale sets.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public VirtualMachineScaleSet[] Value { get; set; }
	}
	
	/// <summary>
	/// Describes the parameters of a ScaleSet managed disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetManagedDiskParameters
	{
		
		/// <summary>
		/// Describes the parameter of customer managed disk encryption set resource id that can be specified for disk. <br><br> NOTE: The disk encryption set resource id can only be specified for managed disk. Please refer https://aka.ms/mdssewithcmkoverview for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskEncryptionSet")]
		public DiskEncryptionSetParameters DiskEncryptionSet { get; set; }
		
		/// <summary>
		/// Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with data disks. It cannot be used with OS Disk. Standard_LRS uses Standard HDD. StandardSSD_LRS uses Standard SSD. Premium_LRS uses Premium SSD. UltraSSD_LRS uses Ultra disk. For more information regarding disks supported for Windows Virtual Machines, refer to https://docs.microsoft.com/en-us/azure/virtual-machines/windows/disks-types and, for Linux Virtual Machines, refer to https://docs.microsoft.com/en-us/azure/virtual-machines/linux/disks-types
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageAccountType")]
		public ImageDiskStorageAccountType StorageAccountType { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set network profile's network configurations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetNetworkConfiguration : SubResource
	{
		
		/// <summary>
		/// The network configuration name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set network profile's IP configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public VirtualMachineScaleSetNetworkConfigurationProperties Properties { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machines scale sets network configuration's DNS settings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetNetworkConfigurationDnsSettings
	{
		
		/// <summary>
		/// List of DNS servers IP addresses
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsServers")]
		public string[] DnsServers { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set network profile's IP configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetNetworkConfigurationProperties
	{
		
		/// <summary>
		/// Describes a virtual machines scale sets network configuration's DNS settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsSettings")]
		public VirtualMachineScaleSetNetworkConfigurationDnsSettings DnsSettings { get; set; }
		
		/// <summary>
		/// Specifies whether the network interface is accelerated networking-enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableAcceleratedNetworking")]
		public System.Nullable<System.Boolean> EnableAcceleratedNetworking { get; set; }
		
		/// <summary>
		/// Whether IP forwarding enabled on this NIC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableIPForwarding")]
		public System.Nullable<System.Boolean> EnableIPForwarding { get; set; }
		
		/// <summary>
		/// Specifies the IP configurations of the network interface.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipConfigurations")]
		public VirtualMachineScaleSetIPConfiguration[] IpConfigurations { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="networkSecurityGroup")]
		public SubResource NetworkSecurityGroup { get; set; }
		
		/// <summary>
		/// Specifies the primary network interface in case the virtual machine has more than 1 network interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary")]
		public System.Nullable<System.Boolean> Primary { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set network profile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetNetworkProfile
	{
		
		/// <summary>
		/// The API entity reference.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthProbe")]
		public ApiEntityReference HealthProbe { get; set; }
		
		/// <summary>
		/// The list of network configurations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkInterfaceConfigurations")]
		public VirtualMachineScaleSetNetworkConfiguration[] NetworkInterfaceConfigurations { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set operating system disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetOSDisk
	{
		
		/// <summary>
		/// Specifies the caching requirements. <br><br> Possible values are: <br><br> **None** <br><br> **ReadOnly** <br><br> **ReadWrite** <br><br> Default: **None for Standard storage. ReadOnly for Premium storage**
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caching")]
		public Caching Caching { get; set; }
		
		/// <summary>
		/// Specifies how the virtual machine should be created.<br><br> Possible values are:<br><br> **Attach** \u2013 This value is used when you are using a specialized disk to create the virtual machine.<br><br> **FromImage** \u2013 This value is used when you are using an image to create the virtual machine. If you are using a platform image, you also use the imageReference element described above. If you are using a marketplace image, you  also use the plan element previously described.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createOption")]
		public CreateOption CreateOption { get; set; }
		
		/// <summary>
		/// Describes the parameters of ephemeral disk settings that can be specified for operating system disk. <br><br> NOTE: The ephemeral disk settings can only be specified for managed disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diffDiskSettings")]
		public DiffDiskSettings DiffDiskSettings { get; set; }
		
		/// <summary>
		/// Specifies the size of the operating system disk in gigabytes. This element can be used to overwrite the size of the disk in a virtual machine image. <br><br> This value cannot be larger than 1023 GB
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskSizeGB")]
		public System.Nullable<System.Int32> DiskSizeGB { get; set; }
		
		/// <summary>
		/// Describes the uri of a disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public VirtualHardDisk Image { get; set; }
		
		/// <summary>
		/// Describes the parameters of a ScaleSet managed disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managedDisk")]
		public VirtualMachineScaleSetManagedDiskParameters ManagedDisk { get; set; }
		
		/// <summary>
		/// The disk name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// This property allows you to specify the type of the OS that is included in the disk if creating a VM from user-image or a specialized VHD. <br><br> Possible values are: <br><br> **Windows** <br><br> **Linux**
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osType")]
		public ImageOSDiskOsType OsType { get; set; }
		
		/// <summary>
		/// Specifies the container urls that are used to store operating system disks for the scale set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vhdContainers")]
		public string[] VhdContainers { get; set; }
		
		/// <summary>
		/// Specifies whether writeAccelerator should be enabled or disabled on the disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="writeAcceleratorEnabled")]
		public System.Nullable<System.Boolean> WriteAcceleratorEnabled { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set OS profile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetOSProfile
	{
		
		/// <summary>
		/// Specifies the password of the administrator account. <br><br> **Minimum-length (Windows):** 8 characters <br><br> **Minimum-length (Linux):** 6 characters <br><br> **Max-length (Windows):** 123 characters <br><br> **Max-length (Linux):** 72 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:** "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1", "Password22", "iloveyou!" <br><br> For resetting the password, see [How to reset the Remote Desktop service or its login password in a Windows VM](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-reset-rdp?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> For resetting root password, see [Manage users, SSH, and check or repair disks on Azure Linux VMs using the VMAccess Extension](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-vmaccess-extension?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json#reset-root-password)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adminPassword")]
		public string AdminPassword { get; set; }
		
		/// <summary>
		/// Specifies the name of the administrator account. <br><br> **Windows-only restriction:** Cannot end in "." <br><br> **Disallowed values:** "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server", "sql", "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5". <br><br> **Minimum-length (Linux):** 1  character <br><br> **Max-length (Linux):** 64 characters <br><br> **Max-length (Windows):** 20 characters  <br><br><li> For root access to the Linux VM, see [Using root privileges on Linux virtual machines in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-use-root-privileges?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)<br><li> For a list of built-in system users on Linux that should not be used in this field, see [Selecting User Names for Linux on Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-usernames?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adminUsername")]
		public string AdminUsername { get; set; }
		
		/// <summary>
		/// Specifies the computer name prefix for all of the virtual machines in the scale set. Computer name prefixes must be 1 to 15 characters long.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computerNamePrefix")]
		public string ComputerNamePrefix { get; set; }
		
		/// <summary>
		/// Specifies a base-64 encoded string of custom data. The base-64 encoded string is decoded to a binary array that is saved as a file on the Virtual Machine. The maximum length of the binary array is 65535 bytes. <br><br> For using cloud-init for your VM, see [Using cloud-init to customize a Linux VM during creation](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-cloud-init?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customData")]
		public string CustomData { get; set; }
		
		/// <summary>
		/// Specifies the Linux operating system settings on the virtual machine. <br><br>For a list of supported Linux distributions, see [Linux on Azure-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-endorsed-distros?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json) <br><br> For running non-endorsed distributions, see [Information for Non-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-create-upload-generic?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linuxConfiguration")]
		public LinuxConfiguration LinuxConfiguration { get; set; }
		
		/// <summary>
		/// Specifies set of certificates that should be installed onto the virtual machines in the scale set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secrets")]
		public VaultSecretGroup[] Secrets { get; set; }
		
		/// <summary>
		/// Specifies Windows operating system settings on the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="windowsConfiguration")]
		public WindowsConfiguration WindowsConfiguration { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of a Virtual Machine Scale Set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetProperties
	{
		
		/// <summary>
		/// Enables or disables a capability on the virtual machine or virtual machine scale set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalCapabilities")]
		public AdditionalCapabilities AdditionalCapabilities { get; set; }
		
		/// <summary>
		/// Specifies the configuration parameters for automatic repairs on the virtual machine scale set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="automaticRepairsPolicy")]
		public AutomaticRepairsPolicy AutomaticRepairsPolicy { get; set; }
		
		/// <summary>
		/// When Overprovision is enabled, extensions are launched only on the requested number of VMs which are finally kept. This property will hence ensure that the extensions do not run on the extra overprovisioned VMs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="doNotRunExtensionsOnOverprovisionedVMs")]
		public System.Nullable<System.Boolean> DoNotRunExtensionsOnOverprovisionedVMs { get; set; }
		
		/// <summary>
		/// Specifies whether the Virtual Machine Scale Set should be overprovisioned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="overprovision")]
		public System.Nullable<System.Boolean> Overprovision { get; set; }
		
		/// <summary>
		/// Fault Domain count for each placement group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platformFaultDomainCount")]
		public System.Nullable<System.Int32> PlatformFaultDomainCount { get; set; }
		
		/// <summary>
		/// The provisioning state, which only appears in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioningState")]
		public string ProvisioningState { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="proximityPlacementGroup")]
		public SubResource ProximityPlacementGroup { get; set; }
		
		/// <summary>
		/// Describes a scale-in policy for a virtual machine scale set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scaleInPolicy")]
		public ScaleInPolicy ScaleInPolicy { get; set; }
		
		/// <summary>
		/// When true this limits the scale set to a single placement group, of max size 100 virtual machines.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="singlePlacementGroup")]
		public System.Nullable<System.Boolean> SinglePlacementGroup { get; set; }
		
		/// <summary>
		/// Specifies the ID which uniquely identifies a Virtual Machine Scale Set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uniqueId")]
		public string UniqueId { get; set; }
		
		/// <summary>
		/// Describes an upgrade policy - automatic, manual, or rolling.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradePolicy")]
		public UpgradePolicy UpgradePolicy { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set virtual machine profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualMachineProfile")]
		public VirtualMachineScaleSetVMProfile VirtualMachineProfile { get; set; }
		
		/// <summary>
		/// Whether to force strictly even Virtual Machine distribution cross x-zones in case there is zone outage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zoneBalance")]
		public System.Nullable<System.Boolean> ZoneBalance { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetPublicIPAddressConfiguration
	{
		
		/// <summary>
		/// The publicIP address configuration name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public VirtualMachineScaleSetPublicIPAddressConfigurationProperties Properties { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machines scale sets network configuration's DNS settings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
	{
		
		/// <summary>
		/// The Domain name label.The concatenation of the domain name label and vm index will be the domain name labels of the PublicIPAddress resources that will be created
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domainNameLabel")]
		public string DomainNameLabel { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetPublicIPAddressConfigurationProperties
	{
		
		/// <summary>
		/// Describes a virtual machines scale sets network configuration's DNS settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsSettings")]
		public VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings DnsSettings { get; set; }
		
		/// <summary>
		/// The idle timeout of the public IP address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="idleTimeoutInMinutes")]
		public System.Nullable<System.Int32> IdleTimeoutInMinutes { get; set; }
		
		/// <summary>
		/// The list of IP tags associated with the public IP address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipTags")]
		public VirtualMachineScaleSetIpTag[] IpTags { get; set; }
		
		/// <summary>
		/// Available from Api-Version 2019-07-01 onwards, it represents whether the specific ipconfiguration is IPv4 or IPv6. Default is taken as IPv4. Possible values are: 'IPv4' and 'IPv6'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicIPAddressVersion")]
		public VirtualMachineScaleSetIPConfigurationPropertiesPrivateIPAddressVersion PublicIPAddressVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="publicIPPrefix")]
		public SubResource PublicIPPrefix { get; set; }
	}
	
	/// <summary>
	/// Describes a Virtual Machine Scale Set VM Reimage Parameters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetReimageParameters : VirtualMachineScaleSetVMReimageParameters
	{
		
		/// <summary>
		/// The virtual machine scale set instance ids. Omitting the virtual machine scale set instance ids will result in the operation being performed on all virtual machines in the virtual machine scale set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceIds")]
		public string[] InstanceIds { get; set; }
	}
	
	/// <summary>
	/// Describes scaling information of a sku.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetSkuCapacity
	{
		
		/// <summary>
		/// The default capacity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultCapacity")]
		public System.Nullable<System.Int64> DefaultCapacity { get; set; }
		
		/// <summary>
		/// The maximum capacity that can be set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximum")]
		public System.Nullable<System.Int64> Maximum { get; set; }
		
		/// <summary>
		/// The minimum capacity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimum")]
		public System.Nullable<System.Int64> Minimum { get; set; }
		
		/// <summary>
		/// The scale type applicable to the sku.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scaleType")]
		public System.Nullable<VirtualMachineScaleSetSkuCapacityScaleType> ScaleType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum VirtualMachineScaleSetSkuCapacityScaleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Automatic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		None = 1,
	}
	
	/// <summary>
	/// Describes a virtual machine scale set storage profile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetStorageProfile
	{
		
		/// <summary>
		/// Specifies the parameters that are used to add data disks to the virtual machines in the scale set. <br><br> For more information about disks, see [About disks and VHDs for Azure virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataDisks")]
		public VirtualMachineScaleSetDataDisk[] DataDisks { get; set; }
		
		/// <summary>
		/// Specifies information about the image to use. You can specify information about platform images, marketplace images, or virtual machine images. This element is required when you want to use a platform image, marketplace image, or virtual machine image, but is not used in other creation operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageReference")]
		public ImageReference ImageReference { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set operating system disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osDisk")]
		public VirtualMachineScaleSetOSDisk OsDisk { get; set; }
	}
	
	/// <summary>
	/// Describes a Virtual Machine Scale Set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetUpdate : UpdateResource
	{
		
		/// <summary>
		/// Identity for the virtual machine scale set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="identity")]
		public VirtualMachineScaleSetIdentity Identity { get; set; }
		
		/// <summary>
		/// Specifies information about the marketplace image used to create the virtual machine. This element is only used for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic use.  In the Azure portal, find the marketplace image that you want to use and then click **Want to deploy programmatically, Get Started ->**. Enter any required information and then click **Save**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="plan")]
		public Plan Plan { get; set; }
		
		/// <summary>
		/// Describes the properties of a Virtual Machine Scale Set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public VirtualMachineScaleSetUpdateProperties Properties { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set sku.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sku")]
		public Sku Sku { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set network profile's IP configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetUpdateIPConfiguration : SubResource
	{
		
		/// <summary>
		/// The IP configuration name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set network profile's IP configuration properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public VirtualMachineScaleSetUpdateIPConfigurationProperties Properties { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set network profile's IP configuration properties.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetUpdateIPConfigurationProperties
	{
		
		/// <summary>
		/// The application gateway backend address pools.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applicationGatewayBackendAddressPools")]
		public SubResource[] ApplicationGatewayBackendAddressPools { get; set; }
		
		/// <summary>
		/// Specifies an array of references to application security group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applicationSecurityGroups")]
		public SubResource[] ApplicationSecurityGroups { get; set; }
		
		/// <summary>
		/// The load balancer backend address pools.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loadBalancerBackendAddressPools")]
		public SubResource[] LoadBalancerBackendAddressPools { get; set; }
		
		/// <summary>
		/// The load balancer inbound nat pools.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loadBalancerInboundNatPools")]
		public SubResource[] LoadBalancerInboundNatPools { get; set; }
		
		/// <summary>
		/// Specifies the primary IP Configuration in case the network interface has more than one IP Configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary")]
		public System.Nullable<System.Boolean> Primary { get; set; }
		
		/// <summary>
		/// Available from Api-Version 2017-03-30 onwards, it represents whether the specific ipconfiguration is IPv4 or IPv6. Default is taken as IPv4.  Possible values are: 'IPv4' and 'IPv6'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateIPAddressVersion")]
		public VirtualMachineScaleSetIPConfigurationPropertiesPrivateIPAddressVersion PrivateIPAddressVersion { get; set; }
		
		/// <summary>
		/// Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicIPAddressConfiguration")]
		public VirtualMachineScaleSetUpdatePublicIPAddressConfiguration PublicIPAddressConfiguration { get; set; }
		
		/// <summary>
		/// The API entity reference.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public ApiEntityReference Subnet { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set network profile's network configurations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetUpdateNetworkConfiguration : SubResource
	{
		
		/// <summary>
		/// The network configuration name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set updatable network profile's IP configuration.Use this object for updating network profile's IP Configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public VirtualMachineScaleSetUpdateNetworkConfigurationProperties Properties { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set updatable network profile's IP configuration.Use this object for updating network profile's IP Configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetUpdateNetworkConfigurationProperties
	{
		
		/// <summary>
		/// Describes a virtual machines scale sets network configuration's DNS settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsSettings")]
		public VirtualMachineScaleSetNetworkConfigurationDnsSettings DnsSettings { get; set; }
		
		/// <summary>
		/// Specifies whether the network interface is accelerated networking-enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableAcceleratedNetworking")]
		public System.Nullable<System.Boolean> EnableAcceleratedNetworking { get; set; }
		
		/// <summary>
		/// Whether IP forwarding enabled on this NIC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableIPForwarding")]
		public System.Nullable<System.Boolean> EnableIPForwarding { get; set; }
		
		/// <summary>
		/// The virtual machine scale set IP Configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipConfigurations")]
		public VirtualMachineScaleSetUpdateIPConfiguration[] IpConfigurations { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="networkSecurityGroup")]
		public SubResource NetworkSecurityGroup { get; set; }
		
		/// <summary>
		/// Whether this is a primary NIC on a virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary")]
		public System.Nullable<System.Boolean> Primary { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set network profile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetUpdateNetworkProfile
	{
		
		/// <summary>
		/// The API entity reference.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthProbe")]
		public ApiEntityReference HealthProbe { get; set; }
		
		/// <summary>
		/// The list of network configurations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkInterfaceConfigurations")]
		public VirtualMachineScaleSetUpdateNetworkConfiguration[] NetworkInterfaceConfigurations { get; set; }
	}
	
	/// <summary>
	/// Describes virtual machine scale set operating system disk Update Object. This should be used for Updating VMSS OS Disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetUpdateOSDisk
	{
		
		/// <summary>
		/// Specifies the caching requirements. <br><br> Possible values are: <br><br> **None** <br><br> **ReadOnly** <br><br> **ReadWrite** <br><br> Default: **None for Standard storage. ReadOnly for Premium storage**
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caching")]
		public Caching Caching { get; set; }
		
		/// <summary>
		/// Specifies the size of the operating system disk in gigabytes. This element can be used to overwrite the size of the disk in a virtual machine image. <br><br> This value cannot be larger than 1023 GB
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskSizeGB")]
		public System.Nullable<System.Int32> DiskSizeGB { get; set; }
		
		/// <summary>
		/// Describes the uri of a disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public VirtualHardDisk Image { get; set; }
		
		/// <summary>
		/// Describes the parameters of a ScaleSet managed disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managedDisk")]
		public VirtualMachineScaleSetManagedDiskParameters ManagedDisk { get; set; }
		
		/// <summary>
		/// The list of virtual hard disk container uris.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vhdContainers")]
		public string[] VhdContainers { get; set; }
		
		/// <summary>
		/// Specifies whether writeAccelerator should be enabled or disabled on the disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="writeAcceleratorEnabled")]
		public System.Nullable<System.Boolean> WriteAcceleratorEnabled { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set OS profile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetUpdateOSProfile
	{
		
		/// <summary>
		/// A base-64 encoded string of custom data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customData")]
		public string CustomData { get; set; }
		
		/// <summary>
		/// Specifies the Linux operating system settings on the virtual machine. <br><br>For a list of supported Linux distributions, see [Linux on Azure-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-endorsed-distros?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json) <br><br> For running non-endorsed distributions, see [Information for Non-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-create-upload-generic?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linuxConfiguration")]
		public LinuxConfiguration LinuxConfiguration { get; set; }
		
		/// <summary>
		/// The List of certificates for addition to the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secrets")]
		public VaultSecretGroup[] Secrets { get; set; }
		
		/// <summary>
		/// Specifies Windows operating system settings on the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="windowsConfiguration")]
		public WindowsConfiguration WindowsConfiguration { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of a Virtual Machine Scale Set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetUpdateProperties
	{
		
		/// <summary>
		/// Enables or disables a capability on the virtual machine or virtual machine scale set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalCapabilities")]
		public AdditionalCapabilities AdditionalCapabilities { get; set; }
		
		/// <summary>
		/// Specifies the configuration parameters for automatic repairs on the virtual machine scale set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="automaticRepairsPolicy")]
		public AutomaticRepairsPolicy AutomaticRepairsPolicy { get; set; }
		
		/// <summary>
		/// When Overprovision is enabled, extensions are launched only on the requested number of VMs which are finally kept. This property will hence ensure that the extensions do not run on the extra overprovisioned VMs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="doNotRunExtensionsOnOverprovisionedVMs")]
		public System.Nullable<System.Boolean> DoNotRunExtensionsOnOverprovisionedVMs { get; set; }
		
		/// <summary>
		/// Specifies whether the Virtual Machine Scale Set should be overprovisioned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="overprovision")]
		public System.Nullable<System.Boolean> Overprovision { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="proximityPlacementGroup")]
		public SubResource ProximityPlacementGroup { get; set; }
		
		/// <summary>
		/// Describes a scale-in policy for a virtual machine scale set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scaleInPolicy")]
		public ScaleInPolicy ScaleInPolicy { get; set; }
		
		/// <summary>
		/// When true this limits the scale set to a single placement group, of max size 100 virtual machines.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="singlePlacementGroup")]
		public System.Nullable<System.Boolean> SinglePlacementGroup { get; set; }
		
		/// <summary>
		/// Describes an upgrade policy - automatic, manual, or rolling.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradePolicy")]
		public UpgradePolicy UpgradePolicy { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set virtual machine profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualMachineProfile")]
		public VirtualMachineScaleSetUpdateVMProfile VirtualMachineProfile { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetUpdatePublicIPAddressConfiguration
	{
		
		/// <summary>
		/// The publicIP address configuration name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public VirtualMachineScaleSetUpdatePublicIPAddressConfigurationProperties Properties { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetUpdatePublicIPAddressConfigurationProperties
	{
		
		/// <summary>
		/// Describes a virtual machines scale sets network configuration's DNS settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsSettings")]
		public VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings DnsSettings { get; set; }
		
		/// <summary>
		/// The idle timeout of the public IP address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="idleTimeoutInMinutes")]
		public System.Nullable<System.Int32> IdleTimeoutInMinutes { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set storage profile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetUpdateStorageProfile
	{
		
		/// <summary>
		/// The data disks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataDisks")]
		public VirtualMachineScaleSetDataDisk[] DataDisks { get; set; }
		
		/// <summary>
		/// Specifies information about the image to use. You can specify information about platform images, marketplace images, or virtual machine images. This element is required when you want to use a platform image, marketplace image, or virtual machine image, but is not used in other creation operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageReference")]
		public ImageReference ImageReference { get; set; }
		
		/// <summary>
		/// Describes virtual machine scale set operating system disk Update Object. This should be used for Updating VMSS OS Disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osDisk")]
		public VirtualMachineScaleSetUpdateOSDisk OsDisk { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set virtual machine profile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetUpdateVMProfile
	{
		
		/// <summary>
		/// Specifies the billing related details of a Azure Spot VM or VMSS. <br><br>Minimum api-version: 2019-03-01.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="billingProfile")]
		public BillingProfile BillingProfile { get; set; }
		
		/// <summary>
		/// Specifies the boot diagnostic settings state. <br><br>Minimum api-version: 2015-06-15.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diagnosticsProfile")]
		public DiagnosticsProfile DiagnosticsProfile { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set extension profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extensionProfile")]
		public VirtualMachineScaleSetExtensionProfile ExtensionProfile { get; set; }
		
		/// <summary>
		/// The license type, which is for bring your own license scenario.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseType")]
		public string LicenseType { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set network profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkProfile")]
		public VirtualMachineScaleSetUpdateNetworkProfile NetworkProfile { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set OS profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osProfile")]
		public VirtualMachineScaleSetUpdateOSProfile OsProfile { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="scheduledEventsProfile")]
		public ScheduledEventsProfile ScheduledEventsProfile { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set storage profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageProfile")]
		public VirtualMachineScaleSetUpdateStorageProfile StorageProfile { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set virtual machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetVM : Resource
	{
		
		/// <summary>
		/// The virtual machine instance ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceId")]
		public string InstanceId { get; set; }
		
		/// <summary>
		/// Specifies information about the marketplace image used to create the virtual machine. This element is only used for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic use.  In the Azure portal, find the marketplace image that you want to use and then click **Want to deploy programmatically, Get Started ->**. Enter any required information and then click **Save**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="plan")]
		public Plan Plan { get; set; }
		
		/// <summary>
		/// Describes the properties of a virtual machine scale set virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public VirtualMachineScaleSetVMProperties Properties { get; set; }
		
		/// <summary>
		/// The virtual machine child extension resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public VirtualMachineExtension[] Resources { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set sku.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sku")]
		public Sku Sku { get; set; }
		
		/// <summary>
		/// The virtual machine zones.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zones")]
		public string[] Zones { get; set; }
	}
	
	/// <summary>
	/// Specifies a list of virtual machine instance IDs from the VM scale set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetVMInstanceIDs
	{
		
		/// <summary>
		/// The virtual machine scale set instance ids. Omitting the virtual machine scale set instance ids will result in the operation being performed on all virtual machines in the virtual machine scale set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceIds")]
		public string[] InstanceIds { get; set; }
	}
	
	/// <summary>
	/// Specifies a list of virtual machine instance IDs from the VM scale set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetVMInstanceRequiredIDs
	{
		
		/// <summary>
		/// The virtual machine scale set instance ids.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="instanceIds")]
		public string[] InstanceIds { get; set; }
	}
	
	/// <summary>
	/// The instance view of a virtual machine scale set VM.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetVMInstanceView
	{
		
		/// <summary>
		/// The instance view of a virtual machine boot diagnostics.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bootDiagnostics")]
		public BootDiagnosticsInstanceView BootDiagnostics { get; set; }
		
		/// <summary>
		/// The disks information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public DiskInstanceView[] Disks { get; set; }
		
		/// <summary>
		/// The extensions information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extensions")]
		public VirtualMachineExtensionInstanceView[] Extensions { get; set; }
		
		/// <summary>
		/// Maintenance Operation Status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maintenanceRedeployStatus")]
		public MaintenanceRedeployStatus MaintenanceRedeployStatus { get; set; }
		
		/// <summary>
		/// The placement group in which the VM is running. If the VM is deallocated it will not have a placementGroupId.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="placementGroupId")]
		public string PlacementGroupId { get; set; }
		
		/// <summary>
		/// The Fault Domain count.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platformFaultDomain")]
		public System.Nullable<System.Int32> PlatformFaultDomain { get; set; }
		
		/// <summary>
		/// The Update Domain count.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platformUpdateDomain")]
		public System.Nullable<System.Int32> PlatformUpdateDomain { get; set; }
		
		/// <summary>
		/// The Remote desktop certificate thumbprint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rdpThumbPrint")]
		public string RdpThumbPrint { get; set; }
		
		/// <summary>
		/// The resource status information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statuses")]
		public InstanceViewStatus[] Statuses { get; set; }
		
		/// <summary>
		/// The instance view of the VM Agent running on the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmAgent")]
		public VirtualMachineAgentInstanceView VmAgent { get; set; }
		
		/// <summary>
		/// The health status of the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmHealth")]
		public VirtualMachineHealthStatus VmHealth { get; set; }
	}
	
	/// <summary>
	/// The List Virtual Machine Scale Set VMs operation response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetVMListResult
	{
		
		/// <summary>
		/// The uri to fetch the next page of Virtual Machine Scale Set VMs. Call ListNext() with this to fetch the next page of VMSS VMs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// The list of virtual machine scale sets VMs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public VirtualMachineScaleSetVM[] Value { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set VM network profile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetVMNetworkProfileConfiguration
	{
		
		/// <summary>
		/// The list of network configurations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkInterfaceConfigurations")]
		public VirtualMachineScaleSetNetworkConfiguration[] NetworkInterfaceConfigurations { get; set; }
	}
	
	/// <summary>
	/// Describes a virtual machine scale set virtual machine profile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetVMProfile
	{
		
		/// <summary>
		/// Specifies the billing related details of a Azure Spot VM or VMSS. <br><br>Minimum api-version: 2019-03-01.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="billingProfile")]
		public BillingProfile BillingProfile { get; set; }
		
		/// <summary>
		/// Specifies the boot diagnostic settings state. <br><br>Minimum api-version: 2015-06-15.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diagnosticsProfile")]
		public DiagnosticsProfile DiagnosticsProfile { get; set; }
		
		/// <summary>
		/// Specifies the eviction policy for the Azure Spot VM/VMSS
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="evictionPolicy")]
		public VirtualMachinePropertiesEvictionPolicy EvictionPolicy { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set extension profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extensionProfile")]
		public VirtualMachineScaleSetExtensionProfile ExtensionProfile { get; set; }
		
		/// <summary>
		/// Specifies that the image or disk that is being used was licensed on-premises. This element is only used for images that contain the Windows Server operating system. <br><br> Possible values are: <br><br> Windows_Client <br><br> Windows_Server <br><br> If this element is included in a request for an update, the value must match the initial value. This value cannot be updated. <br><br> For more information, see [Azure Hybrid Use Benefit for Windows Server](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-hybrid-use-benefit-licensing?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> Minimum api-version: 2015-06-15
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseType")]
		public string LicenseType { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set network profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkProfile")]
		public VirtualMachineScaleSetNetworkProfile NetworkProfile { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set OS profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osProfile")]
		public VirtualMachineScaleSetOSProfile OsProfile { get; set; }
		
		/// <summary>
		/// Specifies the priority for a standalone virtual machine or the virtual machines in the scale set. <br><br> 'Low' enum will be deprecated in the future, please use 'Spot' as the enum to deploy Azure Spot VM/VMSS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public VirtualMachinePropertiesPriority Priority { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="scheduledEventsProfile")]
		public ScheduledEventsProfile ScheduledEventsProfile { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set storage profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageProfile")]
		public VirtualMachineScaleSetStorageProfile StorageProfile { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of a virtual machine scale set virtual machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetVMProperties
	{
		
		/// <summary>
		/// Enables or disables a capability on the virtual machine or virtual machine scale set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalCapabilities")]
		public AdditionalCapabilities AdditionalCapabilities { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="availabilitySet")]
		public SubResource AvailabilitySet { get; set; }
		
		/// <summary>
		/// Specifies the boot diagnostic settings state. <br><br>Minimum api-version: 2015-06-15.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diagnosticsProfile")]
		public DiagnosticsProfile DiagnosticsProfile { get; set; }
		
		/// <summary>
		/// Specifies the hardware settings for the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hardwareProfile")]
		public HardwareProfile HardwareProfile { get; set; }
		
		/// <summary>
		/// The instance view of a virtual machine scale set VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceView")]
		public VirtualMachineScaleSetVMInstanceView InstanceView { get; set; }
		
		/// <summary>
		/// Specifies whether the latest model has been applied to the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latestModelApplied")]
		public System.Nullable<System.Boolean> LatestModelApplied { get; set; }
		
		/// <summary>
		/// Specifies that the image or disk that is being used was licensed on-premises. This element is only used for images that contain the Windows Server operating system. <br><br> Possible values are: <br><br> Windows_Client <br><br> Windows_Server <br><br> If this element is included in a request for an update, the value must match the initial value. This value cannot be updated. <br><br> For more information, see [Azure Hybrid Use Benefit for Windows Server](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-hybrid-use-benefit-licensing?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> Minimum api-version: 2015-06-15
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseType")]
		public string LicenseType { get; set; }
		
		/// <summary>
		/// Specifies whether the model applied to the virtual machine is the model of the virtual machine scale set or the customized model for the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modelDefinitionApplied")]
		public string ModelDefinitionApplied { get; set; }
		
		/// <summary>
		/// Specifies the network interfaces of the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkProfile")]
		public NetworkProfile NetworkProfile { get; set; }
		
		/// <summary>
		/// Describes a virtual machine scale set VM network profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkProfileConfiguration")]
		public VirtualMachineScaleSetVMNetworkProfileConfiguration NetworkProfileConfiguration { get; set; }
		
		/// <summary>
		/// Specifies the operating system settings for the virtual machine. Some of the settings cannot be changed once VM is provisioned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osProfile")]
		public OSProfile OsProfile { get; set; }
		
		/// <summary>
		/// The protection policy of a virtual machine scale set VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protectionPolicy")]
		public VirtualMachineScaleSetVMProtectionPolicy ProtectionPolicy { get; set; }
		
		/// <summary>
		/// The provisioning state, which only appears in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioningState")]
		public string ProvisioningState { get; set; }
		
		/// <summary>
		/// Specifies the storage settings for the virtual machine disks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageProfile")]
		public StorageProfile StorageProfile { get; set; }
		
		/// <summary>
		/// Azure VM unique ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmId")]
		public string VmId { get; set; }
	}
	
	/// <summary>
	/// The protection policy of a virtual machine scale set VM.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetVMProtectionPolicy
	{
		
		/// <summary>
		/// Indicates that the virtual machine scale set VM shouldn't be considered for deletion during a scale-in operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protectFromScaleIn")]
		public System.Nullable<System.Boolean> ProtectFromScaleIn { get; set; }
		
		/// <summary>
		/// Indicates that model updates or actions (including scale-in) initiated on the virtual machine scale set should not be applied to the virtual machine scale set VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protectFromScaleSetActions")]
		public System.Nullable<System.Boolean> ProtectFromScaleSetActions { get; set; }
	}
	
	/// <summary>
	/// Describes a Virtual Machine Scale Set VM Reimage Parameters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineScaleSetVMReimageParameters
	{
	}
	
	/// <summary>
	/// Describes the properties of a VM size.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineSize
	{
		
		/// <summary>
		/// The maximum number of data disks that can be attached to the virtual machine size.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxDataDiskCount")]
		public System.Nullable<System.Int32> MaxDataDiskCount { get; set; }
		
		/// <summary>
		/// The amount of memory, in MB, supported by the virtual machine size.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memoryInMB")]
		public System.Nullable<System.Int32> MemoryInMB { get; set; }
		
		/// <summary>
		/// The name of the virtual machine size.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The number of cores supported by the virtual machine size.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numberOfCores")]
		public System.Nullable<System.Int32> NumberOfCores { get; set; }
		
		/// <summary>
		/// The OS disk size, in MB, allowed by the virtual machine size.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osDiskSizeInMB")]
		public System.Nullable<System.Int32> OsDiskSizeInMB { get; set; }
		
		/// <summary>
		/// The resource disk size, in MB, allowed by the virtual machine size.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceDiskSizeInMB")]
		public System.Nullable<System.Int32> ResourceDiskSizeInMB { get; set; }
	}
	
	/// <summary>
	/// The List Virtual Machine operation response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineSizeListResult
	{
		
		/// <summary>
		/// The list of virtual machine sizes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public VirtualMachineSize[] Value { get; set; }
	}
	
	/// <summary>
	/// Describes a Virtual Machine Update.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineUpdate : UpdateResource
	{
		
		/// <summary>
		/// Identity for the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="identity")]
		public VirtualMachineIdentity Identity { get; set; }
		
		/// <summary>
		/// Specifies information about the marketplace image used to create the virtual machine. This element is only used for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic use.  In the Azure portal, find the marketplace image that you want to use and then click **Want to deploy programmatically, Get Started ->**. Enter any required information and then click **Save**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="plan")]
		public Plan Plan { get; set; }
		
		/// <summary>
		/// Describes the properties of a Virtual Machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public VirtualMachineProperties Properties { get; set; }
		
		/// <summary>
		/// The virtual machine zones.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zones")]
		public string[] Zones { get; set; }
	}
	
	/// <summary>
	/// Describes Windows Remote Management configuration of the VM
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class WinRMConfiguration
	{
		
		/// <summary>
		/// The list of Windows Remote Management listeners
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="listeners")]
		public WinRMListener[] Listeners { get; set; }
	}
	
	/// <summary>
	/// Describes Protocol and thumbprint of Windows Remote Management listener
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class WinRMListener
	{
		
		/// <summary>
		/// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateUrl")]
		public string CertificateUrl { get; set; }
		
		/// <summary>
		/// Specifies the protocol of WinRM listener. <br><br> Possible values are: <br>**http** <br><br> **https**
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public System.Nullable<WinRMListenerProtocol> Protocol { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum WinRMListenerProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Http = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Https = 1,
	}
	
	/// <summary>
	/// Specifies Windows operating system settings on the virtual machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class WindowsConfiguration
	{
		
		/// <summary>
		/// Specifies additional base-64 encoded XML formatted information that can be included in the Unattend.xml file, which is used by Windows Setup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalUnattendContent")]
		public AdditionalUnattendContent[] AdditionalUnattendContent { get; set; }
		
		/// <summary>
		/// Indicates whether Automatic Updates is enabled for the Windows virtual machine. Default value is true. <br><br> For virtual machine scale sets, this property can be updated and updates will take effect on OS reprovisioning.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableAutomaticUpdates")]
		public System.Nullable<System.Boolean> EnableAutomaticUpdates { get; set; }
		
		/// <summary>
		/// Indicates whether virtual machine agent should be provisioned on the virtual machine. <br><br> When this property is not specified in the request body, default behavior is to set it to true.  This will ensure that VM Agent is installed on the VM so that extensions can be added to the VM later.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisionVMAgent")]
		public System.Nullable<System.Boolean> ProvisionVMAgent { get; set; }
		
		/// <summary>
		/// Specifies the time zone of the virtual machine. e.g. "Pacific Standard Time". <br><br> Possible values can be [TimeZoneInfo.Id](https://docs.microsoft.com/en-us/dotnet/api/system.timezoneinfo.id?#System_TimeZoneInfo_Id) value from time zones returned by [TimeZoneInfo.GetSystemTimeZones](https://docs.microsoft.com/en-us/dotnet/api/system.timezoneinfo.getsystemtimezones).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeZone")]
		public string TimeZone { get; set; }
		
		/// <summary>
		/// Describes Windows Remote Management configuration of the VM
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="winRM")]
		public WinRMConfiguration WinRM { get; set; }
	}
	
	/// <summary>
	/// Specifies the eviction policy for the Azure Spot VM/VMSS
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum EvictionPolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Deallocate = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Delete = 1,
	}
	
	/// <summary>
	/// Specifies the priority for a standalone virtual machine or the virtual machines in the scale set. <br><br> 'Low' enum will be deprecated in the future, please use 'Spot' as the enum to deploy Azure Spot VM/VMSS.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Priority
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Regular = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Low = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Spot = 2,
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Gets a list of compute operations.
		/// Operations_List providers/Microsoft.Compute/operations
		/// </summary>
		/// <param name="api_version">Client Api Version.</param>
		/// <returns>OK</returns>
		public async Task<ComputeOperationListResult> Operations_ListAsync(string api_version)
		{
			var requestUri = "providers/Microsoft.Compute/operations?api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ComputeOperationListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all availability sets in a subscription.
		/// AvailabilitySets_ListBySubscription subscriptions/{subscriptionId}/providers/Microsoft.Compute/availabilitySets
		/// </summary>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="expand">The expand expression to apply to the operation.</param>
		/// <returns>OK</returns>
		public async Task<AvailabilitySetListResult> AvailabilitySets_ListBySubscriptionAsync(string api_version, string subscriptionId, string expand)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Compute/availabilitySets?api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&$expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AvailabilitySetListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all of the dedicated host groups in the subscription. Use the nextLink property in the response to get the next page of dedicated host groups.
		/// DedicatedHostGroups_ListBySubscription subscriptions/{subscriptionId}/providers/Microsoft.Compute/hostGroups
		/// </summary>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<DedicatedHostGroupListResult> DedicatedHostGroups_ListBySubscriptionAsync(string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Compute/hostGroups?api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DedicatedHostGroupListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the list of Images in the subscription. Use nextLink property in the response to get the next page of Images. Do this till nextLink is null to fetch all the Images.
		/// Images_List subscriptions/{subscriptionId}/providers/Microsoft.Compute/images
		/// </summary>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<ImageListResult> Images_ListAsync(string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Compute/images?api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ImageListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Export logs that show Api requests made by this subscription in the given time window to show throttling activities.
		/// LogAnalytics_ExportRequestRateByInterval subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/logAnalytics/apiAccess/getRequestRateByInterval
		/// </summary>
		/// <param name="location">The location upon which virtual-machine-sizes is queried.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the LogAnalytics getRequestRateByInterval Api.</param>
		/// <returns>OK</returns>
		public async Task<LogAnalyticsOperationResult> LogAnalytics_ExportRequestRateByIntervalAsync(string location, string api_version, string subscriptionId, RequestRateByIntervalInput requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Compute/locations/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/logAnalytics/apiAccess/getRequestRateByInterval&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LogAnalyticsOperationResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Export logs that show total throttled Api requests for this subscription in the given time window.
		/// LogAnalytics_ExportThrottledRequests subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/logAnalytics/apiAccess/getThrottledRequests
		/// </summary>
		/// <param name="location">The location upon which virtual-machine-sizes is queried.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the LogAnalytics getThrottledRequests Api.</param>
		/// <returns>OK</returns>
		public async Task<LogAnalyticsOperationResult> LogAnalytics_ExportThrottledRequestsAsync(string location, string api_version, string subscriptionId, ThrottledRequestsInput requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Compute/locations/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/logAnalytics/apiAccess/getThrottledRequests&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LogAnalyticsOperationResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets a list of virtual machine image publishers for the specified Azure location.
		/// VirtualMachineImages_ListPublishers subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/publishers
		/// </summary>
		/// <param name="location">The name of a supported Azure region.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineImageResource[]> VirtualMachineImages_ListPublishersAsync(string location, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Compute/locations/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/publishers&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineImageResource[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of virtual machine extension image types.
		/// VirtualMachineExtensionImages_ListTypes subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/publishers/{publisherName}/artifacttypes/vmextension/types
		/// </summary>
		/// <param name="location">The name of a supported Azure region.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineExtensionImage[]> VirtualMachineExtensionImages_ListTypesAsync(string location, string publisherName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Compute/locations/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/publishers/"+ (publisherName==null? "" : System.Uri.EscapeDataString(publisherName))+"/artifacttypes/vmextension/types&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineExtensionImage[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of virtual machine extension image versions.
		/// VirtualMachineExtensionImages_ListVersions subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/publishers/{publisherName}/artifacttypes/vmextension/types/{type}/versions
		/// </summary>
		/// <param name="location">The name of a supported Azure region.</param>
		/// <param name="filter">The filter to apply on the operation.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineExtensionImage[]> VirtualMachineExtensionImages_ListVersionsAsync(string location, string publisherName, string type, string filter, int top, string orderby, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Compute/locations/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/publishers/"+ (publisherName==null? "" : System.Uri.EscapeDataString(publisherName))+"/artifacttypes/vmextension/types/"+ (type==null? "" : System.Uri.EscapeDataString(type))+"/versions&$filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&$top="+top+"&$orderby=" + (orderby==null? "" : System.Uri.EscapeDataString(orderby))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineExtensionImage[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a virtual machine extension image.
		/// VirtualMachineExtensionImages_Get subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/publishers/{publisherName}/artifacttypes/vmextension/types/{type}/versions/{version}
		/// </summary>
		/// <param name="location">The name of a supported Azure region.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineExtensionImage> VirtualMachineExtensionImages_GetAsync(string location, string publisherName, string type, string version, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Compute/locations/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/publishers/"+ (publisherName==null? "" : System.Uri.EscapeDataString(publisherName))+"/artifacttypes/vmextension/types/"+ (type==null? "" : System.Uri.EscapeDataString(type))+"/versions/"+ (version==null? "" : System.Uri.EscapeDataString(version))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineExtensionImage>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of virtual machine image offers for the specified location and publisher.
		/// VirtualMachineImages_ListOffers subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/publishers/{publisherName}/artifacttypes/vmimage/offers
		/// </summary>
		/// <param name="location">The name of a supported Azure region.</param>
		/// <param name="publisherName">A valid image publisher.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineImageResource[]> VirtualMachineImages_ListOffersAsync(string location, string publisherName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Compute/locations/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/publishers/"+ (publisherName==null? "" : System.Uri.EscapeDataString(publisherName))+"/artifacttypes/vmimage/offers&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineImageResource[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of virtual machine image SKUs for the specified location, publisher, and offer.
		/// VirtualMachineImages_ListSkus subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/publishers/{publisherName}/artifacttypes/vmimage/offers/{offer}/skus
		/// </summary>
		/// <param name="location">The name of a supported Azure region.</param>
		/// <param name="publisherName">A valid image publisher.</param>
		/// <param name="offer">A valid image publisher offer.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineImageResource[]> VirtualMachineImages_ListSkusAsync(string location, string publisherName, string offer, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Compute/locations/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/publishers/"+ (publisherName==null? "" : System.Uri.EscapeDataString(publisherName))+"/artifacttypes/vmimage/offers/"+ (offer==null? "" : System.Uri.EscapeDataString(offer))+"/skus&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineImageResource[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of all virtual machine image versions for the specified location, publisher, offer, and SKU.
		/// VirtualMachineImages_List subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/publishers/{publisherName}/artifacttypes/vmimage/offers/{offer}/skus/{skus}/versions
		/// </summary>
		/// <param name="location">The name of a supported Azure region.</param>
		/// <param name="publisherName">A valid image publisher.</param>
		/// <param name="offer">A valid image publisher offer.</param>
		/// <param name="skus">A valid image SKU.</param>
		/// <param name="filter">The filter to apply on the operation.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineImageResource[]> VirtualMachineImages_ListAsync(string location, string publisherName, string offer, string skus, string filter, int top, string orderby, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Compute/locations/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/publishers/"+ (publisherName==null? "" : System.Uri.EscapeDataString(publisherName))+"/artifacttypes/vmimage/offers/"+ (offer==null? "" : System.Uri.EscapeDataString(offer))+"/skus/"+ (skus==null? "" : System.Uri.EscapeDataString(skus))+"/versions&$filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&$top="+top+"&$orderby=" + (orderby==null? "" : System.Uri.EscapeDataString(orderby))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineImageResource[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a virtual machine image.
		/// VirtualMachineImages_Get subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/publishers/{publisherName}/artifacttypes/vmimage/offers/{offer}/skus/{skus}/versions/{version}
		/// </summary>
		/// <param name="location">The name of a supported Azure region.</param>
		/// <param name="publisherName">A valid image publisher.</param>
		/// <param name="offer">A valid image publisher offer.</param>
		/// <param name="skus">A valid image SKU.</param>
		/// <param name="version">A valid image SKU version.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineImage> VirtualMachineImages_GetAsync(string location, string publisherName, string offer, string skus, string version, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Compute/locations/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/publishers/"+ (publisherName==null? "" : System.Uri.EscapeDataString(publisherName))+"/artifacttypes/vmimage/offers/"+ (offer==null? "" : System.Uri.EscapeDataString(offer))+"/skus/"+ (skus==null? "" : System.Uri.EscapeDataString(skus))+"/versions/"+ (version==null? "" : System.Uri.EscapeDataString(version))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineImage>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets, for the specified location, the current compute resource usage information as well as the limits for compute resources under the subscription.
		/// Usage_List subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/usages
		/// </summary>
		/// <param name="location">The location for which resource usage is queried.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<ListUsagesResult> Usage_ListAsync(string location, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Compute/locations/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/usages&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListUsagesResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all the virtual machines under the specified subscription for the specified location.
		/// VirtualMachines_ListByLocation subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/virtualMachines
		/// </summary>
		/// <param name="location">The location for which virtual machines under the subscription are queried.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineListResult> VirtualMachines_ListByLocationAsync(string location, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Compute/locations/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/virtualMachines&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// This API is deprecated. Use [Resources Skus](https://docs.microsoft.com/en-us/rest/api/compute/resourceskus/list)
		/// VirtualMachineSizes_List subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/vmSizes
		/// </summary>
		/// <param name="location">The location upon which virtual-machine-sizes is queried.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineSizeListResult> VirtualMachineSizes_ListAsync(string location, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Compute/locations/"+ (location==null? "" : System.Uri.EscapeDataString(location))+"/vmSizes&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineSizeListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all proximity placement groups in a subscription.
		/// ProximityPlacementGroups_ListBySubscription subscriptions/{subscriptionId}/providers/Microsoft.Compute/proximityPlacementGroups
		/// </summary>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<ProximityPlacementGroupListResult> ProximityPlacementGroups_ListBySubscriptionAsync(string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Compute/proximityPlacementGroups?api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProximityPlacementGroupListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of all VM Scale Sets in the subscription, regardless of the associated resource group. Use nextLink property in the response to get the next page of VM Scale Sets. Do this till nextLink is null to fetch all the VM Scale Sets.
		/// VirtualMachineScaleSets_ListAll subscriptions/{subscriptionId}/providers/Microsoft.Compute/virtualMachineScaleSets
		/// </summary>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineScaleSetListWithLinkResult> VirtualMachineScaleSets_ListAllAsync(string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Compute/virtualMachineScaleSets?api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineScaleSetListWithLinkResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all of the virtual machines in the specified subscription. Use the nextLink property in the response to get the next page of virtual machines.
		/// VirtualMachines_ListAll subscriptions/{subscriptionId}/providers/Microsoft.Compute/virtualMachines
		/// </summary>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="statusOnly">statusOnly=true enables fetching run time status of all Virtual Machines in the subscription.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineListResult> VirtualMachines_ListAllAsync(string api_version, string subscriptionId, string statusOnly)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Compute/virtualMachines?api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&statusOnly=" + (statusOnly==null? "" : System.Uri.EscapeDataString(statusOnly));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all availability sets in a resource group.
		/// AvailabilitySets_List subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/availabilitySets
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<AvailabilitySetListResult> AvailabilitySets_ListAsync(string resourceGroupName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/availabilitySets&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AvailabilitySetListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves information about an availability set.
		/// AvailabilitySets_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/availabilitySets/{availabilitySetName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="availabilitySetName">The name of the availability set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<AvailabilitySet> AvailabilitySets_GetAsync(string resourceGroupName, string availabilitySetName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/availabilitySets/"+ (availabilitySetName==null? "" : System.Uri.EscapeDataString(availabilitySetName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AvailabilitySet>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or update an availability set.
		/// AvailabilitySets_CreateOrUpdate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/availabilitySets/{availabilitySetName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="availabilitySetName">The name of the availability set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Create Availability Set operation.</param>
		/// <returns>OK</returns>
		public async Task<AvailabilitySet> AvailabilitySets_CreateOrUpdateAsync(string resourceGroupName, string availabilitySetName, string api_version, string subscriptionId, AvailabilitySet requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/availabilitySets/"+ (availabilitySetName==null? "" : System.Uri.EscapeDataString(availabilitySetName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AvailabilitySet>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete an availability set.
		/// AvailabilitySets_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/availabilitySets/{availabilitySetName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="availabilitySetName">The name of the availability set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task AvailabilitySets_DeleteAsync(string resourceGroupName, string availabilitySetName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/availabilitySets/"+ (availabilitySetName==null? "" : System.Uri.EscapeDataString(availabilitySetName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an availability set.
		/// AvailabilitySets_Update subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/availabilitySets/{availabilitySetName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="availabilitySetName">The name of the availability set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Update Availability Set operation.</param>
		/// <returns>OK</returns>
		public async Task<AvailabilitySet> AvailabilitySets_UpdateAsync(string resourceGroupName, string availabilitySetName, string api_version, string subscriptionId, AvailabilitySetUpdate requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/availabilitySets/"+ (availabilitySetName==null? "" : System.Uri.EscapeDataString(availabilitySetName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AvailabilitySet>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all available virtual machine sizes that can be used to create a new virtual machine in an existing availability set.
		/// AvailabilitySets_ListAvailableSizes subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/availabilitySets/{availabilitySetName}/vmSizes
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="availabilitySetName">The name of the availability set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineSizeListResult> AvailabilitySets_ListAvailableSizesAsync(string resourceGroupName, string availabilitySetName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/availabilitySets/"+ (availabilitySetName==null? "" : System.Uri.EscapeDataString(availabilitySetName))+"/vmSizes&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineSizeListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all of the dedicated host groups in the specified resource group. Use the nextLink property in the response to get the next page of dedicated host groups.
		/// DedicatedHostGroups_ListByResourceGroup subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<DedicatedHostGroupListResult> DedicatedHostGroups_ListByResourceGroupAsync(string resourceGroupName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/hostGroups&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DedicatedHostGroupListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves information about a dedicated host group.
		/// DedicatedHostGroups_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="hostGroupName">The name of the dedicated host group.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<DedicatedHostGroup> DedicatedHostGroups_GetAsync(string resourceGroupName, string hostGroupName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/hostGroups/"+ (hostGroupName==null? "" : System.Uri.EscapeDataString(hostGroupName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DedicatedHostGroup>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or update a dedicated host group. For details of Dedicated Host and Dedicated Host Groups please see [Dedicated Host Documentation] (https://go.microsoft.com/fwlink/?linkid=2082596)
		/// DedicatedHostGroups_CreateOrUpdate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="hostGroupName">The name of the dedicated host group.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Create Dedicated Host Group.</param>
		/// <returns>OK</returns>
		public async Task<DedicatedHostGroup> DedicatedHostGroups_CreateOrUpdateAsync(string resourceGroupName, string hostGroupName, string api_version, string subscriptionId, DedicatedHostGroup requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/hostGroups/"+ (hostGroupName==null? "" : System.Uri.EscapeDataString(hostGroupName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DedicatedHostGroup>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a dedicated host group.
		/// DedicatedHostGroups_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="hostGroupName">The name of the dedicated host group.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task DedicatedHostGroups_DeleteAsync(string resourceGroupName, string hostGroupName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/hostGroups/"+ (hostGroupName==null? "" : System.Uri.EscapeDataString(hostGroupName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an dedicated host group.
		/// DedicatedHostGroups_Update subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="hostGroupName">The name of the dedicated host group.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Update Dedicated Host Group operation.</param>
		/// <returns>OK</returns>
		public async Task<DedicatedHostGroup> DedicatedHostGroups_UpdateAsync(string resourceGroupName, string hostGroupName, string api_version, string subscriptionId, DedicatedHostGroupUpdate requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/hostGroups/"+ (hostGroupName==null? "" : System.Uri.EscapeDataString(hostGroupName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DedicatedHostGroup>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all of the dedicated hosts in the specified dedicated host group. Use the nextLink property in the response to get the next page of dedicated hosts.
		/// DedicatedHosts_ListByHostGroup subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}/hosts
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="hostGroupName">The name of the dedicated host group.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<DedicatedHostListResult> DedicatedHosts_ListByHostGroupAsync(string resourceGroupName, string hostGroupName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/hostGroups/"+ (hostGroupName==null? "" : System.Uri.EscapeDataString(hostGroupName))+"/hosts&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DedicatedHostListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves information about a dedicated host.
		/// DedicatedHosts_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}/hosts/{hostName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="hostGroupName">The name of the dedicated host group.</param>
		/// <param name="hostName">The name of the dedicated host.</param>
		/// <param name="expand">The expand expression to apply on the operation.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<DedicatedHost> DedicatedHosts_GetAsync(string resourceGroupName, string hostGroupName, string hostName, DedicatedHosts_GetExpand expand, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/hostGroups/"+ (hostGroupName==null? "" : System.Uri.EscapeDataString(hostGroupName))+"/hosts/"+ (hostName==null? "" : System.Uri.EscapeDataString(hostName))+"&$expand=" + expand+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DedicatedHost>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or update a dedicated host .
		/// DedicatedHosts_CreateOrUpdate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}/hosts/{hostName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="hostGroupName">The name of the dedicated host group.</param>
		/// <param name="hostName">The name of the dedicated host .</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Create Dedicated Host.</param>
		/// <returns>OK</returns>
		public async Task<DedicatedHost> DedicatedHosts_CreateOrUpdateAsync(string resourceGroupName, string hostGroupName, string hostName, string api_version, string subscriptionId, DedicatedHost requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/hostGroups/"+ (hostGroupName==null? "" : System.Uri.EscapeDataString(hostGroupName))+"/hosts/"+ (hostName==null? "" : System.Uri.EscapeDataString(hostName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DedicatedHost>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a dedicated host.
		/// DedicatedHosts_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}/hosts/{hostName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="hostGroupName">The name of the dedicated host group.</param>
		/// <param name="hostName">The name of the dedicated host.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task DedicatedHosts_DeleteAsync(string resourceGroupName, string hostGroupName, string hostName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/hostGroups/"+ (hostGroupName==null? "" : System.Uri.EscapeDataString(hostGroupName))+"/hosts/"+ (hostName==null? "" : System.Uri.EscapeDataString(hostName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an dedicated host .
		/// DedicatedHosts_Update subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}/hosts/{hostName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="hostGroupName">The name of the dedicated host group.</param>
		/// <param name="hostName">The name of the dedicated host .</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Update Dedicated Host operation.</param>
		/// <returns>OK</returns>
		public async Task<DedicatedHost> DedicatedHosts_UpdateAsync(string resourceGroupName, string hostGroupName, string hostName, string api_version, string subscriptionId, DedicatedHostUpdate requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/hostGroups/"+ (hostGroupName==null? "" : System.Uri.EscapeDataString(hostGroupName))+"/hosts/"+ (hostName==null? "" : System.Uri.EscapeDataString(hostName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DedicatedHost>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the list of images under a resource group.
		/// Images_ListByResourceGroup subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/images
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<ImageListResult> Images_ListByResourceGroupAsync(string resourceGroupName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/images&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ImageListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets an image.
		/// Images_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/images/{imageName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="imageName">The name of the image.</param>
		/// <param name="expand">The expand expression to apply on the operation.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<Image> Images_GetAsync(string resourceGroupName, string imageName, string expand, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/images/"+ (imageName==null? "" : System.Uri.EscapeDataString(imageName))+"&$expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Image>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or update an image.
		/// Images_CreateOrUpdate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/images/{imageName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="imageName">The name of the image.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Create Image operation.</param>
		/// <returns>OK</returns>
		public async Task<Image> Images_CreateOrUpdateAsync(string resourceGroupName, string imageName, string api_version, string subscriptionId, Image requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/images/"+ (imageName==null? "" : System.Uri.EscapeDataString(imageName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Image>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes an Image.
		/// Images_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/images/{imageName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="imageName">The name of the image.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task Images_DeleteAsync(string resourceGroupName, string imageName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/images/"+ (imageName==null? "" : System.Uri.EscapeDataString(imageName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an image.
		/// Images_Update subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/images/{imageName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="imageName">The name of the image.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Update Image operation.</param>
		/// <returns>OK</returns>
		public async Task<Image> Images_UpdateAsync(string resourceGroupName, string imageName, string api_version, string subscriptionId, ImageUpdate requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/images/"+ (imageName==null? "" : System.Uri.EscapeDataString(imageName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Image>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all proximity placement groups in a resource group.
		/// ProximityPlacementGroups_ListByResourceGroup subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/proximityPlacementGroups
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<ProximityPlacementGroupListResult> ProximityPlacementGroups_ListByResourceGroupAsync(string resourceGroupName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/proximityPlacementGroups&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProximityPlacementGroupListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves information about a proximity placement group .
		/// ProximityPlacementGroups_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/proximityPlacementGroups/{proximityPlacementGroupName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="proximityPlacementGroupName">The name of the proximity placement group.</param>
		/// <param name="includeColocationStatus">includeColocationStatus=true enables fetching the colocation status of all the resources in the proximity placement group.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<ProximityPlacementGroup> ProximityPlacementGroups_GetAsync(string resourceGroupName, string proximityPlacementGroupName, string includeColocationStatus, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/proximityPlacementGroups/"+ (proximityPlacementGroupName==null? "" : System.Uri.EscapeDataString(proximityPlacementGroupName))+"&includeColocationStatus=" + (includeColocationStatus==null? "" : System.Uri.EscapeDataString(includeColocationStatus))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProximityPlacementGroup>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or update a proximity placement group.
		/// ProximityPlacementGroups_CreateOrUpdate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/proximityPlacementGroups/{proximityPlacementGroupName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="proximityPlacementGroupName">The name of the proximity placement group.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Create Proximity Placement Group operation.</param>
		/// <returns>OK</returns>
		public async Task<ProximityPlacementGroup> ProximityPlacementGroups_CreateOrUpdateAsync(string resourceGroupName, string proximityPlacementGroupName, string api_version, string subscriptionId, ProximityPlacementGroup requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/proximityPlacementGroups/"+ (proximityPlacementGroupName==null? "" : System.Uri.EscapeDataString(proximityPlacementGroupName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProximityPlacementGroup>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a proximity placement group.
		/// ProximityPlacementGroups_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/proximityPlacementGroups/{proximityPlacementGroupName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="proximityPlacementGroupName">The name of the proximity placement group.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task ProximityPlacementGroups_DeleteAsync(string resourceGroupName, string proximityPlacementGroupName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/proximityPlacementGroups/"+ (proximityPlacementGroupName==null? "" : System.Uri.EscapeDataString(proximityPlacementGroupName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a proximity placement group.
		/// ProximityPlacementGroups_Update subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/proximityPlacementGroups/{proximityPlacementGroupName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="proximityPlacementGroupName">The name of the proximity placement group.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Update Proximity Placement Group operation.</param>
		/// <returns>OK</returns>
		public async Task<ProximityPlacementGroup> ProximityPlacementGroups_UpdateAsync(string resourceGroupName, string proximityPlacementGroupName, string api_version, string subscriptionId, ProximityPlacementGroupUpdate requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/proximityPlacementGroups/"+ (proximityPlacementGroupName==null? "" : System.Uri.EscapeDataString(proximityPlacementGroupName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProximityPlacementGroup>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets a list of all VM scale sets under a resource group.
		/// VirtualMachineScaleSets_List subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineScaleSetListResult> VirtualMachineScaleSets_ListAsync(string resourceGroupName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineScaleSetListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of all virtual machines in a VM scale sets.
		/// VirtualMachineScaleSetVMs_List subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{virtualMachineScaleSetName}/virtualMachines
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="virtualMachineScaleSetName">The name of the VM scale set.</param>
		/// <param name="filter">The filter to apply to the operation.</param>
		/// <param name="select">The list parameters.</param>
		/// <param name="expand">The expand expression to apply to the operation.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineScaleSetVMListResult> VirtualMachineScaleSetVMs_ListAsync(string resourceGroupName, string virtualMachineScaleSetName, string filter, string select, string expand, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (virtualMachineScaleSetName==null? "" : System.Uri.EscapeDataString(virtualMachineScaleSetName))+"/virtualMachines&$filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&$select=" + (select==null? "" : System.Uri.EscapeDataString(select))+"&$expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineScaleSetVMListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Display information about a virtual machine scale set.
		/// VirtualMachineScaleSets_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineScaleSet> VirtualMachineScaleSets_GetAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineScaleSet>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or update a VM scale set.
		/// VirtualMachineScaleSets_CreateOrUpdate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set to create or update.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">The scale set object.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineScaleSet> VirtualMachineScaleSets_CreateOrUpdateAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId, VirtualMachineScaleSet requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineScaleSet>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a VM scale set.
		/// VirtualMachineScaleSets_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSets_DeleteAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a VM scale set.
		/// VirtualMachineScaleSets_Update subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set to create or update.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">The scale set object.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineScaleSet> VirtualMachineScaleSets_UpdateAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId, VirtualMachineScaleSetUpdate requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineScaleSet>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Converts SinglePlacementGroup property to false for a existing virtual machine scale set.
		/// VirtualMachineScaleSets_ConvertToSinglePlacementGroup subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/convertToSinglePlacementGroup
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the virtual machine scale set to create or update.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">The input object for ConvertToSinglePlacementGroup API.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSets_ConvertToSinglePlacementGroupAsync(string resourceGroupName, string vmScaleSetName, string subscriptionId, VMScaleSetConvertToSinglePlacementGroupInput requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/convertToSinglePlacementGroup";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deallocates specific virtual machines in a VM scale set. Shuts down the virtual machines and releases the compute resources. You are not billed for the compute resources that this virtual machine scale set deallocates.
		/// VirtualMachineScaleSets_Deallocate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/deallocate
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">A list of virtual machine instance IDs from the VM scale set.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSets_DeallocateAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId, VirtualMachineScaleSetVMInstanceIDs requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/deallocate&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes virtual machines in a VM scale set.
		/// VirtualMachineScaleSets_DeleteInstances subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/delete
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">A list of virtual machine instance IDs from the VM scale set.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSets_DeleteInstancesAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId, VirtualMachineScaleSetVMInstanceRequiredIDs requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/delete&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Starts a rolling upgrade to move all extensions for all virtual machine scale set instances to the latest available extension version. Instances which are already running the latest extension versions are not affected.
		/// VirtualMachineScaleSetRollingUpgrades_StartExtensionUpgrade subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/extensionRollingUpgrade
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSetRollingUpgrades_StartExtensionUpgradeAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/extensionRollingUpgrade&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of all extensions in a VM scale set.
		/// VirtualMachineScaleSetExtensions_List subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/extensions
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set containing the extension.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineScaleSetExtensionListResult> VirtualMachineScaleSetExtensions_ListAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/extensions&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineScaleSetExtensionListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The operation to get the extension.
		/// VirtualMachineScaleSetExtensions_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/extensions/{vmssExtensionName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set containing the extension.</param>
		/// <param name="vmssExtensionName">The name of the VM scale set extension.</param>
		/// <param name="expand">The expand expression to apply on the operation.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineScaleSetExtension> VirtualMachineScaleSetExtensions_GetAsync(string resourceGroupName, string vmScaleSetName, string vmssExtensionName, string expand, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/extensions/"+ (vmssExtensionName==null? "" : System.Uri.EscapeDataString(vmssExtensionName))+"&$expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineScaleSetExtension>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The operation to create or update an extension.
		/// VirtualMachineScaleSetExtensions_CreateOrUpdate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/extensions/{vmssExtensionName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set where the extension should be create or updated.</param>
		/// <param name="vmssExtensionName">The name of the VM scale set extension.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Create VM scale set Extension operation.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineScaleSetExtension> VirtualMachineScaleSetExtensions_CreateOrUpdateAsync(string resourceGroupName, string vmScaleSetName, string vmssExtensionName, string api_version, string subscriptionId, VirtualMachineScaleSetExtension requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/extensions/"+ (vmssExtensionName==null? "" : System.Uri.EscapeDataString(vmssExtensionName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineScaleSetExtension>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// The operation to delete the extension.
		/// VirtualMachineScaleSetExtensions_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/extensions/{vmssExtensionName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set where the extension should be deleted.</param>
		/// <param name="vmssExtensionName">The name of the VM scale set extension.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSetExtensions_DeleteAsync(string resourceGroupName, string vmScaleSetName, string vmssExtensionName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/extensions/"+ (vmssExtensionName==null? "" : System.Uri.EscapeDataString(vmssExtensionName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The operation to update an extension.
		/// VirtualMachineScaleSetExtensions_Update subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/extensions/{vmssExtensionName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set where the extension should be updated.</param>
		/// <param name="vmssExtensionName">The name of the VM scale set extension.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Update VM scale set Extension operation.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineScaleSetExtension> VirtualMachineScaleSetExtensions_UpdateAsync(string resourceGroupName, string vmScaleSetName, string vmssExtensionName, string api_version, string subscriptionId, VirtualMachineScaleSetExtensionUpdate requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/extensions/"+ (vmssExtensionName==null? "" : System.Uri.EscapeDataString(vmssExtensionName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineScaleSetExtension>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Manual platform update domain walk to update virtual machines in a service fabric virtual machine scale set.
		/// VirtualMachineScaleSets_ForceRecoveryServiceFabricPlatformUpdateDomainWalk subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/forceRecoveryServiceFabricPlatformUpdateDomainWalk
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="platformUpdateDomain">The platform update domain for which a manual recovery walk is requested</param>
		/// <returns>OK</returns>
		public async Task<RecoveryWalkResponse> VirtualMachineScaleSets_ForceRecoveryServiceFabricPlatformUpdateDomainWalkAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId, int platformUpdateDomain)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/forceRecoveryServiceFabricPlatformUpdateDomainWalk&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&platformUpdateDomain="+platformUpdateDomain;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RecoveryWalkResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the status of a VM scale set instance.
		/// VirtualMachineScaleSets_GetInstanceView subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/instanceView
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineScaleSetInstanceView> VirtualMachineScaleSets_GetInstanceViewAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/instanceView&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineScaleSetInstanceView>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Upgrades one or more virtual machines to the latest SKU set in the VM scale set model.
		/// VirtualMachineScaleSets_UpdateInstances subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/manualupgrade
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">A list of virtual machine instance IDs from the VM scale set.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSets_UpdateInstancesAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId, VirtualMachineScaleSetVMInstanceRequiredIDs requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/manualupgrade&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Starts a rolling upgrade to move all virtual machine scale set instances to the latest available Platform Image OS version. Instances which are already running the latest available OS version are not affected.
		/// VirtualMachineScaleSetRollingUpgrades_StartOSUpgrade subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/osRollingUpgrade
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSetRollingUpgrades_StartOSUpgradeAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/osRollingUpgrade&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets list of OS upgrades on a VM scale set instance.
		/// VirtualMachineScaleSets_GetOSUpgradeHistory subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/osUpgradeHistory
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineScaleSetListOSUpgradeHistory> VirtualMachineScaleSets_GetOSUpgradeHistoryAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/osUpgradeHistory&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineScaleSetListOSUpgradeHistory>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Perform maintenance on one or more virtual machines in a VM scale set. Operation on instances which are not eligible for perform maintenance will be failed. Please refer to best practices for more details: https://docs.microsoft.com/en-us/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-maintenance-notifications
		/// VirtualMachineScaleSets_PerformMaintenance subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/performMaintenance
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">A list of virtual machine instance IDs from the VM scale set.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSets_PerformMaintenanceAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId, VirtualMachineScaleSetVMInstanceIDs requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/performMaintenance&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Power off (stop) one or more virtual machines in a VM scale set. Note that resources are still attached and you are getting charged for the resources. Instead, use deallocate to release resources and avoid charges.
		/// VirtualMachineScaleSets_PowerOff subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/poweroff
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="skipShutdown">The parameter to request non-graceful VM shutdown. True value for this flag indicates non-graceful shutdown whereas false indicates otherwise. Default value for this flag is false if not specified</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">A list of virtual machine instance IDs from the VM scale set.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSets_PowerOffAsync(string resourceGroupName, string vmScaleSetName, bool skipShutdown, string api_version, string subscriptionId, VirtualMachineScaleSetVMInstanceIDs requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/poweroff&skipShutdown="+skipShutdown+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Shuts down all the virtual machines in the virtual machine scale set, moves them to a new node, and powers them back on.
		/// VirtualMachineScaleSets_Redeploy subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/redeploy
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">A list of virtual machine instance IDs from the VM scale set.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSets_RedeployAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId, VirtualMachineScaleSetVMInstanceIDs requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/redeploy&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Reimages (upgrade the operating system) one or more virtual machines in a VM scale set which don't have a ephemeral OS disk, for virtual machines who have a ephemeral OS disk the virtual machine is reset to initial state.
		/// VirtualMachineScaleSets_Reimage subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/reimage
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters for Reimaging VM ScaleSet.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSets_ReimageAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId, VirtualMachineScaleSetReimageParameters requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/reimage&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Reimages all the disks ( including data disks ) in the virtual machines in a VM scale set. This operation is only supported for managed disks.
		/// VirtualMachineScaleSets_ReimageAll subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/reimageall
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">A list of virtual machine instance IDs from the VM scale set.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSets_ReimageAllAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId, VirtualMachineScaleSetVMInstanceIDs requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/reimageall&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Restarts one or more virtual machines in a VM scale set.
		/// VirtualMachineScaleSets_Restart subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/restart
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">A list of virtual machine instance IDs from the VM scale set.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSets_RestartAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId, VirtualMachineScaleSetVMInstanceIDs requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/restart&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Cancels the current virtual machine scale set rolling upgrade.
		/// VirtualMachineScaleSetRollingUpgrades_Cancel subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/rollingUpgrades/cancel
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSetRollingUpgrades_CancelAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/rollingUpgrades/cancel&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the status of the latest virtual machine scale set rolling upgrade.
		/// VirtualMachineScaleSetRollingUpgrades_GetLatest subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/rollingUpgrades/latest
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<RollingUpgradeStatusInfo> VirtualMachineScaleSetRollingUpgrades_GetLatestAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/rollingUpgrades/latest&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RollingUpgradeStatusInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a list of SKUs available for your VM scale set, including the minimum and maximum VM instances allowed for each SKU.
		/// VirtualMachineScaleSets_ListSkus subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/skus
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineScaleSetListSkusResult> VirtualMachineScaleSets_ListSkusAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/skus&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineScaleSetListSkusResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Starts one or more virtual machines in a VM scale set.
		/// VirtualMachineScaleSets_Start subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/start
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">A list of virtual machine instance IDs from the VM scale set.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSets_StartAsync(string resourceGroupName, string vmScaleSetName, string api_version, string subscriptionId, VirtualMachineScaleSetVMInstanceIDs requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/start&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// The operation to get all extensions of an instance in Virtual Machine Scaleset.
		/// VirtualMachineScaleSetVMExtensions_List subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/extensions
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="instanceId">The instance ID of the virtual machine.</param>
		/// <param name="expand">The expand expression to apply on the operation.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineExtensionsListResult> VirtualMachineScaleSetVMExtensions_ListAsync(string resourceGroupName, string vmScaleSetName, string instanceId, string expand, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/virtualMachines/"+ (instanceId==null? "" : System.Uri.EscapeDataString(instanceId))+"/extensions&$expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineExtensionsListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The operation to get the VMSS VM extension.
		/// VirtualMachineScaleSetVMExtensions_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/extensions/{vmExtensionName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="instanceId">The instance ID of the virtual machine.</param>
		/// <param name="vmExtensionName">The name of the virtual machine extension.</param>
		/// <param name="expand">The expand expression to apply on the operation.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineExtension> VirtualMachineScaleSetVMExtensions_GetAsync(string resourceGroupName, string vmScaleSetName, string instanceId, string vmExtensionName, string expand, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/virtualMachines/"+ (instanceId==null? "" : System.Uri.EscapeDataString(instanceId))+"/extensions/"+ (vmExtensionName==null? "" : System.Uri.EscapeDataString(vmExtensionName))+"&$expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineExtension>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The operation to create or update the VMSS VM extension.
		/// VirtualMachineScaleSetVMExtensions_CreateOrUpdate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/extensions/{vmExtensionName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="instanceId">The instance ID of the virtual machine.</param>
		/// <param name="vmExtensionName">The name of the virtual machine extension.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Create Virtual Machine Extension operation.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineExtension> VirtualMachineScaleSetVMExtensions_CreateOrUpdateAsync(string resourceGroupName, string vmScaleSetName, string instanceId, string vmExtensionName, string api_version, string subscriptionId, VirtualMachineExtension requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/virtualMachines/"+ (instanceId==null? "" : System.Uri.EscapeDataString(instanceId))+"/extensions/"+ (vmExtensionName==null? "" : System.Uri.EscapeDataString(vmExtensionName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineExtension>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// The operation to delete the VMSS VM extension.
		/// VirtualMachineScaleSetVMExtensions_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/extensions/{vmExtensionName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="instanceId">The instance ID of the virtual machine.</param>
		/// <param name="vmExtensionName">The name of the virtual machine extension.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSetVMExtensions_DeleteAsync(string resourceGroupName, string vmScaleSetName, string instanceId, string vmExtensionName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/virtualMachines/"+ (instanceId==null? "" : System.Uri.EscapeDataString(instanceId))+"/extensions/"+ (vmExtensionName==null? "" : System.Uri.EscapeDataString(vmExtensionName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The operation to update the VMSS VM extension.
		/// VirtualMachineScaleSetVMExtensions_Update subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/extensions/{vmExtensionName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="instanceId">The instance ID of the virtual machine.</param>
		/// <param name="vmExtensionName">The name of the virtual machine extension.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Update Virtual Machine Extension operation.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineExtension> VirtualMachineScaleSetVMExtensions_UpdateAsync(string resourceGroupName, string vmScaleSetName, string instanceId, string vmExtensionName, string api_version, string subscriptionId, VirtualMachineExtensionUpdate requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/virtualMachines/"+ (instanceId==null? "" : System.Uri.EscapeDataString(instanceId))+"/extensions/"+ (vmExtensionName==null? "" : System.Uri.EscapeDataString(vmExtensionName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineExtension>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets a virtual machine from a VM scale set.
		/// VirtualMachineScaleSetVMs_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="instanceId">The instance ID of the virtual machine.</param>
		/// <param name="expand">The expand expression to apply on the operation.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineScaleSetVM> VirtualMachineScaleSetVMs_GetAsync(string resourceGroupName, string vmScaleSetName, string instanceId, DedicatedHosts_GetExpand expand, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/virtualmachines/"+ (instanceId==null? "" : System.Uri.EscapeDataString(instanceId))+"&$expand=" + expand+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineScaleSetVM>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a virtual machine of a VM scale set.
		/// VirtualMachineScaleSetVMs_Update subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set where the extension should be create or updated.</param>
		/// <param name="instanceId">The instance ID of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Update Virtual Machine Scale Sets VM operation.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineScaleSetVM> VirtualMachineScaleSetVMs_UpdateAsync(string resourceGroupName, string vmScaleSetName, string instanceId, string api_version, string subscriptionId, VirtualMachineScaleSetVM requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/virtualmachines/"+ (instanceId==null? "" : System.Uri.EscapeDataString(instanceId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineScaleSetVM>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a virtual machine from a VM scale set.
		/// VirtualMachineScaleSetVMs_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="instanceId">The instance ID of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSetVMs_DeleteAsync(string resourceGroupName, string vmScaleSetName, string instanceId, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/virtualmachines/"+ (instanceId==null? "" : System.Uri.EscapeDataString(instanceId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deallocates a specific virtual machine in a VM scale set. Shuts down the virtual machine and releases the compute resources it uses. You are not billed for the compute resources of this virtual machine once it is deallocated.
		/// VirtualMachineScaleSetVMs_Deallocate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}/deallocate
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="instanceId">The instance ID of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSetVMs_DeallocateAsync(string resourceGroupName, string vmScaleSetName, string instanceId, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/virtualmachines/"+ (instanceId==null? "" : System.Uri.EscapeDataString(instanceId))+"/deallocate&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the status of a virtual machine from a VM scale set.
		/// VirtualMachineScaleSetVMs_GetInstanceView subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}/instanceView
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="instanceId">The instance ID of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineScaleSetVMInstanceView> VirtualMachineScaleSetVMs_GetInstanceViewAsync(string resourceGroupName, string vmScaleSetName, string instanceId, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/virtualmachines/"+ (instanceId==null? "" : System.Uri.EscapeDataString(instanceId))+"/instanceView&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineScaleSetVMInstanceView>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Performs maintenance on a virtual machine in a VM scale set.
		/// VirtualMachineScaleSetVMs_PerformMaintenance subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}/performMaintenance
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="instanceId">The instance ID of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSetVMs_PerformMaintenanceAsync(string resourceGroupName, string vmScaleSetName, string instanceId, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/virtualmachines/"+ (instanceId==null? "" : System.Uri.EscapeDataString(instanceId))+"/performMaintenance&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Power off (stop) a virtual machine in a VM scale set. Note that resources are still attached and you are getting charged for the resources. Instead, use deallocate to release resources and avoid charges.
		/// VirtualMachineScaleSetVMs_PowerOff subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}/poweroff
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="instanceId">The instance ID of the virtual machine.</param>
		/// <param name="skipShutdown">The parameter to request non-graceful VM shutdown. True value for this flag indicates non-graceful shutdown whereas false indicates otherwise. Default value for this flag is false if not specified</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSetVMs_PowerOffAsync(string resourceGroupName, string vmScaleSetName, string instanceId, bool skipShutdown, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/virtualmachines/"+ (instanceId==null? "" : System.Uri.EscapeDataString(instanceId))+"/poweroff&skipShutdown="+skipShutdown+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Shuts down the virtual machine in the virtual machine scale set, moves it to a new node, and powers it back on.
		/// VirtualMachineScaleSetVMs_Redeploy subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}/redeploy
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="instanceId">The instance ID of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSetVMs_RedeployAsync(string resourceGroupName, string vmScaleSetName, string instanceId, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/virtualmachines/"+ (instanceId==null? "" : System.Uri.EscapeDataString(instanceId))+"/redeploy&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reimages (upgrade the operating system) a specific virtual machine in a VM scale set.
		/// VirtualMachineScaleSetVMs_Reimage subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}/reimage
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="instanceId">The instance ID of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters for the Reimaging Virtual machine in ScaleSet.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSetVMs_ReimageAsync(string resourceGroupName, string vmScaleSetName, string instanceId, string api_version, string subscriptionId, VirtualMachineScaleSetVMReimageParameters requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/virtualmachines/"+ (instanceId==null? "" : System.Uri.EscapeDataString(instanceId))+"/reimage&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Allows you to re-image all the disks ( including data disks ) in the a VM scale set instance. This operation is only supported for managed disks.
		/// VirtualMachineScaleSetVMs_ReimageAll subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}/reimageall
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="instanceId">The instance ID of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSetVMs_ReimageAllAsync(string resourceGroupName, string vmScaleSetName, string instanceId, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/virtualmachines/"+ (instanceId==null? "" : System.Uri.EscapeDataString(instanceId))+"/reimageall&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Restarts a virtual machine in a VM scale set.
		/// VirtualMachineScaleSetVMs_Restart subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}/restart
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="instanceId">The instance ID of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSetVMs_RestartAsync(string resourceGroupName, string vmScaleSetName, string instanceId, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/virtualmachines/"+ (instanceId==null? "" : System.Uri.EscapeDataString(instanceId))+"/restart&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Starts a virtual machine in a VM scale set.
		/// VirtualMachineScaleSetVMs_Start subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}/start
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmScaleSetName">The name of the VM scale set.</param>
		/// <param name="instanceId">The instance ID of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineScaleSetVMs_StartAsync(string resourceGroupName, string vmScaleSetName, string instanceId, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachineScaleSets/"+ (vmScaleSetName==null? "" : System.Uri.EscapeDataString(vmScaleSetName))+"/virtualmachines/"+ (instanceId==null? "" : System.Uri.EscapeDataString(instanceId))+"/start&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all of the virtual machines in the specified resource group. Use the nextLink property in the response to get the next page of virtual machines.
		/// VirtualMachines_List subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineListResult> VirtualMachines_ListAsync(string resourceGroupName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves information about the model view or the instance view of a virtual machine.
		/// VirtualMachines_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine.</param>
		/// <param name="expand">The expand expression to apply on the operation.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachine> VirtualMachines_GetAsync(string resourceGroupName, string vmName, DedicatedHosts_GetExpand expand, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"&$expand=" + expand+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachine>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The operation to create or update a virtual machine. Please note some properties can be set only during virtual machine creation.
		/// VirtualMachines_CreateOrUpdate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Create Virtual Machine operation.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachine> VirtualMachines_CreateOrUpdateAsync(string resourceGroupName, string vmName, string api_version, string subscriptionId, VirtualMachine requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachine>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// The operation to delete a virtual machine.
		/// VirtualMachines_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachines_DeleteAsync(string resourceGroupName, string vmName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The operation to update a virtual machine.
		/// VirtualMachines_Update subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Update Virtual Machine operation.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachine> VirtualMachines_UpdateAsync(string resourceGroupName, string vmName, string api_version, string subscriptionId, VirtualMachineUpdate requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachine>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Captures the VM by copying virtual hard disks of the VM and outputs a template that can be used to create similar VMs.
		/// VirtualMachines_Capture subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/capture
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Capture Virtual Machine operation.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineCaptureResult> VirtualMachines_CaptureAsync(string resourceGroupName, string vmName, string api_version, string subscriptionId, VirtualMachineCaptureParameters requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"/capture&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineCaptureResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Converts virtual machine disks from blob-based to managed disks. Virtual machine must be stop-deallocated before invoking this operation.
		/// VirtualMachines_ConvertToManagedDisks subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/convertToManagedDisks
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachines_ConvertToManagedDisksAsync(string resourceGroupName, string vmName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"/convertToManagedDisks&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Shuts down the virtual machine and releases the compute resources. You are not billed for the compute resources that this virtual machine uses.
		/// VirtualMachines_Deallocate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/deallocate
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachines_DeallocateAsync(string resourceGroupName, string vmName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"/deallocate&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The operation to get all extensions of a Virtual Machine.
		/// VirtualMachineExtensions_List subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/extensions
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine containing the extension.</param>
		/// <param name="expand">The expand expression to apply on the operation.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineExtensionsListResult> VirtualMachineExtensions_ListAsync(string resourceGroupName, string vmName, string expand, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"/extensions&$expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineExtensionsListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The operation to get the extension.
		/// VirtualMachineExtensions_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/extensions/{vmExtensionName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine containing the extension.</param>
		/// <param name="vmExtensionName">The name of the virtual machine extension.</param>
		/// <param name="expand">The expand expression to apply on the operation.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineExtension> VirtualMachineExtensions_GetAsync(string resourceGroupName, string vmName, string vmExtensionName, string expand, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"/extensions/"+ (vmExtensionName==null? "" : System.Uri.EscapeDataString(vmExtensionName))+"&$expand=" + (expand==null? "" : System.Uri.EscapeDataString(expand))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineExtension>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The operation to create or update the extension.
		/// VirtualMachineExtensions_CreateOrUpdate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/extensions/{vmExtensionName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine where the extension should be created or updated.</param>
		/// <param name="vmExtensionName">The name of the virtual machine extension.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Create Virtual Machine Extension operation.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineExtension> VirtualMachineExtensions_CreateOrUpdateAsync(string resourceGroupName, string vmName, string vmExtensionName, string api_version, string subscriptionId, VirtualMachineExtension requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"/extensions/"+ (vmExtensionName==null? "" : System.Uri.EscapeDataString(vmExtensionName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineExtension>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// The operation to delete the extension.
		/// VirtualMachineExtensions_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/extensions/{vmExtensionName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine where the extension should be deleted.</param>
		/// <param name="vmExtensionName">The name of the virtual machine extension.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachineExtensions_DeleteAsync(string resourceGroupName, string vmName, string vmExtensionName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"/extensions/"+ (vmExtensionName==null? "" : System.Uri.EscapeDataString(vmExtensionName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The operation to update the extension.
		/// VirtualMachineExtensions_Update subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/extensions/{vmExtensionName}
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine where the extension should be updated.</param>
		/// <param name="vmExtensionName">The name of the virtual machine extension.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Update Virtual Machine Extension operation.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineExtension> VirtualMachineExtensions_UpdateAsync(string resourceGroupName, string vmName, string vmExtensionName, string api_version, string subscriptionId, VirtualMachineExtensionUpdate requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"/extensions/"+ (vmExtensionName==null? "" : System.Uri.EscapeDataString(vmExtensionName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineExtension>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the OS state of the virtual machine to generalized. It is recommended to sysprep the virtual machine before performing this operation. <br>For Windows, please refer to [Create a managed image of a generalized VM in Azure](https://docs.microsoft.com/en-us/azure/virtual-machines/windows/capture-image-resource).<br>For Linux, please refer to [How to create an image of a virtual machine or VHD](https://docs.microsoft.com/en-us/azure/virtual-machines/linux/capture-image).
		/// VirtualMachines_Generalize subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/generalize
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachines_GeneralizeAsync(string resourceGroupName, string vmName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"/generalize&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves information about the run-time state of a virtual machine.
		/// VirtualMachines_InstanceView subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/instanceView
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineInstanceView> VirtualMachines_InstanceViewAsync(string resourceGroupName, string vmName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"/instanceView&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineInstanceView>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The operation to perform maintenance on a virtual machine.
		/// VirtualMachines_PerformMaintenance subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/performMaintenance
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachines_PerformMaintenanceAsync(string resourceGroupName, string vmName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"/performMaintenance&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The operation to power off (stop) a virtual machine. The virtual machine can be restarted with the same provisioned resources. You are still charged for this virtual machine.
		/// VirtualMachines_PowerOff subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/powerOff
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine.</param>
		/// <param name="skipShutdown">The parameter to request non-graceful VM shutdown. True value for this flag indicates non-graceful shutdown whereas false indicates otherwise. Default value for this flag is false if not specified</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachines_PowerOffAsync(string resourceGroupName, string vmName, bool skipShutdown, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"/powerOff&skipShutdown="+skipShutdown+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The operation to reapply a virtual machine's state.
		/// VirtualMachines_Reapply subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/reapply
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachines_ReapplyAsync(string resourceGroupName, string vmName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"/reapply&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Shuts down the virtual machine, moves it to a new node, and powers it back on.
		/// VirtualMachines_Redeploy subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/redeploy
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachines_RedeployAsync(string resourceGroupName, string vmName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"/redeploy&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reimages the virtual machine which has an ephemeral OS disk back to its initial state.
		/// VirtualMachines_Reimage subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/reimage
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <param name="requestBody">Parameters supplied to the Reimage Virtual Machine operation.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachines_ReimageAsync(string resourceGroupName, string vmName, string api_version, string subscriptionId, VirtualMachineReimageParameters requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"/reimage&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// The operation to restart a virtual machine.
		/// VirtualMachines_Restart subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/restart
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachines_RestartAsync(string resourceGroupName, string vmName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"/restart&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The operation to start a virtual machine.
		/// VirtualMachines_Start subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/start
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task VirtualMachines_StartAsync(string resourceGroupName, string vmName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"/start&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all available virtual machine sizes to which the specified virtual machine can be resized.
		/// VirtualMachines_ListAvailableSizes subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/vmSizes
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group.</param>
		/// <param name="vmName">The name of the virtual machine.</param>
		/// <param name="api_version">Client Api Version.</param>
		/// <param name="subscriptionId">Subscription credentials which uniquely identify Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
		/// <returns>OK</returns>
		public async Task<VirtualMachineSizeListResult> VirtualMachines_ListAvailableSizesAsync(string resourceGroupName, string vmName, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Compute/virtualMachines/"+ (vmName==null? "" : System.Uri.EscapeDataString(vmName))+"/vmSizes&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VirtualMachineSizeListResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum DedicatedHosts_GetExpand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		instanceView = 0,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
