//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// A process accepting on a port.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Acceptor : Relationship
	{
		
		/// <summary>
		/// Properties for an acceptor relationship.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public AcceptorProperties Properties { get; set; }
	}
	
	/// <summary>
	/// Properties for an acceptor relationship.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class AcceptorProperties
	{
		
		/// <summary>
		/// Reference to a process.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public ProcessReference Destination { get; set; }
		
		/// <summary>
		/// Relationship end time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.Nullable<System.DateTimeOffset> EndTime { get; set; }
		
		/// <summary>
		/// Reference to a port.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public PortReference Source { get; set; }
		
		/// <summary>
		/// Relationship start time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.Nullable<System.DateTimeOffset> StartTime { get; set; }
	}
	
	/// <summary>
	/// Specifies the accuracy of a computation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Accuracy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		actual = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		estimated = 1,
	}
	
	/// <summary>
	/// Describes the configuration of the Dependency Agent installed on a machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class AgentConfiguration
	{
		
		/// <summary>
		/// Health Service Agent unique identifier.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="agentId")]
		public string AgentId { get; set; }
		
		/// <summary>
		/// Machine clock granularity in milliseconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clockGranularity")]
		public System.Nullable<System.Int32> ClockGranularity { get; set; }
		
		/// <summary>
		/// Dependency Agent unique identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dependencyAgentId")]
		public string DependencyAgentId { get; set; }
		
		/// <summary>
		/// Dependency Agent revision number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dependencyAgentRevision")]
		public string DependencyAgentRevision { get; set; }
		
		/// <summary>
		/// Dependency Agent version number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dependencyAgentVersion")]
		public string DependencyAgentVersion { get; set; }
		
		/// <summary>
		/// Specifies if the machine has been rebooted since the installation of the dependency agent.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rebootStatus")]
		public System.Nullable<AgentConfigurationRebootStatus> RebootStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum AgentConfigurationRebootStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rebooted = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		notRebooted = 2,
	}
	
	/// <summary>
	/// Describes an Azure Cloud Service
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class AzureCloudServiceConfiguration
	{
		
		/// <summary>
		/// Cloud Service deployment identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deployment")]
		public string Deployment { get; set; }
		
		/// <summary>
		/// Cloud Service instance identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceId")]
		public string InstanceId { get; set; }
		
		/// <summary>
		/// Cloud Service name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Cloud Service role name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="roleName")]
		public string RoleName { get; set; }
		
		/// <summary>
		/// Used to specify type of an Azure Cloud Service role
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="roleType")]
		public System.Nullable<AzureCloudServiceConfigurationRoleType> RoleType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum AzureCloudServiceConfigurationRoleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		worker = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		web = 2,
	}
	
	/// <summary>
	/// Provides information about how a machine is hosted in Azure
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class AzureHostingConfiguration : HostingConfiguration
	{
		
		/// <summary>
		/// Describes an Azure Cloud Service
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloudService")]
		public AzureCloudServiceConfiguration CloudService { get; set; }
		
		/// <summary>
		/// Fault domain of the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="faultDomain")]
		public string FaultDomain { get; set; }
		
		/// <summary>
		/// Describes the VM image of a machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public ImageConfiguration Image { get; set; }
		
		/// <summary>
		/// Geographical location of the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Machine name according to the hosting provider.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Resource group name within the specified subscription.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceGroup")]
		public string ResourceGroup { get; set; }
		
		/// <summary>
		/// Unique identifier of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceId")]
		public string ResourceId { get; set; }
		
		/// <summary>
		/// Describes an Azure Service Fabric Cluster
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceFabricCluster")]
		public AzureServiceFabricClusterConfiguration ServiceFabricCluster { get; set; }
		
		/// <summary>
		/// Size of the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public string Size { get; set; }
		
		/// <summary>
		/// Subscription ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscriptionId")]
		public string SubscriptionId { get; set; }
		
		/// <summary>
		/// Update domain of the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateDomain")]
		public string UpdateDomain { get; set; }
		
		/// <summary>
		/// Virtual Machine ID (unique identifier).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmId")]
		public string VmId { get; set; }
		
		/// <summary>
		/// Describes an Azure Virtual Machine Scale Set
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmScaleSet")]
		public AzureVmScaleSetConfiguration VmScaleSet { get; set; }
	}
	
	/// <summary>
	/// Describes the hosting configuration of a process when hosted on azure
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class AzureProcessHostingConfiguration : ProcessHostingConfiguration
	{
		
		/// <summary>
		/// Describes an Azure Cloud Service
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloudService")]
		public AzureCloudServiceConfiguration CloudService { get; set; }
	}
	
	/// <summary>
	/// Describes an Azure Service Fabric Cluster
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class AzureServiceFabricClusterConfiguration
	{
		
		/// <summary>
		/// Service Fabric cluster identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clusterId")]
		public string ClusterId { get; set; }
		
		/// <summary>
		/// Service Fabric cluster name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Describes an Azure Virtual Machine Scale Set
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class AzureVmScaleSetConfiguration
	{
		
		/// <summary>
		/// Virtual Machine Scale Set deployment identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deployment")]
		public string Deployment { get; set; }
		
		/// <summary>
		/// Virtual Machine Scale Set instance identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceId")]
		public string InstanceId { get; set; }
		
		/// <summary>
		/// Virtual Machine Scale Set name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Unique identifier of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceId")]
		public string ResourceId { get; set; }
	}
	
	/// <summary>
	/// Specifies the bitness of a machine or process.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum Bitness
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="32bit")]
		_32bit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="64bit")]
		_64bit = 1,
	}
	
	/// <summary>
	/// Represents a collection of clients of a resource. A client group can represent the clients of a port, process, or a machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ClientGroup : CoreResource
	{
		
		/// <summary>
		/// Resource properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public ClientGroupProperties Properties { get; set; }
	}
	
	public class ClientGroupProperties
	{
		
		/// <summary>
		/// Represents a reference to another resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clientsOf")]
		public ResourceReference ClientsOf { get; set; }
	}
	
	/// <summary>
	/// Represents a member of a client group
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ClientGroupMember : Resource
	{
		
		/// <summary>
		/// Resource properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public ClientGroupMemberProperties Properties { get; set; }
	}
	
	public class ClientGroupMemberProperties
	{
		
		/// <summary>
		/// IP address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
		
		/// <summary>
		/// Reference to a port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public PortReference Port { get; set; }
		
		/// <summary>
		/// Processes accepting on the above port that received connections from this client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="processes")]
		public ProcessReference[] Processes { get; set; }
	}
	
	/// <summary>
	/// Reference to a process.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ProcessReference : ResourceReference
	{
		
		/// <summary>
		/// Resource properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public ProcessReferenceProperties Properties { get; set; }
	}
	
	public class ProcessReferenceProperties
	{
		
		/// <summary>
		/// Reference to a machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machine")]
		public MachineReference Machine { get; set; }
	}
	
	/// <summary>
	/// Collection of ClientGroupMember resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ClientGroupMembersCollection
	{
		
		/// <summary>
		/// The URL to the next set of resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// Collection of ClientGroupMember resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public ClientGroupMember[] Value { get; set; }
	}
	
	/// <summary>
	/// Specifies the number of members in a client group.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ClientGroupMembersCount
	{
		
		/// <summary>
		/// Specifies the accuracy of a computation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="accuracy")]
		public Accuracy Accuracy { get; set; }
		
		/// <summary>
		/// Number of members in the client group. Use this value together with the value of ```accuracy```. If accuracy is `exact` then the value represents the actual number of members in the cloud. When accuracy is `estimated`, the actual number of members is larger than the value of ```count```.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="count")]
		public int Count { get; set; }
		
		/// <summary>
		/// Membership interval start time.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
		
		/// <summary>
		/// Client Group URI.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="groupId")]
		public string GroupId { get; set; }
		
		/// <summary>
		/// Membership interval start time.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
	}
	
	/// <summary>
	/// Reference to a client group.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ClientGroupReference
	{
	}
	
	/// <summary>
	/// A network connection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Connection : Relationship
	{
		
		/// <summary>
		/// Properties for a connection resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public ConnectionProperties Properties { get; set; }
	}
	
	/// <summary>
	/// Collection of Connection resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ConnectionCollection
	{
		
		/// <summary>
		/// The URL to the next set of resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// Collection of Connection resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public Connection[] Value { get; set; }
	}
	
	/// <summary>
	/// Connection failure state:
	/// * ```ok``` indicates no failures
	/// * ```failed``` indicates only failures
	/// * ```mixed``` indicates both failures and successes
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ConnectionFailureState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ok = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		mixed = 2,
	}
	
	/// <summary>
	/// Properties for a connection resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ConnectionProperties : RelationshipProperties
	{
		
		/// <summary>
		/// Connection failure state:
		/// * ```ok``` indicates no failures
		/// * ```failed``` indicates only failures
		/// * ```mixed``` indicates both failures and successes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failureState")]
		public ConnectionFailureState FailureState { get; set; }
		
		/// <summary>
		/// Reference to a port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serverPort")]
		public PortReference ServerPort { get; set; }
	}
	
	/// <summary>
	/// Marker resource for the core Service Map resources
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class CoreResource : Resource
	{
		
		/// <summary>
		/// Resource ETAG.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// Additional resource type qualifier.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public CoreResourceKind Kind { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum CoreResourceKind
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		machine = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		process = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		port = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		clientGroup = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		machineGroup = 4,
	}
	
	/// <summary>
	/// Error details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Error
	{
		
		/// <summary>
		/// Error code identifying the specific error.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Error message in the caller's locale.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// An error response from the API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ErrorResponse
	{
		
		/// <summary>
		/// Error details.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Error Error { get; set; }
	}
	
	/// <summary>
	/// Describes the hosting configuration of a machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class HostingConfiguration
	{
		
		/// <summary>
		/// Additional hosting configuration type qualifier.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public HostingConfigurationKind Kind { get; set; }
		
		/// <summary>
		/// The hosting provider of the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provider")]
		public System.Nullable<HostingConfigurationProvider> Provider { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum HostingConfigurationKind
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="provider:azure")]
		providerazure = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum HostingConfigurationProvider
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		azure = 0,
	}
	
	/// <summary>
	/// Describes the hypervisor configuration of a machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class HypervisorConfiguration
	{
		
		/// <summary>
		/// Specifies the hypervisor type of a machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hypervisorType")]
		public System.Nullable<HypervisorConfigurationHypervisorType> HypervisorType { get; set; }
		
		/// <summary>
		/// The unique identifier of the hypervisor machine as reported by the underlying virtualization system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nativeHostMachineId")]
		public string NativeHostMachineId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum HypervisorConfigurationHypervisorType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hyperv = 1,
	}
	
	/// <summary>
	/// Specifies the hypervisor type of a machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum HypervisorType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hyperv = 1,
	}
	
	/// <summary>
	/// Describes the VM image of a machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ImageConfiguration
	{
		
		/// <summary>
		/// Offering of the VM image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="offering")]
		public string Offering { get; set; }
		
		/// <summary>
		/// Publisher of the VM image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publisher")]
		public string Publisher { get; set; }
		
		/// <summary>
		/// SKU of the VM image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sku")]
		public string Sku { get; set; }
		
		/// <summary>
		/// Version of the VM image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Describes an IPv4 network interface.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Ipv4NetworkInterface
	{
		
		/// <summary>
		/// IPv4 address.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
		
		/// <summary>
		/// IPv4 subnet mask.
		/// </summary>
		[System.ComponentModel.DefaultValue("255.255.255.255")]
		[System.Runtime.Serialization.DataMember(Name="subnetMask")]
		public string SubnetMask { get; set; } = "255.255.255.255";
	}
	
	/// <summary>
	/// Describes an IPv6 network interface.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Ipv6NetworkInterface
	{
		
		/// <summary>
		/// IPv6 address.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
	}
	
	/// <summary>
	/// Specifies the contents of a check liveness response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Liveness
	{
		
		/// <summary>
		/// Liveness interval end time.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
		
		/// <summary>
		/// `true` if the resource is live during [startTime, endTime], `false` otherwise
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="live")]
		public bool Live { get; set; }
		
		/// <summary>
		/// Liveness interval start time.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
	}
	
	/// <summary>
	/// A machine resource represents a discovered computer system. It can be *monitored*, i.e., a Dependency Agent is running on it, or *discovered*, i.e., its existence was inferred by observing the data stream from monitored machines. As machines change, prior versions of the machine resource are preserved and available for access. A machine is live during an interval of time, if either its Dependency Agent has reported data during (parts) of that interval, or a Dependency agent running on other machines has reported activity associated with the machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Machine : CoreResource
	{
		
		/// <summary>
		/// Resource properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public MachineProperties Properties { get; set; }
	}
	
	public class MachineProperties
	{
		
		/// <summary>
		/// Describes the configuration of the Dependency Agent installed on a machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="agent")]
		public AgentConfiguration Agent { get; set; }
		
		/// <summary>
		/// UTC date and time when the machine last booted
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bootTime")]
		public System.Nullable<System.DateTimeOffset> BootTime { get; set; }
		
		/// <summary>
		/// Name of the machine, e.g., server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computerName")]
		public string ComputerName { get; set; }
		
		/// <summary>
		/// Name to use for display purposes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Fully-qualified name of the machine, e.g., server.company.com
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fullyQualifiedDomainName")]
		public string FullyQualifiedDomainName { get; set; }
		
		/// <summary>
		/// Describes the hosting configuration of a machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosting")]
		public HostingConfiguration Hosting { get; set; }
		
		/// <summary>
		/// Describes the hypervisor configuration of a machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hypervisor")]
		public HypervisorConfiguration Hypervisor { get; set; }
		
		/// <summary>
		/// Used to specify if a resources is monitored or discovered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monitoringState")]
		public System.Nullable<MachinePropertiesMonitoringState> MonitoringState { get; set; }
		
		/// <summary>
		/// Describes the network configuration of a machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networking")]
		public NetworkConfiguration Networking { get; set; }
		
		/// <summary>
		/// Describes the configuration of the operating system of a machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operatingSystem")]
		public OperatingSystemConfiguration OperatingSystem { get; set; }
		
		/// <summary>
		/// Describes the resources of a machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public MachineResourcesConfiguration Resources { get; set; }
		
		/// <summary>
		/// UTC date and time when this resource was updated in the system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public System.Nullable<System.DateTimeOffset> Timestamp { get; set; }
		
		/// <summary>
		/// Describes a timezone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timezone")]
		public Timezone Timezone { get; set; }
		
		/// <summary>
		/// Describes the virtualization-related configuration of a machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualMachine")]
		public VirtualMachineConfiguration VirtualMachine { get; set; }
		
		/// <summary>
		/// Specifies if the machine is physical, virtual, hypervisor, or unknown.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualizationState")]
		public System.Nullable<MachinePropertiesVirtualizationState> VirtualizationState { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum MachinePropertiesMonitoringState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		monitored = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		discovered = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum MachinePropertiesVirtualizationState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		physical = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="virtual")]
		_virtual = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hypervisor = 3,
	}
	
	/// <summary>
	/// Collection of Machine resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class MachineCollection
	{
		
		/// <summary>
		/// The URL to the next set of resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// Collection of Machine resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public Machine[] Value { get; set; }
	}
	
	/// <summary>
	/// Machines by operating system.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class MachineCountsByOperatingSystem
	{
		
		/// <summary>
		/// Number of live Linux machines.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="linux")]
		public int Linux { get; set; }
		
		/// <summary>
		/// Number of live Windows machines.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="windows")]
		public int Windows { get; set; }
	}
	
	/// <summary>
	/// A user-defined logical grouping of machines.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class MachineGroup : CoreResource
	{
		
		/// <summary>
		/// Resource ETAG.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// Resource properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public MachineGroupProperties Properties { get; set; }
	}
	
	public class MachineGroupProperties
	{
		
		/// <summary>
		/// Count of machines in this group. The value of count may be bigger than the number of machines in case of the group has been truncated due to exceeding the max number of machines a group can handle.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public System.Nullable<System.Int32> Count { get; set; }
		
		/// <summary>
		/// User defined name for the group
		/// Required
		/// Min length: 1
		/// Max length: 256
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Type of the machine group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupType")]
		public System.Nullable<MachineGroupPropertiesGroupType> GroupType { get; set; }
		
		/// <summary>
		/// References of the machines in this group. The hints within each reference do not represent the current value of the corresponding fields. They are a snapshot created during the last time the machine group was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machines")]
		public MachineReferenceWithHints[] Machines { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum MachineGroupPropertiesGroupType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="azure-cs")]
		azureMinuscs = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="azure-sf")]
		azureMinussf = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="azure-vmss")]
		azureMinusvmss = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="user-static")]
		userMinusstatic = 4,
	}
	
	/// <summary>
	/// A machine reference with a hint of the machine's name and operating system.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class MachineReferenceWithHints : ResourceReference
	{
		
		/// <summary>
		/// Machine reference with name and os hints.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public MachineReferenceWithHintsProperties Properties { get; set; }
	}
	
	public class MachineReferenceWithHintsProperties
	{
		
		/// <summary>
		/// Last known display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayNameHint")]
		public string DisplayNameHint { get; set; }
		
		/// <summary>
		/// Specifies the operating system family, e.g., Linux, Windows, etc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osFamilyHint")]
		public System.Nullable<MachineReferenceWithHintsPropertiesOsFamilyHint> OsFamilyHint { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum MachineReferenceWithHintsPropertiesOsFamilyHint
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		windows = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linux = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		solaris = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		aix = 4,
	}
	
	/// <summary>
	/// Collection of Machine Group resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class MachineGroupCollection
	{
		
		/// <summary>
		/// The URL to the next set of resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// Collection of Machine Group resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public MachineGroup[] Value { get; set; }
	}
	
	/// <summary>
	/// Specifies the computation of a machine group dependency map. A machine group dependency map includes all direct dependencies the machines in the group.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class MachineGroupMapRequest : MultipleMachinesMapRequest
	{
		
		/// <summary>
		/// URI of machine group resource for which to generate the map.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="machineGroupId")]
		public string MachineGroupId { get; set; }
	}
	
	/// <summary>
	/// Specifies the computation of a one hope dependency map for a list of machines. The resulting map includes all direct dependencies for the specified machines.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class MachineListMapRequest : MultipleMachinesMapRequest
	{
		
		/// <summary>
		/// a list of URIs of machine resources for which to generate the map.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="machineIds")]
		public string[] MachineIds { get; set; }
	}
	
	/// <summary>
	/// Specifies if the machine has been rebooted since the installation of the dependency agent.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum MachineRebootStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rebooted = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		notRebooted = 2,
	}
	
	/// <summary>
	/// Reference to a machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class MachineReference
	{
	}
	
	/// <summary>
	/// Describes the resources of a machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class MachineResourcesConfiguration
	{
		
		/// <summary>
		/// CPU speed in megahertz (Mhz).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuSpeed")]
		public System.Nullable<System.Int32> CpuSpeed { get; set; }
		
		/// <summary>
		/// Specifies the accuracy of a computation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuSpeedAccuracy")]
		public Accuracy CpuSpeedAccuracy { get; set; }
		
		/// <summary>
		/// Number of CPUs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpus")]
		public System.Nullable<System.Int32> Cpus { get; set; }
		
		/// <summary>
		/// Physical memory in megabytes (MB).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="physicalMemory")]
		public System.Nullable<System.Int32> PhysicalMemory { get; set; }
	}
	
	/// <summary>
	/// A summary of the machines in the workspace.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class MachinesSummary : Summary
	{
		
		/// <summary>
		/// Summarizes machines in the workspace.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public MachinesSummaryProperties Properties { get; set; }
	}
	
	/// <summary>
	/// Summarizes machines in the workspace.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class MachinesSummaryProperties
	{
		
		/// <summary>
		/// Number of live machines.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="live")]
		public int Live { get; set; }
		
		/// <summary>
		/// Machines by operating system.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="os")]
		public MachineCountsByOperatingSystem Os { get; set; }
		
		/// <summary>
		/// Total number of machines.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total")]
		public int Total { get; set; }
	}
	
	/// <summary>
	/// A map of resources and relationships between them.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Map
	{
		
		/// <summary>
		/// The edges (relationships) of a map.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="edges")]
		public MapEdges Edges { get; set; }
		
		/// <summary>
		/// The nodes (entities) of a map.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nodes")]
		public MapNodes Nodes { get; set; }
	}
	
	/// <summary>
	/// The edges (relationships) of a map.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class MapEdges
	{
		
		/// <summary>
		/// Processes accepting on a port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acceptors")]
		public Acceptor[] Acceptors { get; set; }
		
		/// <summary>
		/// Network connections.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connections")]
		public Connection[] Connections { get; set; }
	}
	
	/// <summary>
	/// The nodes (entities) of a map.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class MapNodes
	{
		
		/// <summary>
		/// Client Group resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientGroups")]
		public ClientGroup[] ClientGroups { get; set; }
		
		/// <summary>
		/// Machine resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machines")]
		public Machine[] Machines { get; set; }
		
		/// <summary>
		/// Port resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ports")]
		public Port[] Ports { get; set; }
		
		/// <summary>
		/// Process resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="processes")]
		public Process[] Processes { get; set; }
	}
	
	/// <summary>
	/// A port resource represents a server port on a machine. The port may be actively *monitored*, i.e., a Dependency Agent is running on its machine, or *discovered*, i.e., its existence was inferred by observing the data stream from monitored machines. A port is live during an interval of time, if that port had associated activity during (parts) of that interval.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Port : CoreResource
	{
		
		/// <summary>
		/// Resource properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public PortProperties Properties { get; set; }
	}
	
	public class PortProperties
	{
		
		/// <summary>
		/// Name to use for display purposes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// IP address associated with the port. At present only IPv4 addresses are supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
		
		/// <summary>
		/// Represents a reference to another resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machine")]
		public ResourceReference Machine { get; set; }
		
		/// <summary>
		/// Used to specify if a resources is monitored or discovered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monitoringState")]
		public MachinePropertiesMonitoringState MonitoringState { get; set; }
		
		/// <summary>
		/// Port number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portNumber")]
		public System.Nullable<System.Int32> PortNumber { get; set; }
	}
	
	/// <summary>
	/// A process resource represents a process running on a machine. The process may be actively *monitored*, i.e., a Dependency Agent is running on its machine, or *discovered*, i.e., its existence was inferred by observing the data stream from monitored machines. A process resource represents a pool of actual operating system resources that share command lines and metadata. As the process pool evolves over time, prior versions of the process resource are preserved and available for access. A process is live during an interval of time, if that process is executing during (parts) of that interval
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Process : CoreResource
	{
		
		/// <summary>
		/// Resource properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public ProcessProperties Properties { get; set; }
	}
	
	public class ProcessProperties
	{
		
		/// <summary>
		/// Represents a reference to another resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acceptorOf")]
		public ResourceReference AcceptorOf { get; set; }
		
		/// <summary>
		/// Represents a reference to another resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientOf")]
		public ResourceReference ClientOf { get; set; }
		
		/// <summary>
		/// Describes process metadata.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public ProcessDetails Details { get; set; }
		
		/// <summary>
		/// Name to use for display purposes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// The name of the process executable
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executableName")]
		public string ExecutableName { get; set; }
		
		/// <summary>
		/// The name of the product or suite of the process. The group is determined by its executable name, command line, etc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public string Group { get; set; }
		
		/// <summary>
		/// Describes the hosting configuration of a process.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosting")]
		public ProcessHostingConfiguration Hosting { get; set; }
		
		/// <summary>
		/// Represents a reference to another resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machine")]
		public ResourceReference Machine { get; set; }
		
		/// <summary>
		/// Used to specify if a resources is monitored or discovered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monitoringState")]
		public MachinePropertiesMonitoringState MonitoringState { get; set; }
		
		/// <summary>
		/// The inferred role of this process based on its name, command line, etc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="role")]
		public System.Nullable<ProcessPropertiesRole> Role { get; set; }
		
		/// <summary>
		/// UTC date and time when the process started
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.Nullable<System.DateTimeOffset> StartTime { get; set; }
		
		/// <summary>
		/// UTC date and time when this process resource was updated in the system
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public System.Nullable<System.DateTimeOffset> Timestamp { get; set; }
		
		/// <summary>
		/// Describes the user under which a process is running.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public ProcessUser User { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ProcessPropertiesRole
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		webServer = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		appServer = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		databaseServer = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ldapServer = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		smbServer = 4,
	}
	
	/// <summary>
	/// Specifies the contents of request to generate a map.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class MapRequest
	{
		
		/// <summary>
		/// Map interval end time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.Nullable<System.DateTimeOffset> EndTime { get; set; }
		
		/// <summary>
		/// The type of map to create.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public MapRequestKind Kind { get; set; }
		
		/// <summary>
		/// Map interval start time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.Nullable<System.DateTimeOffset> StartTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum MapRequestKind
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="map:single-machine-dependency")]
		mapsingleMinusmachineMinusdependency = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="map:machine-group-dependency")]
		mapmachineMinusgroupMinusdependency = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="map:machine-list-dependency")]
		mapmachineMinuslistMinusdependency = 2,
	}
	
	/// <summary>
	/// Specified the contents of a map response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class MapResponse
	{
		
		/// <summary>
		/// Map interval end time.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
		
		/// <summary>
		/// A map of resources and relationships between them.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="map")]
		public Map Map { get; set; }
		
		/// <summary>
		/// Map interval start time.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
	}
	
	/// <summary>
	/// Used to specify if a resources is monitored or discovered.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum MonitoringState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		monitored = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		discovered = 1,
	}
	
	/// <summary>
	/// Provides a base class for describing map requests for a collection of machines
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class MultipleMachinesMapRequest : MapRequest
	{
		
		/// <summary>
		/// If true, only processes between specified machines will be included. Any connections in or out of those processes will be included.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filterProcesses")]
		public System.Nullable<System.Boolean> FilterProcesses { get; set; }
	}
	
	/// <summary>
	/// Describes the network configuration of a machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class NetworkConfiguration
	{
		
		/// <summary>
		/// Default IPv4 gateways.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultIpv4Gateways")]
		public string[] DefaultIpv4Gateways { get; set; }
		
		/// <summary>
		/// DNS names associated with the machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsNames")]
		public string[] DnsNames { get; set; }
		
		/// <summary>
		/// IPv4 interfaces.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4Interfaces")]
		public Ipv4NetworkInterface[] Ipv4Interfaces { get; set; }
		
		/// <summary>
		/// IPv6 interfaces.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6Interfaces")]
		public Ipv6NetworkInterface[] Ipv6Interfaces { get; set; }
		
		/// <summary>
		/// MAC addresses of all active network interfaces.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="macAddresses")]
		public string[] MacAddresses { get; set; }
	}
	
	/// <summary>
	/// Describes the configuration of the operating system of a machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class OperatingSystemConfiguration
	{
		
		/// <summary>
		/// Specifies the bitness of a machine or process.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bitness")]
		public OperatingSystemConfigurationBitness Bitness { get; set; }
		
		/// <summary>
		/// Specifies the operating system family, e.g., Linux, Windows, etc.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="family")]
		public MachineReferenceWithHintsPropertiesOsFamilyHint Family { get; set; }
		
		/// <summary>
		/// Operating system full name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fullName")]
		public string FullName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum OperatingSystemConfigurationBitness
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="32bit")]
		_32bit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="64bit")]
		_64bit = 1,
	}
	
	/// <summary>
	/// Specifies the operating system family, e.g., Linux, Windows, etc.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum OperatingSystemFamily
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		windows = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linux = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		solaris = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		aix = 4,
	}
	
	/// <summary>
	/// Collection of Port resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class PortCollection
	{
		
		/// <summary>
		/// The URL to the next set of resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// Collection of Port resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public Port[] Value { get; set; }
	}
	
	/// <summary>
	/// Reference to a port.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class PortReference : ResourceReference
	{
		
		/// <summary>
		/// Resource properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public PortReferenceProperties Properties { get; set; }
	}
	
	public class PortReferenceProperties
	{
		
		/// <summary>
		/// IP address of the port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
		
		/// <summary>
		/// Reference to a machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machine")]
		public MachineReference Machine { get; set; }
		
		/// <summary>
		/// Port number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portNumber")]
		public System.Nullable<System.Int32> PortNumber { get; set; }
	}
	
	/// <summary>
	/// Collection of Process resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ProcessCollection
	{
		
		/// <summary>
		/// The URL to the next set of resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// Collection of Process resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public Process[] Value { get; set; }
	}
	
	/// <summary>
	/// Describes process metadata.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ProcessDetails
	{
		
		/// <summary>
		/// Process command line.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commandLine")]
		public string CommandLine { get; set; }
		
		/// <summary>
		/// Name of company that created the process executable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="companyName")]
		public string CompanyName { get; set; }
		
		/// <summary>
		/// Process description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Process executable path.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executablePath")]
		public string ExecutablePath { get; set; }
		
		/// <summary>
		/// File version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileVersion")]
		public string FileVersion { get; set; }
		
		/// <summary>
		/// The Operating System Process Identifier (PID) of the first process in this process pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firstPid")]
		public System.Nullable<System.Int32> FirstPid { get; set; }
		
		/// <summary>
		/// Internal process name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="internalName")]
		public string InternalName { get; set; }
		
		/// <summary>
		/// A unique identifier for a process, generally resilient to process restart, computed by Service Map.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="persistentKey")]
		public string PersistentKey { get; set; }
		
		/// <summary>
		/// Represents the identity of the process pool assigned to the process by Dependency Agent.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="poolId")]
		public System.Nullable<System.Int32> PoolId { get; set; }
		
		/// <summary>
		/// Product name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productName")]
		public string ProductName { get; set; }
		
		/// <summary>
		/// Product version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productVersion")]
		public string ProductVersion { get; set; }
		
		/// <summary>
		/// Collection of services hosted by this Process (Windows only).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="services")]
		public ProcessHostedService[] Services { get; set; }
		
		/// <summary>
		/// Process workingDirectory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workingDirectory")]
		public string WorkingDirectory { get; set; }
		
		/// <summary>
		/// Process zone name (Linux only).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zoneName")]
		public string ZoneName { get; set; }
	}
	
	/// <summary>
	/// A service hosted by a process.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ProcessHostedService
	{
		
		/// <summary>
		/// The service's display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// The name of the service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Describes the hosting configuration of a process.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ProcessHostingConfiguration
	{
		
		/// <summary>
		/// Additional hosting configuration type qualifier.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public ProcessHostingConfigurationKind Kind { get; set; }
		
		/// <summary>
		/// The hosting provider of the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provider")]
		public HostingConfigurationProvider Provider { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ProcessHostingConfigurationKind
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="provider:azure")]
		providerazure = 0,
	}
	
	/// <summary>
	/// Describes the user under which a process is running.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ProcessUser
	{
		
		/// <summary>
		/// Domain name for the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userDomain")]
		public string UserDomain { get; set; }
		
		/// <summary>
		/// User name under which the process is running.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userName")]
		public string UserName { get; set; }
	}
	
	/// <summary>
	/// A typed relationship between two entities.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Relationship : Resource
	{
		
		/// <summary>
		/// Additional resource type qualifier.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public RelationshipKind Kind { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum RelationshipKind
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="rel:connection")]
		relconnection = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="rel:acceptor")]
		relacceptor = 1,
	}
	
	/// <summary>
	/// Relationship properties.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class RelationshipProperties
	{
		
		/// <summary>
		/// Represents a reference to another resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public ResourceReference Destination { get; set; }
		
		/// <summary>
		/// Relationship end time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.Nullable<System.DateTimeOffset> EndTime { get; set; }
		
		/// <summary>
		/// Represents a reference to another resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public ResourceReference Source { get; set; }
		
		/// <summary>
		/// Relationship start time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.Nullable<System.DateTimeOffset> StartTime { get; set; }
	}
	
	/// <summary>
	/// Resource model definition.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Resource
	{
		
		/// <summary>
		/// Resource identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Resource name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Represents a reference to another resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ResourceReference
	{
		
		/// <summary>
		/// Resource URI.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Specifies the sub-class of the reference.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public ResourceReferenceKind Kind { get; set; }
		
		/// <summary>
		/// Resource name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Resource type qualifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ResourceReferenceKind
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ref:machine")]
		refmachine = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ref:machinewithhints")]
		refmachinewithhints = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ref:process")]
		refprocess = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ref:port")]
		refport = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ref:onmachine")]
		refonmachine = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ref:clientgroup")]
		refclientgroup = 5,
	}
	
	/// <summary>
	/// Specifies the computation of a single server dependency map. A single server dependency map includes all direct dependencies of a given machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class SingleMachineDependencyMapRequest : MapRequest
	{
		
		/// <summary>
		/// URI of machine resource for which to generate the map.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="machineId")]
		public string MachineId { get; set; }
	}
	
	/// <summary>
	/// Base for all resource summaries.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Summary
	{
	}
	
	/// <summary>
	/// Base for all summaries.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class SummaryProperties
	{
		
		/// <summary>
		/// Summary interval end time.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
		
		/// <summary>
		/// Summary interval start time.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
	}
	
	/// <summary>
	/// Describes a timezone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Timezone
	{
		
		/// <summary>
		/// Timezone full name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fullName")]
		public string FullName { get; set; }
	}
	
	/// <summary>
	/// Describes the virtualization-related configuration of a machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VirtualMachineConfiguration
	{
		
		/// <summary>
		/// The unique identifier of the host of this virtual machine as reported by the underlying virtualization system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nativeHostMachineId")]
		public string NativeHostMachineId { get; set; }
		
		/// <summary>
		/// The unique identifier of the virtual machine as reported by the underlying virtualization system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nativeMachineId")]
		public string NativeMachineId { get; set; }
		
		/// <summary>
		/// The Name of the virtual machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualMachineName")]
		public string VirtualMachineName { get; set; }
		
		/// <summary>
		/// Specifies the virtualization type of a machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualMachineType")]
		public System.Nullable<VirtualMachineConfigurationVirtualMachineType> VirtualMachineType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum VirtualMachineConfigurationVirtualMachineType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hyperv = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ldom = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		lpar = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		vmware = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		virtualPc = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		xen = 6,
	}
	
	/// <summary>
	/// Specifies the virtualization type of a machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum VirtualMachineType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hyperv = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ldom = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		lpar = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		vmware = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		virtualPc = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		xen = 6,
	}
	
	/// <summary>
	/// Specifies if the machine is physical, virtual, hypervisor, or unknown.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum VirtualizationState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		physical = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="virtual")]
		_virtual = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hypervisor = 3,
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Retrieves the specified client group
		/// ClientGroups_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/clientGroups/{clientGroupName}
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="clientGroupName">Client Group resource name.
		/// Min length: 3
		/// Max length: 256
		// </param>
		/// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses DateTime.UtcNow - 10m</param>
		/// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ClientGroup> ClientGroups_GetAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string clientGroupName, System.DateTimeOffset startTime, System.DateTimeOffset endTime)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/clientGroups/"+ (clientGroupName==null? "" : System.Uri.EscapeDataString(clientGroupName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ClientGroup>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns the members of the client group during the specified time interval.
		/// ClientGroups_ListMembers subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/clientGroups/{clientGroupName}/members
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="clientGroupName">Client Group resource name.
		/// Min length: 3
		/// Max length: 256
		// </param>
		/// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses DateTime.UtcNow - 10m</param>
		/// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
		/// <param name="top">Page size to use. When not specified, the default page size is 100 records.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ClientGroupMembersCollection> ClientGroups_ListMembersAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string clientGroupName, System.DateTimeOffset startTime, System.DateTimeOffset endTime, int top)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/clientGroups/"+ (clientGroupName==null? "" : System.Uri.EscapeDataString(clientGroupName))+"/members&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&$top="+top;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ClientGroupMembersCollection>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns the approximate number of members in the client group.
		/// ClientGroups_GetMembersCount subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/clientGroups/{clientGroupName}/membersCount
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="clientGroupName">Client Group resource name.
		/// Min length: 3
		/// Max length: 256
		// </param>
		/// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses DateTime.UtcNow - 10m</param>
		/// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ClientGroupMembersCount> ClientGroups_GetMembersCountAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string clientGroupName, System.DateTimeOffset startTime, System.DateTimeOffset endTime)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/clientGroups/"+ (clientGroupName==null? "" : System.Uri.EscapeDataString(clientGroupName))+"/membersCount&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ClientGroupMembersCount>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Generates the specified map.
		/// Maps_Generate subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/generateMap
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="requestBody">Request options.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<MapResponse> Maps_GenerateAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, MapRequest requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/generateMap&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<MapResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns all machine groups during the specified time interval.
		/// MachineGroups_ListByWorkspace subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machineGroups
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses DateTime.UtcNow - 10m</param>
		/// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<MachineGroupCollection> MachineGroups_ListByWorkspaceAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, System.DateTimeOffset startTime, System.DateTimeOffset endTime)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machineGroups&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<MachineGroupCollection>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Creates a new machine group.
		/// MachineGroups_Create subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machineGroups
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="requestBody">Machine Group resource to create.</param>
		public async Task MachineGroups_CreateAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, MachineGroup requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machineGroups&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns the specified machine group as it existed during the specified time interval.
		/// MachineGroups_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machineGroups/{machineGroupName}
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="machineGroupName">Machine Group resource name.
		/// Min length: 36
		/// Max length: 36
		// </param>
		/// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses DateTime.UtcNow - 10m</param>
		/// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<MachineGroup> MachineGroups_GetAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string machineGroupName, System.DateTimeOffset startTime, System.DateTimeOffset endTime)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machineGroups/"+ (machineGroupName==null? "" : System.Uri.EscapeDataString(machineGroupName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<MachineGroup>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates a machine group.
		/// MachineGroups_Update subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machineGroups/{machineGroupName}
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="machineGroupName">Machine Group resource name.
		/// Min length: 36
		/// Max length: 36
		// </param>
		/// <param name="requestBody">Machine Group resource to update.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<MachineGroup> MachineGroups_UpdateAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string machineGroupName, MachineGroup requestBody)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machineGroups/"+ (machineGroupName==null? "" : System.Uri.EscapeDataString(machineGroupName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<MachineGroup>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Deletes the specified Machine Group.
		/// MachineGroups_Delete subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machineGroups/{machineGroupName}
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="machineGroupName">Machine Group resource name.
		/// Min length: 36
		/// Max length: 36
		// </param>
		public async Task MachineGroups_DeleteAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string machineGroupName)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machineGroups/"+ (machineGroupName==null? "" : System.Uri.EscapeDataString(machineGroupName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns a collection of machines matching the specified conditions.  The returned collection represents either machines that are active/live during the specified interval  of time (`live=true` and `startTime`/`endTime` are specified) or that are known to have existed at or  some time prior to the specified point in time (`live=false` and `timestamp` is specified).
		/// Machines_ListByWorkspace subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="live">Specifies whether to return live resources (true) or inventory resources (false). Defaults to **true**. When retrieving live resources, the start time (`startTime`) and end time (`endTime`) of the desired interval should be included. When retrieving inventory resources, an optional timestamp (`timestamp`) parameter can be specified to return the version of each resource closest (not-after) that timestamp.</param>
		/// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses DateTime.UtcNow - 10m</param>
		/// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
		/// <param name="timestamp">UTC date and time specifying a time instance relative to which to evaluate each machine resource. Only applies when `live=false`. When not specified, the service uses DateTime.UtcNow.</param>
		/// <param name="top">Page size to use. When not specified, the default page size is 100 records.
		/// Minimum: 1
		/// Maximum: 200
		// </param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<MachineCollection> Machines_ListByWorkspaceAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, bool live, System.DateTimeOffset startTime, System.DateTimeOffset endTime, System.DateTimeOffset timestamp, int top)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machines&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&live="+live+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&timestamp=" + timestamp.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&$top="+top;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<MachineCollection>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns the specified machine.
		/// Machines_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="machineName">Machine resource name.
		/// Min length: 3
		/// Max length: 64
		// </param>
		/// <param name="timestamp">UTC date and time specifying a time instance relative to which to evaluate the machine resource. When not specified, the service uses DateTime.UtcNow.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<Machine> Machines_GetAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string machineName, System.DateTimeOffset timestamp)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machines/"+ (machineName==null? "" : System.Uri.EscapeDataString(machineName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&timestamp=" + timestamp.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Machine>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns a collection of connections terminating or originating at the specified machine
		/// Machines_ListConnections subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/connections
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="machineName">Machine resource name.
		/// Min length: 3
		/// Max length: 64
		// </param>
		/// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses DateTime.UtcNow - 10m</param>
		/// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ConnectionCollection> Machines_ListConnectionsAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string machineName, System.DateTimeOffset startTime, System.DateTimeOffset endTime)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machines/"+ (machineName==null? "" : System.Uri.EscapeDataString(machineName))+"/connections&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ConnectionCollection>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Obtains the liveness status of the machine during the specified time interval.
		/// Machines_GetLiveness subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/liveness
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="machineName">Machine resource name.
		/// Min length: 3
		/// Max length: 64
		// </param>
		/// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses DateTime.UtcNow - 10m</param>
		/// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<Liveness> Machines_GetLivenessAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string machineName, System.DateTimeOffset startTime, System.DateTimeOffset endTime)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machines/"+ (machineName==null? "" : System.Uri.EscapeDataString(machineName))+"/liveness&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Liveness>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns a collection of machine groups this machine belongs to during the specified time interval.
		/// Machines_ListMachineGroupMembership subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/machineGroups
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="machineName">Machine resource name.
		/// Min length: 3
		/// Max length: 64
		// </param>
		/// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses DateTime.UtcNow - 10m</param>
		/// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<MachineGroupCollection> Machines_ListMachineGroupMembershipAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string machineName, System.DateTimeOffset startTime, System.DateTimeOffset endTime)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machines/"+ (machineName==null? "" : System.Uri.EscapeDataString(machineName))+"/machineGroups&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<MachineGroupCollection>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns a collection of live ports on the specified machine during the specified time interval.
		/// Machines_ListPorts subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/ports
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="machineName">Machine resource name.
		/// Min length: 3
		/// Max length: 64
		// </param>
		/// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses DateTime.UtcNow - 10m</param>
		/// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<PortCollection> Machines_ListPortsAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string machineName, System.DateTimeOffset startTime, System.DateTimeOffset endTime)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machines/"+ (machineName==null? "" : System.Uri.EscapeDataString(machineName))+"/ports&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<PortCollection>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns the specified port. The port must be live during the specified time interval. If the port is not live during the interval, status 404 (Not Found) is returned.
		/// Ports_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/ports/{portName}
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="machineName">Machine resource name.
		/// Min length: 3
		/// Max length: 64
		// </param>
		/// <param name="portName">Port resource name.
		/// Min length: 3
		/// Max length: 64
		// </param>
		/// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses DateTime.UtcNow - 10m</param>
		/// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<Port> Ports_GetAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string machineName, string portName, System.DateTimeOffset startTime, System.DateTimeOffset endTime)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machines/"+ (machineName==null? "" : System.Uri.EscapeDataString(machineName))+"/ports/"+ (portName==null? "" : System.Uri.EscapeDataString(portName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Port>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns a collection of processes accepting on the specified port
		/// Ports_ListAcceptingProcesses subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/ports/{portName}/acceptingProcesses
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="machineName">Machine resource name.
		/// Min length: 3
		/// Max length: 64
		// </param>
		/// <param name="portName">Port resource name.
		/// Min length: 3
		/// Max length: 64
		// </param>
		/// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses DateTime.UtcNow - 10m</param>
		/// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ProcessCollection> Ports_ListAcceptingProcessesAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string machineName, string portName, System.DateTimeOffset startTime, System.DateTimeOffset endTime)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machines/"+ (machineName==null? "" : System.Uri.EscapeDataString(machineName))+"/ports/"+ (portName==null? "" : System.Uri.EscapeDataString(portName))+"/acceptingProcesses&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ProcessCollection>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns a collection of connections established via the specified port.
		/// Ports_ListConnections subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/ports/{portName}/connections
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="machineName">Machine resource name.
		/// Min length: 3
		/// Max length: 64
		// </param>
		/// <param name="portName">Port resource name.
		/// Min length: 3
		/// Max length: 64
		// </param>
		/// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses DateTime.UtcNow - 10m</param>
		/// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ConnectionCollection> Ports_ListConnectionsAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string machineName, string portName, System.DateTimeOffset startTime, System.DateTimeOffset endTime)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machines/"+ (machineName==null? "" : System.Uri.EscapeDataString(machineName))+"/ports/"+ (portName==null? "" : System.Uri.EscapeDataString(portName))+"/connections&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ConnectionCollection>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Obtains the liveness status of the port during the specified time interval.
		/// Ports_GetLiveness subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/ports/{portName}/liveness
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="machineName">Machine resource name.
		/// Min length: 3
		/// Max length: 64
		// </param>
		/// <param name="portName">Port resource name.
		/// Min length: 3
		/// Max length: 64
		// </param>
		/// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses DateTime.UtcNow - 10m</param>
		/// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<Liveness> Ports_GetLivenessAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string machineName, string portName, System.DateTimeOffset startTime, System.DateTimeOffset endTime)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machines/"+ (machineName==null? "" : System.Uri.EscapeDataString(machineName))+"/ports/"+ (portName==null? "" : System.Uri.EscapeDataString(portName))+"/liveness&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Liveness>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns a collection of processes on the specified machine matching the specified conditions. The returned collection represents either processes that are active/live during the specified interval  of time (`live=true` and `startTime`/`endTime` are specified) or that are known to have existed at or  some time prior to the specified point in time (`live=false` and `timestamp` is specified).
		/// Machines_ListProcesses subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/processes
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="machineName">Machine resource name.
		/// Min length: 3
		/// Max length: 64
		// </param>
		/// <param name="live">Specifies whether to return live resources (true) or inventory resources (false). Defaults to **true**. When retrieving live resources, the start time (`startTime`) and end time (`endTime`) of the desired interval should be included. When retrieving inventory resources, an optional timestamp (`timestamp`) parameter can be specified to return the version of each resource closest (not-after) that timestamp.</param>
		/// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses DateTime.UtcNow - 10m</param>
		/// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
		/// <param name="timestamp">UTC date and time specifying a time instance relative to which to evaluate all process resource. Only applies when `live=false`. When not specified, the service uses DateTime.UtcNow.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ProcessCollection> Machines_ListProcessesAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string machineName, bool live, System.DateTimeOffset startTime, System.DateTimeOffset endTime, System.DateTimeOffset timestamp)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machines/"+ (machineName==null? "" : System.Uri.EscapeDataString(machineName))+"/processes&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&live="+live+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&timestamp=" + timestamp.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ProcessCollection>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns the specified process.
		/// Processes_Get subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/processes/{processName}
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="machineName">Machine resource name.
		/// Min length: 3
		/// Max length: 64
		// </param>
		/// <param name="processName">Process resource name.
		/// Min length: 3
		/// Max length: 128
		// </param>
		/// <param name="timestamp">UTC date and time specifying a time instance relative to which to evaluate a resource. When not specified, the service uses DateTime.UtcNow.</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<Process> Processes_GetAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string machineName, string processName, System.DateTimeOffset timestamp)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machines/"+ (machineName==null? "" : System.Uri.EscapeDataString(machineName))+"/processes/"+ (processName==null? "" : System.Uri.EscapeDataString(processName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&timestamp=" + timestamp.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Process>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns a collection of ports on which this process is accepting
		/// Processes_ListAcceptingPorts subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/processes/{processName}/acceptingPorts
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="machineName">Machine resource name.
		/// Min length: 3
		/// Max length: 64
		// </param>
		/// <param name="processName">Process resource name.
		/// Min length: 3
		/// Max length: 128
		// </param>
		/// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses DateTime.UtcNow - 10m</param>
		/// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<PortCollection> Processes_ListAcceptingPortsAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string machineName, string processName, System.DateTimeOffset startTime, System.DateTimeOffset endTime)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machines/"+ (machineName==null? "" : System.Uri.EscapeDataString(machineName))+"/processes/"+ (processName==null? "" : System.Uri.EscapeDataString(processName))+"/acceptingPorts&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<PortCollection>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns a collection of connections terminating or originating at the specified process
		/// Processes_ListConnections subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/processes/{processName}/connections
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="machineName">Machine resource name.
		/// Min length: 3
		/// Max length: 64
		// </param>
		/// <param name="processName">Process resource name.
		/// Min length: 3
		/// Max length: 128
		// </param>
		/// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses DateTime.UtcNow - 10m</param>
		/// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<ConnectionCollection> Processes_ListConnectionsAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string machineName, string processName, System.DateTimeOffset startTime, System.DateTimeOffset endTime)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machines/"+ (machineName==null? "" : System.Uri.EscapeDataString(machineName))+"/processes/"+ (processName==null? "" : System.Uri.EscapeDataString(processName))+"/connections&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ConnectionCollection>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Obtains the liveness status of the process during the specified time interval.
		/// Processes_GetLiveness subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/processes/{processName}/liveness
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="machineName">Machine resource name.
		/// Min length: 3
		/// Max length: 64
		// </param>
		/// <param name="processName">Process resource name.
		/// Min length: 3
		/// Max length: 128
		// </param>
		/// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses DateTime.UtcNow - 10m</param>
		/// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<Liveness> Processes_GetLivenessAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, string machineName, string processName, System.DateTimeOffset startTime, System.DateTimeOffset endTime)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/machines/"+ (machineName==null? "" : System.Uri.EscapeDataString(machineName))+"/processes/"+ (processName==null? "" : System.Uri.EscapeDataString(processName))+"/liveness&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Liveness>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns summary information about the machines in the workspace.
		/// Summaries_GetMachines subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/summaries/machines
		/// </summary>
		/// <param name="subscriptionId">Azure subscription identifier.</param>
		/// <param name="resourceGroupName">Resource group name within the specified subscriptionId.
		/// Min length: 1
		/// Max length: 64
		// </param>
		/// <param name="workspaceName">OMS workspace containing the resources of interest.
		/// Min length: 3
		/// Max length: 63
		// </param>
		/// <param name="api_version">API version.</param>
		/// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses DateTime.UtcNow - 10m</param>
		/// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
		/// <returns>The operation completed successfully.</returns>
		public async Task<MachinesSummary> Summaries_GetMachinesAsync(string subscriptionId, string resourceGroupName, string workspaceName, string api_version, System.DateTimeOffset startTime, System.DateTimeOffset endTime)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.OperationalInsights/workspaces/"+ (workspaceName==null? "" : System.Uri.EscapeDataString(workspaceName))+"/features/serviceMap/summaries/machines&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<MachinesSummary>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
