//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// An error response from a policy operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class CloudError
	{
		
		/// <summary>
		/// The resource management error response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public object Error { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ErrorResponse
	{
	}
	
	/// <summary>
	/// Identity for the resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Identity
	{
		
		/// <summary>
		/// The principal ID of the resource identity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="principalId")]
		public string PrincipalId { get; set; }
		
		/// <summary>
		/// The tenant ID of the resource identity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tenantId")]
		public string TenantId { get; set; }
		
		/// <summary>
		/// The identity type. This is the only required field when adding a system assigned identity to a resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<IdentityType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum IdentityType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SystemAssigned = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		None = 1,
	}
	
	/// <summary>
	/// The parameter values for the policy rule. The keys are the parameter names.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ParameterValues
	{
	}
	
	/// <summary>
	/// The value of a parameter.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ParameterValuesValue
	{
		
		/// <summary>
		/// The value of the parameter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// The policy assignment.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class PolicyAssignment
	{
		
		/// <summary>
		/// The ID of the policy assignment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Identity for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="identity")]
		public Identity Identity { get; set; }
		
		/// <summary>
		/// The location of the policy assignment. Only required when utilizing managed identity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// The name of the policy assignment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The policy assignment properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public PolicyAssignmentProperties Properties { get; set; }
		
		/// <summary>
		/// The policy sku. This property is optional, obsolete, and will be ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sku")]
		public PolicySku Sku { get; set; }
		
		/// <summary>
		/// The type of the policy assignment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// List of policy assignments.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class PolicyAssignmentListResult
	{
		
		/// <summary>
		/// The URL to use for getting the next set of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLink")]
		public string NextLink { get; set; }
		
		/// <summary>
		/// An array of policy assignments.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public PolicyAssignment[] Value { get; set; }
	}
	
	/// <summary>
	/// The policy assignment properties.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class PolicyAssignmentProperties
	{
		
		/// <summary>
		/// This message will be part of response in case of policy violation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The display name of the policy assignment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// The policy assignment enforcement mode. Possible values are Default and DoNotEnforce.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforcementMode")]
		public System.Nullable<PolicyAssignmentPropertiesEnforcementMode> EnforcementMode { get; set; }
		
		/// <summary>
		/// The policy assignment metadata. Metadata is an open ended object and is typically a collection of key value pairs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// The policy's excluded scopes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notScopes")]
		public string[] NotScopes { get; set; }
		
		/// <summary>
		/// The parameter values for the policy rule. The keys are the parameter names.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parameters")]
		public ParameterValues Parameters { get; set; }
		
		/// <summary>
		/// The ID of the policy definition or policy set definition being assigned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policyDefinitionId")]
		public string PolicyDefinitionId { get; set; }
		
		/// <summary>
		/// The scope for the policy assignment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scope")]
		public string Scope { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum PolicyAssignmentPropertiesEnforcementMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Default = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DoNotEnforce = 1,
	}
	
	/// <summary>
	/// The policy sku. This property is optional, obsolete, and will be ignored.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class PolicySku
	{
		
		/// <summary>
		/// The name of the policy sku. Possible values are A0 and A1.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The policy sku tier. Possible values are Free and Standard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tier")]
		public string Tier { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Retrieves all policy assignments that apply to a management group.
		/// This operation retrieves the list of all policy assignments applicable to the management group that match the given $filter. Valid values for $filter are: 'atScope()' or 'policyDefinitionId eq '{value}''. If $filter=atScope() is provided, the returned list includes all policy assignments that are assigned to the management group or the management group's ancestors. If $filter=policyDefinitionId eq '{value}' is provided, the returned list includes all policy assignments of the policy definition whose id is {value} that apply to the management group.
		/// PolicyAssignments_ListForManagementGroup providers/Microsoft.Management/managementgroups/{managementGroupId}/providers/Microsoft.Authorization/policyAssignments
		/// </summary>
		/// <param name="managementGroupId">The ID of the management group.</param>
		/// <param name="filter">The filter to apply on the operation. Valid values for $filter are: 'atScope()' or 'policyDefinitionId eq '{value}''. A filter is required when listing policy assignments at management group scope.</param>
		/// <param name="api_version">The API version to use for the operation.</param>
		/// <returns>OK - Returns an array of policy assignments.</returns>
		public async Task<PolicyAssignmentListResult> PolicyAssignments_ListForManagementGroupAsync(string managementGroupId, string filter, string api_version)
		{
			var requestUri = "providers/Microsoft.Management/managementgroups/"+ (managementGroupId==null? "" : System.Uri.EscapeDataString(managementGroupId))+"/providers/Microsoft.Authorization/policyAssignments&$filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PolicyAssignmentListResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves all policy assignments that apply to a subscription.
		/// This operation retrieves the list of all policy assignments associated with the given subscription that match the optional given $filter. Valid values for $filter are: 'atScope()' or 'policyDefinitionId eq '{value}''. If $filter is not provided, the unfiltered list includes all policy assignments associated with the subscription, including those that apply directly or from management groups that contain the given subscription, as well as any applied to objects contained within the subscription. If $filter=atScope() is provided, the returned list includes all policy assignments that apply to the subscription, which is everything in the unfiltered list except those applied to objects contained within the subscription. If $filter=policyDefinitionId eq '{value}' is provided, the returned list includes all policy assignments of the policy definition whose id is {value}.
		/// PolicyAssignments_List subscriptions/{subscriptionId}/providers/Microsoft.Authorization/policyAssignments
		/// </summary>
		/// <param name="filter">The filter to apply on the operation. Valid values for $filter are: 'atScope()' or 'policyDefinitionId eq '{value}''. If $filter is not provided, no filtering is performed.</param>
		/// <param name="api_version">The API version to use for the operation.</param>
		/// <param name="subscriptionId">The ID of the target subscription.</param>
		/// <returns>OK - Returns an array of policy assignments.</returns>
		public async Task<PolicyAssignmentListResult> PolicyAssignments_ListAsync(string filter, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/providers/Microsoft.Authorization/policyAssignments?$filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PolicyAssignmentListResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves all policy assignments that apply to a resource group.
		/// This operation retrieves the list of all policy assignments associated with the given resource group in the given subscription that match the optional given $filter. Valid values for $filter are: 'atScope()' or 'policyDefinitionId eq '{value}''. If $filter is not provided, the unfiltered list includes all policy assignments associated with the resource group, including those that apply directly or apply from containing scopes, as well as any applied to resources contained within the resource group. If $filter=atScope() is provided, the returned list includes all policy assignments that apply to the resource group, which is everything in the unfiltered list except those applied to resources contained within the resource group. If $filter=policyDefinitionId eq '{value}' is provided, the returned list includes all policy assignments of the policy definition whose id is {value} that apply to the resource group.
		/// PolicyAssignments_ListForResourceGroup subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/policyAssignments
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group that contains policy assignments.
		/// Min length: 1
		/// Max length: 90
		// </param>
		/// <param name="filter">The filter to apply on the operation. Valid values for $filter are: 'atScope()' or 'policyDefinitionId eq '{value}''. If $filter is not provided, no filtering is performed.</param>
		/// <param name="api_version">The API version to use for the operation.</param>
		/// <param name="subscriptionId">The ID of the target subscription.</param>
		/// <returns>OK - Returns an array of policy assignments.</returns>
		public async Task<PolicyAssignmentListResult> PolicyAssignments_ListForResourceGroupAsync(string resourceGroupName, string filter, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourceGroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/Microsoft.Authorization/policyAssignments&$filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PolicyAssignmentListResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves all policy assignments that apply to a resource.
		/// This operation retrieves the list of all policy assignments associated with the specified resource in the given resource group and subscription that match the optional given $filter. Valid values for $filter are: 'atScope()' or 'policyDefinitionId eq '{value}''. If $filter is not provided, the unfiltered list includes all policy assignments associated with the resource, including those that apply directly or from all containing scopes, as well as any applied to resources contained within the resource. If $filter=atScope() is provided, the returned list includes all policy assignments that apply to the resource, which is everything in the unfiltered list except those applied to resources contained within the resource. If $filter=policyDefinitionId eq '{value}' is provided, the returned list includes all policy assignments of the policy definition whose id is {value} that apply to the resource. Three parameters plus the resource name are used to identify a specific resource. If the resource is not part of a parent resource (the more common case), the parent resource path should not be provided (or provided as ''). For example a web app could be specified as ({resourceProviderNamespace} == 'Microsoft.Web', {parentResourcePath} == '', {resourceType} == 'sites', {resourceName} == 'MyWebApp'). If the resource is part of a parent resource, then all parameters should be provided. For example a virtual machine DNS name could be specified as ({resourceProviderNamespace} == 'Microsoft.Compute', {parentResourcePath} == 'virtualMachines/MyVirtualMachine', {resourceType} == 'domainNames', {resourceName} == 'MyComputerName'). A convenient alternative to providing the namespace and type name separately is to provide both in the {resourceType} parameter, format: ({resourceProviderNamespace} == '', {parentResourcePath} == '', {resourceType} == 'Microsoft.Web/sites', {resourceName} == 'MyWebApp').
		/// PolicyAssignments_ListForResource subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/policyAssignments
		/// </summary>
		/// <param name="resourceGroupName">The name of the resource group containing the resource.
		/// Min length: 1
		/// Max length: 90
		// </param>
		/// <param name="resourceProviderNamespace">The namespace of the resource provider. For example, the namespace of a virtual machine is Microsoft.Compute (from Microsoft.Compute/virtualMachines)</param>
		/// <param name="parentResourcePath">The parent resource path. Use empty string if there is none.</param>
		/// <param name="resourceType">The resource type name. For example the type name of a web app is 'sites' (from Microsoft.Web/sites).</param>
		/// <param name="resourceName">The name of the resource.</param>
		/// <param name="filter">The filter to apply on the operation. Valid values for $filter are: 'atScope()' or 'policyDefinitionId eq '{value}''. If $filter is not provided, no filtering is performed.</param>
		/// <param name="api_version">The API version to use for the operation.</param>
		/// <param name="subscriptionId">The ID of the target subscription.</param>
		/// <returns>OK - Returns an array of policy assignments.</returns>
		public async Task<PolicyAssignmentListResult> PolicyAssignments_ListForResourceAsync(string resourceGroupName, string resourceProviderNamespace, string parentResourcePath, string resourceType, string resourceName, string filter, string api_version, string subscriptionId)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId))+"/resourcegroups/"+ (resourceGroupName==null? "" : System.Uri.EscapeDataString(resourceGroupName))+"/providers/"+ (resourceProviderNamespace==null? "" : System.Uri.EscapeDataString(resourceProviderNamespace))+"/"+ (parentResourcePath==null? "" : System.Uri.EscapeDataString(parentResourcePath))+"/"+ (resourceType==null? "" : System.Uri.EscapeDataString(resourceType))+"/"+ (resourceName==null? "" : System.Uri.EscapeDataString(resourceName))+"/providers/Microsoft.Authorization/policyAssignments&$filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PolicyAssignmentListResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the policy assignment with the given ID.
		/// The operation retrieves the policy assignment with the given ID. Policy assignment IDs have this format: '{scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}'. Valid scopes are: management group (format: '/providers/Microsoft.Management/managementGroups/{managementGroup}'), subscription (format: '/subscriptions/{subscriptionId}'), resource group (format: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'.
		/// PolicyAssignments_GetById {policyAssignmentId}
		/// </summary>
		/// <param name="policyAssignmentId">The ID of the policy assignment to get. Use the format '{scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}'.</param>
		/// <param name="api_version">The API version to use for the operation.</param>
		/// <returns>OK - Returns information about the policy assignment.</returns>
		public async Task<PolicyAssignment> PolicyAssignments_GetByIdAsync(string policyAssignmentId, string api_version)
		{
			var requestUri = ""+ (policyAssignmentId==null? "" : System.Uri.EscapeDataString(policyAssignmentId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PolicyAssignment>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates or updates a policy assignment.
		/// This operation creates or updates the policy assignment with the given ID. Policy assignments made on a scope apply to all resources contained in that scope. For example, when you assign a policy to a resource group that policy applies to all resources in the group. Policy assignment IDs have this format: '{scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}'. Valid scopes are: management group (format: '/providers/Microsoft.Management/managementGroups/{managementGroup}'), subscription (format: '/subscriptions/{subscriptionId}'), resource group (format: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'.
		/// PolicyAssignments_CreateById {policyAssignmentId}
		/// </summary>
		/// <param name="policyAssignmentId">The ID of the policy assignment to create. Use the format '{scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}'.</param>
		/// <param name="api_version">The API version to use for the operation.</param>
		/// <param name="requestBody">Parameters for policy assignment.</param>
		public async Task PolicyAssignments_CreateByIdAsync(string policyAssignmentId, string api_version, PolicyAssignment requestBody)
		{
			var requestUri = ""+ (policyAssignmentId==null? "" : System.Uri.EscapeDataString(policyAssignmentId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a policy assignment.
		/// This operation deletes the policy with the given ID. Policy assignment IDs have this format: '{scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}'. Valid formats for {scope} are: '/providers/Microsoft.Management/managementGroups/{managementGroup}' (management group), '/subscriptions/{subscriptionId}' (subscription), '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' (resource group), or '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}' (resource).
		/// PolicyAssignments_DeleteById {policyAssignmentId}
		/// </summary>
		/// <param name="policyAssignmentId">The ID of the policy assignment to delete. Use the format '{scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}'.</param>
		/// <param name="api_version">The API version to use for the operation.</param>
		/// <returns>OK - Returns information about the policy assignment.</returns>
		public async Task<PolicyAssignment> PolicyAssignments_DeleteByIdAsync(string policyAssignmentId, string api_version)
		{
			var requestUri = ""+ (policyAssignmentId==null? "" : System.Uri.EscapeDataString(policyAssignmentId))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PolicyAssignment>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a policy assignment.
		/// This operation retrieves a single policy assignment, given its name and the scope it was created at.
		/// PolicyAssignments_Get {scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}
		/// </summary>
		/// <param name="scope">The scope of the policy assignment. Valid scopes are: management group (format: '/providers/Microsoft.Management/managementGroups/{managementGroup}'), subscription (format: '/subscriptions/{subscriptionId}'), resource group (format: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'</param>
		/// <param name="policyAssignmentName">The name of the policy assignment to get.</param>
		/// <param name="api_version">The API version to use for the operation.</param>
		/// <returns>OK - Returns information about the policy assignment.</returns>
		public async Task<PolicyAssignment> PolicyAssignments_GetAsync(string scope, string policyAssignmentName, string api_version)
		{
			var requestUri = ""+ (scope==null? "" : System.Uri.EscapeDataString(scope))+"/providers/Microsoft.Authorization/policyAssignments/"+ (policyAssignmentName==null? "" : System.Uri.EscapeDataString(policyAssignmentName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PolicyAssignment>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates or updates a policy assignment.
		/// This operation creates or updates a policy assignment with the given scope and name. Policy assignments apply to all resources contained within their scope. For example, when you assign a policy at resource group scope, that policy applies to all resources in the group.
		/// PolicyAssignments_Create {scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}
		/// </summary>
		/// <param name="scope">The scope of the policy assignment. Valid scopes are: management group (format: '/providers/Microsoft.Management/managementGroups/{managementGroup}'), subscription (format: '/subscriptions/{subscriptionId}'), resource group (format: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'</param>
		/// <param name="policyAssignmentName">The name of the policy assignment.</param>
		/// <param name="api_version">The API version to use for the operation.</param>
		/// <param name="requestBody">Parameters for the policy assignment.</param>
		public async Task PolicyAssignments_CreateAsync(string scope, string policyAssignmentName, string api_version, PolicyAssignment requestBody)
		{
			var requestUri = ""+ (scope==null? "" : System.Uri.EscapeDataString(scope))+"/providers/Microsoft.Authorization/policyAssignments/"+ (policyAssignmentName==null? "" : System.Uri.EscapeDataString(policyAssignmentName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a policy assignment.
		/// This operation deletes a policy assignment, given its name and the scope it was created in. The scope of a policy assignment is the part of its ID preceding '/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}'.
		/// PolicyAssignments_Delete {scope}/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}
		/// </summary>
		/// <param name="scope">The scope of the policy assignment. Valid scopes are: management group (format: '/providers/Microsoft.Management/managementGroups/{managementGroup}'), subscription (format: '/subscriptions/{subscriptionId}'), resource group (format: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'</param>
		/// <param name="policyAssignmentName">The name of the policy assignment to delete.</param>
		/// <param name="api_version">The API version to use for the operation.</param>
		/// <returns>OK - Returns information about the deleted assignment.</returns>
		public async Task<PolicyAssignment> PolicyAssignments_DeleteAsync(string scope, string policyAssignmentName, string api_version)
		{
			var requestUri = ""+ (scope==null? "" : System.Uri.EscapeDataString(scope))+"/providers/Microsoft.Authorization/policyAssignments/"+ (policyAssignmentName==null? "" : System.Uri.EscapeDataString(policyAssignmentName))+"&api-version=" + (api_version==null? "" : System.Uri.EscapeDataString(api_version));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PolicyAssignment>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
