//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// List available blockchains
		/// Get an array of active blockchains
		/// GetAvailableBlockchains 
		/// </summary>
		/// <returns>OK</returns>
		public async Task<string[]> GetAvailableBlockchainsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Blockchain Info Summary
		/// Get basic summary of info relating to the currently selected blockchain
		/// GetBlockchain {blockchain}
		/// </summary>
		/// <returns>OK</returns>
		public async Task<GetBlockchainReturn> GetBlockchainAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "{blockchain}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetBlockchainReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get address V2
		/// Returns balances and transactions of an address. The returned transactions are sorted by block height, newest blocks first.
		/// 
		/// The **details** query parameter can specify the level of details returned by the request (default: "txids").
		/// Possible values are:
		/// 
		/// **basic**: return only xpub balances, without any derived addresses and transactions
		/// 
		/// **tokens**: basic + tokens (addresses) derived from the xpub, subject to tokens parameter
		/// 
		/// **tokenBalances**: basic + tokens (addresses) derived from the xpub with balances, subject to tokens parameter
		/// 
		/// **txids**: tokenBalances + list of txids, subject to from, to filter and paging
		/// 
		/// **txs**: tokenBalances + list of transaction with details, subject to from, to filter and paging
		/// 
		/// GetAddressV2 {blockchain}/v2/address/{address}
		/// </summary>
		/// <param name="page">specifies page of returned transactions, starting from 1. If out of range, Blockbook returns the closest possible page.</param>
		/// <param name="pageSize">number of transactions returned by call (default and maximum 1000)</param>
		/// <param name="fromBlock">filter of the returned transactions from block height to block height (default no filter)</param>
		/// <param name="toBlock">filter of the returned transactions from block height to block height (default no filter)</param>
		/// <param name="details">specifies level of details returned by request</param>
		/// <param name="contract">return only transactions which affect specified contract (applicable only to coins which support contracts)</param>
		/// <param name="secondary">specifies secondary (fiat) currency in which the token and total balances are returned in addition to crypto values</param>
		/// <returns>OK</returns>
		public async Task<string> GetAddressV2Async(int page, int pageSize, int fromBlock, int toBlock, GetAddressV2Details details, string contract, string secondary, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "{blockchain}/v2/address/{address}?page="+page+"&pageSize="+pageSize+"&fromBlock="+fromBlock+"&toBlock="+toBlock+"&details=" + details+"&contract=" + (contract==null? "" : System.Uri.EscapeDataString(contract))+"&secondary=" + (secondary==null? "" : System.Uri.EscapeDataString(secondary));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get Balance History V2
		/// Returns a balance history for the specified XPUB or address
		/// 
		/// The value of sentToSelf is the amount sent from the same address to the same address or within addresses of xpub.
		/// GetBalanceHistoryV2 {blockchain}/v2/balancehistory/{addressOrXpub}
		/// </summary>
		/// <param name="fromDate">specifies a start date as a Unix timestamp</param>
		/// <param name="toDate">specifies an end date as a Unix timestamp</param>
		/// <param name="fiatcurrency">if specified, the response will contain secondary (fiat) rate at the time of transaction. If not, all available currencies will be returned</param>
		/// <param name="groupBy">an interval in seconds, to group results by. Default is 3600 seconds</param>
		/// <returns>OK</returns>
		public async Task<GetBalanceHistoryV2Return[]> GetBalanceHistoryV2Async(string fromDate, string toDate, string fiatcurrency, double groupBy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "{blockchain}/v2/balancehistory/{addressOrXpub}?fromDate=" + (fromDate==null? "" : System.Uri.EscapeDataString(fromDate))+"&toDate=" + (toDate==null? "" : System.Uri.EscapeDataString(toDate))+"&fiatcurrency=" + (fiatcurrency==null? "" : System.Uri.EscapeDataString(fiatcurrency))+"&groupBy="+groupBy;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetBalanceHistoryV2Return[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get block hash V2
		/// Get block hash by its height
		/// 
		/// Note: Blockbook always follows the main chain of the backend it is attached to.
		/// GetBlockHashV2 {blockchain}/v2/block-index/{blockHeight}
		/// </summary>
		/// <returns>OK</returns>
		public async Task<GetBlockHashV2Return> GetBlockHashV2Async(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "{blockchain}/v2/block-index/{blockHeight}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetBlockHashV2Return>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get Block V2
		/// Returns information about block with transactions, subject to paging.
		/// 
		/// Note: Blockbook always follows the main chain of the backend it is attached to. If there is a rollback-reorg in the backend, Blockbook will also do rollback. When you ask for block by height, you will always get the main chain block. If you ask for block by hash, you may get the block from another fork but it is not guaranteed (backend may not keep it)
		/// GetBlockV2 {blockchain}/v2/block/{blockHashOrHeight}
		/// </summary>
		/// <param name="page">specifies page of returned transactions, starting from 1. If out of range, Blockbook returns the closest possible page.</param>
		/// <param name="pageSize">number of transactions returned by call (default and maximum 1000)</param>
		/// <returns>OK</returns>
		public async Task<GetBlockV2Return> GetBlockV2Async(int page, int pageSize, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "{blockchain}/v2/block/{blockHashOrHeight}?page="+page+"&pageSize="+pageSize;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetBlockV2Return>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Estimate transaction fee V2
		/// Returns an estimated transaction fee for a specific confirmation target.
		/// If you want your transaction to be included in the next block, then you give 1 as parameter. If it is not urgent, then you can wait a bit longer and get an estimation for the fifth next block.
		/// GetEstimateFeeV2 {blockchain}/v2/estimatefee/{confirmationTarget}
		/// </summary>
		/// <returns>OK</returns>
		public async Task<GetEstimateFeeV2Return> GetEstimateFeeV2Async(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "{blockchain}/v2/estimatefee/{confirmationTarget}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetEstimateFeeV2Return>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get Mempool V2
		/// Get a list of transaction IDs currently in the mempool of the node (meaning unconfirmed transactions not included in any block yet)
		/// 
		/// Note: this route was implemented by us and is therefore not yet supported by existing blockbook clients.
		/// GetMempoolV2 {blockchain}/v2/mempool/
		/// </summary>
		/// <param name="page">specifies page of returned transactions, starting from 1. If out of range, Blockbook returns the closest possible page.</param>
		/// <param name="pageSize">number of transactions returned by call (default and maximum 1000)</param>
		/// <returns>OK</returns>
		public async Task<GetMempoolV2Return> GetMempoolV2Async(int page, int pageSize, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "{blockchain}/v2/mempool/?page="+page+"&pageSize="+pageSize;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetMempoolV2Return>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get NFT metadata V2
		/// Only works on Ethereum-like blockchains (currently ethereum and bsc)
		/// 
		/// Get metadata like name or description for a specified contract and token ID.
		/// The resulting data contains a link which can then be used to request the IPFS link for the actual image to display in a block explorer for example.
		/// 
		/// Note: this route was implemented by us and is therefore not yet supported by existing blockbook clients.
		/// GetNFTMetaV2 {blockchain}/v2/nft/{nftContract}/{nftTokenId}
		/// </summary>
		/// <returns>OK</returns>
		public async Task<GetNFTMetaV2Return> GetNFTMetaV2Async(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "{blockchain}/v2/nft/{nftContract}/{nftTokenId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNFTMetaV2Return>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get raw block data V2
		/// Returns the raw hex-encoded block data for a given block hash or height
		/// GetRawBlockV2 {blockchain}/v2/rawblock/{blockHashOrHeight}
		/// </summary>
		/// <returns>OK</returns>
		public async Task<GetRawBlockV2Return> GetRawBlockV2Async(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "{blockchain}/v2/rawblock/{blockHashOrHeight}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetRawBlockV2Return>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Send transaction (in URL) V2
		/// Sends new transaction to backend
		/// 
		/// It is recommended to use POST for sending transactions as there is a limit on how much data can be sent in the URL itself.
		/// GetSendTxV2 {blockchain}/v2/sendtx/{hex}
		/// </summary>
		/// <returns>OK</returns>
		public async Task<GetSendTxV2Return> GetSendTxV2Async(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "{blockchain}/v2/sendtx/{hex}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetSendTxV2Return>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get Tickers list V2
		/// Returns a list of available currency rate tickers (secondary currencies) for the specified date, along with an actual data timestamp.
		/// 
		/// Trailing slash '/' is mandatory
		/// GetTickersListV2 {blockchain}/v2/tickers-list/
		/// </summary>
		/// <param name="timestamp">specifies a Unix timestamp to (/tickers-list) return available tickers for or (/tickers) that specifies a date to return currency rates for. If not specified, the last available rate will be returned.</param>
		/// <returns>OK</returns>
		public async Task<GetTickersListV2Return> GetTickersListV2Async(string timestamp, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "{blockchain}/v2/tickers-list/?timestamp=" + (timestamp==null? "" : System.Uri.EscapeDataString(timestamp));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetTickersListV2Return>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get Tickers V2
		/// Returns currency rate for the specified currency and date. If the currency is not available for that specific timestamp, the next closest rate will be returned. All responses contain an actual rate timestamp.
		/// GetTickersV2 {blockchain}/v2/tickers/
		/// </summary>
		/// <param name="timestamp">specifies a Unix timestamp to (/tickers-list) return available tickers for or (/tickers) that specifies a date to return currency rates for. If not specified, the last available rate will be returned.</param>
		/// <param name="currency">specifies a currency of returned rate ("usd", "eur", "eth"...). If not specified, all available currencies will be returned</param>
		/// <returns>OK</returns>
		public async Task<GetTickersV2Return> GetTickersV2Async(string timestamp, string currency, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "{blockchain}/v2/tickers/?timestamp=" + (timestamp==null? "" : System.Uri.EscapeDataString(timestamp))+"&currency=" + (currency==null? "" : System.Uri.EscapeDataString(currency));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetTickersV2Return>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get transaction (as is from Backend) V2
		/// Returns transaction data in the exact format as returned by backend, including all coin specific fields
		/// GetTxSpecificV2 {blockchain}/v2/tx-specific/{txId}
		/// </summary>
		/// <returns>OK</returns>
		public async Task<string> GetTxSpecificV2Async(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "{blockchain}/v2/tx-specific/{txId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get transaction V2
		/// Get transaction returns "normalized" data about transaction, which has the same general structure for all supported coins. It does not return coin specific fields (for example information about Zcash shielded addresses).
		/// 
		/// A note about the blockTime field:
		/// for already mined transaction (confirmations > 0), the field blockTime contains time of the block
		/// for transactions in mempool (confirmations == 0), the field contains time when the running instance of Blockbook was first time notified about the transaction. This time may be different in different instances of Blockbook.
		/// GetTransactionV2 {blockchain}/v2/tx/{txId}
		/// </summary>
		/// <returns>OK</returns>
		public async Task<GetTransactionV2Return> GetTransactionV2Async(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "{blockchain}/v2/tx/{txId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetTransactionV2Return>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get UTXO V2
		/// Returns array of unspent transaction outputs of address or xpub, applicable only for Bitcoin-type coins. By default, the list contains both confirmed and unconfirmed transactions. The query parameter confirmed=true disables return of unconfirmed transactions. The returned utxos are sorted by block height, newest blocks first. For xpubs or output descriptors, the response also contains address and derivation path of the utxo.
		/// 
		/// 
		/// 
		/// Unconfirmed utxos do not have field height, the field confirmations has value 0 and may contain field lockTime, if not zero.
		/// 
		/// Coinbase utxos have field coinbase set to true, however due to performance reasons only up to minimum coinbase confirmations limit (100). After this limit, utxos are not detected as coinbase.
		/// GetUTXOV2 {blockchain}/v2/utxo/{addressOrXpub}
		/// </summary>
		/// <param name="confirmed">confirmed=true disables return of unconfirmed transactions</param>
		/// <returns>OK</returns>
		public async Task<string[]> GetUTXOV2Async(bool confirmed, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "{blockchain}/v2/utxo/{addressOrXpub}?confirmed="+confirmed;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get xpub V2
		/// Returns balances and transactions of an xpub or output descriptor, applicable only for Bitcoin-type coins.
		/// 
		/// Blockbook supports BIP44, BIP49, BIP84 and BIP86 (Taproot) derivation schemes, using either xpubs or output descriptors (see https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md)
		/// 
		/// Note: usedTokens always returns total number of used addresses of xpub.
		/// 
		/// Detailed documentation found here: https://github.com/trezor/blockbook/blob/master/docs/api.md#get-xpub
		/// GetXpubV2 {blockchain}/v2/xpub/{xpub}
		/// </summary>
		/// <param name="page">specifies page of returned transactions, starting from 1. If out of range, Blockbook returns the closest possible page.</param>
		/// <param name="pageSize">number of transactions returned by call (default and maximum 1000)</param>
		/// <param name="fromBlock">filter of the returned transactions from block height to block height (default no filter)</param>
		/// <param name="toBlock">filter of the returned transactions from block height to block height (default no filter)</param>
		/// <param name="details">specifies level of details returned by request</param>
		/// <param name="tokens">specifies what tokens (xpub addresses) are returned by the request (default nonzero)</param>
		/// <param name="secondary">specifies secondary (fiat) currency in which the token and total balances are returned in addition to crypto values</param>
		/// <returns>OK</returns>
		public async Task<GetXpubV2Return> GetXpubV2Async(int page, int pageSize, int fromBlock, int toBlock, GetAddressV2Details details, GetXpubV2Tokens tokens, string secondary, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "{blockchain}/v2/xpub/{xpub}?page="+page+"&pageSize="+pageSize+"&fromBlock="+fromBlock+"&toBlock="+toBlock+"&details=" + details+"&tokens=" + tokens+"&secondary=" + (secondary==null? "" : System.Uri.EscapeDataString(secondary));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetXpubV2Return>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
	}
	
	public class GetBlockchainReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="backend")]
		public GetBlockchainReturnBackend Backend { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="blockbook")]
		public GetBlockchainReturnBlockbook Blockbook { get; set; }
	}
	
	public class GetBlockchainReturnBackend
	{
		
		[System.Runtime.Serialization.DataMember(Name="bestBlockHash")]
		public string BestBlockHash { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="blocks")]
		public System.Nullable<System.Int32> Blocks { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="chain")]
		public string Chain { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="difficulty")]
		public string Difficulty { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public System.Nullable<System.Int32> Headers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="protocolVersion")]
		public string ProtocolVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sizeOnDisk")]
		public System.Nullable<System.Int32> SizeOnDisk { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subversion")]
		public string Subversion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	public class GetBlockchainReturnBlockbook
	{
		
		[System.Runtime.Serialization.DataMember(Name="about")]
		public string About { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="bestHeight")]
		public System.Nullable<System.Int32> BestHeight { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="buildTime")]
		public string BuildTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="coin")]
		public string Coin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="currentFiatRatesTime")]
		public string CurrentFiatRatesTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dbSize")]
		public System.Nullable<System.Int32> DbSize { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="decimals")]
		public System.Nullable<System.Int32> Decimals { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gitCommit")]
		public string GitCommit { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hasFiatRates")]
		public System.Nullable<System.Boolean> HasFiatRates { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="historicalFiatRatesTime")]
		public string HistoricalFiatRatesTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="inSync")]
		public System.Nullable<System.Boolean> InSync { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="inSyncMempool")]
		public System.Nullable<System.Boolean> InSyncMempool { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="initialSync")]
		public System.Nullable<System.Boolean> InitialSync { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lastBlockTime")]
		public string LastBlockTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lastMempoolTime")]
		public string LastMempoolTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mempoolSize")]
		public System.Nullable<System.Int32> MempoolSize { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="syncMode")]
		public System.Nullable<System.Boolean> SyncMode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	public enum GetAddressV2Details
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		basic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tokens = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tokenBalances = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		txids = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		txslight = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		txs = 5,
	}
	
	public class GetBalanceHistoryV2Return
	{
		
		[System.Runtime.Serialization.DataMember(Name="rates")]
		public string Rates { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="received")]
		public string Received { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sent")]
		public string Sent { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sentToSelf")]
		public string SentToSelf { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.Int32> Time { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="txs")]
		public System.Nullable<System.Int32> Txs { get; set; }
	}
	
	public class GetBlockHashV2Return
	{
		
		[System.Runtime.Serialization.DataMember(Name="blockHash")]
		public string BlockHash { get; set; }
	}
	
	public class GetBlockV2Return
	{
		
		[System.Runtime.Serialization.DataMember(Name="bits")]
		public string Bits { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="confirmations")]
		public System.Nullable<System.Int32> Confirmations { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="difficulty")]
		public string Difficulty { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hash")]
		public string Hash { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="height")]
		public System.Nullable<System.Int32> Height { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="itemsOnPage")]
		public System.Nullable<System.Int32> ItemsOnPage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="merkleRoot")]
		public string MerkleRoot { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextBlockHash")]
		public string NextBlockHash { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nonce")]
		public string Nonce { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page")]
		public System.Nullable<System.Int32> Page { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="previousBlockHash")]
		public string PreviousBlockHash { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.Int32> Time { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="totalPages")]
		public System.Nullable<System.Int32> TotalPages { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="txCount")]
		public System.Nullable<System.Int32> TxCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="txs")]
		public GetBlockV2ReturnTxs[] GetBlockV2ReturnTxs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="version")]
		public System.Nullable<System.Int32> Version { get; set; }
	}
	
	public class GetBlockV2ReturnTxs
	{
		
		[System.Runtime.Serialization.DataMember(Name="blockHash")]
		public string BlockHash { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="blockHeight")]
		public System.Nullable<System.Int32> BlockHeight { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="blockTime")]
		public System.Nullable<System.Int32> BlockTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="confirmations")]
		public System.Nullable<System.Int32> Confirmations { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="fees")]
		public string Fees { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="txid")]
		public string Txid { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="valueIn")]
		public string ValueIn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="vin")]
		public GetBlockV2ReturnTxsVin[] GetBlockV2ReturnTxsVin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="vout")]
		public GetBlockV2ReturnTxsVout[] GetBlockV2ReturnTxsVout { get; set; }
	}
	
	public class GetBlockV2ReturnTxsVin
	{
		
		[System.Runtime.Serialization.DataMember(Name="isAddress")]
		public System.Nullable<System.Boolean> IsAddress { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="n")]
		public System.Nullable<System.Int32> N { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class GetBlockV2ReturnTxsVout
	{
		
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public string[] Addresses { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="isAddress")]
		public System.Nullable<System.Boolean> IsAddress { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="n")]
		public System.Nullable<System.Int32> N { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class GetEstimateFeeV2Return
	{
		
		[System.Runtime.Serialization.DataMember(Name="result")]
		public string Result { get; set; }
	}
	
	public class GetMempoolV2Return
	{
		
		[System.Runtime.Serialization.DataMember(Name="itemsOnPage")]
		public System.Nullable<System.Int32> ItemsOnPage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mempool")]
		public GetMempoolV2ReturnMempool[] GetMempoolV2ReturnMempool { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mempoolSize")]
		public System.Nullable<System.Int32> MempoolSize { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page")]
		public System.Nullable<System.Int32> Page { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="totalPages")]
		public System.Nullable<System.Int32> TotalPages { get; set; }
	}
	
	public class GetMempoolV2ReturnMempool
	{
		
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.Int32> Time { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="txid")]
		public string Txid { get; set; }
	}
	
	public class GetNFTMetaV2Return
	{
		
		[System.Runtime.Serialization.DataMember(Name="contractInfo")]
		public GetNFTMetaV2ReturnContractInfo ContractInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tokenId")]
		public string TokenId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
	}
	
	public class GetNFTMetaV2ReturnContractInfo
	{
		
		[System.Runtime.Serialization.DataMember(Name="contract")]
		public string Contract { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="decimals")]
		public System.Nullable<System.Int32> Decimals { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="symbol")]
		public string Symbol { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class GetRawBlockV2Return
	{
		
		[System.Runtime.Serialization.DataMember(Name="hex")]
		public string Hex { get; set; }
	}
	
	public class GetSendTxV2Return
	{
		
		[System.Runtime.Serialization.DataMember(Name="result")]
		public string Result { get; set; }
	}
	
	public class GetTickersListV2Return
	{
		
		[System.Runtime.Serialization.DataMember(Name="available_currencies")]
		public string[] Available_currencies { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ts")]
		public System.Nullable<System.Int32> Ts { get; set; }
	}
	
	public class GetTickersV2Return
	{
		
		[System.Runtime.Serialization.DataMember(Name="rates")]
		public string Rates { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ts")]
		public System.Nullable<System.Int32> Ts { get; set; }
	}
	
	public class GetTransactionV2Return
	{
		
		[System.Runtime.Serialization.DataMember(Name="blockHash")]
		public string BlockHash { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="blockHeight")]
		public System.Nullable<System.Int32> BlockHeight { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="blockTime")]
		public System.Nullable<System.Int32> BlockTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="confirmations")]
		public System.Nullable<System.Int32> Confirmations { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="fees")]
		public string Fees { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hex")]
		public string Hex { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="txid")]
		public string Txid { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="valueIn")]
		public string ValueIn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="version")]
		public System.Nullable<System.Int32> Version { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="vin")]
		public GetTransactionV2ReturnVin[] GetTransactionV2ReturnVin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="vout")]
		public GetTransactionV2ReturnVout[] GetTransactionV2ReturnVout { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="vsize")]
		public System.Nullable<System.Int32> Vsize { get; set; }
	}
	
	public class GetTransactionV2ReturnVin
	{
		
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public string[] Addresses { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hex")]
		public string Hex { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="isAddress")]
		public System.Nullable<System.Boolean> IsAddress { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="n")]
		public System.Nullable<System.Int32> N { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sequence")]
		public System.Nullable<System.Int32> Sequence { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="txid")]
		public string Txid { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="vout")]
		public System.Nullable<System.Int32> Vout { get; set; }
	}
	
	public class GetTransactionV2ReturnVout
	{
		
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public string[] Addresses { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hex")]
		public string Hex { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="isAddress")]
		public System.Nullable<System.Boolean> IsAddress { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="n")]
		public System.Nullable<System.Int32> N { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public enum GetXpubV2Tokens
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		nonzero = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		used = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		derived = 2,
	}
	
	public class GetXpubV2Return
	{
		
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="balance")]
		public string Balance { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="itemsOnPage")]
		public System.Nullable<System.Int32> ItemsOnPage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page")]
		public System.Nullable<System.Int32> Page { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="secondaryValue")]
		public System.Nullable<System.Double> SecondaryValue { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tokens")]
		public GetXpubV2ReturnTokens[] GetXpubV2ReturnTokens { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="totalPages")]
		public System.Nullable<System.Int32> TotalPages { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="totalReceived")]
		public string TotalReceived { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="totalSent")]
		public string TotalSent { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="txids")]
		public string[] Txids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="txs")]
		public System.Nullable<System.Int32> Txs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="unconfirmedBalance")]
		public string UnconfirmedBalance { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="unconfirmedTxs")]
		public System.Nullable<System.Int32> UnconfirmedTxs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="usedTokens")]
		public System.Nullable<System.Int32> UsedTokens { get; set; }
	}
	
	public class GetXpubV2ReturnTokens
	{
		
		[System.Runtime.Serialization.DataMember(Name="balance")]
		public string Balance { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="decimals")]
		public System.Nullable<System.Int32> Decimals { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="totalReceived")]
		public string TotalReceived { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="totalSent")]
		public string TotalSent { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="transfers")]
		public System.Nullable<System.Int32> Transfers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
