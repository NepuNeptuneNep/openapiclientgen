//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterface
	{
		
		/// <summary>
		/// The next hop for any traffic that isn't going to a directly connected subnet or over a static route.         This IP address must exist in a subnet with a routed interface. Required if this is the first IPv4 interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultGateway")]
		public string DefaultGateway { get; set; }
		
		/// <summary>
		/// The IP address this switch will use for layer 3 routing on this VLAN or subnet. This cannot be the same         as the switch's management IP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaceIp")]
		public string InterfaceIp { get; set; }
		
		/// <summary>
		/// The IPv6 settings of the interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceIpv6 Ipv6 { get; set; }
		
		/// <summary>
		/// Enable multicast support if, multicast routing between VLANs is required. Options are:         'disabled', 'enabled' or 'IGMP snooping querier'. Default is 'disabled'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multicastRouting")]
		public System.Nullable<CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceMulticastRouting> MulticastRouting { get; set; }
		
		/// <summary>
		/// A friendly name or description for the interface or VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The OSPF routing settings of the interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ospfSettings")]
		public CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceOspfSettings OspfSettings { get; set; }
		
		/// <summary>
		/// The OSPFv3 routing settings of the interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ospfV3")]
		public CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceOspfV3 OspfV3 { get; set; }
		
		/// <summary>
		/// The network that this routed interface is on, in CIDR notation (ex. 10.1.1.0/24).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
		
		/// <summary>
		/// The VLAN this routed interface is on. VLAN must be between 1 and 4094.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public System.Nullable<System.Int32> VlanId { get; set; }
	}
	
	public class CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceIpv6
	{
		
		/// <summary>
		/// The IPv6 address of the interface. Required if assignmentMode is 'static'. Must not be included if           assignmentMode is 'eui-64'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The IPv6 assignment mode for the interface. Can be either 'eui-64' or 'static'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignmentMode")]
		public string AssignmentMode { get; set; }
		
		/// <summary>
		/// The IPv6 default gateway of the interface. Required if prefix is defined and this is the first           interface with IPv6 configured for the switch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The IPv6 prefix of the interface. Required if IPv6 object is included.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceMulticastRouting
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IGMP snooping querier")]
		IGMP_snooping_querier = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 2,
	}
	
	public class CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceOspfSettings
	{
		
		/// <summary>
		/// The OSPF area to which this interface should belong. Can be either 'disabled' or the identifier of an           existing OSPF area. Defaults to 'disabled'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="area")]
		public string Area { get; set; }
		
		/// <summary>
		/// The path cost for this interface. Defaults to 1, but can be increased up to 65535           to give lower priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cost")]
		public System.Nullable<System.Int32> Cost { get; set; }
		
		/// <summary>
		/// When enabled, OSPF will not run on the interface, but the subnet will still be advertised.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPassiveEnabled")]
		public System.Nullable<System.Boolean> IsPassiveEnabled { get; set; }
	}
	
	public class CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterfaceOspfV3
	{
		
		/// <summary>
		/// The OSPFv3 area to which this interface should belong. Can be either 'disabled' or the identifier of an           existing OSPFv3 area. Defaults to 'disabled'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="area")]
		public string Area { get; set; }
		
		/// <summary>
		/// The path cost for this interface. Defaults to 1, but can be increased up to 65535           to give lower priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cost")]
		public System.Nullable<System.Int32> Cost { get; set; }
		
		/// <summary>
		/// When enabled, OSPFv3 will not run on the interface, but the subnet will still be advertised.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPassiveEnabled")]
		public System.Nullable<System.Boolean> IsPassiveEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateDeviceSwitchRoutingStaticRouteCreatedeviceswitchroutingstaticroute
	{
		
		/// <summary>
		/// Option to advertise static route via OSPF
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advertiseViaOspfEnabled")]
		public System.Nullable<System.Boolean> AdvertiseViaOspfEnabled { get; set; }
		
		/// <summary>
		/// Name or description for layer 3 static route
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// IP address of the next hop device to which the device sends its traffic for the subnet
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nextHopIp")]
		public string NextHopIp { get; set; }
		
		/// <summary>
		/// Option to prefer static route over OSPF routes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preferOverOspfRoutesEnabled")]
		public System.Nullable<System.Boolean> PreferOverOspfRoutesEnabled { get; set; }
		
		/// <summary>
		/// The subnet which is routed via this static route and should be specified in CIDR notation (ex. 1.2.3.0/24)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroup
	{
		
		/// <summary>
		/// The devices and Switch Stacks assigned to the Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignedDevices")]
		public CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevices AssignedDevices { get; set; }
		
		/// <summary>
		/// Description of the Staged Upgrade Group. Length must be 1 to 255 characters
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Boolean indicating the default Group. Any device that does not have a group explicitly assigned will upgrade with this group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isDefault")]
		public bool IsDefault { get; set; }
		
		/// <summary>
		/// Name of the Staged Upgrade Group. Length must be 1 to 255 characters
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevices
	{
		
		/// <summary>
		/// Data Array of Devices containing the name and serial
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="devices")]
		public CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesDevices[] CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesDevices { get; set; }
		
		/// <summary>
		/// Data Array of Switch Stacks containing the name and id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchStacks")]
		public CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesSwitchStacks[] CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesSwitchStacks { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesDevices
	{
		
		/// <summary>
		/// Name of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Serial of the device
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroupAssignedDevicesSwitchStacks
	{
		
		/// <summary>
		/// ID of the Switch Stack
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the Switch Stack
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateNetworkSmTargetGroupCreatenetworksmtargetgroup
	{
		
		/// <summary>
		/// The name of this target group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The scope and tag options of the target group. Comma separated values beginning with one of withAny, withAll, withoutAny, withoutAll, all, none, followed by tags. Default to none if empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scope")]
		public string Scope { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateDeviceSwitchRoutingStaticRouteUpdatedeviceswitchroutingstaticroute
	{
		
		/// <summary>
		/// Option to advertise static route via OSPF
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advertiseViaOspfEnabled")]
		public System.Nullable<System.Boolean> AdvertiseViaOspfEnabled { get; set; }
		
		/// <summary>
		/// Name or description for layer 3 static route
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// IP address of the next hop device to which the device sends its traffic for the subnet
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextHopIp")]
		public string NextHopIp { get; set; }
		
		/// <summary>
		/// Option to prefer static route over OSPF routes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preferOverOspfRoutesEnabled")]
		public System.Nullable<System.Boolean> PreferOverOspfRoutesEnabled { get; set; }
		
		/// <summary>
		/// The subnet which is routed via this static route and should be specified in CIDR notation (ex. 1.2.3.0/24)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrules
	{
		
		/// <summary>
		/// An ordered array of the firewall rules (not including the default rule)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRules[] UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRules { get; set; }
	}
	
	public class UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRules
	{
		
		/// <summary>
		/// Description of the rule (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destCidr")]
		public string DestCidr { get; set; }
		
		/// <summary>
		/// Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destPort")]
		public string DestPort { get; set; }
		
		/// <summary>
		/// 'allow' or 'deny' traffic specified by this rule
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy Policy { get; set; }
		
		/// <summary>
		/// The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="srcCidr")]
		public string SrcCidr { get; set; }
		
		/// <summary>
		/// Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPort")]
		public string SrcPort { get; set; }
		
		/// <summary>
		/// Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syslogEnabled")]
		public System.Nullable<System.Boolean> SyslogEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		allow = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deny = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		any = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		icmp = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		icmp6 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tcp = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		udp = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrules
	{
		
		/// <summary>
		/// An ordered array of the firewall rules (not including the default rule)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRules[] UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRules { get; set; }
		
		/// <summary>
		/// Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syslogDefaultRule")]
		public System.Nullable<System.Boolean> SyslogDefaultRule { get; set; }
	}
	
	public class UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrulesRules
	{
		
		/// <summary>
		/// Description of the rule (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destCidr")]
		public string DestCidr { get; set; }
		
		/// <summary>
		/// Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destPort")]
		public string DestPort { get; set; }
		
		/// <summary>
		/// 'allow' or 'deny' traffic specified by this rule
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy Policy { get; set; }
		
		/// <summary>
		/// The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="srcCidr")]
		public string SrcCidr { get; set; }
		
		/// <summary>
		/// Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPort")]
		public string SrcPort { get; set; }
		
		/// <summary>
		/// Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syslogEnabled")]
		public System.Nullable<System.Boolean> SyslogEnabled { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Returns the identity of the current user.
		/// Returns the identity of the current user.
		/// GetAdministeredIdentitiesMe administered/identities/me
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetAdministeredIdentitiesMeReturn> GetAdministeredIdentitiesMeAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "administered/identities/me";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetAdministeredIdentitiesMeReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a single device
		/// Return a single device
		/// GetDevice devices/{serial}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the attributes of a device
		/// Update the attributes of a device
		/// UpdateDevice devices/{serial}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateDeviceAsync(string serial, UpdateDevicePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the DHCP subnet information for an appliance
		/// Return the DHCP subnet information for an appliance
		/// GetDeviceApplianceDhcpSubnets devices/{serial}/appliance/dhcp/subnets
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetDeviceApplianceDhcpSubnetsAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/appliance/dhcp/subnets";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the performance score for a single MX
		/// Return the performance score for a single MX. Only primary MX devices supported. If no data is available, a 204 error code is returned.
		/// GetDeviceAppliancePerformance devices/{serial}/appliance/performance
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceAppliancePerformanceAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/appliance/performance";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return current delegated IPv6 prefixes on an appliance.
		/// Return current delegated IPv6 prefixes on an appliance.
		/// GetDeviceAppliancePrefixesDelegated devices/{serial}/appliance/prefixes/delegated
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetDeviceAppliancePrefixesDelegatedAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/appliance/prefixes/delegated";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return prefixes assigned to all IPv6 enabled VLANs on an appliance.
		/// Return prefixes assigned to all IPv6 enabled VLANs on an appliance.
		/// GetDeviceAppliancePrefixesDelegatedVlanAssignments devices/{serial}/appliance/prefixes/delegated/vlanAssignments
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetDeviceAppliancePrefixesDelegatedVlanAssignmentsAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/appliance/prefixes/delegated/vlanAssignments";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the uplink settings for an MX appliance
		/// Return the uplink settings for an MX appliance
		/// GetDeviceApplianceUplinksSettings devices/{serial}/appliance/uplinks/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetDeviceApplianceUplinksSettingsReturn> GetDeviceApplianceUplinksSettingsAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/appliance/uplinks/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetDeviceApplianceUplinksSettingsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the uplink settings for an MX appliance
		/// Update the uplink settings for an MX appliance
		/// UpdateDeviceApplianceUplinksSettings devices/{serial}/appliance/uplinks/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateDeviceApplianceUplinksSettingsReturn> UpdateDeviceApplianceUplinksSettingsAsync(string serial, UpdateDeviceApplianceUplinksSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/appliance/uplinks/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateDeviceApplianceUplinksSettingsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Generate a new vMX authentication token
		/// Generate a new vMX authentication token
		/// CreateDeviceApplianceVmxAuthenticationToken devices/{serial}/appliance/vmx/authenticationToken
		/// </summary>
		public async Task CreateDeviceApplianceVmxAuthenticationTokenAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/appliance/vmx/authenticationToken";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Blink the LEDs on a device
		/// Blink the LEDs on a device
		/// BlinkDeviceLeds devices/{serial}/blinkLeds
		/// </summary>
		public async Task BlinkDeviceLedsAsync(string serial, BlinkDeviceLedsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/blinkLeds";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns live state from camera of analytics zones
		/// Returns live state from camera of analytics zones
		/// GetDeviceCameraAnalyticsLive devices/{serial}/camera/analytics/live
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceCameraAnalyticsLiveAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/analytics/live";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns an overview of aggregate analytics data for a timespan
		/// Returns an overview of aggregate analytics data for a timespan
		/// GetDeviceCameraAnalyticsOverview devices/{serial}/camera/analytics/overview
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 365 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 1 hour.</param>
		/// <param name="objectType">[optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle].</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetDeviceCameraAnalyticsOverviewAsync(string serial, string t0, string t1, float timespan, GetDeviceCameraAnalyticsOverviewObjectType objectType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/analytics/overview&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&objectType=" + objectType;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns most recent record for analytics zones
		/// Returns most recent record for analytics zones
		/// GetDeviceCameraAnalyticsRecent devices/{serial}/camera/analytics/recent
		/// </summary>
		/// <param name="objectType">[optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle].</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetDeviceCameraAnalyticsRecentAsync(string serial, GetDeviceCameraAnalyticsOverviewObjectType objectType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/analytics/recent&objectType=" + objectType;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns all configured analytic zones for this camera
		/// Returns all configured analytic zones for this camera
		/// GetDeviceCameraAnalyticsZones devices/{serial}/camera/analytics/zones
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetDeviceCameraAnalyticsZonesAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/analytics/zones";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return historical records for analytic zones
		/// Return historical records for analytic zones
		/// GetDeviceCameraAnalyticsZoneHistory devices/{serial}/camera/analytics/zones/{zoneId}/history
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 365 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 14 hours after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 hours. The default is 1 hour.</param>
		/// <param name="resolution">The time resolution in seconds for returned data. The valid resolutions are: 60. The default is 60.</param>
		/// <param name="objectType">[optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle].</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetDeviceCameraAnalyticsZoneHistoryAsync(string serial, string zoneId, string t0, string t1, float timespan, int resolution, GetDeviceCameraAnalyticsOverviewObjectType objectType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/analytics/zones/"+ (zoneId==null? "" : System.Uri.EscapeDataString(zoneId))+"/history&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&resolution="+resolution+"&objectType=" + objectType;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return custom analytics settings for a camera
		/// Return custom analytics settings for a camera
		/// GetDeviceCameraCustomAnalytics devices/{serial}/camera/customAnalytics
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceCameraCustomAnalyticsAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/customAnalytics";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update custom analytics settings for a camera
		/// Update custom analytics settings for a camera
		/// UpdateDeviceCameraCustomAnalytics devices/{serial}/camera/customAnalytics
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateDeviceCameraCustomAnalyticsAsync(string serial, UpdateDeviceCameraCustomAnalyticsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/customAnalytics";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Generate a snapshot of what the camera sees at the specified time and return a link to that image.
		/// Generate a snapshot of what the camera sees at the specified time and return a link to that image.
		/// GenerateDeviceCameraSnapshot devices/{serial}/camera/generateSnapshot
		/// </summary>
		public async Task GenerateDeviceCameraSnapshotAsync(string serial, GenerateDeviceCameraSnapshotPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/generateSnapshot";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns quality and retention settings for the given camera
		/// Returns quality and retention settings for the given camera
		/// GetDeviceCameraQualityAndRetention devices/{serial}/camera/qualityAndRetention
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceCameraQualityAndRetentionAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/qualityAndRetention";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update quality and retention settings for the given camera
		/// Update quality and retention settings for the given camera
		/// UpdateDeviceCameraQualityAndRetention devices/{serial}/camera/qualityAndRetention
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateDeviceCameraQualityAndRetentionAsync(string serial, UpdateDeviceCameraQualityAndRetentionPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/qualityAndRetention";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns sense settings for a given camera
		/// Returns sense settings for a given camera
		/// GetDeviceCameraSense devices/{serial}/camera/sense
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceCameraSenseAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/sense";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update sense settings for the given camera
		/// Update sense settings for the given camera
		/// UpdateDeviceCameraSense devices/{serial}/camera/sense
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateDeviceCameraSenseAsync(string serial, UpdateDeviceCameraSensePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/sense";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns the MV Sense object detection model list for the given camera
		/// Returns the MV Sense object detection model list for the given camera
		/// GetDeviceCameraSenseObjectDetectionModels devices/{serial}/camera/sense/objectDetectionModels
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetDeviceCameraSenseObjectDetectionModelsAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/sense/objectDetectionModels";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns video settings for the given camera
		/// Returns video settings for the given camera
		/// GetDeviceCameraVideoSettings devices/{serial}/camera/video/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceCameraVideoSettingsAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/video/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update video settings for the given camera
		/// Update video settings for the given camera
		/// UpdateDeviceCameraVideoSettings devices/{serial}/camera/video/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateDeviceCameraVideoSettingsAsync(string serial, UpdateDeviceCameraVideoSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/video/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns video link to the specified camera
		/// Returns video link to the specified camera. If a timestamp is supplied, it links to that timestamp.
		/// GetDeviceCameraVideoLink devices/{serial}/camera/videoLink
		/// </summary>
		/// <param name="timestamp">[optional] The video link will start at this time. The timestamp should be a string in ISO8601 format. If no timestamp is specified, we will assume current time.</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceCameraVideoLinkAsync(string serial, System.DateTimeOffset timestamp, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/videoLink&timestamp=" + timestamp.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns wireless profile assigned to the given camera
		/// Returns wireless profile assigned to the given camera
		/// GetDeviceCameraWirelessProfiles devices/{serial}/camera/wirelessProfiles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceCameraWirelessProfilesAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/wirelessProfiles";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Assign wireless profiles to the given camera
		/// Assign wireless profiles to the given camera. Incremental updates are not supported, all profile assignment need to be supplied at once.
		/// UpdateDeviceCameraWirelessProfiles devices/{serial}/camera/wirelessProfiles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateDeviceCameraWirelessProfilesAsync(string serial, UpdateDeviceCameraWirelessProfilesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/camera/wirelessProfiles";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the SIM and APN configurations for a cellular device.
		/// Return the SIM and APN configurations for a cellular device.
		/// GetDeviceCellularSims devices/{serial}/cellular/sims
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceCellularSimsAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/cellular/sims";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates the SIM and APN configurations for a cellular device.
		/// Updates the SIM and APN configurations for a cellular device.
		/// UpdateDeviceCellularSims devices/{serial}/cellular/sims
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateDeviceCellularSimsAsync(string serial, UpdateDeviceCellularSimsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/cellular/sims";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Show the LAN Settings of a MG
		/// Show the LAN Settings of a MG
		/// GetDeviceCellularGatewayLan devices/{serial}/cellularGateway/lan
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceCellularGatewayLanAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/cellularGateway/lan";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the LAN Settings for a single MG.
		/// Update the LAN Settings for a single MG.
		/// UpdateDeviceCellularGatewayLan devices/{serial}/cellularGateway/lan
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateDeviceCellularGatewayLanAsync(string serial, UpdateDeviceCellularGatewayLanPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/cellularGateway/lan";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns the port forwarding rules for a single MG.
		/// Returns the port forwarding rules for a single MG.
		/// GetDeviceCellularGatewayPortForwardingRules devices/{serial}/cellularGateway/portForwardingRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceCellularGatewayPortForwardingRulesAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/cellularGateway/portForwardingRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates the port forwarding rules for a single MG.
		/// Updates the port forwarding rules for a single MG.
		/// UpdateDeviceCellularGatewayPortForwardingRules devices/{serial}/cellularGateway/portForwardingRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateDeviceCellularGatewayPortForwardingRulesAsync(string serial, UpdateDeviceCellularGatewayPortForwardingRulesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/cellularGateway/portForwardingRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the clients of a device, up to a maximum of a month ago
		/// List the clients of a device, up to a maximum of a month ago. The usage of each client is returned in kilobytes. If the device is a switch, the switchport is returned; otherwise the switchport field is null.
		/// GetDeviceClients devices/{serial}/clients
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetDeviceClientsAsync(string serial, string t0, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/clients&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&timespan="+timespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Enqueue a job to ping a target host from the device
		/// Enqueue a job to ping a target host from the device
		/// CreateDeviceLiveToolsPing devices/{serial}/liveTools/ping
		/// </summary>
		public async Task CreateDeviceLiveToolsPingAsync(string serial, CreateDeviceLiveToolsPingPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/liveTools/ping";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a ping job
		/// Return a ping job. Latency unit in response is in milliseconds. Size is in bytes.
		/// GetDeviceLiveToolsPing devices/{serial}/liveTools/ping/{id}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetDeviceLiveToolsPingReturn> GetDeviceLiveToolsPingAsync(string serial, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/liveTools/ping/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetDeviceLiveToolsPingReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Enqueue a job to check connectivity status to the device
		/// Enqueue a job to check connectivity status to the device
		/// CreateDeviceLiveToolsPingDevice devices/{serial}/liveTools/pingDevice
		/// </summary>
		public async Task CreateDeviceLiveToolsPingDeviceAsync(string serial, CreateDeviceLiveToolsPingDevicePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/liveTools/pingDevice";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a ping device job
		/// Return a ping device job. Latency unit in response is in milliseconds. Size is in bytes.
		/// GetDeviceLiveToolsPingDevice devices/{serial}/liveTools/pingDevice/{id}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetDeviceLiveToolsPingDeviceReturn> GetDeviceLiveToolsPingDeviceAsync(string serial, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/liveTools/pingDevice/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetDeviceLiveToolsPingDeviceReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List LLDP and CDP information for a device
		/// List LLDP and CDP information for a device
		/// GetDeviceLldpCdp devices/{serial}/lldpCdp
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceLldpCdpAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/lldpCdp";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get the uplink loss percentage and latency in milliseconds, and goodput in kilobits per second for a wired network device.
		/// Get the uplink loss percentage and latency in milliseconds, and goodput in kilobits per second for a wired network device.
		/// GetDeviceLossAndLatencyHistory devices/{serial}/lossAndLatencyHistory
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 60 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <param name="resolution">The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60.</param>
		/// <param name="uplink">The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, cellular. The default is wan1.</param>
		/// <param name="ip">The destination IP used to obtain the requested stats. This is required.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetDeviceLossAndLatencyHistoryAsync(string serial, string t0, string t1, float timespan, int resolution, GetDeviceLossAndLatencyHistoryUplink uplink, string ip, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/lossAndLatencyHistory&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&resolution="+resolution+"&uplink=" + uplink+"&ip=" + (ip==null? "" : System.Uri.EscapeDataString(ip));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the management interface settings for a device
		/// Return the management interface settings for a device
		/// GetDeviceManagementInterface devices/{serial}/managementInterface
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceManagementInterfaceAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/managementInterface";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the management interface settings for a device
		/// Update the management interface settings for a device
		/// UpdateDeviceManagementInterface devices/{serial}/managementInterface
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateDeviceManagementInterfaceAsync(string serial, UpdateDeviceManagementInterfacePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/managementInterface";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Reboot a device
		/// Reboot a device
		/// RebootDevice devices/{serial}/reboot
		/// </summary>
		public async Task RebootDeviceAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/reboot";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the sensor roles for a given sensor or camera device.
		/// List the sensor roles for a given sensor or camera device.
		/// GetDeviceSensorRelationships devices/{serial}/sensor/relationships
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetDeviceSensorRelationshipsReturn[]> GetDeviceSensorRelationshipsAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/sensor/relationships";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetDeviceSensorRelationshipsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Assign one or more sensor roles to a given sensor or camera device.
		/// Assign one or more sensor roles to a given sensor or camera device.
		/// UpdateDeviceSensorRelationships devices/{serial}/sensor/relationships
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateDeviceSensorRelationshipsReturn> UpdateDeviceSensorRelationshipsAsync(string serial, UpdateDeviceSensorRelationshipsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/sensor/relationships";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateDeviceSensorRelationshipsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the switch ports for a switch
		/// List the switch ports for a switch
		/// GetDeviceSwitchPorts devices/{serial}/switch/ports
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetDeviceSwitchPortsReturn[]> GetDeviceSwitchPortsAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/ports";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetDeviceSwitchPortsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Cycle a set of switch ports
		/// Cycle a set of switch ports
		/// CycleDeviceSwitchPorts devices/{serial}/switch/ports/cycle
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> CycleDeviceSwitchPortsAsync(string serial, CycleDeviceSwitchPortsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/ports/cycle";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the status for all the ports of a switch
		/// Return the status for all the ports of a switch
		/// GetDeviceSwitchPortsStatuses devices/{serial}/switch/ports/statuses
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetDeviceSwitchPortsStatusesReturn[]> GetDeviceSwitchPortsStatusesAsync(string serial, string t0, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/ports/statuses&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&timespan="+timespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetDeviceSwitchPortsStatusesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the packet counters for all the ports of a switch
		/// Return the packet counters for all the ports of a switch
		/// GetDeviceSwitchPortsStatusesPackets devices/{serial}/switch/ports/statuses/packets
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 1 day from today.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 1 day. The default is 1 day.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetDeviceSwitchPortsStatusesPacketsAsync(string serial, string t0, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/ports/statuses/packets&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&timespan="+timespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a switch port
		/// Return a switch port
		/// GetDeviceSwitchPort devices/{serial}/switch/ports/{portId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetDeviceSwitchPortReturn> GetDeviceSwitchPortAsync(string serial, string portId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/ports/"+ (portId==null? "" : System.Uri.EscapeDataString(portId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetDeviceSwitchPortReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a switch port
		/// Update a switch port
		/// UpdateDeviceSwitchPort devices/{serial}/switch/ports/{portId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateDeviceSwitchPortReturn> UpdateDeviceSwitchPortAsync(string serial, string portId, UpdateDeviceSwitchPortPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/ports/"+ (portId==null? "" : System.Uri.EscapeDataString(portId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateDeviceSwitchPortReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List layer 3 interfaces for a switch
		/// List layer 3 interfaces for a switch. Those for a stack may be found under switch stack routing.
		/// GetDeviceSwitchRoutingInterfaces devices/{serial}/switch/routing/interfaces
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetDeviceSwitchRoutingInterfacesReturn[]> GetDeviceSwitchRoutingInterfacesAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/routing/interfaces";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetDeviceSwitchRoutingInterfacesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a layer 3 interface for a switch
		/// Create a layer 3 interface for a switch
		/// CreateDeviceSwitchRoutingInterface devices/{serial}/switch/routing/interfaces
		/// </summary>
		public async Task CreateDeviceSwitchRoutingInterfaceAsync(string serial, CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterface requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/routing/interfaces";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a layer 3 interface from the switch
		/// Delete a layer 3 interface from the switch
		/// DeleteDeviceSwitchRoutingInterface devices/{serial}/switch/routing/interfaces/{interfaceId}
		/// </summary>
		public async Task DeleteDeviceSwitchRoutingInterfaceAsync(string serial, string interfaceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/routing/interfaces/"+ (interfaceId==null? "" : System.Uri.EscapeDataString(interfaceId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a layer 3 interface for a switch
		/// Return a layer 3 interface for a switch
		/// GetDeviceSwitchRoutingInterface devices/{serial}/switch/routing/interfaces/{interfaceId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetDeviceSwitchRoutingInterfaceReturn> GetDeviceSwitchRoutingInterfaceAsync(string serial, string interfaceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/routing/interfaces/"+ (interfaceId==null? "" : System.Uri.EscapeDataString(interfaceId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetDeviceSwitchRoutingInterfaceReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a layer 3 interface for a switch
		/// Update a layer 3 interface for a switch
		/// UpdateDeviceSwitchRoutingInterface devices/{serial}/switch/routing/interfaces/{interfaceId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateDeviceSwitchRoutingInterfaceReturn> UpdateDeviceSwitchRoutingInterfaceAsync(string serial, string interfaceId, CreateDeviceSwitchRoutingInterfaceCreatedeviceswitchroutinginterface requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/routing/interfaces/"+ (interfaceId==null? "" : System.Uri.EscapeDataString(interfaceId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateDeviceSwitchRoutingInterfaceReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a layer 3 interface DHCP configuration for a switch
		/// Return a layer 3 interface DHCP configuration for a switch
		/// GetDeviceSwitchRoutingInterfaceDhcp devices/{serial}/switch/routing/interfaces/{interfaceId}/dhcp
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceSwitchRoutingInterfaceDhcpAsync(string serial, string interfaceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/routing/interfaces/"+ (interfaceId==null? "" : System.Uri.EscapeDataString(interfaceId))+"/dhcp";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a layer 3 interface DHCP configuration for a switch
		/// Update a layer 3 interface DHCP configuration for a switch
		/// UpdateDeviceSwitchRoutingInterfaceDhcp devices/{serial}/switch/routing/interfaces/{interfaceId}/dhcp
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateDeviceSwitchRoutingInterfaceDhcpAsync(string serial, string interfaceId, UpdateDeviceSwitchRoutingInterfaceDhcpPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/routing/interfaces/"+ (interfaceId==null? "" : System.Uri.EscapeDataString(interfaceId))+"/dhcp";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List layer 3 static routes for a switch
		/// List layer 3 static routes for a switch
		/// GetDeviceSwitchRoutingStaticRoutes devices/{serial}/switch/routing/staticRoutes
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetDeviceSwitchRoutingStaticRoutesAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/routing/staticRoutes";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a layer 3 static route for a switch
		/// Create a layer 3 static route for a switch
		/// CreateDeviceSwitchRoutingStaticRoute devices/{serial}/switch/routing/staticRoutes
		/// </summary>
		public async Task CreateDeviceSwitchRoutingStaticRouteAsync(string serial, CreateDeviceSwitchRoutingStaticRouteCreatedeviceswitchroutingstaticroute requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/routing/staticRoutes";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a layer 3 static route for a switch
		/// Delete a layer 3 static route for a switch
		/// DeleteDeviceSwitchRoutingStaticRoute devices/{serial}/switch/routing/staticRoutes/{staticRouteId}
		/// </summary>
		public async Task DeleteDeviceSwitchRoutingStaticRouteAsync(string serial, string staticRouteId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/routing/staticRoutes/"+ (staticRouteId==null? "" : System.Uri.EscapeDataString(staticRouteId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a layer 3 static route for a switch
		/// Return a layer 3 static route for a switch
		/// GetDeviceSwitchRoutingStaticRoute devices/{serial}/switch/routing/staticRoutes/{staticRouteId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetDeviceSwitchRoutingStaticRouteReturn> GetDeviceSwitchRoutingStaticRouteAsync(string serial, string staticRouteId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/routing/staticRoutes/"+ (staticRouteId==null? "" : System.Uri.EscapeDataString(staticRouteId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetDeviceSwitchRoutingStaticRouteReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a layer 3 static route for a switch
		/// Update a layer 3 static route for a switch
		/// UpdateDeviceSwitchRoutingStaticRoute devices/{serial}/switch/routing/staticRoutes/{staticRouteId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateDeviceSwitchRoutingStaticRouteAsync(string serial, string staticRouteId, UpdateDeviceSwitchRoutingStaticRouteUpdatedeviceswitchroutingstaticroute requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/routing/staticRoutes/"+ (staticRouteId==null? "" : System.Uri.EscapeDataString(staticRouteId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return warm spare configuration for a switch
		/// Return warm spare configuration for a switch
		/// GetDeviceSwitchWarmSpare devices/{serial}/switch/warmSpare
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceSwitchWarmSpareAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/warmSpare";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update warm spare configuration for a switch
		/// Update warm spare configuration for a switch. The spare will use the same L3 configuration as the primary. Note that this will irreversibly destroy any existing L3 configuration on the spare.
		/// UpdateDeviceSwitchWarmSpare devices/{serial}/switch/warmSpare
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateDeviceSwitchWarmSpareAsync(string serial, UpdateDeviceSwitchWarmSparePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/switch/warmSpare";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the bluetooth settings for a wireless device
		/// Return the bluetooth settings for a wireless device
		/// GetDeviceWirelessBluetoothSettings devices/{serial}/wireless/bluetooth/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetDeviceWirelessBluetoothSettingsReturn> GetDeviceWirelessBluetoothSettingsAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/wireless/bluetooth/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetDeviceWirelessBluetoothSettingsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the bluetooth settings for a wireless device
		/// Update the bluetooth settings for a wireless device
		/// UpdateDeviceWirelessBluetoothSettings devices/{serial}/wireless/bluetooth/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateDeviceWirelessBluetoothSettingsReturn> UpdateDeviceWirelessBluetoothSettingsAsync(string serial, UpdateDeviceWirelessBluetoothSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/wireless/bluetooth/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateDeviceWirelessBluetoothSettingsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Aggregated connectivity info for a given AP on this network
		/// Aggregated connectivity info for a given AP on this network
		/// GetDeviceWirelessConnectionStats devices/{serial}/wireless/connectionStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <returns>Successful operation</returns>
		public async Task<GetDeviceWirelessConnectionStatsReturn> GetDeviceWirelessConnectionStatsAsync(string serial, string t0, string t1, float timespan, GetDeviceWirelessConnectionStatsBand band, int ssid, int vlan, string apTag, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/wireless/connectionStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetDeviceWirelessConnectionStatsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Aggregated latency info for a given AP on this network
		/// Aggregated latency info for a given AP on this network
		/// GetDeviceWirelessLatencyStats devices/{serial}/wireless/latencyStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <param name="fields">Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceWirelessLatencyStatsAsync(string serial, string t0, string t1, float timespan, GetDeviceWirelessLatencyStatsBand band, int ssid, int vlan, string apTag, string fields, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/wireless/latencyStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag))+"&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the radio settings of a device
		/// Return the radio settings of a device
		/// GetDeviceWirelessRadioSettings devices/{serial}/wireless/radio/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceWirelessRadioSettingsAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/wireless/radio/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the radio settings of a device
		/// Update the radio settings of a device
		/// UpdateDeviceWirelessRadioSettings devices/{serial}/wireless/radio/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateDeviceWirelessRadioSettingsAsync(string serial, UpdateDeviceWirelessRadioSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/wireless/radio/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the SSID statuses of an access point
		/// Return the SSID statuses of an access point
		/// GetDeviceWirelessStatus devices/{serial}/wireless/status
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetDeviceWirelessStatusAsync(string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial))+"/wireless/status";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a network
		/// Delete a network
		/// DeleteNetwork networks/{networkId}
		/// </summary>
		public async Task DeleteNetworkAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a network
		/// Return a network
		/// GetNetwork networks/{networkId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkReturn> GetNetworkAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a network
		/// Update a network
		/// UpdateNetwork networks/{networkId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkReturn> UpdateNetworkAsync(string networkId, UpdateNetworkPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the alert history for this network
		/// Return the alert history for this network
		/// GetNetworkAlertsHistory networks/{networkId}/alerts/history
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkAlertsHistoryReturn[]> GetNetworkAlertsHistoryAsync(string networkId, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/alerts/history&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkAlertsHistoryReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the alert configuration for this network
		/// Return the alert configuration for this network
		/// GetNetworkAlertsSettings networks/{networkId}/alerts/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkAlertsSettingsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/alerts/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the alert configuration for this network
		/// Update the alert configuration for this network
		/// UpdateNetworkAlertsSettings networks/{networkId}/alerts/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkAlertsSettingsAsync(string networkId, UpdateNetworkAlertsSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/alerts/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the security events for a client
		/// List the security events for a client. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		/// GetNetworkApplianceClientSecurityEvents networks/{networkId}/appliance/clients/{clientId}/security/events
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 791 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="sortOrder">Sorted order of security events based on event detection time. Order options are 'ascending' or 'descending'. Default is ascending order.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkApplianceClientSecurityEventsAsync(string networkId, string clientId, string t0, string t1, float timespan, int perPage, string startingAfter, string endingBefore, GetNetworkApplianceClientSecurityEventsSortOrder sortOrder, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/security/events&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&sortOrder=" + sortOrder;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the connectivity testing destinations for an MX network
		/// Return the connectivity testing destinations for an MX network
		/// GetNetworkApplianceConnectivityMonitoringDestinations networks/{networkId}/appliance/connectivityMonitoringDestinations
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceConnectivityMonitoringDestinationsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/connectivityMonitoringDestinations";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the connectivity testing destinations for an MX network
		/// Update the connectivity testing destinations for an MX network
		/// UpdateNetworkApplianceConnectivityMonitoringDestinations networks/{networkId}/appliance/connectivityMonitoringDestinations
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceConnectivityMonitoringDestinationsAsync(string networkId, UpdateNetworkApplianceConnectivityMonitoringDestinationsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/connectivityMonitoringDestinations";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the content filtering settings for an MX network
		/// Return the content filtering settings for an MX network
		/// GetNetworkApplianceContentFiltering networks/{networkId}/appliance/contentFiltering
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceContentFilteringAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/contentFiltering";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the content filtering settings for an MX network
		/// Update the content filtering settings for an MX network
		/// UpdateNetworkApplianceContentFiltering networks/{networkId}/appliance/contentFiltering
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceContentFilteringAsync(string networkId, UpdateNetworkApplianceContentFilteringPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/contentFiltering";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List all available content filtering categories for an MX network
		/// List all available content filtering categories for an MX network
		/// GetNetworkApplianceContentFilteringCategories networks/{networkId}/appliance/contentFiltering/categories
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceContentFilteringCategoriesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/contentFiltering/categories";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the cellular firewall rules for an MX network
		/// Return the cellular firewall rules for an MX network
		/// GetNetworkApplianceFirewallCellularFirewallRules networks/{networkId}/appliance/firewall/cellularFirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceFirewallCellularFirewallRulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/cellularFirewallRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the cellular firewall rules of an MX network
		/// Update the cellular firewall rules of an MX network
		/// UpdateNetworkApplianceFirewallCellularFirewallRules networks/{networkId}/appliance/firewall/cellularFirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceFirewallCellularFirewallRulesAsync(string networkId, UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrules requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/cellularFirewallRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the appliance services and their accessibility rules
		/// List the appliance services and their accessibility rules
		/// GetNetworkApplianceFirewallFirewalledServices networks/{networkId}/appliance/firewall/firewalledServices
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkApplianceFirewallFirewalledServicesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/firewalledServices";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the accessibility settings of the given service ('ICMP', 'web', or 'SNMP')
		/// Return the accessibility settings of the given service ('ICMP', 'web', or 'SNMP')
		/// GetNetworkApplianceFirewallFirewalledService networks/{networkId}/appliance/firewall/firewalledServices/{service}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceFirewallFirewalledServiceAsync(string networkId, string service, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/firewalledServices/"+ (service==null? "" : System.Uri.EscapeDataString(service));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates the accessibility settings for the given service ('ICMP', 'web', or 'SNMP')
		/// Updates the accessibility settings for the given service ('ICMP', 'web', or 'SNMP')
		/// UpdateNetworkApplianceFirewallFirewalledService networks/{networkId}/appliance/firewall/firewalledServices/{service}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceFirewallFirewalledServiceAsync(string networkId, string service, UpdateNetworkApplianceFirewallFirewalledServicePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/firewalledServices/"+ (service==null? "" : System.Uri.EscapeDataString(service));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the inbound cellular firewall rules for an MX network
		/// Return the inbound cellular firewall rules for an MX network
		/// GetNetworkApplianceFirewallInboundCellularFirewallRules networks/{networkId}/appliance/firewall/inboundCellularFirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkApplianceFirewallInboundCellularFirewallRulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/inboundCellularFirewallRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the inbound cellular firewall rules of an MX network
		/// Update the inbound cellular firewall rules of an MX network
		/// UpdateNetworkApplianceFirewallInboundCellularFirewallRules networks/{networkId}/appliance/firewall/inboundCellularFirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> UpdateNetworkApplianceFirewallInboundCellularFirewallRulesAsync(string networkId, UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrules requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/inboundCellularFirewallRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the inbound firewall rules for an MX network
		/// Return the inbound firewall rules for an MX network
		/// GetNetworkApplianceFirewallInboundFirewallRules networks/{networkId}/appliance/firewall/inboundFirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceFirewallInboundFirewallRulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/inboundFirewallRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the inbound firewall rules of an MX network
		/// Update the inbound firewall rules of an MX network
		/// UpdateNetworkApplianceFirewallInboundFirewallRules networks/{networkId}/appliance/firewall/inboundFirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceFirewallInboundFirewallRulesAsync(string networkId, UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrules requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/inboundFirewallRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the L3 firewall rules for an MX network
		/// Return the L3 firewall rules for an MX network
		/// GetNetworkApplianceFirewallL3FirewallRules networks/{networkId}/appliance/firewall/l3FirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceFirewallL3FirewallRulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/l3FirewallRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the L3 firewall rules of an MX network
		/// Update the L3 firewall rules of an MX network
		/// UpdateNetworkApplianceFirewallL3FirewallRules networks/{networkId}/appliance/firewall/l3FirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceFirewallL3FirewallRulesAsync(string networkId, UpdateNetworkApplianceFirewallInboundFirewallRulesUpdatenetworkappliancefirewallinboundfirewallrules requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/l3FirewallRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the MX L7 firewall rules for an MX network
		/// List the MX L7 firewall rules for an MX network
		/// GetNetworkApplianceFirewallL7FirewallRules networks/{networkId}/appliance/firewall/l7FirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceFirewallL7FirewallRulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/l7FirewallRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the MX L7 firewall rules for an MX network
		/// Update the MX L7 firewall rules for an MX network
		/// UpdateNetworkApplianceFirewallL7FirewallRules networks/{networkId}/appliance/firewall/l7FirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceFirewallL7FirewallRulesAsync(string networkId, UpdateNetworkApplianceFirewallL7FirewallRulesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/l7FirewallRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the L7 firewall application categories and their associated applications for an MX network
		/// Return the L7 firewall application categories and their associated applications for an MX network
		/// GetNetworkApplianceFirewallL7FirewallRulesApplicationCategories networks/{networkId}/appliance/firewall/l7FirewallRules/applicationCategories
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceFirewallL7FirewallRulesApplicationCategoriesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/l7FirewallRules/applicationCategories";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the 1:Many NAT mapping rules for an MX network
		/// Return the 1:Many NAT mapping rules for an MX network
		/// GetNetworkApplianceFirewallOneToManyNatRules networks/{networkId}/appliance/firewall/oneToManyNatRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceFirewallOneToManyNatRulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/oneToManyNatRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Set the 1:Many NAT mapping rules for an MX network
		/// Set the 1:Many NAT mapping rules for an MX network
		/// UpdateNetworkApplianceFirewallOneToManyNatRules networks/{networkId}/appliance/firewall/oneToManyNatRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceFirewallOneToManyNatRulesAsync(string networkId, UpdateNetworkApplianceFirewallOneToManyNatRulesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/oneToManyNatRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the 1:1 NAT mapping rules for an MX network
		/// Return the 1:1 NAT mapping rules for an MX network
		/// GetNetworkApplianceFirewallOneToOneNatRules networks/{networkId}/appliance/firewall/oneToOneNatRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceFirewallOneToOneNatRulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/oneToOneNatRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Set the 1:1 NAT mapping rules for an MX network
		/// Set the 1:1 NAT mapping rules for an MX network
		/// UpdateNetworkApplianceFirewallOneToOneNatRules networks/{networkId}/appliance/firewall/oneToOneNatRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceFirewallOneToOneNatRulesAsync(string networkId, UpdateNetworkApplianceFirewallOneToOneNatRulesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/oneToOneNatRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the port forwarding rules for an MX network
		/// Return the port forwarding rules for an MX network
		/// GetNetworkApplianceFirewallPortForwardingRules networks/{networkId}/appliance/firewall/portForwardingRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceFirewallPortForwardingRulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/portForwardingRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the port forwarding rules for an MX network
		/// Update the port forwarding rules for an MX network
		/// UpdateNetworkApplianceFirewallPortForwardingRules networks/{networkId}/appliance/firewall/portForwardingRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceFirewallPortForwardingRulesAsync(string networkId, UpdateNetworkApplianceFirewallPortForwardingRulesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/portForwardingRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the firewall settings for this network
		/// Return the firewall settings for this network
		/// GetNetworkApplianceFirewallSettings networks/{networkId}/appliance/firewall/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceFirewallSettingsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the firewall settings for this network
		/// Update the firewall settings for this network
		/// UpdateNetworkApplianceFirewallSettings networks/{networkId}/appliance/firewall/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceFirewallSettingsAsync(string networkId, UpdateNetworkApplianceFirewallSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/firewall/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List per-port VLAN settings for all ports of a MX.
		/// List per-port VLAN settings for all ports of a MX.
		/// GetNetworkAppliancePorts networks/{networkId}/appliance/ports
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkAppliancePortsReturn[]> GetNetworkAppliancePortsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/ports";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkAppliancePortsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return per-port VLAN settings for a single MX port.
		/// Return per-port VLAN settings for a single MX port.
		/// GetNetworkAppliancePort networks/{networkId}/appliance/ports/{portId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkAppliancePortReturn> GetNetworkAppliancePortAsync(string networkId, string portId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/ports/"+ (portId==null? "" : System.Uri.EscapeDataString(portId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkAppliancePortReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the per-port VLAN settings for a single MX port.
		/// Update the per-port VLAN settings for a single MX port.
		/// UpdateNetworkAppliancePort networks/{networkId}/appliance/ports/{portId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkAppliancePortReturn> UpdateNetworkAppliancePortAsync(string networkId, string portId, UpdateNetworkAppliancePortPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/ports/"+ (portId==null? "" : System.Uri.EscapeDataString(portId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkAppliancePortReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List static delegated prefixes for a network
		/// List static delegated prefixes for a network
		/// GetNetworkAppliancePrefixesDelegatedStatics networks/{networkId}/appliance/prefixes/delegated/statics
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkAppliancePrefixesDelegatedStaticsReturn[]> GetNetworkAppliancePrefixesDelegatedStaticsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/prefixes/delegated/statics";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkAppliancePrefixesDelegatedStaticsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add a static delegated prefix from a network
		/// Add a static delegated prefix from a network
		/// CreateNetworkAppliancePrefixesDelegatedStatic networks/{networkId}/appliance/prefixes/delegated/statics
		/// </summary>
		public async Task CreateNetworkAppliancePrefixesDelegatedStaticAsync(string networkId, CreateNetworkAppliancePrefixesDelegatedStaticPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/prefixes/delegated/statics";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a static delegated prefix from a network
		/// Delete a static delegated prefix from a network
		/// DeleteNetworkAppliancePrefixesDelegatedStatic networks/{networkId}/appliance/prefixes/delegated/statics/{staticDelegatedPrefixId}
		/// </summary>
		public async Task DeleteNetworkAppliancePrefixesDelegatedStaticAsync(string networkId, string staticDelegatedPrefixId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/prefixes/delegated/statics/"+ (staticDelegatedPrefixId==null? "" : System.Uri.EscapeDataString(staticDelegatedPrefixId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a static delegated prefix from a network
		/// Return a static delegated prefix from a network
		/// GetNetworkAppliancePrefixesDelegatedStatic networks/{networkId}/appliance/prefixes/delegated/statics/{staticDelegatedPrefixId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkAppliancePrefixesDelegatedStaticReturn> GetNetworkAppliancePrefixesDelegatedStaticAsync(string networkId, string staticDelegatedPrefixId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/prefixes/delegated/statics/"+ (staticDelegatedPrefixId==null? "" : System.Uri.EscapeDataString(staticDelegatedPrefixId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkAppliancePrefixesDelegatedStaticReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a static delegated prefix from a network
		/// Update a static delegated prefix from a network
		/// UpdateNetworkAppliancePrefixesDelegatedStatic networks/{networkId}/appliance/prefixes/delegated/statics/{staticDelegatedPrefixId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkAppliancePrefixesDelegatedStaticAsync(string networkId, string staticDelegatedPrefixId, UpdateNetworkAppliancePrefixesDelegatedStaticPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/prefixes/delegated/statics/"+ (staticDelegatedPrefixId==null? "" : System.Uri.EscapeDataString(staticDelegatedPrefixId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the security events for a network
		/// List the security events for a network
		/// GetNetworkApplianceSecurityEvents networks/{networkId}/appliance/security/events
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 365 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="sortOrder">Sorted order of security events based on event detection time. Order options are 'ascending' or 'descending'. Default is ascending order.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkApplianceSecurityEventsAsync(string networkId, string t0, string t1, float timespan, int perPage, string startingAfter, string endingBefore, GetNetworkApplianceClientSecurityEventsSortOrder sortOrder, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/security/events&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&sortOrder=" + sortOrder;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns all supported intrusion settings for an MX network
		/// Returns all supported intrusion settings for an MX network
		/// GetNetworkApplianceSecurityIntrusion networks/{networkId}/appliance/security/intrusion
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceSecurityIntrusionAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/security/intrusion";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Set the supported intrusion settings for an MX network
		/// Set the supported intrusion settings for an MX network
		/// UpdateNetworkApplianceSecurityIntrusion networks/{networkId}/appliance/security/intrusion
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceSecurityIntrusionAsync(string networkId, UpdateNetworkApplianceSecurityIntrusionPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/security/intrusion";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns all supported malware settings for an MX network
		/// Returns all supported malware settings for an MX network
		/// GetNetworkApplianceSecurityMalware networks/{networkId}/appliance/security/malware
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceSecurityMalwareAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/security/malware";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Set the supported malware settings for an MX network
		/// Set the supported malware settings for an MX network
		/// UpdateNetworkApplianceSecurityMalware networks/{networkId}/appliance/security/malware
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceSecurityMalwareAsync(string networkId, UpdateNetworkApplianceSecurityMalwarePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/security/malware";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the appliance settings for a network
		/// Return the appliance settings for a network
		/// GetNetworkApplianceSettings networks/{networkId}/appliance/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkApplianceSettingsReturn> GetNetworkApplianceSettingsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkApplianceSettingsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the appliance settings for a network
		/// Update the appliance settings for a network
		/// UpdateNetworkApplianceSettings networks/{networkId}/appliance/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkApplianceSettingsReturn> UpdateNetworkApplianceSettingsAsync(string networkId, UpdateNetworkApplianceSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkApplianceSettingsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return single LAN configuration
		/// Return single LAN configuration
		/// GetNetworkApplianceSingleLan networks/{networkId}/appliance/singleLan
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkApplianceSingleLanReturn> GetNetworkApplianceSingleLanAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/singleLan";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkApplianceSingleLanReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update single LAN configuration
		/// Update single LAN configuration
		/// UpdateNetworkApplianceSingleLan networks/{networkId}/appliance/singleLan
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkApplianceSingleLanReturn> UpdateNetworkApplianceSingleLanAsync(string networkId, UpdateNetworkApplianceSingleLanPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/singleLan";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkApplianceSingleLanReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the MX SSIDs in a network
		/// List the MX SSIDs in a network
		/// GetNetworkApplianceSsids networks/{networkId}/appliance/ssids
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkApplianceSsidsReturn[]> GetNetworkApplianceSsidsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/ssids";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkApplianceSsidsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a single MX SSID
		/// Return a single MX SSID
		/// GetNetworkApplianceSsid networks/{networkId}/appliance/ssids/{number}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkApplianceSsidReturn> GetNetworkApplianceSsidAsync(string networkId, string number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkApplianceSsidReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the attributes of an MX SSID
		/// Update the attributes of an MX SSID
		/// UpdateNetworkApplianceSsid networks/{networkId}/appliance/ssids/{number}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkApplianceSsidReturn> UpdateNetworkApplianceSsidAsync(string networkId, string number, UpdateNetworkApplianceSsidPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkApplianceSsidReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the static routes for an MX or teleworker network
		/// List the static routes for an MX or teleworker network
		/// GetNetworkApplianceStaticRoutes networks/{networkId}/appliance/staticRoutes
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkApplianceStaticRoutesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/staticRoutes";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add a static route for an MX or teleworker network
		/// Add a static route for an MX or teleworker network
		/// CreateNetworkApplianceStaticRoute networks/{networkId}/appliance/staticRoutes
		/// </summary>
		public async Task CreateNetworkApplianceStaticRouteAsync(string networkId, CreateNetworkApplianceStaticRoutePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/staticRoutes";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a static route from an MX or teleworker network
		/// Delete a static route from an MX or teleworker network
		/// DeleteNetworkApplianceStaticRoute networks/{networkId}/appliance/staticRoutes/{staticRouteId}
		/// </summary>
		public async Task DeleteNetworkApplianceStaticRouteAsync(string networkId, string staticRouteId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/staticRoutes/"+ (staticRouteId==null? "" : System.Uri.EscapeDataString(staticRouteId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a static route for an MX or teleworker network
		/// Return a static route for an MX or teleworker network
		/// GetNetworkApplianceStaticRoute networks/{networkId}/appliance/staticRoutes/{staticRouteId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceStaticRouteAsync(string networkId, string staticRouteId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/staticRoutes/"+ (staticRouteId==null? "" : System.Uri.EscapeDataString(staticRouteId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a static route for an MX or teleworker network
		/// Update a static route for an MX or teleworker network
		/// UpdateNetworkApplianceStaticRoute networks/{networkId}/appliance/staticRoutes/{staticRouteId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceStaticRouteAsync(string networkId, string staticRouteId, UpdateNetworkApplianceStaticRoutePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/staticRoutes/"+ (staticRouteId==null? "" : System.Uri.EscapeDataString(staticRouteId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Display the traffic shaping settings for an MX network
		/// Display the traffic shaping settings for an MX network
		/// GetNetworkApplianceTrafficShaping networks/{networkId}/appliance/trafficShaping
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceTrafficShapingAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/trafficShaping";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the traffic shaping settings for an MX network
		/// Update the traffic shaping settings for an MX network
		/// UpdateNetworkApplianceTrafficShaping networks/{networkId}/appliance/trafficShaping
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceTrafficShapingAsync(string networkId, UpdateNetworkApplianceTrafficShapingPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/trafficShaping";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List all custom performance classes for an MX network
		/// List all custom performance classes for an MX network
		/// GetNetworkApplianceTrafficShapingCustomPerformanceClasses networks/{networkId}/appliance/trafficShaping/customPerformanceClasses
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkApplianceTrafficShapingCustomPerformanceClassesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/trafficShaping/customPerformanceClasses";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add a custom performance class for an MX network
		/// Add a custom performance class for an MX network
		/// CreateNetworkApplianceTrafficShapingCustomPerformanceClass networks/{networkId}/appliance/trafficShaping/customPerformanceClasses
		/// </summary>
		public async Task CreateNetworkApplianceTrafficShapingCustomPerformanceClassAsync(string networkId, CreateNetworkApplianceTrafficShapingCustomPerformanceClassPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/trafficShaping/customPerformanceClasses";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a custom performance class from an MX network
		/// Delete a custom performance class from an MX network
		/// DeleteNetworkApplianceTrafficShapingCustomPerformanceClass networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}
		/// </summary>
		public async Task DeleteNetworkApplianceTrafficShapingCustomPerformanceClassAsync(string networkId, string customPerformanceClassId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/trafficShaping/customPerformanceClasses/"+ (customPerformanceClassId==null? "" : System.Uri.EscapeDataString(customPerformanceClassId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a custom performance class for an MX network
		/// Return a custom performance class for an MX network
		/// GetNetworkApplianceTrafficShapingCustomPerformanceClass networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceTrafficShapingCustomPerformanceClassAsync(string networkId, string customPerformanceClassId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/trafficShaping/customPerformanceClasses/"+ (customPerformanceClassId==null? "" : System.Uri.EscapeDataString(customPerformanceClassId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a custom performance class for an MX network
		/// Update a custom performance class for an MX network
		/// UpdateNetworkApplianceTrafficShapingCustomPerformanceClass networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceTrafficShapingCustomPerformanceClassAsync(string networkId, string customPerformanceClassId, UpdateNetworkApplianceTrafficShapingCustomPerformanceClassPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/trafficShaping/customPerformanceClasses/"+ (customPerformanceClassId==null? "" : System.Uri.EscapeDataString(customPerformanceClassId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Display the traffic shaping settings rules for an MX network
		/// Display the traffic shaping settings rules for an MX network
		/// GetNetworkApplianceTrafficShapingRules networks/{networkId}/appliance/trafficShaping/rules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceTrafficShapingRulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/trafficShaping/rules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the traffic shaping settings rules for an MX network
		/// Update the traffic shaping settings rules for an MX network
		/// UpdateNetworkApplianceTrafficShapingRules networks/{networkId}/appliance/trafficShaping/rules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceTrafficShapingRulesAsync(string networkId, UpdateNetworkApplianceTrafficShapingRulesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/trafficShaping/rules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns the uplink bandwidth limits for your MX network
		/// Returns the uplink bandwidth limits for your MX network. This may not reflect the affected device's hardware capabilities.  For more information on your device's hardware capabilities, please consult our MX Family Datasheet - [https://meraki.cisco.com/product-collateral/mx-family-datasheet/?file]
		/// GetNetworkApplianceTrafficShapingUplinkBandwidth networks/{networkId}/appliance/trafficShaping/uplinkBandwidth
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkApplianceTrafficShapingUplinkBandwidthReturn> GetNetworkApplianceTrafficShapingUplinkBandwidthAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/trafficShaping/uplinkBandwidth";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkApplianceTrafficShapingUplinkBandwidthReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates the uplink bandwidth settings for your MX network.
		/// Updates the uplink bandwidth settings for your MX network.
		/// UpdateNetworkApplianceTrafficShapingUplinkBandwidth networks/{networkId}/appliance/trafficShaping/uplinkBandwidth
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceTrafficShapingUplinkBandwidthAsync(string networkId, UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/trafficShaping/uplinkBandwidth";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Show uplink selection settings for an MX network
		/// Show uplink selection settings for an MX network
		/// GetNetworkApplianceTrafficShapingUplinkSelection networks/{networkId}/appliance/trafficShaping/uplinkSelection
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkApplianceTrafficShapingUplinkSelectionReturn> GetNetworkApplianceTrafficShapingUplinkSelectionAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/trafficShaping/uplinkSelection";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkApplianceTrafficShapingUplinkSelectionReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update uplink selection settings for an MX network
		/// Update uplink selection settings for an MX network
		/// UpdateNetworkApplianceTrafficShapingUplinkSelection networks/{networkId}/appliance/trafficShaping/uplinkSelection
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturn> UpdateNetworkApplianceTrafficShapingUplinkSelectionAsync(string networkId, UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/trafficShaping/uplinkSelection";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkApplianceTrafficShapingUplinkSelectionReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get the sent and received bytes for each uplink of a network.
		/// Get the sent and received bytes for each uplink of a network.
		/// GetNetworkApplianceUplinksUsageHistory networks/{networkId}/appliance/uplinks/usageHistory
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 365 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 10 minutes.</param>
		/// <param name="resolution">The time resolution in seconds for returned data. The valid resolutions are: 60, 300, 600, 1800, 3600, 86400. The default is 60.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkApplianceUplinksUsageHistoryAsync(string networkId, string t0, string t1, float timespan, int resolution, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/uplinks/usageHistory&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&resolution="+resolution;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the VLANs for an MX network
		/// List the VLANs for an MX network
		/// GetNetworkApplianceVlans networks/{networkId}/appliance/vlans
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkApplianceVlansReturn[]> GetNetworkApplianceVlansAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/vlans";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkApplianceVlansReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add a VLAN
		/// Add a VLAN
		/// CreateNetworkApplianceVlan networks/{networkId}/appliance/vlans
		/// </summary>
		public async Task CreateNetworkApplianceVlanAsync(string networkId, CreateNetworkApplianceVlanPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/vlans";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns the enabled status of VLANs for the network
		/// Returns the enabled status of VLANs for the network
		/// GetNetworkApplianceVlansSettings networks/{networkId}/appliance/vlans/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceVlansSettingsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/vlans/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Enable/Disable VLANs for the given network
		/// Enable/Disable VLANs for the given network
		/// UpdateNetworkApplianceVlansSettings networks/{networkId}/appliance/vlans/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceVlansSettingsAsync(string networkId, UpdateNetworkApplianceVlansSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/vlans/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a VLAN from a network
		/// Delete a VLAN from a network
		/// DeleteNetworkApplianceVlan networks/{networkId}/appliance/vlans/{vlanId}
		/// </summary>
		public async Task DeleteNetworkApplianceVlanAsync(string networkId, string vlanId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/vlans/"+ (vlanId==null? "" : System.Uri.EscapeDataString(vlanId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a VLAN
		/// Return a VLAN
		/// GetNetworkApplianceVlan networks/{networkId}/appliance/vlans/{vlanId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkApplianceVlanReturn> GetNetworkApplianceVlanAsync(string networkId, string vlanId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/vlans/"+ (vlanId==null? "" : System.Uri.EscapeDataString(vlanId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkApplianceVlanReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a VLAN
		/// Update a VLAN
		/// UpdateNetworkApplianceVlan networks/{networkId}/appliance/vlans/{vlanId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkApplianceVlanReturn> UpdateNetworkApplianceVlanAsync(string networkId, string vlanId, UpdateNetworkApplianceVlanPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/vlans/"+ (vlanId==null? "" : System.Uri.EscapeDataString(vlanId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkApplianceVlanReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a Hub BGP Configuration
		/// Return a Hub BGP Configuration
		/// GetNetworkApplianceVpnBgp networks/{networkId}/appliance/vpn/bgp
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceVpnBgpAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/vpn/bgp";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a Hub BGP Configuration
		/// Update a Hub BGP Configuration
		/// UpdateNetworkApplianceVpnBgp networks/{networkId}/appliance/vpn/bgp
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceVpnBgpAsync(string networkId, UpdateNetworkApplianceVpnBgpPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/vpn/bgp";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the site-to-site VPN settings of a network
		/// Return the site-to-site VPN settings of a network. Only valid for MX networks.
		/// GetNetworkApplianceVpnSiteToSiteVpn networks/{networkId}/appliance/vpn/siteToSiteVpn
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkApplianceVpnSiteToSiteVpnReturn> GetNetworkApplianceVpnSiteToSiteVpnAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/vpn/siteToSiteVpn";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkApplianceVpnSiteToSiteVpnReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the site-to-site VPN settings of a network
		/// Update the site-to-site VPN settings of a network. Only valid for MX networks in NAT mode.
		/// UpdateNetworkApplianceVpnSiteToSiteVpn networks/{networkId}/appliance/vpn/siteToSiteVpn
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkApplianceVpnSiteToSiteVpnReturn> UpdateNetworkApplianceVpnSiteToSiteVpnAsync(string networkId, UpdateNetworkApplianceVpnSiteToSiteVpnPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/vpn/siteToSiteVpn";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkApplianceVpnSiteToSiteVpnReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return MX warm spare settings
		/// Return MX warm spare settings
		/// GetNetworkApplianceWarmSpare networks/{networkId}/appliance/warmSpare
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkApplianceWarmSpareAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/warmSpare";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update MX warm spare settings
		/// Update MX warm spare settings
		/// UpdateNetworkApplianceWarmSpare networks/{networkId}/appliance/warmSpare
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkApplianceWarmSpareAsync(string networkId, UpdateNetworkApplianceWarmSparePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/warmSpare";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Swap MX primary and warm spare appliances
		/// Swap MX primary and warm spare appliances
		/// SwapNetworkApplianceWarmSpare networks/{networkId}/appliance/warmSpare/swap
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> SwapNetworkApplianceWarmSpareAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/appliance/warmSpare/swap";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Bind a network to a template.
		/// Bind a network to a template.
		/// BindNetwork networks/{networkId}/bind
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> BindNetworkAsync(string networkId, BindNetworkPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/bind";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the Bluetooth clients seen by APs in this network
		/// List the Bluetooth clients seen by APs in this network
		/// GetNetworkBluetoothClients networks/{networkId}/bluetoothClients
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 7 days from today.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 7 days. The default is 1 day.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 5 - 1000. Default is 10.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="includeConnectivityHistory">Include the connectivity history for this client</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkBluetoothClientsAsync(string networkId, string t0, float timespan, int perPage, string startingAfter, string endingBefore, bool includeConnectivityHistory, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/bluetoothClients&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&timespan="+timespan+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&includeConnectivityHistory="+includeConnectivityHistory;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a Bluetooth client
		/// Return a Bluetooth client. Bluetooth clients can be identified by their ID or their MAC.
		/// GetNetworkBluetoothClient networks/{networkId}/bluetoothClients/{bluetoothClientId}
		/// </summary>
		/// <param name="includeConnectivityHistory">Include the connectivity history for this client</param>
		/// <param name="connectivityHistoryTimespan">The timespan, in seconds, for the connectivityHistory data. By default 1 day, 86400, will be used.</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkBluetoothClientAsync(string networkId, string bluetoothClientId, bool includeConnectivityHistory, int connectivityHistoryTimespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/bluetoothClients/"+ (bluetoothClientId==null? "" : System.Uri.EscapeDataString(bluetoothClientId))+"&includeConnectivityHistory="+includeConnectivityHistory+"&connectivityHistoryTimespan="+connectivityHistoryTimespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the quality retention profiles for this network
		/// List the quality retention profiles for this network
		/// GetNetworkCameraQualityRetentionProfiles networks/{networkId}/camera/qualityRetentionProfiles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkCameraQualityRetentionProfilesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/camera/qualityRetentionProfiles";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Creates new quality retention profile for this network.
		/// Creates new quality retention profile for this network.
		/// CreateNetworkCameraQualityRetentionProfile networks/{networkId}/camera/qualityRetentionProfiles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> CreateNetworkCameraQualityRetentionProfileAsync(string networkId, CreateNetworkCameraQualityRetentionProfilePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/camera/qualityRetentionProfiles";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete an existing quality retention profile for this network.
		/// Delete an existing quality retention profile for this network.
		/// DeleteNetworkCameraQualityRetentionProfile networks/{networkId}/camera/qualityRetentionProfiles/{qualityRetentionProfileId}
		/// </summary>
		public async Task DeleteNetworkCameraQualityRetentionProfileAsync(string networkId, string qualityRetentionProfileId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/camera/qualityRetentionProfiles/"+ (qualityRetentionProfileId==null? "" : System.Uri.EscapeDataString(qualityRetentionProfileId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve a single quality retention profile
		/// Retrieve a single quality retention profile
		/// GetNetworkCameraQualityRetentionProfile networks/{networkId}/camera/qualityRetentionProfiles/{qualityRetentionProfileId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkCameraQualityRetentionProfileAsync(string networkId, string qualityRetentionProfileId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/camera/qualityRetentionProfiles/"+ (qualityRetentionProfileId==null? "" : System.Uri.EscapeDataString(qualityRetentionProfileId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update an existing quality retention profile for this network.
		/// Update an existing quality retention profile for this network.
		/// UpdateNetworkCameraQualityRetentionProfile networks/{networkId}/camera/qualityRetentionProfiles/{qualityRetentionProfileId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkCameraQualityRetentionProfileAsync(string networkId, string qualityRetentionProfileId, UpdateNetworkCameraQualityRetentionProfilePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/camera/qualityRetentionProfiles/"+ (qualityRetentionProfileId==null? "" : System.Uri.EscapeDataString(qualityRetentionProfileId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns a list of all camera recording schedules.
		/// Returns a list of all camera recording schedules.
		/// GetNetworkCameraSchedules networks/{networkId}/camera/schedules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkCameraSchedulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/camera/schedules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the camera wireless profiles for this network.
		/// List the camera wireless profiles for this network.
		/// GetNetworkCameraWirelessProfiles networks/{networkId}/camera/wirelessProfiles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkCameraWirelessProfilesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/camera/wirelessProfiles";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Creates a new camera wireless profile for this network.
		/// Creates a new camera wireless profile for this network.
		/// CreateNetworkCameraWirelessProfile networks/{networkId}/camera/wirelessProfiles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> CreateNetworkCameraWirelessProfileAsync(string networkId, CreateNetworkCameraWirelessProfilePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/camera/wirelessProfiles";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete an existing camera wireless profile for this network.
		/// Delete an existing camera wireless profile for this network.
		/// DeleteNetworkCameraWirelessProfile networks/{networkId}/camera/wirelessProfiles/{wirelessProfileId}
		/// </summary>
		public async Task DeleteNetworkCameraWirelessProfileAsync(string networkId, string wirelessProfileId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/camera/wirelessProfiles/"+ (wirelessProfileId==null? "" : System.Uri.EscapeDataString(wirelessProfileId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve a single camera wireless profile.
		/// Retrieve a single camera wireless profile.
		/// GetNetworkCameraWirelessProfile networks/{networkId}/camera/wirelessProfiles/{wirelessProfileId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkCameraWirelessProfileAsync(string networkId, string wirelessProfileId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/camera/wirelessProfiles/"+ (wirelessProfileId==null? "" : System.Uri.EscapeDataString(wirelessProfileId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update an existing camera wireless profile in this network.
		/// Update an existing camera wireless profile in this network.
		/// UpdateNetworkCameraWirelessProfile networks/{networkId}/camera/wirelessProfiles/{wirelessProfileId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkCameraWirelessProfileAsync(string networkId, string wirelessProfileId, UpdateNetworkCameraWirelessProfilePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/camera/wirelessProfiles/"+ (wirelessProfileId==null? "" : System.Uri.EscapeDataString(wirelessProfileId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the connectivity testing destinations for an MG network
		/// Return the connectivity testing destinations for an MG network
		/// GetNetworkCellularGatewayConnectivityMonitoringDestinations networks/{networkId}/cellularGateway/connectivityMonitoringDestinations
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkCellularGatewayConnectivityMonitoringDestinationsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/cellularGateway/connectivityMonitoringDestinations";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the connectivity testing destinations for an MG network
		/// Update the connectivity testing destinations for an MG network
		/// UpdateNetworkCellularGatewayConnectivityMonitoringDestinations networks/{networkId}/cellularGateway/connectivityMonitoringDestinations
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkCellularGatewayConnectivityMonitoringDestinationsAsync(string networkId, UpdateNetworkCellularGatewayConnectivityMonitoringDestinationsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/cellularGateway/connectivityMonitoringDestinations";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List common DHCP settings of MGs
		/// List common DHCP settings of MGs
		/// GetNetworkCellularGatewayDhcp networks/{networkId}/cellularGateway/dhcp
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkCellularGatewayDhcpReturn> GetNetworkCellularGatewayDhcpAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/cellularGateway/dhcp";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkCellularGatewayDhcpReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update common DHCP settings of MGs
		/// Update common DHCP settings of MGs
		/// UpdateNetworkCellularGatewayDhcp networks/{networkId}/cellularGateway/dhcp
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkCellularGatewayDhcpReturn> UpdateNetworkCellularGatewayDhcpAsync(string networkId, UpdateNetworkCellularGatewayDhcpPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/cellularGateway/dhcp";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkCellularGatewayDhcpReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the subnet pool and mask configured for MGs in the network.
		/// Return the subnet pool and mask configured for MGs in the network.
		/// GetNetworkCellularGatewaySubnetPool networks/{networkId}/cellularGateway/subnetPool
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkCellularGatewaySubnetPoolAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/cellularGateway/subnetPool";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the subnet pool and mask configuration for MGs in the network.
		/// Update the subnet pool and mask configuration for MGs in the network.
		/// UpdateNetworkCellularGatewaySubnetPool networks/{networkId}/cellularGateway/subnetPool
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkCellularGatewaySubnetPoolAsync(string networkId, UpdateNetworkCellularGatewaySubnetPoolPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/cellularGateway/subnetPool";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns the uplink settings for your MG network.
		/// Returns the uplink settings for your MG network.
		/// GetNetworkCellularGatewayUplink networks/{networkId}/cellularGateway/uplink
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkCellularGatewayUplinkAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/cellularGateway/uplink";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates the uplink settings for your MG network.
		/// Updates the uplink settings for your MG network.
		/// UpdateNetworkCellularGatewayUplink networks/{networkId}/cellularGateway/uplink
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkCellularGatewayUplinkAsync(string networkId, UpdateNetworkCellularGatewayUplinkPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/cellularGateway/uplink";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the clients that have used this network in the timespan
		/// List the clients that have used this network in the timespan
		/// GetNetworkClients networks/{networkId}/clients
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="statuses">Filters clients based on status. Can be one of 'Online' or 'Offline'.</param>
		/// <param name="ip">Filters clients based on a partial or full match for the ip address field.</param>
		/// <param name="ip6">Filters clients based on a partial or full match for the ip6 address field.</param>
		/// <param name="ip6Local">Filters clients based on a partial or full match for the ip6Local address field.</param>
		/// <param name="mac">Filters clients based on a partial or full match for the mac address field.</param>
		/// <param name="os">Filters clients based on a partial or full match for the os (operating system) field.</param>
		/// <param name="description">Filters clients based on a partial or full match for the description field.</param>
		/// <param name="vlan">Filters clients based on the full match for the VLAN field.</param>
		/// <param name="recentDeviceConnections">Filters clients based on recent connection type. Can be one of 'Wired' or 'Wireless'.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkClientsReturn> GetNetworkClientsAsync(
					string networkId, 
					string t0, 
					float timespan, 
					int perPage, 
					string startingAfter, 
					string endingBefore, 
					string[] statuses, 
					string ip, 
					string ip6, 
					string ip6Local, 
					string mac, 
					string os, 
					string description, 
					string vlan, 
					string[] recentDeviceConnections, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&timespan="+timespan+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&"+string.Join("&", statuses.Select(z => $"statuses={System.Uri.EscapeDataString(z.ToString())}"))+"&ip=" + (ip==null? "" : System.Uri.EscapeDataString(ip))+"&ip6=" + (ip6==null? "" : System.Uri.EscapeDataString(ip6))+"&ip6Local=" + (ip6Local==null? "" : System.Uri.EscapeDataString(ip6Local))+"&mac=" + (mac==null? "" : System.Uri.EscapeDataString(mac))+"&os=" + (os==null? "" : System.Uri.EscapeDataString(os))+"&description=" + (description==null? "" : System.Uri.EscapeDataString(description))+"&vlan=" + (vlan==null? "" : System.Uri.EscapeDataString(vlan))+"&"+string.Join("&", recentDeviceConnections.Select(z => $"recentDeviceConnections={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkClientsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the application usage data for clients
		/// Return the application usage data for clients. Usage data is in kilobytes. Clients can be identified by client keys or either the MACs or IPs depending on whether the network uses Track-by-IP.
		/// GetNetworkClientsApplicationUsage networks/{networkId}/clients/applicationUsage
		/// </summary>
		/// <param name="clients">A list of client keys, MACs or IPs separated by comma.</param>
		/// <param name="ssidNumber">An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkClientsApplicationUsageAsync(string networkId, string clients, GetNetworkClientsApplicationUsageSsidNumber ssidNumber, int perPage, string startingAfter, string endingBefore, string t0, string t1, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/applicationUsage&clients=" + (clients==null? "" : System.Uri.EscapeDataString(clients))+"&ssidNumber="+ssidNumber+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns a timeseries of total traffic consumption rates for all clients on a network within a given timespan, in megabits per second.
		/// Returns a timeseries of total traffic consumption rates for all clients on a network within a given timespan, in megabits per second.
		/// GetNetworkClientsBandwidthUsageHistory networks/{networkId}/clients/bandwidthUsageHistory
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 30 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkClientsBandwidthUsageHistoryAsync(string networkId, string t0, string t1, float timespan, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/bandwidthUsageHistory&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return overview statistics for network clients
		/// Return overview statistics for network clients
		/// GetNetworkClientsOverview networks/{networkId}/clients/overview
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <param name="resolution">The time resolution in seconds for returned data. The valid resolutions are: 7200, 86400, 604800, 2592000. The default is 604800.</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkClientsOverviewAsync(string networkId, string t0, string t1, float timespan, int resolution, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/overview&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&resolution="+resolution;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Provisions a client with a name and policy
		/// Provisions a client with a name and policy. Clients can be provisioned before they associate to the network.
		/// ProvisionNetworkClients networks/{networkId}/clients/provision
		/// </summary>
		public async Task ProvisionNetworkClientsAsync(string networkId, ProvisionNetworkClientsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/provision";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the usage histories for clients
		/// Return the usage histories for clients. Usage data is in kilobytes. Clients can be identified by client keys or either the MACs or IPs depending on whether the network uses Track-by-IP.
		/// GetNetworkClientsUsageHistories networks/{networkId}/clients/usageHistories
		/// </summary>
		/// <param name="clients">A list of client keys, MACs or IPs separated by comma.</param>
		/// <param name="ssidNumber">An SSID number to include. If not specified, events for all SSIDs will be returned.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkClientsUsageHistoriesAsync(string networkId, string clients, GetNetworkClientsUsageHistoriesSsidNumber ssidNumber, int perPage, string startingAfter, string endingBefore, string t0, string t1, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/usageHistories&clients=" + (clients==null? "" : System.Uri.EscapeDataString(clients))+"&ssidNumber="+ssidNumber+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the client associated with the given identifier
		/// Return the client associated with the given identifier. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		/// GetNetworkClient networks/{networkId}/clients/{clientId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkClientReturn> GetNetworkClientAsync(string networkId, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkClientReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the policy assigned to a client on the network
		/// Return the policy assigned to a client on the network. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		/// GetNetworkClientPolicy networks/{networkId}/clients/{clientId}/policy
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkClientPolicyAsync(string networkId, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/policy";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the policy assigned to a client on the network
		/// Update the policy assigned to a client on the network. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		/// UpdateNetworkClientPolicy networks/{networkId}/clients/{clientId}/policy
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkClientPolicyAsync(string networkId, string clientId, UpdateNetworkClientPolicyPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/policy";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the splash authorization for a client, for each SSID they've associated with through splash
		/// Return the splash authorization for a client, for each SSID they've associated with through splash. Only enabled SSIDs with Click-through splash enabled will be included. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		/// GetNetworkClientSplashAuthorizationStatus networks/{networkId}/clients/{clientId}/splashAuthorizationStatus
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkClientSplashAuthorizationStatusAsync(string networkId, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/splashAuthorizationStatus";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a client's splash authorization
		/// Update a client's splash authorization. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		/// UpdateNetworkClientSplashAuthorizationStatus networks/{networkId}/clients/{clientId}/splashAuthorizationStatus
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkClientSplashAuthorizationStatusAsync(string networkId, string clientId, UpdateNetworkClientSplashAuthorizationStatusPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/splashAuthorizationStatus";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the client's network traffic data over time
		/// Return the client's network traffic data over time. Usage data is in kilobytes. This endpoint requires detailed traffic analysis to be enabled on the Network-wide > General page. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		/// GetNetworkClientTrafficHistory networks/{networkId}/clients/{clientId}/trafficHistory
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkClientTrafficHistoryAsync(string networkId, string clientId, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/trafficHistory&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the client's daily usage history
		/// Return the client's daily usage history. Usage data is in kilobytes. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
		/// GetNetworkClientUsageHistory networks/{networkId}/clients/{clientId}/usageHistory
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkClientUsageHistoryAsync(string networkId, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/usageHistory";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the devices in a network
		/// List the devices in a network
		/// GetNetworkDevices networks/{networkId}/devices
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkDevicesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/devices";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requsts against that device to succeed)
		/// Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requsts against that device to succeed)
		/// ClaimNetworkDevices networks/{networkId}/devices/claim
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task ClaimNetworkDevicesAsync(string networkId, ClaimNetworkDevicesPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/devices/claim";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Claim a vMX into a network
		/// Claim a vMX into a network
		/// VmxNetworkDevicesClaim networks/{networkId}/devices/claim/vmx
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> VmxNetworkDevicesClaimAsync(string networkId, VmxNetworkDevicesClaimPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/devices/claim/vmx";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove a single device
		/// Remove a single device
		/// RemoveNetworkDevices networks/{networkId}/devices/remove
		/// </summary>
		public async Task RemoveNetworkDevicesAsync(string networkId, RemoveNetworkDevicesPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/devices/remove";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the events for the network
		/// List the events for the network
		/// GetNetworkEvents networks/{networkId}/events
		/// </summary>
		/// <param name="productType">The product type to fetch events for. This parameter is required for networks with multiple device types. Valid types are wireless, appliance, switch, systemsManager, camera, and cellularGateway</param>
		/// <param name="includedEventTypes">A list of event types. The returned events will be filtered to only include events with these types.</param>
		/// <param name="excludedEventTypes">A list of event types. The returned events will be filtered to exclude events with these types.</param>
		/// <param name="deviceMac">The MAC address of the Meraki device which the list of events will be filtered with</param>
		/// <param name="deviceSerial">The serial of the Meraki device which the list of events will be filtered with</param>
		/// <param name="deviceName">The name of the Meraki device which the list of events will be filtered with</param>
		/// <param name="clientIp">The IP of the client which the list of events will be filtered with. Only supported for track-by-IP networks.</param>
		/// <param name="clientMac">The MAC address of the client which the list of events will be filtered with. Only supported for track-by-MAC networks.</param>
		/// <param name="clientName">The name, or partial name, of the client which the list of events will be filtered with</param>
		/// <param name="smDeviceMac">The MAC address of the Systems Manager device which the list of events will be filtered with</param>
		/// <param name="smDeviceName">The name of the Systems Manager device which the list of events will be filtered with</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkEventsReturn> GetNetworkEventsAsync(
					string networkId, 
					GetNetworkEventsProductType productType, 
					string[] includedEventTypes, 
					string[] excludedEventTypes, 
					string deviceMac, 
					string deviceSerial, 
					string deviceName, 
					string clientIp, 
					string clientMac, 
					string clientName, 
					string smDeviceMac, 
					string smDeviceName, 
					int perPage, 
					string startingAfter, 
					string endingBefore, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/events&productType=" + productType+"&"+string.Join("&", includedEventTypes.Select(z => $"includedEventTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", excludedEventTypes.Select(z => $"excludedEventTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&deviceMac=" + (deviceMac==null? "" : System.Uri.EscapeDataString(deviceMac))+"&deviceSerial=" + (deviceSerial==null? "" : System.Uri.EscapeDataString(deviceSerial))+"&deviceName=" + (deviceName==null? "" : System.Uri.EscapeDataString(deviceName))+"&clientIp=" + (clientIp==null? "" : System.Uri.EscapeDataString(clientIp))+"&clientMac=" + (clientMac==null? "" : System.Uri.EscapeDataString(clientMac))+"&clientName=" + (clientName==null? "" : System.Uri.EscapeDataString(clientName))+"&smDeviceMac=" + (smDeviceMac==null? "" : System.Uri.EscapeDataString(smDeviceMac))+"&smDeviceName=" + (smDeviceName==null? "" : System.Uri.EscapeDataString(smDeviceName))+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkEventsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the event type to human-readable description
		/// List the event type to human-readable description
		/// GetNetworkEventsEventTypes networks/{networkId}/events/eventTypes
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkEventsEventTypesReturn[]> GetNetworkEventsEventTypesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/events/eventTypes";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkEventsEventTypesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get firmware upgrade information for a network
		/// Get firmware upgrade information for a network
		/// GetNetworkFirmwareUpgrades networks/{networkId}/firmwareUpgrades
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkFirmwareUpgradesReturn> GetNetworkFirmwareUpgradesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/firmwareUpgrades";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkFirmwareUpgradesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update firmware upgrade information for a network
		/// Update firmware upgrade information for a network
		/// UpdateNetworkFirmwareUpgrades networks/{networkId}/firmwareUpgrades
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkFirmwareUpgradesReturn> UpdateNetworkFirmwareUpgradesAsync(string networkId, UpdateNetworkFirmwareUpgradesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/firmwareUpgrades";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkFirmwareUpgradesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Rollback a Firmware Upgrade For A Network
		/// Rollback a Firmware Upgrade For A Network
		/// CreateNetworkFirmwareUpgradesRollback networks/{networkId}/firmwareUpgrades/rollbacks
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<CreateNetworkFirmwareUpgradesRollbackReturn> CreateNetworkFirmwareUpgradesRollbackAsync(string networkId, CreateNetworkFirmwareUpgradesRollbackPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/firmwareUpgrades/rollbacks";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<CreateNetworkFirmwareUpgradesRollbackReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get the Staged Upgrade Event from a network
		/// Get the Staged Upgrade Event from a network
		/// GetNetworkFirmwareUpgradesStagedEvents networks/{networkId}/firmwareUpgrades/staged/events
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkFirmwareUpgradesStagedEventsReturn> GetNetworkFirmwareUpgradesStagedEventsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/firmwareUpgrades/staged/events";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkFirmwareUpgradesStagedEventsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a Staged Upgrade Event for a network
		/// Create a Staged Upgrade Event for a network
		/// CreateNetworkFirmwareUpgradesStagedEvent networks/{networkId}/firmwareUpgrades/staged/events
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<CreateNetworkFirmwareUpgradesStagedEventReturn> CreateNetworkFirmwareUpgradesStagedEventAsync(string networkId, CreateNetworkFirmwareUpgradesStagedEventPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/firmwareUpgrades/staged/events";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<CreateNetworkFirmwareUpgradesStagedEventReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the Staged Upgrade Event for a network
		/// Update the Staged Upgrade Event for a network
		/// UpdateNetworkFirmwareUpgradesStagedEvents networks/{networkId}/firmwareUpgrades/staged/events
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkFirmwareUpgradesStagedEventsReturn> UpdateNetworkFirmwareUpgradesStagedEventsAsync(string networkId, UpdateNetworkFirmwareUpgradesStagedEventsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/firmwareUpgrades/staged/events";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkFirmwareUpgradesStagedEventsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Postpone by 1 week all pending staged upgrade stages for a network
		/// Postpone by 1 week all pending staged upgrade stages for a network
		/// DeferNetworkFirmwareUpgradesStagedEvents networks/{networkId}/firmwareUpgrades/staged/events/defer
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<DeferNetworkFirmwareUpgradesStagedEventsReturn> DeferNetworkFirmwareUpgradesStagedEventsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/firmwareUpgrades/staged/events/defer";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DeferNetworkFirmwareUpgradesStagedEventsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Rollback a Staged Upgrade Event for a network
		/// Rollback a Staged Upgrade Event for a network
		/// RollbacksNetworkFirmwareUpgradesStagedEvents networks/{networkId}/firmwareUpgrades/staged/events/rollbacks
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<RollbacksNetworkFirmwareUpgradesStagedEventsReturn> RollbacksNetworkFirmwareUpgradesStagedEventsAsync(string networkId, RollbacksNetworkFirmwareUpgradesStagedEventsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/firmwareUpgrades/staged/events/rollbacks";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<RollbacksNetworkFirmwareUpgradesStagedEventsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List of Staged Upgrade Groups in a network
		/// List of Staged Upgrade Groups in a network
		/// GetNetworkFirmwareUpgradesStagedGroups networks/{networkId}/firmwareUpgrades/staged/groups
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkFirmwareUpgradesStagedGroupsReturn[]> GetNetworkFirmwareUpgradesStagedGroupsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/firmwareUpgrades/staged/groups";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkFirmwareUpgradesStagedGroupsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a Staged Upgrade Group for a network
		/// Create a Staged Upgrade Group for a network
		/// CreateNetworkFirmwareUpgradesStagedGroup networks/{networkId}/firmwareUpgrades/staged/groups
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> CreateNetworkFirmwareUpgradesStagedGroupAsync(string networkId, CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroup requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/firmwareUpgrades/staged/groups";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a Staged Upgrade Group
		/// Delete a Staged Upgrade Group
		/// DeleteNetworkFirmwareUpgradesStagedGroup networks/{networkId}/firmwareUpgrades/staged/groups/{groupId}
		/// </summary>
		public async Task DeleteNetworkFirmwareUpgradesStagedGroupAsync(string networkId, string groupId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/firmwareUpgrades/staged/groups/"+ (groupId==null? "" : System.Uri.EscapeDataString(groupId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a Staged Upgrade Group from a network
		/// Get a Staged Upgrade Group from a network
		/// GetNetworkFirmwareUpgradesStagedGroup networks/{networkId}/firmwareUpgrades/staged/groups/{groupId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkFirmwareUpgradesStagedGroupReturn> GetNetworkFirmwareUpgradesStagedGroupAsync(string networkId, string groupId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/firmwareUpgrades/staged/groups/"+ (groupId==null? "" : System.Uri.EscapeDataString(groupId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkFirmwareUpgradesStagedGroupReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a Staged Upgrade Group for a network
		/// Update a Staged Upgrade Group for a network
		/// UpdateNetworkFirmwareUpgradesStagedGroup networks/{networkId}/firmwareUpgrades/staged/groups/{groupId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkFirmwareUpgradesStagedGroupAsync(string networkId, string groupId, CreateNetworkFirmwareUpgradesStagedGroupCreatenetworkfirmwareupgradesstagedgroup requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/firmwareUpgrades/staged/groups/"+ (groupId==null? "" : System.Uri.EscapeDataString(groupId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Order of Staged Upgrade Groups in a network
		/// Order of Staged Upgrade Groups in a network
		/// GetNetworkFirmwareUpgradesStagedStages networks/{networkId}/firmwareUpgrades/staged/stages
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkFirmwareUpgradesStagedStagesReturn[]> GetNetworkFirmwareUpgradesStagedStagesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/firmwareUpgrades/staged/stages";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkFirmwareUpgradesStagedStagesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Assign Staged Upgrade Group order in the sequence.
		/// Assign Staged Upgrade Group order in the sequence.
		/// UpdateNetworkFirmwareUpgradesStagedStages networks/{networkId}/firmwareUpgrades/staged/stages
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkFirmwareUpgradesStagedStagesReturn[]> UpdateNetworkFirmwareUpgradesStagedStagesAsync(string networkId, UpdateNetworkFirmwareUpgradesStagedStagesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/firmwareUpgrades/staged/stages";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkFirmwareUpgradesStagedStagesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the floor plans that belong to your network
		/// List the floor plans that belong to your network
		/// GetNetworkFloorPlans networks/{networkId}/floorPlans
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkFloorPlansAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/floorPlans";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Upload a floor plan
		/// Upload a floor plan
		/// CreateNetworkFloorPlan networks/{networkId}/floorPlans
		/// </summary>
		public async Task CreateNetworkFloorPlanAsync(string networkId, CreateNetworkFloorPlanPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/floorPlans";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Destroy a floor plan
		/// Destroy a floor plan
		/// DeleteNetworkFloorPlan networks/{networkId}/floorPlans/{floorPlanId}
		/// </summary>
		public async Task DeleteNetworkFloorPlanAsync(string networkId, string floorPlanId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/floorPlans/"+ (floorPlanId==null? "" : System.Uri.EscapeDataString(floorPlanId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Find a floor plan by ID
		/// Find a floor plan by ID
		/// GetNetworkFloorPlan networks/{networkId}/floorPlans/{floorPlanId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkFloorPlanAsync(string networkId, string floorPlanId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/floorPlans/"+ (floorPlanId==null? "" : System.Uri.EscapeDataString(floorPlanId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a floor plan's geolocation and other meta data
		/// Update a floor plan's geolocation and other meta data
		/// UpdateNetworkFloorPlan networks/{networkId}/floorPlans/{floorPlanId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkFloorPlanAsync(string networkId, string floorPlanId, UpdateNetworkFloorPlanPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/floorPlans/"+ (floorPlanId==null? "" : System.Uri.EscapeDataString(floorPlanId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the group policies in a network
		/// List the group policies in a network
		/// GetNetworkGroupPolicies networks/{networkId}/groupPolicies
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkGroupPoliciesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/groupPolicies";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a group policy
		/// Create a group policy
		/// CreateNetworkGroupPolicy networks/{networkId}/groupPolicies
		/// </summary>
		public async Task CreateNetworkGroupPolicyAsync(string networkId, CreateNetworkGroupPolicyPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/groupPolicies";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a group policy
		/// Delete a group policy
		/// DeleteNetworkGroupPolicy networks/{networkId}/groupPolicies/{groupPolicyId}
		/// </summary>
		public async Task DeleteNetworkGroupPolicyAsync(string networkId, string groupPolicyId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/groupPolicies/"+ (groupPolicyId==null? "" : System.Uri.EscapeDataString(groupPolicyId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Display a group policy
		/// Display a group policy
		/// GetNetworkGroupPolicy networks/{networkId}/groupPolicies/{groupPolicyId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkGroupPolicyAsync(string networkId, string groupPolicyId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/groupPolicies/"+ (groupPolicyId==null? "" : System.Uri.EscapeDataString(groupPolicyId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a group policy
		/// Update a group policy
		/// UpdateNetworkGroupPolicy networks/{networkId}/groupPolicies/{groupPolicyId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkGroupPolicyAsync(string networkId, string groupPolicyId, UpdateNetworkGroupPolicyPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/groupPolicies/"+ (groupPolicyId==null? "" : System.Uri.EscapeDataString(groupPolicyId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return all global alerts on this network
		/// Return all global alerts on this network
		/// GetNetworkHealthAlerts networks/{networkId}/health/alerts
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkHealthAlertsReturn[]> GetNetworkHealthAlertsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/health/alerts";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkHealthAlertsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get application health by time
		/// Get application health by time
		/// GetNetworkInsightApplicationHealthByTime networks/{networkId}/insight/applications/{applicationId}/healthByTime
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 7 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 2 hours.</param>
		/// <param name="resolution">The time resolution in seconds for returned data. The valid resolutions are: 60, 300, 3600, 86400. The default is 300.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkInsightApplicationHealthByTimeReturn[]> GetNetworkInsightApplicationHealthByTimeAsync(string networkId, string applicationId, string t0, string t1, float timespan, int resolution, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/insight/applications/"+ (applicationId==null? "" : System.Uri.EscapeDataString(applicationId))+"/healthByTime&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&resolution="+resolution;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkInsightApplicationHealthByTimeReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the users configured under Meraki Authentication for a network (splash guest or RADIUS users for a wireless network, or client VPN users for a wired network)
		/// List the users configured under Meraki Authentication for a network (splash guest or RADIUS users for a wireless network, or client VPN users for a wired network)
		/// GetNetworkMerakiAuthUsers networks/{networkId}/merakiAuthUsers
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkMerakiAuthUsersReturn[]> GetNetworkMerakiAuthUsersAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/merakiAuthUsers";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkMerakiAuthUsersReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Authorize a user configured with Meraki Authentication for a network (currently supports 802.1X, splash guest, and client VPN users, and currently, organizations have a 50,000 user cap)
		/// Authorize a user configured with Meraki Authentication for a network (currently supports 802.1X, splash guest, and client VPN users, and currently, organizations have a 50,000 user cap)
		/// CreateNetworkMerakiAuthUser networks/{networkId}/merakiAuthUsers
		/// </summary>
		public async Task CreateNetworkMerakiAuthUserAsync(string networkId, CreateNetworkMerakiAuthUserPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/merakiAuthUsers";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Deauthorize a user
		/// Deauthorize a user. To reauthorize a user after deauthorizing them, POST to this endpoint. (Currently, 802.1X RADIUS, splash guest, and client VPN users can be deauthorized.)
		/// DeleteNetworkMerakiAuthUser networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}
		/// </summary>
		public async Task DeleteNetworkMerakiAuthUserAsync(string networkId, string merakiAuthUserId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/merakiAuthUsers/"+ (merakiAuthUserId==null? "" : System.Uri.EscapeDataString(merakiAuthUserId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the Meraki Auth splash guest, RADIUS, or client VPN user
		/// Return the Meraki Auth splash guest, RADIUS, or client VPN user
		/// GetNetworkMerakiAuthUser networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkMerakiAuthUserReturn> GetNetworkMerakiAuthUserAsync(string networkId, string merakiAuthUserId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/merakiAuthUsers/"+ (merakiAuthUserId==null? "" : System.Uri.EscapeDataString(merakiAuthUserId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkMerakiAuthUserReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a user configured with Meraki Authentication (currently, 802.1X RADIUS, splash guest, and client VPN users can be updated)
		/// Update a user configured with Meraki Authentication (currently, 802.1X RADIUS, splash guest, and client VPN users can be updated)
		/// UpdateNetworkMerakiAuthUser networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkMerakiAuthUserReturn> UpdateNetworkMerakiAuthUserAsync(string networkId, string merakiAuthUserId, UpdateNetworkMerakiAuthUserPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/merakiAuthUsers/"+ (merakiAuthUserId==null? "" : System.Uri.EscapeDataString(merakiAuthUserId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkMerakiAuthUserReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the MQTT brokers for this network
		/// List the MQTT brokers for this network
		/// GetNetworkMqttBrokers networks/{networkId}/mqttBrokers
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkMqttBrokersAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/mqttBrokers";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add an MQTT broker
		/// Add an MQTT broker
		/// CreateNetworkMqttBroker networks/{networkId}/mqttBrokers
		/// </summary>
		public async Task CreateNetworkMqttBrokerAsync(string networkId, CreateNetworkMqttBrokerPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/mqttBrokers";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete an MQTT broker
		/// Delete an MQTT broker
		/// DeleteNetworkMqttBroker networks/{networkId}/mqttBrokers/{mqttBrokerId}
		/// </summary>
		public async Task DeleteNetworkMqttBrokerAsync(string networkId, string mqttBrokerId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/mqttBrokers/"+ (mqttBrokerId==null? "" : System.Uri.EscapeDataString(mqttBrokerId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return an MQTT broker
		/// Return an MQTT broker
		/// GetNetworkMqttBroker networks/{networkId}/mqttBrokers/{mqttBrokerId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkMqttBrokerAsync(string networkId, string mqttBrokerId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/mqttBrokers/"+ (mqttBrokerId==null? "" : System.Uri.EscapeDataString(mqttBrokerId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update an MQTT broker
		/// Update an MQTT broker
		/// UpdateNetworkMqttBroker networks/{networkId}/mqttBrokers/{mqttBrokerId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkMqttBrokerAsync(string networkId, string mqttBrokerId, UpdateNetworkMqttBrokerPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/mqttBrokers/"+ (mqttBrokerId==null? "" : System.Uri.EscapeDataString(mqttBrokerId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the NetFlow traffic reporting settings for a network
		/// Return the NetFlow traffic reporting settings for a network
		/// GetNetworkNetflow networks/{networkId}/netflow
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkNetflowAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/netflow";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the NetFlow traffic reporting settings for a network
		/// Update the NetFlow traffic reporting settings for a network
		/// UpdateNetworkNetflow networks/{networkId}/netflow
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkNetflowAsync(string networkId, UpdateNetworkNetflowPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/netflow";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get the channel utilization over each radio for all APs in a network.
		/// Get the channel utilization over each radio for all APs in a network.
		/// GetNetworkNetworkHealthChannelUtilization networks/{networkId}/networkHealth/channelUtilization
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <param name="resolution">The time resolution in seconds for returned data. The valid resolutions are: 600. The default is 600.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 100. Default is 10.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkNetworkHealthChannelUtilizationAsync(string networkId, string t0, string t1, float timespan, int resolution, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/networkHealth/channelUtilization&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&resolution="+resolution+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the keys required to access Personally Identifiable Information (PII) for a given identifier
		/// List the keys required to access Personally Identifiable Information (PII) for a given identifier. Exactly one identifier will be accepted. If the organization contains org-wide Systems Manager users matching the key provided then there will be an entry with the key "0" containing the applicable keys.
		/// 
		/// ## ALTERNATE PATH
		/// 
		/// ```
		/// /organizations/{organizationId}/pii/piiKeys
		/// ```
		/// GetNetworkPiiPiiKeys networks/{networkId}/pii/piiKeys
		/// </summary>
		/// <param name="username">The username of a Systems Manager user</param>
		/// <param name="email">The email of a network user account or a Systems Manager device</param>
		/// <param name="mac">The MAC of a network client device or a Systems Manager device</param>
		/// <param name="serial">The serial of a Systems Manager device</param>
		/// <param name="imei">The IMEI of a Systems Manager device</param>
		/// <param name="bluetoothMac">The MAC of a Bluetooth client</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkPiiPiiKeysAsync(string networkId, string username, string email, string mac, string serial, string imei, string bluetoothMac, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/pii/piiKeys&username=" + (username==null? "" : System.Uri.EscapeDataString(username))+"&email=" + (email==null? "" : System.Uri.EscapeDataString(email))+"&mac=" + (mac==null? "" : System.Uri.EscapeDataString(mac))+"&serial=" + (serial==null? "" : System.Uri.EscapeDataString(serial))+"&imei=" + (imei==null? "" : System.Uri.EscapeDataString(imei))+"&bluetoothMac=" + (bluetoothMac==null? "" : System.Uri.EscapeDataString(bluetoothMac));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the PII requests for this network or organization
		/// List the PII requests for this network or organization
		/// 
		/// ## ALTERNATE PATH
		/// 
		/// ```
		/// /organizations/{organizationId}/pii/requests
		/// ```
		/// GetNetworkPiiRequests networks/{networkId}/pii/requests
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkPiiRequestsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/pii/requests";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Submit a new delete or restrict processing PII request
		/// Submit a new delete or restrict processing PII request
		/// 
		/// ## ALTERNATE PATH
		/// 
		/// ```
		/// /organizations/{organizationId}/pii/requests
		/// ```
		/// CreateNetworkPiiRequest networks/{networkId}/pii/requests
		/// </summary>
		public async Task CreateNetworkPiiRequestAsync(string networkId, CreateNetworkPiiRequestPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/pii/requests";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a restrict processing PII request
		/// Delete a restrict processing PII request
		/// 
		/// ## ALTERNATE PATH
		/// 
		/// ```
		/// /organizations/{organizationId}/pii/requests/{requestId}
		/// ```
		/// DeleteNetworkPiiRequest networks/{networkId}/pii/requests/{requestId}
		/// </summary>
		public async Task DeleteNetworkPiiRequestAsync(string networkId, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/pii/requests/"+ (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a PII request
		/// Return a PII request
		/// 
		/// ## ALTERNATE PATH
		/// 
		/// ```
		/// /organizations/{organizationId}/pii/requests/{requestId}
		/// ```
		/// GetNetworkPiiRequest networks/{networkId}/pii/requests/{requestId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkPiiRequestAsync(string networkId, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/pii/requests/"+ (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Given a piece of Personally Identifiable Information (PII), return the Systems Manager device ID(s) associated with that identifier
		/// Given a piece of Personally Identifiable Information (PII), return the Systems Manager device ID(s) associated with that identifier. These device IDs can be used with the Systems Manager API endpoints to retrieve device details. Exactly one identifier will be accepted.
		/// 
		/// ## ALTERNATE PATH
		/// 
		/// ```
		/// /organizations/{organizationId}/pii/smDevicesForKey
		/// ```
		/// GetNetworkPiiSmDevicesForKey networks/{networkId}/pii/smDevicesForKey
		/// </summary>
		/// <param name="username">The username of a Systems Manager user</param>
		/// <param name="email">The email of a network user account or a Systems Manager device</param>
		/// <param name="mac">The MAC of a network client device or a Systems Manager device</param>
		/// <param name="serial">The serial of a Systems Manager device</param>
		/// <param name="imei">The IMEI of a Systems Manager device</param>
		/// <param name="bluetoothMac">The MAC of a Bluetooth client</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkPiiSmDevicesForKeyAsync(string networkId, string username, string email, string mac, string serial, string imei, string bluetoothMac, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/pii/smDevicesForKey&username=" + (username==null? "" : System.Uri.EscapeDataString(username))+"&email=" + (email==null? "" : System.Uri.EscapeDataString(email))+"&mac=" + (mac==null? "" : System.Uri.EscapeDataString(mac))+"&serial=" + (serial==null? "" : System.Uri.EscapeDataString(serial))+"&imei=" + (imei==null? "" : System.Uri.EscapeDataString(imei))+"&bluetoothMac=" + (bluetoothMac==null? "" : System.Uri.EscapeDataString(bluetoothMac));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Given a piece of Personally Identifiable Information (PII), return the Systems Manager owner ID(s) associated with that identifier
		/// Given a piece of Personally Identifiable Information (PII), return the Systems Manager owner ID(s) associated with that identifier. These owner IDs can be used with the Systems Manager API endpoints to retrieve owner details. Exactly one identifier will be accepted.
		/// 
		/// ## ALTERNATE PATH
		/// 
		/// ```
		/// /organizations/{organizationId}/pii/smOwnersForKey
		/// ```
		/// GetNetworkPiiSmOwnersForKey networks/{networkId}/pii/smOwnersForKey
		/// </summary>
		/// <param name="username">The username of a Systems Manager user</param>
		/// <param name="email">The email of a network user account or a Systems Manager device</param>
		/// <param name="mac">The MAC of a network client device or a Systems Manager device</param>
		/// <param name="serial">The serial of a Systems Manager device</param>
		/// <param name="imei">The IMEI of a Systems Manager device</param>
		/// <param name="bluetoothMac">The MAC of a Bluetooth client</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkPiiSmOwnersForKeyAsync(string networkId, string username, string email, string mac, string serial, string imei, string bluetoothMac, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/pii/smOwnersForKey&username=" + (username==null? "" : System.Uri.EscapeDataString(username))+"&email=" + (email==null? "" : System.Uri.EscapeDataString(email))+"&mac=" + (mac==null? "" : System.Uri.EscapeDataString(mac))+"&serial=" + (serial==null? "" : System.Uri.EscapeDataString(serial))+"&imei=" + (imei==null? "" : System.Uri.EscapeDataString(imei))+"&bluetoothMac=" + (bluetoothMac==null? "" : System.Uri.EscapeDataString(bluetoothMac));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get policies for all clients with policies
		/// Get policies for all clients with policies
		/// GetNetworkPoliciesByClient networks/{networkId}/policies/byClient
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkPoliciesByClientReturn[]> GetNetworkPoliciesByClientAsync(string networkId, int perPage, string startingAfter, string endingBefore, string t0, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/policies/byClient&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&timespan="+timespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkPoliciesByClientReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return an overview of currently alerting sensors by metric
		/// Return an overview of currently alerting sensors by metric
		/// GetNetworkSensorAlertsCurrentOverviewByMetric networks/{networkId}/sensor/alerts/current/overview/byMetric
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSensorAlertsCurrentOverviewByMetricReturn> GetNetworkSensorAlertsCurrentOverviewByMetricAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sensor/alerts/current/overview/byMetric";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSensorAlertsCurrentOverviewByMetricReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return an overview of alert occurrences over a timespan, by metric
		/// Return an overview of alert occurrences over a timespan, by metric
		/// GetNetworkSensorAlertsOverviewByMetric networks/{networkId}/sensor/alerts/overview/byMetric
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 365 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.</param>
		/// <param name="interval">The time interval in seconds for returned data. The valid intervals are: 86400, 604800. The default is 604800.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSensorAlertsOverviewByMetricReturn[]> GetNetworkSensorAlertsOverviewByMetricAsync(string networkId, string t0, string t1, float timespan, int interval, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sensor/alerts/overview/byMetric&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&interval="+interval;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSensorAlertsOverviewByMetricReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Lists all sensor alert profiles for a network.
		/// Lists all sensor alert profiles for a network.
		/// GetNetworkSensorAlertsProfiles networks/{networkId}/sensor/alerts/profiles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSensorAlertsProfilesReturn[]> GetNetworkSensorAlertsProfilesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sensor/alerts/profiles";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSensorAlertsProfilesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Creates a sensor alert profile for a network.
		/// Creates a sensor alert profile for a network.
		/// CreateNetworkSensorAlertsProfile networks/{networkId}/sensor/alerts/profiles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<CreateNetworkSensorAlertsProfileReturn> CreateNetworkSensorAlertsProfileAsync(string networkId, CreateNetworkSensorAlertsProfilePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sensor/alerts/profiles";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<CreateNetworkSensorAlertsProfileReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Deletes a sensor alert profile from a network.
		/// Deletes a sensor alert profile from a network.
		/// DeleteNetworkSensorAlertsProfile networks/{networkId}/sensor/alerts/profiles/{id}
		/// </summary>
		public async Task DeleteNetworkSensorAlertsProfileAsync(string networkId, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sensor/alerts/profiles/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Show details of a sensor alert profile for a network.
		/// Show details of a sensor alert profile for a network.
		/// GetNetworkSensorAlertsProfile networks/{networkId}/sensor/alerts/profiles/{id}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSensorAlertsProfileReturn> GetNetworkSensorAlertsProfileAsync(string networkId, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sensor/alerts/profiles/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSensorAlertsProfileReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates a sensor alert profile for a network.
		/// Updates a sensor alert profile for a network.
		/// UpdateNetworkSensorAlertsProfile networks/{networkId}/sensor/alerts/profiles/{id}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkSensorAlertsProfileReturn> UpdateNetworkSensorAlertsProfileAsync(string networkId, string id, UpdateNetworkSensorAlertsProfilePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sensor/alerts/profiles/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkSensorAlertsProfileReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the sensor roles for devices in a given network
		/// List the sensor roles for devices in a given network
		/// GetNetworkSensorRelationships networks/{networkId}/sensor/relationships
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSensorRelationshipsReturn[]> GetNetworkSensorRelationshipsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sensor/relationships";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSensorRelationshipsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the settings for a network
		/// Return the settings for a network
		/// GetNetworkSettings networks/{networkId}/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSettingsReturn> GetNetworkSettingsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSettingsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the settings for a network
		/// Update the settings for a network
		/// UpdateNetworkSettings networks/{networkId}/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkSettingsReturn> UpdateNetworkSettingsAsync(string networkId, UpdateNetworkSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkSettingsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Bypass activation lock attempt
		/// Bypass activation lock attempt
		/// CreateNetworkSmBypassActivationLockAttempt networks/{networkId}/sm/bypassActivationLockAttempts
		/// </summary>
		public async Task CreateNetworkSmBypassActivationLockAttemptAsync(string networkId, CreateNetworkSmBypassActivationLockAttemptPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/bypassActivationLockAttempts";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Bypass activation lock attempt status
		/// Bypass activation lock attempt status
		/// GetNetworkSmBypassActivationLockAttempt networks/{networkId}/sm/bypassActivationLockAttempts/{attemptId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSmBypassActivationLockAttemptAsync(string networkId, string attemptId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/bypassActivationLockAttempts/"+ (attemptId==null? "" : System.Uri.EscapeDataString(attemptId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the devices enrolled in an SM network with various specified fields and filters
		/// List the devices enrolled in an SM network with various specified fields and filters
		/// GetNetworkSmDevices networks/{networkId}/sm/devices
		/// </summary>
		/// <param name="fields">Additional fields that will be displayed for each device.
		///    The default fields are: id, name, tags, ssid, wifiMac, osName, systemModel, uuid, and serialNumber. The additional fields are: ip,
		///    systemType, availableDeviceCapacity, kioskAppName, biosVersion, lastConnected, missingAppsCount, userSuppliedAddress, location, lastUser,
		///    ownerEmail, ownerUsername, osBuild, publicIp, phoneNumber, diskInfoJson, deviceCapacity, isManaged, hadMdm, isSupervised, meid, imei, iccid,
		///    simCarrierNetwork, cellularDataUsed, isHotspotEnabled, createdAt, batteryEstCharge, quarantined, avName, avRunning, asName, fwName,
		///    isRooted, loginRequired, screenLockEnabled, screenLockDelay, autoLoginDisabled, autoTags, hasMdm, hasDesktopAgent, diskEncryptionEnabled,
		///    hardwareEncryptionCaps, passCodeLock, usesHardwareKeystore, androidSecurityPatchVersion, and url.</param>
		/// <param name="wifiMacs">Filter devices by wifi mac(s).</param>
		/// <param name="serials">Filter devices by serial(s).</param>
		/// <param name="ids">Filter devices by id(s).</param>
		/// <param name="scope">Specify a scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSmDevicesReturn[]> GetNetworkSmDevicesAsync(string networkId, string[] fields, string[] wifiMacs, string[] serials, string[] ids, string[] scope, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices&"+string.Join("&", fields.Select(z => $"fields={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", wifiMacs.Select(z => $"wifiMacs={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", serials.Select(z => $"serials={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", ids.Select(z => $"ids={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", scope.Select(z => $"scope={System.Uri.EscapeDataString(z.ToString())}"))+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSmDevicesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Force check-in a set of devices
		/// Force check-in a set of devices
		/// CheckinNetworkSmDevices networks/{networkId}/sm/devices/checkin
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<CheckinNetworkSmDevicesReturn> CheckinNetworkSmDevicesAsync(string networkId, CheckinNetworkSmDevicesPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/checkin";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<CheckinNetworkSmDevicesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Modify the fields of a device
		/// Modify the fields of a device
		/// UpdateNetworkSmDevicesFields networks/{networkId}/sm/devices/fields
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkSmDevicesFieldsReturn[]> UpdateNetworkSmDevicesFieldsAsync(string networkId, UpdateNetworkSmDevicesFieldsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/fields";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkSmDevicesFieldsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Lock a set of devices
		/// Lock a set of devices
		/// LockNetworkSmDevices networks/{networkId}/sm/devices/lock
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<LockNetworkSmDevicesReturn> LockNetworkSmDevicesAsync(string networkId, LockNetworkSmDevicesPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/lock";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LockNetworkSmDevicesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add, delete, or update the tags of a set of devices
		/// Add, delete, or update the tags of a set of devices
		/// ModifyNetworkSmDevicesTags networks/{networkId}/sm/devices/modifyTags
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<ModifyNetworkSmDevicesTagsReturn[]> ModifyNetworkSmDevicesTagsAsync(string networkId, ModifyNetworkSmDevicesTagsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/modifyTags";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ModifyNetworkSmDevicesTagsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Move a set of devices to a new network
		/// Move a set of devices to a new network
		/// MoveNetworkSmDevices networks/{networkId}/sm/devices/move
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<MoveNetworkSmDevicesReturn> MoveNetworkSmDevicesAsync(string networkId, MoveNetworkSmDevicesPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/move";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<MoveNetworkSmDevicesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Wipe a device
		/// Wipe a device
		/// WipeNetworkSmDevices networks/{networkId}/sm/devices/wipe
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<WipeNetworkSmDevicesReturn> WipeNetworkSmDevicesAsync(string networkId, WipeNetworkSmDevicesPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/wipe";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<WipeNetworkSmDevicesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the client's daily cellular data usage history
		/// Return the client's daily cellular data usage history. Usage data is in kilobytes.
		/// GetNetworkSmDeviceCellularUsageHistory networks/{networkId}/sm/devices/{deviceId}/cellularUsageHistory
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSmDeviceCellularUsageHistoryReturn[]> GetNetworkSmDeviceCellularUsageHistoryAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/cellularUsageHistory";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSmDeviceCellularUsageHistoryReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the certs on a device
		/// List the certs on a device
		/// GetNetworkSmDeviceCerts networks/{networkId}/sm/devices/{deviceId}/certs
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSmDeviceCertsReturn[]> GetNetworkSmDeviceCertsAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/certs";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSmDeviceCertsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns historical connectivity data (whether a device is regularly checking in to Dashboard).
		/// Returns historical connectivity data (whether a device is regularly checking in to Dashboard).
		/// GetNetworkSmDeviceConnectivity networks/{networkId}/sm/devices/{deviceId}/connectivity
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSmDeviceConnectivityReturn[]> GetNetworkSmDeviceConnectivityAsync(string networkId, string deviceId, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/connectivity&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSmDeviceConnectivityReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return historical records of various Systems Manager network connection details for desktop devices.
		/// Return historical records of various Systems Manager network connection details for desktop devices.
		/// GetNetworkSmDeviceDesktopLogs networks/{networkId}/sm/devices/{deviceId}/desktopLogs
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSmDeviceDesktopLogsReturn[]> GetNetworkSmDeviceDesktopLogsAsync(string networkId, string deviceId, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/desktopLogs&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSmDeviceDesktopLogsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return historical records of commands sent to Systems Manager devices
		/// Return historical records of commands sent to Systems Manager devices. Note that this will include the name of the Dashboard user who initiated the command if it was generated by a Dashboard admin rather than the automatic behavior of the system; you may wish to filter this out of any reports.
		/// GetNetworkSmDeviceDeviceCommandLogs networks/{networkId}/sm/devices/{deviceId}/deviceCommandLogs
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSmDeviceDeviceCommandLogsReturn[]> GetNetworkSmDeviceDeviceCommandLogsAsync(string networkId, string deviceId, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/deviceCommandLogs&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSmDeviceDeviceCommandLogsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get the installed profiles associated with a device
		/// Get the installed profiles associated with a device
		/// GetNetworkSmDeviceDeviceProfiles networks/{networkId}/sm/devices/{deviceId}/deviceProfiles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSmDeviceDeviceProfilesReturn[]> GetNetworkSmDeviceDeviceProfilesAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/deviceProfiles";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSmDeviceDeviceProfilesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the network adapters of a device
		/// List the network adapters of a device
		/// GetNetworkSmDeviceNetworkAdapters networks/{networkId}/sm/devices/{deviceId}/networkAdapters
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSmDeviceNetworkAdaptersReturn[]> GetNetworkSmDeviceNetworkAdaptersAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/networkAdapters";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSmDeviceNetworkAdaptersReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return historical records of various Systems Manager client metrics for desktop devices.
		/// Return historical records of various Systems Manager client metrics for desktop devices.
		/// GetNetworkSmDevicePerformanceHistory networks/{networkId}/sm/devices/{deviceId}/performanceHistory
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSmDevicePerformanceHistoryReturn[]> GetNetworkSmDevicePerformanceHistoryAsync(string networkId, string deviceId, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/performanceHistory&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSmDevicePerformanceHistoryReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Refresh the details of a device
		/// Refresh the details of a device
		/// RefreshNetworkSmDeviceDetails networks/{networkId}/sm/devices/{deviceId}/refreshDetails
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task RefreshNetworkSmDeviceDetailsAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/refreshDetails";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the restrictions on a device
		/// List the restrictions on a device
		/// GetNetworkSmDeviceRestrictions networks/{networkId}/sm/devices/{deviceId}/restrictions
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSmDeviceRestrictionsAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/restrictions";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the security centers on a device
		/// List the security centers on a device
		/// GetNetworkSmDeviceSecurityCenters networks/{networkId}/sm/devices/{deviceId}/securityCenters
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSmDeviceSecurityCentersReturn[]> GetNetworkSmDeviceSecurityCentersAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/securityCenters";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSmDeviceSecurityCentersReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a list of softwares associated with a device
		/// Get a list of softwares associated with a device
		/// GetNetworkSmDeviceSoftwares networks/{networkId}/sm/devices/{deviceId}/softwares
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSmDeviceSoftwaresReturn[]> GetNetworkSmDeviceSoftwaresAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/softwares";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSmDeviceSoftwaresReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Unenroll a device
		/// Unenroll a device
		/// UnenrollNetworkSmDevice networks/{networkId}/sm/devices/{deviceId}/unenroll
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UnenrollNetworkSmDeviceAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/unenroll";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the saved SSID names on a device
		/// List the saved SSID names on a device
		/// GetNetworkSmDeviceWlanLists networks/{networkId}/sm/devices/{deviceId}/wlanLists
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSmDeviceWlanListsReturn[]> GetNetworkSmDeviceWlanListsAsync(string networkId, string deviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/devices/"+ (deviceId==null? "" : System.Uri.EscapeDataString(deviceId))+"/wlanLists";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSmDeviceWlanListsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List all profiles in a network
		/// List all profiles in a network
		/// GetNetworkSmProfiles networks/{networkId}/sm/profiles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSmProfilesReturn[]> GetNetworkSmProfilesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/profiles";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSmProfilesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the target groups in this network
		/// List the target groups in this network
		/// GetNetworkSmTargetGroups networks/{networkId}/sm/targetGroups
		/// </summary>
		/// <param name="withDetails">Boolean indicating if the the ids of the devices or users scoped by the target group should be included in the response</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSmTargetGroupsAsync(string networkId, bool withDetails, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/targetGroups&withDetails="+withDetails;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add a target group
		/// Add a target group
		/// CreateNetworkSmTargetGroup networks/{networkId}/sm/targetGroups
		/// </summary>
		public async Task CreateNetworkSmTargetGroupAsync(string networkId, CreateNetworkSmTargetGroupCreatenetworksmtargetgroup requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/targetGroups";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a target group from a network
		/// Delete a target group from a network
		/// DeleteNetworkSmTargetGroup networks/{networkId}/sm/targetGroups/{targetGroupId}
		/// </summary>
		public async Task DeleteNetworkSmTargetGroupAsync(string networkId, string targetGroupId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/targetGroups/"+ (targetGroupId==null? "" : System.Uri.EscapeDataString(targetGroupId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a target group
		/// Return a target group
		/// GetNetworkSmTargetGroup networks/{networkId}/sm/targetGroups/{targetGroupId}
		/// </summary>
		/// <param name="withDetails">Boolean indicating if the the ids of the devices or users scoped by the target group should be included in the response</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSmTargetGroupAsync(string networkId, string targetGroupId, bool withDetails, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/targetGroups/"+ (targetGroupId==null? "" : System.Uri.EscapeDataString(targetGroupId))+"&withDetails="+withDetails;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a target group
		/// Update a target group
		/// UpdateNetworkSmTargetGroup networks/{networkId}/sm/targetGroups/{targetGroupId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSmTargetGroupAsync(string networkId, string targetGroupId, CreateNetworkSmTargetGroupCreatenetworksmtargetgroup requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/targetGroups/"+ (targetGroupId==null? "" : System.Uri.EscapeDataString(targetGroupId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List Trusted Access Configs
		/// List Trusted Access Configs
		/// GetNetworkSmTrustedAccessConfigs networks/{networkId}/sm/trustedAccessConfigs
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSmTrustedAccessConfigsReturn[]> GetNetworkSmTrustedAccessConfigsAsync(string networkId, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/trustedAccessConfigs&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSmTrustedAccessConfigsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List User Access Devices and its Trusted Access Connections
		/// List User Access Devices and its Trusted Access Connections
		/// GetNetworkSmUserAccessDevices networks/{networkId}/sm/userAccessDevices
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSmUserAccessDevicesReturn[]> GetNetworkSmUserAccessDevicesAsync(string networkId, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/userAccessDevices&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSmUserAccessDevicesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a User Access Device
		/// Delete a User Access Device
		/// DeleteNetworkSmUserAccessDevice networks/{networkId}/sm/userAccessDevices/{userAccessDeviceId}
		/// </summary>
		public async Task DeleteNetworkSmUserAccessDeviceAsync(string networkId, string userAccessDeviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/userAccessDevices/"+ (userAccessDeviceId==null? "" : System.Uri.EscapeDataString(userAccessDeviceId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the owners in an SM network with various specified fields and filters
		/// List the owners in an SM network with various specified fields and filters
		/// GetNetworkSmUsers networks/{networkId}/sm/users
		/// </summary>
		/// <param name="ids">Filter users by id(s).</param>
		/// <param name="usernames">Filter users by username(s).</param>
		/// <param name="emails">Filter users by email(s).</param>
		/// <param name="scope">Specifiy a scope (one of all, none, withAny, withAll, withoutAny, withoutAll) and a set of tags.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSmUsersReturn[]> GetNetworkSmUsersAsync(string networkId, string[] ids, string[] usernames, string[] emails, string[] scope, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/users&"+string.Join("&", ids.Select(z => $"ids={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", usernames.Select(z => $"usernames={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", emails.Select(z => $"emails={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", scope.Select(z => $"scope={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSmUsersReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get the profiles associated with a user
		/// Get the profiles associated with a user
		/// GetNetworkSmUserDeviceProfiles networks/{networkId}/sm/users/{userId}/deviceProfiles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSmUserDeviceProfilesReturn[]> GetNetworkSmUserDeviceProfilesAsync(string networkId, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/deviceProfiles";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSmUserDeviceProfilesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a list of softwares associated with a user
		/// Get a list of softwares associated with a user
		/// GetNetworkSmUserSoftwares networks/{networkId}/sm/users/{userId}/softwares
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSmUserSoftwaresReturn[]> GetNetworkSmUserSoftwaresAsync(string networkId, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/sm/users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/softwares";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSmUserSoftwaresReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the SNMP settings for a network
		/// Return the SNMP settings for a network
		/// GetNetworkSnmp networks/{networkId}/snmp
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSnmpAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/snmp";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the SNMP settings for a network
		/// Update the SNMP settings for a network
		/// UpdateNetworkSnmp networks/{networkId}/snmp
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSnmpAsync(string networkId, UpdateNetworkSnmpPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/snmp";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the splash login attempts for a network
		/// List the splash login attempts for a network
		/// GetNetworkSplashLoginAttempts networks/{networkId}/splashLoginAttempts
		/// </summary>
		/// <param name="ssidNumber">Only return the login attempts for the specified SSID</param>
		/// <param name="loginIdentifier">The username, email, or phone number used during login</param>
		/// <param name="timespan">The timespan, in seconds, for the login attempts. The period will be from [timespan] seconds ago until now. The maximum timespan is 3 months</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSplashLoginAttemptsAsync(string networkId, GetNetworkSplashLoginAttemptsSsidNumber ssidNumber, string loginIdentifier, int timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/splashLoginAttempts&ssidNumber="+ssidNumber+"&loginIdentifier=" + (loginIdentifier==null? "" : System.Uri.EscapeDataString(loginIdentifier))+"&timespan="+timespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Split a combined network into individual networks for each type of device
		/// Split a combined network into individual networks for each type of device
		/// SplitNetwork networks/{networkId}/split
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SplitNetworkReturn> SplitNetworkAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/split";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<SplitNetworkReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the access control lists for a MS network
		/// Return the access control lists for a MS network
		/// GetNetworkSwitchAccessControlLists networks/{networkId}/switch/accessControlLists
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSwitchAccessControlListsReturn> GetNetworkSwitchAccessControlListsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/accessControlLists";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSwitchAccessControlListsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the access control lists for a MS network
		/// Update the access control lists for a MS network
		/// UpdateNetworkSwitchAccessControlLists networks/{networkId}/switch/accessControlLists
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkSwitchAccessControlListsReturn> UpdateNetworkSwitchAccessControlListsAsync(string networkId, UpdateNetworkSwitchAccessControlListsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/accessControlLists";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkSwitchAccessControlListsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the access policies for a switch network
		/// List the access policies for a switch network. Only returns access policies with 'my RADIUS server' as authentication method
		/// GetNetworkSwitchAccessPolicies networks/{networkId}/switch/accessPolicies
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSwitchAccessPoliciesReturn[]> GetNetworkSwitchAccessPoliciesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/accessPolicies";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSwitchAccessPoliciesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create an access policy for a switch network
		/// Create an access policy for a switch network. If you would like to enable Meraki Authentication, set radiusServers to empty array.
		/// CreateNetworkSwitchAccessPolicy networks/{networkId}/switch/accessPolicies
		/// </summary>
		public async Task CreateNetworkSwitchAccessPolicyAsync(string networkId, CreateNetworkSwitchAccessPolicyPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/accessPolicies";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete an access policy for a switch network
		/// Delete an access policy for a switch network
		/// DeleteNetworkSwitchAccessPolicy networks/{networkId}/switch/accessPolicies/{accessPolicyNumber}
		/// </summary>
		public async Task DeleteNetworkSwitchAccessPolicyAsync(string networkId, string accessPolicyNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/accessPolicies/"+ (accessPolicyNumber==null? "" : System.Uri.EscapeDataString(accessPolicyNumber));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a specific access policy for a switch network
		/// Return a specific access policy for a switch network
		/// GetNetworkSwitchAccessPolicy networks/{networkId}/switch/accessPolicies/{accessPolicyNumber}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSwitchAccessPolicyReturn> GetNetworkSwitchAccessPolicyAsync(string networkId, string accessPolicyNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/accessPolicies/"+ (accessPolicyNumber==null? "" : System.Uri.EscapeDataString(accessPolicyNumber));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSwitchAccessPolicyReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update an access policy for a switch network
		/// Update an access policy for a switch network. If you would like to enable Meraki Authentication, set radiusServers to empty array.
		/// UpdateNetworkSwitchAccessPolicy networks/{networkId}/switch/accessPolicies/{accessPolicyNumber}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkSwitchAccessPolicyReturn> UpdateNetworkSwitchAccessPolicyAsync(string networkId, string accessPolicyNumber, UpdateNetworkSwitchAccessPolicyPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/accessPolicies/"+ (accessPolicyNumber==null? "" : System.Uri.EscapeDataString(accessPolicyNumber));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkSwitchAccessPolicyReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the switch alternate management interface for the network
		/// Return the switch alternate management interface for the network
		/// GetNetworkSwitchAlternateManagementInterface networks/{networkId}/switch/alternateManagementInterface
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSwitchAlternateManagementInterfaceAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/alternateManagementInterface";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the switch alternate management interface for the network
		/// Update the switch alternate management interface for the network
		/// UpdateNetworkSwitchAlternateManagementInterface networks/{networkId}/switch/alternateManagementInterface
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchAlternateManagementInterfaceAsync(string networkId, UpdateNetworkSwitchAlternateManagementInterfacePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/alternateManagementInterface";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the network's DHCPv4 servers seen within the selected timeframe (default 1 day)
		/// Return the network's DHCPv4 servers seen within the selected timeframe (default 1 day)
		/// GetNetworkSwitchDhcpV4ServersSeen networks/{networkId}/switch/dhcp/v4/servers/seen
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSwitchDhcpV4ServersSeenReturn[]> GetNetworkSwitchDhcpV4ServersSeenAsync(string networkId, string t0, float timespan, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/dhcp/v4/servers/seen&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&timespan="+timespan+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSwitchDhcpV4ServersSeenReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the DHCP server settings
		/// Return the DHCP server settings. Blocked/allowed servers are only applied when default policy is allow/block, respectively
		/// GetNetworkSwitchDhcpServerPolicy networks/{networkId}/switch/dhcpServerPolicy
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSwitchDhcpServerPolicyAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/dhcpServerPolicy";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the DHCP server settings
		/// Update the DHCP server settings. Blocked/allowed servers are only applied when default policy is allow/block, respectively
		/// UpdateNetworkSwitchDhcpServerPolicy networks/{networkId}/switch/dhcpServerPolicy
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchDhcpServerPolicyAsync(string networkId, UpdateNetworkSwitchDhcpServerPolicyPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/dhcpServerPolicy";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the list of servers trusted by Dynamic ARP Inspection on this network
		/// Return the list of servers trusted by Dynamic ARP Inspection on this network. These are also known as whitelisted snoop entries
		/// GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServers networks/{networkId}/switch/dhcpServerPolicy/arpInspection/trustedServers
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersReturn[]> GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersAsync(string networkId, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/dhcpServerPolicy/arpInspection/trustedServers&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add a server to be trusted by Dynamic ARP Inspection on this network
		/// Add a server to be trusted by Dynamic ARP Inspection on this network
		/// CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServer networks/{networkId}/switch/dhcpServerPolicy/arpInspection/trustedServers
		/// </summary>
		public async Task CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerAsync(string networkId, CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/dhcpServerPolicy/arpInspection/trustedServers";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove a server from being trusted by Dynamic ARP Inspection on this network
		/// Remove a server from being trusted by Dynamic ARP Inspection on this network
		/// DeleteNetworkSwitchDhcpServerPolicyArpInspectionTrustedServer networks/{networkId}/switch/dhcpServerPolicy/arpInspection/trustedServers/{trustedServerId}
		/// </summary>
		public async Task DeleteNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerAsync(string networkId, string trustedServerId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/dhcpServerPolicy/arpInspection/trustedServers/"+ (trustedServerId==null? "" : System.Uri.EscapeDataString(trustedServerId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a server that is trusted by Dynamic ARP Inspection on this network
		/// Update a server that is trusted by Dynamic ARP Inspection on this network
		/// UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServer networks/{networkId}/switch/dhcpServerPolicy/arpInspection/trustedServers/{trustedServerId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerReturn> UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerAsync(string networkId, string trustedServerId, UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/dhcpServerPolicy/arpInspection/trustedServers/"+ (trustedServerId==null? "" : System.Uri.EscapeDataString(trustedServerId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the devices that have a Dynamic ARP Inspection warning and their warnings
		/// Return the devices that have a Dynamic ARP Inspection warning and their warnings
		/// GetNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDevice networks/{networkId}/switch/dhcpServerPolicy/arpInspection/warnings/byDevice
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDeviceReturn[]> GetNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDeviceAsync(string networkId, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/dhcpServerPolicy/arpInspection/warnings/byDevice&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDeviceReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the DSCP to CoS mappings
		/// Return the DSCP to CoS mappings
		/// GetNetworkSwitchDscpToCosMappings networks/{networkId}/switch/dscpToCosMappings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSwitchDscpToCosMappingsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/dscpToCosMappings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the DSCP to CoS mappings
		/// Update the DSCP to CoS mappings
		/// UpdateNetworkSwitchDscpToCosMappings networks/{networkId}/switch/dscpToCosMappings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchDscpToCosMappingsAsync(string networkId, UpdateNetworkSwitchDscpToCosMappingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/dscpToCosMappings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List link aggregation groups
		/// List link aggregation groups
		/// GetNetworkSwitchLinkAggregations networks/{networkId}/switch/linkAggregations
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSwitchLinkAggregationsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/linkAggregations";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a link aggregation group
		/// Create a link aggregation group
		/// CreateNetworkSwitchLinkAggregation networks/{networkId}/switch/linkAggregations
		/// </summary>
		public async Task CreateNetworkSwitchLinkAggregationAsync(string networkId, CreateNetworkSwitchLinkAggregationPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/linkAggregations";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Split a link aggregation group into separate ports
		/// Split a link aggregation group into separate ports
		/// DeleteNetworkSwitchLinkAggregation networks/{networkId}/switch/linkAggregations/{linkAggregationId}
		/// </summary>
		public async Task DeleteNetworkSwitchLinkAggregationAsync(string networkId, string linkAggregationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/linkAggregations/"+ (linkAggregationId==null? "" : System.Uri.EscapeDataString(linkAggregationId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a link aggregation group
		/// Update a link aggregation group
		/// UpdateNetworkSwitchLinkAggregation networks/{networkId}/switch/linkAggregations/{linkAggregationId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchLinkAggregationAsync(string networkId, string linkAggregationId, UpdateNetworkSwitchLinkAggregationPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/linkAggregations/"+ (linkAggregationId==null? "" : System.Uri.EscapeDataString(linkAggregationId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the MTU configuration
		/// Return the MTU configuration
		/// GetNetworkSwitchMtu networks/{networkId}/switch/mtu
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSwitchMtuReturn> GetNetworkSwitchMtuAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/mtu";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSwitchMtuReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the MTU configuration
		/// Update the MTU configuration
		/// UpdateNetworkSwitchMtu networks/{networkId}/switch/mtu
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchMtuAsync(string networkId, UpdateNetworkSwitchMtuPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/mtu";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List switch port schedules
		/// List switch port schedules
		/// GetNetworkSwitchPortSchedules networks/{networkId}/switch/portSchedules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSwitchPortSchedulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/portSchedules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add a switch port schedule
		/// Add a switch port schedule
		/// CreateNetworkSwitchPortSchedule networks/{networkId}/switch/portSchedules
		/// </summary>
		public async Task CreateNetworkSwitchPortScheduleAsync(string networkId, CreateNetworkSwitchPortSchedulePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/portSchedules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a switch port schedule
		/// Delete a switch port schedule
		/// DeleteNetworkSwitchPortSchedule networks/{networkId}/switch/portSchedules/{portScheduleId}
		/// </summary>
		public async Task DeleteNetworkSwitchPortScheduleAsync(string networkId, string portScheduleId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/portSchedules/"+ (portScheduleId==null? "" : System.Uri.EscapeDataString(portScheduleId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a switch port schedule
		/// Update a switch port schedule
		/// UpdateNetworkSwitchPortSchedule networks/{networkId}/switch/portSchedules/{portScheduleId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchPortScheduleAsync(string networkId, string portScheduleId, UpdateNetworkSwitchPortSchedulePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/portSchedules/"+ (portScheduleId==null? "" : System.Uri.EscapeDataString(portScheduleId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List quality of service rules
		/// List quality of service rules
		/// GetNetworkSwitchQosRules networks/{networkId}/switch/qosRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSwitchQosRulesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/qosRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add a quality of service rule
		/// Add a quality of service rule
		/// CreateNetworkSwitchQosRule networks/{networkId}/switch/qosRules
		/// </summary>
		public async Task CreateNetworkSwitchQosRuleAsync(string networkId, CreateNetworkSwitchQosRulePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/qosRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the quality of service rule IDs by order in which they will be processed by the switch
		/// Return the quality of service rule IDs by order in which they will be processed by the switch
		/// GetNetworkSwitchQosRulesOrder networks/{networkId}/switch/qosRules/order
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSwitchQosRulesOrderAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/qosRules/order";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the order in which the rules should be processed by the switch
		/// Update the order in which the rules should be processed by the switch
		/// UpdateNetworkSwitchQosRulesOrder networks/{networkId}/switch/qosRules/order
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchQosRulesOrderAsync(string networkId, UpdateNetworkSwitchQosRulesOrderPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/qosRules/order";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a quality of service rule
		/// Delete a quality of service rule
		/// DeleteNetworkSwitchQosRule networks/{networkId}/switch/qosRules/{qosRuleId}
		/// </summary>
		public async Task DeleteNetworkSwitchQosRuleAsync(string networkId, string qosRuleId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/qosRules/"+ (qosRuleId==null? "" : System.Uri.EscapeDataString(qosRuleId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a quality of service rule
		/// Return a quality of service rule
		/// GetNetworkSwitchQosRule networks/{networkId}/switch/qosRules/{qosRuleId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSwitchQosRuleAsync(string networkId, string qosRuleId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/qosRules/"+ (qosRuleId==null? "" : System.Uri.EscapeDataString(qosRuleId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a quality of service rule
		/// Update a quality of service rule
		/// UpdateNetworkSwitchQosRule networks/{networkId}/switch/qosRules/{qosRuleId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchQosRuleAsync(string networkId, string qosRuleId, UpdateNetworkSwitchQosRulePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/qosRules/"+ (qosRuleId==null? "" : System.Uri.EscapeDataString(qosRuleId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return multicast settings for a network
		/// Return multicast settings for a network
		/// GetNetworkSwitchRoutingMulticast networks/{networkId}/switch/routing/multicast
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSwitchRoutingMulticastAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/routing/multicast";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update multicast settings for a network
		/// Update multicast settings for a network
		/// UpdateNetworkSwitchRoutingMulticast networks/{networkId}/switch/routing/multicast
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchRoutingMulticastAsync(string networkId, UpdateNetworkSwitchRoutingMulticastPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/routing/multicast";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List multicast rendezvous points
		/// List multicast rendezvous points
		/// GetNetworkSwitchRoutingMulticastRendezvousPoints networks/{networkId}/switch/routing/multicast/rendezvousPoints
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSwitchRoutingMulticastRendezvousPointsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/routing/multicast/rendezvousPoints";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a multicast rendezvous point
		/// Create a multicast rendezvous point
		/// CreateNetworkSwitchRoutingMulticastRendezvousPoint networks/{networkId}/switch/routing/multicast/rendezvousPoints
		/// </summary>
		public async Task CreateNetworkSwitchRoutingMulticastRendezvousPointAsync(string networkId, CreateNetworkSwitchRoutingMulticastRendezvousPointPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/routing/multicast/rendezvousPoints";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a multicast rendezvous point
		/// Delete a multicast rendezvous point
		/// DeleteNetworkSwitchRoutingMulticastRendezvousPoint networks/{networkId}/switch/routing/multicast/rendezvousPoints/{rendezvousPointId}
		/// </summary>
		public async Task DeleteNetworkSwitchRoutingMulticastRendezvousPointAsync(string networkId, string rendezvousPointId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/routing/multicast/rendezvousPoints/"+ (rendezvousPointId==null? "" : System.Uri.EscapeDataString(rendezvousPointId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a multicast rendezvous point
		/// Return a multicast rendezvous point
		/// GetNetworkSwitchRoutingMulticastRendezvousPoint networks/{networkId}/switch/routing/multicast/rendezvousPoints/{rendezvousPointId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSwitchRoutingMulticastRendezvousPointAsync(string networkId, string rendezvousPointId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/routing/multicast/rendezvousPoints/"+ (rendezvousPointId==null? "" : System.Uri.EscapeDataString(rendezvousPointId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a multicast rendezvous point
		/// Update a multicast rendezvous point
		/// UpdateNetworkSwitchRoutingMulticastRendezvousPoint networks/{networkId}/switch/routing/multicast/rendezvousPoints/{rendezvousPointId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchRoutingMulticastRendezvousPointAsync(string networkId, string rendezvousPointId, UpdateNetworkSwitchRoutingMulticastRendezvousPointPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/routing/multicast/rendezvousPoints/"+ (rendezvousPointId==null? "" : System.Uri.EscapeDataString(rendezvousPointId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return layer 3 OSPF routing configuration
		/// Return layer 3 OSPF routing configuration
		/// GetNetworkSwitchRoutingOspf networks/{networkId}/switch/routing/ospf
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSwitchRoutingOspfAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/routing/ospf";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update layer 3 OSPF routing configuration
		/// Update layer 3 OSPF routing configuration
		/// UpdateNetworkSwitchRoutingOspf networks/{networkId}/switch/routing/ospf
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchRoutingOspfAsync(string networkId, UpdateNetworkSwitchRoutingOspfPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/routing/ospf";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns the switch network settings
		/// Returns the switch network settings
		/// GetNetworkSwitchSettings networks/{networkId}/switch/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSwitchSettingsReturn> GetNetworkSwitchSettingsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSwitchSettingsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update switch network settings
		/// Update switch network settings
		/// UpdateNetworkSwitchSettings networks/{networkId}/switch/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkSwitchSettingsReturn> UpdateNetworkSwitchSettingsAsync(string networkId, UpdateNetworkSwitchSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkSwitchSettingsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the switch stacks in a network
		/// List the switch stacks in a network
		/// GetNetworkSwitchStacks networks/{networkId}/switch/stacks
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSwitchStacksAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stacks";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a stack
		/// Create a stack
		/// CreateNetworkSwitchStack networks/{networkId}/switch/stacks
		/// </summary>
		public async Task CreateNetworkSwitchStackAsync(string networkId, CreateNetworkSwitchStackPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stacks";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a stack
		/// Delete a stack
		/// DeleteNetworkSwitchStack networks/{networkId}/switch/stacks/{switchStackId}
		/// </summary>
		public async Task DeleteNetworkSwitchStackAsync(string networkId, string switchStackId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stacks/"+ (switchStackId==null? "" : System.Uri.EscapeDataString(switchStackId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Show a switch stack
		/// Show a switch stack
		/// GetNetworkSwitchStack networks/{networkId}/switch/stacks/{switchStackId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSwitchStackReturn> GetNetworkSwitchStackAsync(string networkId, string switchStackId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stacks/"+ (switchStackId==null? "" : System.Uri.EscapeDataString(switchStackId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSwitchStackReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add a switch to a stack
		/// Add a switch to a stack
		/// AddNetworkSwitchStack networks/{networkId}/switch/stacks/{switchStackId}/add
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> AddNetworkSwitchStackAsync(string networkId, string switchStackId, AddNetworkSwitchStackPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stacks/"+ (switchStackId==null? "" : System.Uri.EscapeDataString(switchStackId))+"/add";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove a switch from a stack
		/// Remove a switch from a stack
		/// RemoveNetworkSwitchStack networks/{networkId}/switch/stacks/{switchStackId}/remove
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> RemoveNetworkSwitchStackAsync(string networkId, string switchStackId, RemoveNetworkSwitchStackPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stacks/"+ (switchStackId==null? "" : System.Uri.EscapeDataString(switchStackId))+"/remove";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List layer 3 interfaces for a switch stack
		/// List layer 3 interfaces for a switch stack
		/// GetNetworkSwitchStackRoutingInterfaces networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSwitchStackRoutingInterfacesAsync(string networkId, string switchStackId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stacks/"+ (switchStackId==null? "" : System.Uri.EscapeDataString(switchStackId))+"/routing/interfaces";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a layer 3 interface for a switch stack
		/// Create a layer 3 interface for a switch stack
		/// CreateNetworkSwitchStackRoutingInterface networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces
		/// </summary>
		public async Task CreateNetworkSwitchStackRoutingInterfaceAsync(string networkId, string switchStackId, CreateNetworkSwitchStackRoutingInterfacePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stacks/"+ (switchStackId==null? "" : System.Uri.EscapeDataString(switchStackId))+"/routing/interfaces";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a layer 3 interface from a switch stack
		/// Delete a layer 3 interface from a switch stack
		/// DeleteNetworkSwitchStackRoutingInterface networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces/{interfaceId}
		/// </summary>
		public async Task DeleteNetworkSwitchStackRoutingInterfaceAsync(string networkId, string switchStackId, string interfaceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stacks/"+ (switchStackId==null? "" : System.Uri.EscapeDataString(switchStackId))+"/routing/interfaces/"+ (interfaceId==null? "" : System.Uri.EscapeDataString(interfaceId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a layer 3 interface from a switch stack
		/// Return a layer 3 interface from a switch stack
		/// GetNetworkSwitchStackRoutingInterface networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces/{interfaceId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSwitchStackRoutingInterfaceAsync(string networkId, string switchStackId, string interfaceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stacks/"+ (switchStackId==null? "" : System.Uri.EscapeDataString(switchStackId))+"/routing/interfaces/"+ (interfaceId==null? "" : System.Uri.EscapeDataString(interfaceId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a layer 3 interface for a switch stack
		/// Update a layer 3 interface for a switch stack
		/// UpdateNetworkSwitchStackRoutingInterface networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces/{interfaceId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchStackRoutingInterfaceAsync(string networkId, string switchStackId, string interfaceId, UpdateNetworkSwitchStackRoutingInterfacePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stacks/"+ (switchStackId==null? "" : System.Uri.EscapeDataString(switchStackId))+"/routing/interfaces/"+ (interfaceId==null? "" : System.Uri.EscapeDataString(interfaceId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a layer 3 interface DHCP configuration for a switch stack
		/// Return a layer 3 interface DHCP configuration for a switch stack
		/// GetNetworkSwitchStackRoutingInterfaceDhcp networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces/{interfaceId}/dhcp
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSwitchStackRoutingInterfaceDhcpAsync(string networkId, string switchStackId, string interfaceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stacks/"+ (switchStackId==null? "" : System.Uri.EscapeDataString(switchStackId))+"/routing/interfaces/"+ (interfaceId==null? "" : System.Uri.EscapeDataString(interfaceId))+"/dhcp";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a layer 3 interface DHCP configuration for a switch stack
		/// Update a layer 3 interface DHCP configuration for a switch stack
		/// UpdateNetworkSwitchStackRoutingInterfaceDhcp networks/{networkId}/switch/stacks/{switchStackId}/routing/interfaces/{interfaceId}/dhcp
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchStackRoutingInterfaceDhcpAsync(string networkId, string switchStackId, string interfaceId, UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stacks/"+ (switchStackId==null? "" : System.Uri.EscapeDataString(switchStackId))+"/routing/interfaces/"+ (interfaceId==null? "" : System.Uri.EscapeDataString(interfaceId))+"/dhcp";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List layer 3 static routes for a switch stack
		/// List layer 3 static routes for a switch stack
		/// GetNetworkSwitchStackRoutingStaticRoutes networks/{networkId}/switch/stacks/{switchStackId}/routing/staticRoutes
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkSwitchStackRoutingStaticRoutesAsync(string networkId, string switchStackId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stacks/"+ (switchStackId==null? "" : System.Uri.EscapeDataString(switchStackId))+"/routing/staticRoutes";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a layer 3 static route for a switch stack
		/// Create a layer 3 static route for a switch stack
		/// CreateNetworkSwitchStackRoutingStaticRoute networks/{networkId}/switch/stacks/{switchStackId}/routing/staticRoutes
		/// </summary>
		public async Task CreateNetworkSwitchStackRoutingStaticRouteAsync(string networkId, string switchStackId, CreateDeviceSwitchRoutingStaticRouteCreatedeviceswitchroutingstaticroute requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stacks/"+ (switchStackId==null? "" : System.Uri.EscapeDataString(switchStackId))+"/routing/staticRoutes";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a layer 3 static route for a switch stack
		/// Delete a layer 3 static route for a switch stack
		/// DeleteNetworkSwitchStackRoutingStaticRoute networks/{networkId}/switch/stacks/{switchStackId}/routing/staticRoutes/{staticRouteId}
		/// </summary>
		public async Task DeleteNetworkSwitchStackRoutingStaticRouteAsync(string networkId, string switchStackId, string staticRouteId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stacks/"+ (switchStackId==null? "" : System.Uri.EscapeDataString(switchStackId))+"/routing/staticRoutes/"+ (staticRouteId==null? "" : System.Uri.EscapeDataString(staticRouteId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a layer 3 static route for a switch stack
		/// Return a layer 3 static route for a switch stack
		/// GetNetworkSwitchStackRoutingStaticRoute networks/{networkId}/switch/stacks/{switchStackId}/routing/staticRoutes/{staticRouteId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSwitchStackRoutingStaticRouteAsync(string networkId, string switchStackId, string staticRouteId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stacks/"+ (switchStackId==null? "" : System.Uri.EscapeDataString(switchStackId))+"/routing/staticRoutes/"+ (staticRouteId==null? "" : System.Uri.EscapeDataString(staticRouteId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a layer 3 static route for a switch stack
		/// Update a layer 3 static route for a switch stack
		/// UpdateNetworkSwitchStackRoutingStaticRoute networks/{networkId}/switch/stacks/{switchStackId}/routing/staticRoutes/{staticRouteId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchStackRoutingStaticRouteAsync(string networkId, string switchStackId, string staticRouteId, UpdateDeviceSwitchRoutingStaticRouteUpdatedeviceswitchroutingstaticroute requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stacks/"+ (switchStackId==null? "" : System.Uri.EscapeDataString(switchStackId))+"/routing/staticRoutes/"+ (staticRouteId==null? "" : System.Uri.EscapeDataString(staticRouteId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the storm control configuration for a switch network
		/// Return the storm control configuration for a switch network
		/// GetNetworkSwitchStormControl networks/{networkId}/switch/stormControl
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSwitchStormControlReturn> GetNetworkSwitchStormControlAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stormControl";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSwitchStormControlReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the storm control configuration for a switch network
		/// Update the storm control configuration for a switch network
		/// UpdateNetworkSwitchStormControl networks/{networkId}/switch/stormControl
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchStormControlAsync(string networkId, UpdateNetworkSwitchStormControlPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stormControl";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns STP settings
		/// Returns STP settings
		/// GetNetworkSwitchStp networks/{networkId}/switch/stp
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkSwitchStpAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stp";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates STP settings
		/// Updates STP settings
		/// UpdateNetworkSwitchStp networks/{networkId}/switch/stp
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkSwitchStpAsync(string networkId, UpdateNetworkSwitchStpPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/switch/stp";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the syslog servers for a network
		/// List the syslog servers for a network
		/// GetNetworkSyslogServers networks/{networkId}/syslogServers
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkSyslogServersReturn> GetNetworkSyslogServersAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/syslogServers";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkSyslogServersReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the syslog servers for a network
		/// Update the syslog servers for a network
		/// UpdateNetworkSyslogServers networks/{networkId}/syslogServers
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkSyslogServersReturn> UpdateNetworkSyslogServersAsync(string networkId, UpdateNetworkSyslogServersPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/syslogServers";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkSyslogServersReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the LLDP and CDP information for all discovered devices and connections in a network.
		/// List the LLDP and CDP information for all discovered devices and connections in a network.
		/// GetNetworkTopologyLinkLayer networks/{networkId}/topology/linkLayer
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkTopologyLinkLayerAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/topology/linkLayer";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the traffic analysis data for this network
		/// Return the traffic analysis data for this network. Traffic analysis with hostname visibility must be enabled on the network.
		/// GetNetworkTraffic networks/{networkId}/traffic
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 30 days from today.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days.</param>
		/// <param name="deviceType">Filter the data by device type: 'combined', 'wireless', 'switch' or 'appliance'. Defaults to 'combined'. When using 'combined', for each rule the data will come from the device type with the most usage.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkTrafficAsync(string networkId, string t0, float timespan, GetNetworkTrafficDeviceType deviceType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/traffic&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&timespan="+timespan+"&deviceType=" + deviceType;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the traffic analysis settings for a network
		/// Return the traffic analysis settings for a network
		/// GetNetworkTrafficAnalysis networks/{networkId}/trafficAnalysis
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkTrafficAnalysisAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/trafficAnalysis";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the traffic analysis settings for a network
		/// Update the traffic analysis settings for a network
		/// UpdateNetworkTrafficAnalysis networks/{networkId}/trafficAnalysis
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkTrafficAnalysisAsync(string networkId, UpdateNetworkTrafficAnalysisPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/trafficAnalysis";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns the application categories for traffic shaping rules.
		/// Returns the application categories for traffic shaping rules.
		/// GetNetworkTrafficShapingApplicationCategories networks/{networkId}/trafficShaping/applicationCategories
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkTrafficShapingApplicationCategoriesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/trafficShaping/applicationCategories";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns the available DSCP tagging options for your traffic shaping rules.
		/// Returns the available DSCP tagging options for your traffic shaping rules.
		/// GetNetworkTrafficShapingDscpTaggingOptions networks/{networkId}/trafficShaping/dscpTaggingOptions
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkTrafficShapingDscpTaggingOptionsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/trafficShaping/dscpTaggingOptions";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Unbind a network from a template.
		/// Unbind a network from a template.
		/// UnbindNetwork networks/{networkId}/unbind
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UnbindNetworkReturn> UnbindNetworkAsync(string networkId, UnbindNetworkPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/unbind";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UnbindNetworkReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the HTTP servers for a network
		/// List the HTTP servers for a network
		/// GetNetworkWebhooksHttpServers networks/{networkId}/webhooks/httpServers
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWebhooksHttpServersReturn[]> GetNetworkWebhooksHttpServersAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/webhooks/httpServers";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWebhooksHttpServersReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add an HTTP server to a network
		/// Add an HTTP server to a network
		/// CreateNetworkWebhooksHttpServer networks/{networkId}/webhooks/httpServers
		/// </summary>
		public async Task CreateNetworkWebhooksHttpServerAsync(string networkId, CreateNetworkWebhooksHttpServerPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/webhooks/httpServers";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete an HTTP server from a network
		/// Delete an HTTP server from a network
		/// DeleteNetworkWebhooksHttpServer networks/{networkId}/webhooks/httpServers/{httpServerId}
		/// </summary>
		public async Task DeleteNetworkWebhooksHttpServerAsync(string networkId, string httpServerId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/webhooks/httpServers/"+ (httpServerId==null? "" : System.Uri.EscapeDataString(httpServerId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return an HTTP server for a network
		/// Return an HTTP server for a network
		/// GetNetworkWebhooksHttpServer networks/{networkId}/webhooks/httpServers/{httpServerId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWebhooksHttpServerReturn> GetNetworkWebhooksHttpServerAsync(string networkId, string httpServerId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/webhooks/httpServers/"+ (httpServerId==null? "" : System.Uri.EscapeDataString(httpServerId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWebhooksHttpServerReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update an HTTP server
		/// Update an HTTP server. To change a URL, create a new HTTP server.
		/// UpdateNetworkWebhooksHttpServer networks/{networkId}/webhooks/httpServers/{httpServerId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkWebhooksHttpServerReturn> UpdateNetworkWebhooksHttpServerAsync(string networkId, string httpServerId, UpdateNetworkWebhooksHttpServerPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/webhooks/httpServers/"+ (httpServerId==null? "" : System.Uri.EscapeDataString(httpServerId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkWebhooksHttpServerReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the webhook payload templates for a network
		/// List the webhook payload templates for a network
		/// GetNetworkWebhooksPayloadTemplates networks/{networkId}/webhooks/payloadTemplates
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWebhooksPayloadTemplatesReturn[]> GetNetworkWebhooksPayloadTemplatesAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/webhooks/payloadTemplates";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWebhooksPayloadTemplatesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a webhook payload template for a network
		/// Create a webhook payload template for a network
		/// CreateNetworkWebhooksPayloadTemplate networks/{networkId}/webhooks/payloadTemplates
		/// </summary>
		public async Task CreateNetworkWebhooksPayloadTemplateAsync(string networkId, CreateNetworkWebhooksPayloadTemplatePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/webhooks/payloadTemplates";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Destroy a webhook payload template for a network
		/// Destroy a webhook payload template for a network. Does not work for included templates ('wpt_00001', 'wpt_00002', 'wpt_00003', 'wpt_00004', 'wpt_00005' or 'wpt_00006')
		/// DeleteNetworkWebhooksPayloadTemplate networks/{networkId}/webhooks/payloadTemplates/{payloadTemplateId}
		/// </summary>
		public async Task DeleteNetworkWebhooksPayloadTemplateAsync(string networkId, string payloadTemplateId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/webhooks/payloadTemplates/"+ (payloadTemplateId==null? "" : System.Uri.EscapeDataString(payloadTemplateId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get the webhook payload template for a network
		/// Get the webhook payload template for a network
		/// GetNetworkWebhooksPayloadTemplate networks/{networkId}/webhooks/payloadTemplates/{payloadTemplateId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWebhooksPayloadTemplateReturn> GetNetworkWebhooksPayloadTemplateAsync(string networkId, string payloadTemplateId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/webhooks/payloadTemplates/"+ (payloadTemplateId==null? "" : System.Uri.EscapeDataString(payloadTemplateId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWebhooksPayloadTemplateReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a webhook payload template for a network
		/// Update a webhook payload template for a network
		/// UpdateNetworkWebhooksPayloadTemplate networks/{networkId}/webhooks/payloadTemplates/{payloadTemplateId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkWebhooksPayloadTemplateReturn> UpdateNetworkWebhooksPayloadTemplateAsync(string networkId, string payloadTemplateId, UpdateNetworkWebhooksPayloadTemplatePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/webhooks/payloadTemplates/"+ (payloadTemplateId==null? "" : System.Uri.EscapeDataString(payloadTemplateId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkWebhooksPayloadTemplateReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Send a test webhook for a network
		/// Send a test webhook for a network
		/// CreateNetworkWebhooksWebhookTest networks/{networkId}/webhooks/webhookTests
		/// </summary>
		public async Task CreateNetworkWebhooksWebhookTestAsync(string networkId, CreateNetworkWebhooksWebhookTestPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/webhooks/webhookTests";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the status of a webhook test for a network
		/// Return the status of a webhook test for a network
		/// GetNetworkWebhooksWebhookTest networks/{networkId}/webhooks/webhookTests/{webhookTestId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWebhooksWebhookTestReturn> GetNetworkWebhooksWebhookTestAsync(string networkId, string webhookTestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/webhooks/webhookTests/"+ (webhookTestId==null? "" : System.Uri.EscapeDataString(webhookTestId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWebhooksWebhookTestReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List Air Marshal scan results from a network
		/// List Air Marshal scan results from a network
		/// GetNetworkWirelessAirMarshal networks/{networkId}/wireless/airMarshal
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkWirelessAirMarshalAsync(string networkId, string t0, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/airMarshal&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&timespan="+timespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return alternate management interface and devices with IP assigned
		/// Return alternate management interface and devices with IP assigned
		/// GetNetworkWirelessAlternateManagementInterface networks/{networkId}/wireless/alternateManagementInterface
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkWirelessAlternateManagementInterfaceAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/alternateManagementInterface";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update alternate management interface and device static IP
		/// Update alternate management interface and device static IP
		/// UpdateNetworkWirelessAlternateManagementInterface networks/{networkId}/wireless/alternateManagementInterface
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkWirelessAlternateManagementInterfaceAsync(string networkId, UpdateNetworkWirelessAlternateManagementInterfacePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/alternateManagementInterface";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the billing settings of this network
		/// Return the billing settings of this network
		/// GetNetworkWirelessBilling networks/{networkId}/wireless/billing
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkWirelessBillingAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/billing";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the billing settings
		/// Update the billing settings
		/// UpdateNetworkWirelessBilling networks/{networkId}/wireless/billing
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkWirelessBillingAsync(string networkId, UpdateNetworkWirelessBillingPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/billing";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the Bluetooth settings for a network. <a href="https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)">Bluetooth settings</a> must be enabled on the network.
		/// Return the Bluetooth settings for a network. <a href="https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)">Bluetooth settings</a> must be enabled on the network.
		/// GetNetworkWirelessBluetoothSettings networks/{networkId}/wireless/bluetooth/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWirelessBluetoothSettingsReturn> GetNetworkWirelessBluetoothSettingsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/bluetooth/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWirelessBluetoothSettingsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the Bluetooth settings for a network
		/// Update the Bluetooth settings for a network. See the docs page for <a href="https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)">Bluetooth settings</a>.
		/// UpdateNetworkWirelessBluetoothSettings networks/{networkId}/wireless/bluetooth/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkWirelessBluetoothSettingsReturn> UpdateNetworkWirelessBluetoothSettingsAsync(string networkId, UpdateNetworkWirelessBluetoothSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/bluetooth/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkWirelessBluetoothSettingsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return AP channel utilization over time for a device or network client
		/// Return AP channel utilization over time for a device or network client
		/// GetNetworkWirelessChannelUtilizationHistory networks/{networkId}/wireless/channelUtilizationHistory
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.</param>
		/// <param name="resolution">The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400.</param>
		/// <param name="autoResolution">Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.</param>
		/// <param name="clientId">Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client's connection history.</param>
		/// <param name="deviceSerial">Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified.</param>
		/// <param name="apTag">Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified.</param>
		/// <param name="band">Filter results by band (either '2.4', '5' or '6').</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWirelessChannelUtilizationHistoryReturn[]> GetNetworkWirelessChannelUtilizationHistoryAsync(string networkId, string t0, string t1, float timespan, int resolution, bool autoResolution, string clientId, string deviceSerial, string apTag, GetNetworkWirelessChannelUtilizationHistoryBand band, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/channelUtilizationHistory&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&resolution="+resolution+"&autoResolution="+autoResolution+"&clientId=" + (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"&deviceSerial=" + (deviceSerial==null? "" : System.Uri.EscapeDataString(deviceSerial))+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag))+"&band=" + band;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWirelessChannelUtilizationHistoryReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return wireless client counts over time for a network, device, or network client
		/// Return wireless client counts over time for a network, device, or network client
		/// GetNetworkWirelessClientCountHistory networks/{networkId}/wireless/clientCountHistory
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.</param>
		/// <param name="resolution">The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.</param>
		/// <param name="autoResolution">Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.</param>
		/// <param name="clientId">Filter results by network client to return per-device client counts over time inner joined by the queried client's connection history.</param>
		/// <param name="deviceSerial">Filter results by device.</param>
		/// <param name="apTag">Filter results by AP tag.</param>
		/// <param name="band">Filter results by band (either '2.4', '5' or '6').</param>
		/// <param name="ssid">Filter results by SSID number.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWirelessClientCountHistoryReturn[]> GetNetworkWirelessClientCountHistoryAsync(string networkId, string t0, string t1, float timespan, int resolution, bool autoResolution, string clientId, string deviceSerial, string apTag, GetNetworkWirelessClientCountHistoryBand band, int ssid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/clientCountHistory&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&resolution="+resolution+"&autoResolution="+autoResolution+"&clientId=" + (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"&deviceSerial=" + (deviceSerial==null? "" : System.Uri.EscapeDataString(deviceSerial))+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag))+"&band=" + band+"&ssid="+ssid;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWirelessClientCountHistoryReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Aggregated connectivity info for this network, grouped by clients
		/// Aggregated connectivity info for this network, grouped by clients
		/// GetNetworkWirelessClientsConnectionStats networks/{networkId}/wireless/clients/connectionStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkWirelessClientsConnectionStatsAsync(string networkId, string t0, string t1, float timespan, GetNetworkWirelessClientsConnectionStatsBand band, int ssid, int vlan, string apTag, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/clients/connectionStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Aggregated latency info for this network, grouped by clients
		/// Aggregated latency info for this network, grouped by clients
		/// GetNetworkWirelessClientsLatencyStats networks/{networkId}/wireless/clients/latencyStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <param name="fields">Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkWirelessClientsLatencyStatsAsync(string networkId, string t0, string t1, float timespan, GetNetworkWirelessClientsLatencyStatsBand band, int ssid, int vlan, string apTag, string fields, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/clients/latencyStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag))+"&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Aggregated connectivity info for a given client on this network
		/// Aggregated connectivity info for a given client on this network. Clients are identified by their MAC.
		/// GetNetworkWirelessClientConnectionStats networks/{networkId}/wireless/clients/{clientId}/connectionStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkWirelessClientConnectionStatsAsync(string networkId, string clientId, string t0, string t1, float timespan, GetNetworkWirelessClientConnectionStatsBand band, int ssid, int vlan, string apTag, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/connectionStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the wireless connectivity events for a client within a network in the timespan.
		/// List the wireless connectivity events for a client within a network in the timespan.
		/// GetNetworkWirelessClientConnectivityEvents networks/{networkId}/wireless/clients/{clientId}/connectivityEvents
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <param name="types">A list of event types to include. If not specified, events of all types will be returned. Valid types are 'assoc', 'disassoc', 'auth', 'deauth', 'dns', 'dhcp', 'roam', 'connection' and/or 'sticky'.</param>
		/// <param name="includedSeverities">A list of severities to include. If not specified, events of all severities will be returned. Valid severities are 'good', 'info', 'warn' and/or 'bad'.</param>
		/// <param name="band">Filter results by band (either '2.4', '5', '6').</param>
		/// <param name="ssidNumber">An SSID number to include. If not specified, events for all SSIDs will be returned.</param>
		/// <param name="deviceSerial">Filter results by an AP's serial number.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkWirelessClientConnectivityEventsAsync(string networkId, string clientId, int perPage, string startingAfter, string endingBefore, string t0, string t1, float timespan, string[] types, string[] includedSeverities, GetNetworkWirelessClientConnectivityEventsBand band, GetNetworkWirelessClientConnectivityEventsSsidNumber ssidNumber, string deviceSerial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/connectivityEvents&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&"+string.Join("&", types.Select(z => $"types={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", includedSeverities.Select(z => $"includedSeverities={System.Uri.EscapeDataString(z.ToString())}"))+"&band=" + band+"&ssidNumber="+ssidNumber+"&deviceSerial=" + (deviceSerial==null? "" : System.Uri.EscapeDataString(deviceSerial));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the latency history for a client
		/// Return the latency history for a client. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP. The latency data is from a sample of 2% of packets and is grouped into 4 traffic categories: background, best effort, video, voice. Within these categories the sampled packet counters are bucketed by latency in milliseconds.
		/// GetNetworkWirelessClientLatencyHistory networks/{networkId}/wireless/clients/{clientId}/latencyHistory
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 791 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 791 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day.</param>
		/// <param name="resolution">The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkWirelessClientLatencyHistoryAsync(string networkId, string clientId, string t0, string t1, float timespan, int resolution, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/latencyHistory&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&resolution="+resolution;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Aggregated latency info for a given client on this network
		/// Aggregated latency info for a given client on this network. Clients are identified by their MAC.
		/// GetNetworkWirelessClientLatencyStats networks/{networkId}/wireless/clients/{clientId}/latencyStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <param name="fields">Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkWirelessClientLatencyStatsAsync(string networkId, string clientId, string t0, string t1, float timespan, GetNetworkWirelessClientLatencyStatsBand band, int ssid, int vlan, string apTag, string fields, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/clients/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/latencyStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag))+"&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Aggregated connectivity info for this network
		/// Aggregated connectivity info for this network
		/// GetNetworkWirelessConnectionStats networks/{networkId}/wireless/connectionStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWirelessConnectionStatsReturn> GetNetworkWirelessConnectionStatsAsync(string networkId, string t0, string t1, float timespan, GetNetworkWirelessConnectionStatsBand band, int ssid, int vlan, string apTag, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/connectionStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWirelessConnectionStatsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return PHY data rates over time for a network, device, or network client
		/// Return PHY data rates over time for a network, device, or network client
		/// GetNetworkWirelessDataRateHistory networks/{networkId}/wireless/dataRateHistory
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.</param>
		/// <param name="resolution">The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.</param>
		/// <param name="autoResolution">Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.</param>
		/// <param name="clientId">Filter results by network client.</param>
		/// <param name="deviceSerial">Filter results by device.</param>
		/// <param name="apTag">Filter results by AP tag.</param>
		/// <param name="band">Filter results by band (either '2.4', '5' or '6').</param>
		/// <param name="ssid">Filter results by SSID number.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWirelessDataRateHistoryReturn[]> GetNetworkWirelessDataRateHistoryAsync(string networkId, string t0, string t1, float timespan, int resolution, bool autoResolution, string clientId, string deviceSerial, string apTag, GetNetworkWirelessDataRateHistoryBand band, int ssid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/dataRateHistory&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&resolution="+resolution+"&autoResolution="+autoResolution+"&clientId=" + (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"&deviceSerial=" + (deviceSerial==null? "" : System.Uri.EscapeDataString(deviceSerial))+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag))+"&band=" + band+"&ssid="+ssid;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWirelessDataRateHistoryReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Aggregated connectivity info for this network, grouped by node
		/// Aggregated connectivity info for this network, grouped by node
		/// GetNetworkWirelessDevicesConnectionStats networks/{networkId}/wireless/devices/connectionStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWirelessDevicesConnectionStatsReturn[]> GetNetworkWirelessDevicesConnectionStatsAsync(string networkId, string t0, string t1, float timespan, GetNetworkWirelessDevicesConnectionStatsBand band, int ssid, int vlan, string apTag, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/devices/connectionStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWirelessDevicesConnectionStatsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Aggregated latency info for this network, grouped by node
		/// Aggregated latency info for this network, grouped by node
		/// GetNetworkWirelessDevicesLatencyStats networks/{networkId}/wireless/devices/latencyStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <param name="fields">Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkWirelessDevicesLatencyStatsAsync(string networkId, string t0, string t1, float timespan, GetNetworkWirelessDevicesLatencyStatsBand band, int ssid, int vlan, string apTag, string fields, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/devices/latencyStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag))+"&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List of all failed client connection events on this network in a given time range
		/// List of all failed client connection events on this network in a given time range
		/// GetNetworkWirelessFailedConnections networks/{networkId}/wireless/failedConnections
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <param name="serial">Filter by AP</param>
		/// <param name="clientId">Filter by client MAC</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWirelessFailedConnectionsReturn[]> GetNetworkWirelessFailedConnectionsAsync(string networkId, string t0, string t1, float timespan, GetNetworkWirelessFailedConnectionsBand band, int ssid, int vlan, string apTag, string serial, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/failedConnections&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag))+"&serial=" + (serial==null? "" : System.Uri.EscapeDataString(serial))+"&clientId=" + (clientId==null? "" : System.Uri.EscapeDataString(clientId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWirelessFailedConnectionsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return average wireless latency over time for a network, device, or network client
		/// Return average wireless latency over time for a network, device, or network client
		/// GetNetworkWirelessLatencyHistory networks/{networkId}/wireless/latencyHistory
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.</param>
		/// <param name="resolution">The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.</param>
		/// <param name="autoResolution">Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.</param>
		/// <param name="clientId">Filter results by network client.</param>
		/// <param name="deviceSerial">Filter results by device.</param>
		/// <param name="apTag">Filter results by AP tag.</param>
		/// <param name="band">Filter results by band (either '2.4', '5' or '6').</param>
		/// <param name="ssid">Filter results by SSID number.</param>
		/// <param name="accessCategory">Filter by access category.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWirelessLatencyHistoryReturn[]> GetNetworkWirelessLatencyHistoryAsync(string networkId, string t0, string t1, float timespan, int resolution, bool autoResolution, string clientId, string deviceSerial, string apTag, GetNetworkWirelessLatencyHistoryBand band, int ssid, GetNetworkWirelessLatencyHistoryAccessCategory accessCategory, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/latencyHistory&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&resolution="+resolution+"&autoResolution="+autoResolution+"&clientId=" + (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"&deviceSerial=" + (deviceSerial==null? "" : System.Uri.EscapeDataString(deviceSerial))+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag))+"&band=" + band+"&ssid="+ssid+"&accessCategory=" + accessCategory;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWirelessLatencyHistoryReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Aggregated latency info for this network
		/// Aggregated latency info for this network
		/// GetNetworkWirelessLatencyStats networks/{networkId}/wireless/latencyStats
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 180 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.</param>
		/// <param name="band">Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.</param>
		/// <param name="ssid">Filter results by SSID</param>
		/// <param name="vlan">Filter results by VLAN</param>
		/// <param name="apTag">Filter results by AP Tag</param>
		/// <param name="fields">Partial selection: If present, this call will return only the selected fields of ["rawDistribution", "avg"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkWirelessLatencyStatsAsync(string networkId, string t0, string t1, float timespan, GetNetworkWirelessLatencyStatsBand band, int ssid, int vlan, string apTag, string fields, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/latencyStats&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&band=" + band+"&ssid="+ssid+"&vlan="+vlan+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag))+"&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List wireless mesh statuses for repeaters
		/// List wireless mesh statuses for repeaters
		/// GetNetworkWirelessMeshStatuses networks/{networkId}/wireless/meshStatuses
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 500. Default is 50.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkWirelessMeshStatusesAsync(string networkId, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/meshStatuses&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the non-basic RF profiles for this network
		/// List the non-basic RF profiles for this network
		/// GetNetworkWirelessRfProfiles networks/{networkId}/wireless/rfProfiles
		/// </summary>
		/// <param name="includeTemplateProfiles">If the network is bound to a template, this parameter controls whether or not the non-basic RF profiles defined on the template should be included in the response alongside the non-basic profiles defined on the bound network. Defaults to false.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkWirelessRfProfilesAsync(string networkId, bool includeTemplateProfiles, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/rfProfiles&includeTemplateProfiles="+includeTemplateProfiles;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Creates new RF profile for this network
		/// Creates new RF profile for this network
		/// CreateNetworkWirelessRfProfile networks/{networkId}/wireless/rfProfiles
		/// </summary>
		public async Task CreateNetworkWirelessRfProfileAsync(string networkId, CreateNetworkWirelessRfProfilePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/rfProfiles";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a RF Profile
		/// Delete a RF Profile
		/// DeleteNetworkWirelessRfProfile networks/{networkId}/wireless/rfProfiles/{rfProfileId}
		/// </summary>
		public async Task DeleteNetworkWirelessRfProfileAsync(string networkId, string rfProfileId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/rfProfiles/"+ (rfProfileId==null? "" : System.Uri.EscapeDataString(rfProfileId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a RF profile
		/// Return a RF profile
		/// GetNetworkWirelessRfProfile networks/{networkId}/wireless/rfProfiles/{rfProfileId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkWirelessRfProfileAsync(string networkId, string rfProfileId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/rfProfiles/"+ (rfProfileId==null? "" : System.Uri.EscapeDataString(rfProfileId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates specified RF profile for this network
		/// Updates specified RF profile for this network
		/// UpdateNetworkWirelessRfProfile networks/{networkId}/wireless/rfProfiles/{rfProfileId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkWirelessRfProfileReturn> UpdateNetworkWirelessRfProfileAsync(string networkId, string rfProfileId, UpdateNetworkWirelessRfProfilePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/rfProfiles/"+ (rfProfileId==null? "" : System.Uri.EscapeDataString(rfProfileId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkWirelessRfProfileReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the wireless settings for a network
		/// Return the wireless settings for a network
		/// GetNetworkWirelessSettings networks/{networkId}/wireless/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWirelessSettingsReturn> GetNetworkWirelessSettingsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWirelessSettingsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the wireless settings for a network
		/// Update the wireless settings for a network
		/// UpdateNetworkWirelessSettings networks/{networkId}/wireless/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkWirelessSettingsReturn> UpdateNetworkWirelessSettingsAsync(string networkId, UpdateNetworkWirelessSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkWirelessSettingsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return signal quality (SNR/RSSI) over time for a device or network client
		/// Return signal quality (SNR/RSSI) over time for a device or network client
		/// GetNetworkWirelessSignalQualityHistory networks/{networkId}/wireless/signalQualityHistory
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.</param>
		/// <param name="resolution">The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.</param>
		/// <param name="autoResolution">Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.</param>
		/// <param name="clientId">Filter results by network client.</param>
		/// <param name="deviceSerial">Filter results by device.</param>
		/// <param name="apTag">Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.</param>
		/// <param name="band">Filter results by band (either '2.4', '5' or '6').</param>
		/// <param name="ssid">Filter results by SSID number.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWirelessSignalQualityHistoryReturn[]> GetNetworkWirelessSignalQualityHistoryAsync(string networkId, string t0, string t1, float timespan, int resolution, bool autoResolution, string clientId, string deviceSerial, string apTag, GetNetworkWirelessSignalQualityHistoryBand band, int ssid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/signalQualityHistory&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&resolution="+resolution+"&autoResolution="+autoResolution+"&clientId=" + (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"&deviceSerial=" + (deviceSerial==null? "" : System.Uri.EscapeDataString(deviceSerial))+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag))+"&band=" + band+"&ssid="+ssid;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWirelessSignalQualityHistoryReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the MR SSIDs in a network
		/// List the MR SSIDs in a network
		/// GetNetworkWirelessSsids networks/{networkId}/wireless/ssids
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetNetworkWirelessSsidsAsync(string networkId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a single MR SSID
		/// Return a single MR SSID
		/// GetNetworkWirelessSsid networks/{networkId}/wireless/ssids/{number}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkWirelessSsidAsync(string networkId, string number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the attributes of an MR SSID
		/// Update the attributes of an MR SSID
		/// UpdateNetworkWirelessSsid networks/{networkId}/wireless/ssids/{number}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkWirelessSsidAsync(string networkId, string number, UpdateNetworkWirelessSsidPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the Bonjour forwarding setting and rules for the SSID
		/// List the Bonjour forwarding setting and rules for the SSID
		/// GetNetworkWirelessSsidBonjourForwarding networks/{networkId}/wireless/ssids/{number}/bonjourForwarding
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkWirelessSsidBonjourForwardingAsync(string networkId, string number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/bonjourForwarding";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the bonjour forwarding setting and rules for the SSID
		/// Update the bonjour forwarding setting and rules for the SSID
		/// UpdateNetworkWirelessSsidBonjourForwarding networks/{networkId}/wireless/ssids/{number}/bonjourForwarding
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkWirelessSsidBonjourForwardingAsync(string networkId, string number, UpdateNetworkWirelessSsidBonjourForwardingPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/bonjourForwarding";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the device type group policies for the SSID
		/// List the device type group policies for the SSID
		/// GetNetworkWirelessSsidDeviceTypeGroupPolicies networks/{networkId}/wireless/ssids/{number}/deviceTypeGroupPolicies
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkWirelessSsidDeviceTypeGroupPoliciesAsync(string networkId, string number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/deviceTypeGroupPolicies";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the device type group policies for the SSID
		/// Update the device type group policies for the SSID
		/// UpdateNetworkWirelessSsidDeviceTypeGroupPolicies networks/{networkId}/wireless/ssids/{number}/deviceTypeGroupPolicies
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesAsync(string networkId, string number, UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/deviceTypeGroupPolicies";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the EAP overridden parameters for an SSID
		/// Return the EAP overridden parameters for an SSID
		/// GetNetworkWirelessSsidEapOverride networks/{networkId}/wireless/ssids/{number}/eapOverride
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWirelessSsidEapOverrideReturn> GetNetworkWirelessSsidEapOverrideAsync(string networkId, string number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/eapOverride";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWirelessSsidEapOverrideReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the EAP overridden parameters for an SSID.
		/// Update the EAP overridden parameters for an SSID.
		/// UpdateNetworkWirelessSsidEapOverride networks/{networkId}/wireless/ssids/{number}/eapOverride
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkWirelessSsidEapOverrideReturn> UpdateNetworkWirelessSsidEapOverrideAsync(string networkId, string number, UpdateNetworkWirelessSsidEapOverridePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/eapOverride";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkWirelessSsidEapOverrideReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the L3 firewall rules for an SSID on an MR network
		/// Return the L3 firewall rules for an SSID on an MR network
		/// GetNetworkWirelessSsidFirewallL3FirewallRules networks/{networkId}/wireless/ssids/{number}/firewall/l3FirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkWirelessSsidFirewallL3FirewallRulesAsync(string networkId, string number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/firewall/l3FirewallRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the L3 firewall rules of an SSID on an MR network
		/// Update the L3 firewall rules of an SSID on an MR network
		/// UpdateNetworkWirelessSsidFirewallL3FirewallRules networks/{networkId}/wireless/ssids/{number}/firewall/l3FirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkWirelessSsidFirewallL3FirewallRulesAsync(string networkId, string number, UpdateNetworkWirelessSsidFirewallL3FirewallRulesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/firewall/l3FirewallRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the L7 firewall rules for an SSID on an MR network
		/// Return the L7 firewall rules for an SSID on an MR network
		/// GetNetworkWirelessSsidFirewallL7FirewallRules networks/{networkId}/wireless/ssids/{number}/firewall/l7FirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkWirelessSsidFirewallL7FirewallRulesAsync(string networkId, string number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/firewall/l7FirewallRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the L7 firewall rules of an SSID on an MR network
		/// Update the L7 firewall rules of an SSID on an MR network
		/// UpdateNetworkWirelessSsidFirewallL7FirewallRules networks/{networkId}/wireless/ssids/{number}/firewall/l7FirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkWirelessSsidFirewallL7FirewallRulesAsync(string networkId, string number, UpdateNetworkWirelessSsidFirewallL7FirewallRulesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/firewall/l7FirewallRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the Hotspot 2.0 settings for an SSID
		/// Return the Hotspot 2.0 settings for an SSID
		/// GetNetworkWirelessSsidHotspot20 networks/{networkId}/wireless/ssids/{number}/hotspot20
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkWirelessSsidHotspot20Async(string networkId, string number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/hotspot20";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the Hotspot 2.0 settings of an SSID
		/// Update the Hotspot 2.0 settings of an SSID
		/// UpdateNetworkWirelessSsidHotspot20 networks/{networkId}/wireless/ssids/{number}/hotspot20
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkWirelessSsidHotspot20Async(string networkId, string number, UpdateNetworkWirelessSsidHotspot20PutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/hotspot20";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List all Identity PSKs in a wireless network
		/// List all Identity PSKs in a wireless network
		/// GetNetworkWirelessSsidIdentityPsks networks/{networkId}/wireless/ssids/{number}/identityPsks
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWirelessSsidIdentityPsksReturn[]> GetNetworkWirelessSsidIdentityPsksAsync(string networkId, string number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/identityPsks";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWirelessSsidIdentityPsksReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create an Identity PSK
		/// Create an Identity PSK
		/// CreateNetworkWirelessSsidIdentityPsk networks/{networkId}/wireless/ssids/{number}/identityPsks
		/// </summary>
		public async Task CreateNetworkWirelessSsidIdentityPskAsync(string networkId, string number, CreateNetworkWirelessSsidIdentityPskPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/identityPsks";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete an Identity PSK
		/// Delete an Identity PSK
		/// DeleteNetworkWirelessSsidIdentityPsk networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}
		/// </summary>
		public async Task DeleteNetworkWirelessSsidIdentityPskAsync(string networkId, string number, string identityPskId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/identityPsks/"+ (identityPskId==null? "" : System.Uri.EscapeDataString(identityPskId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return an Identity PSK
		/// Return an Identity PSK
		/// GetNetworkWirelessSsidIdentityPsk networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWirelessSsidIdentityPskReturn> GetNetworkWirelessSsidIdentityPskAsync(string networkId, string number, string identityPskId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/identityPsks/"+ (identityPskId==null? "" : System.Uri.EscapeDataString(identityPskId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWirelessSsidIdentityPskReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update an Identity PSK
		/// Update an Identity PSK
		/// UpdateNetworkWirelessSsidIdentityPsk networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkWirelessSsidIdentityPskAsync(string networkId, string number, string identityPskId, UpdateNetworkWirelessSsidIdentityPskPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/identityPsks/"+ (identityPskId==null? "" : System.Uri.EscapeDataString(identityPskId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the outage schedule for the SSID
		/// List the outage schedule for the SSID
		/// GetNetworkWirelessSsidSchedules networks/{networkId}/wireless/ssids/{number}/schedules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkWirelessSsidSchedulesAsync(string networkId, string number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/schedules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the outage schedule for the SSID
		/// Update the outage schedule for the SSID
		/// UpdateNetworkWirelessSsidSchedules networks/{networkId}/wireless/ssids/{number}/schedules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkWirelessSsidSchedulesAsync(string networkId, string number, UpdateNetworkWirelessSsidSchedulesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/schedules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Display the splash page settings for the given SSID
		/// Display the splash page settings for the given SSID
		/// GetNetworkWirelessSsidSplashSettings networks/{networkId}/wireless/ssids/{number}/splash/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWirelessSsidSplashSettingsReturn> GetNetworkWirelessSsidSplashSettingsAsync(string networkId, string number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/splash/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWirelessSsidSplashSettingsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Modify the splash page settings for the given SSID
		/// Modify the splash page settings for the given SSID
		/// UpdateNetworkWirelessSsidSplashSettings networks/{networkId}/wireless/ssids/{number}/splash/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateNetworkWirelessSsidSplashSettingsReturn> UpdateNetworkWirelessSsidSplashSettingsAsync(string networkId, string number, UpdateNetworkWirelessSsidSplashSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/splash/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateNetworkWirelessSsidSplashSettingsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Display the traffic shaping settings for a SSID on an MR network
		/// Display the traffic shaping settings for a SSID on an MR network
		/// GetNetworkWirelessSsidTrafficShapingRules networks/{networkId}/wireless/ssids/{number}/trafficShaping/rules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkWirelessSsidTrafficShapingRulesAsync(string networkId, string number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/trafficShaping/rules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the traffic shaping settings for an SSID on an MR network
		/// Update the traffic shaping settings for an SSID on an MR network
		/// UpdateNetworkWirelessSsidTrafficShapingRules networks/{networkId}/wireless/ssids/{number}/trafficShaping/rules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkWirelessSsidTrafficShapingRulesAsync(string networkId, string number, UpdateNetworkWirelessSsidTrafficShapingRulesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/trafficShaping/rules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the VPN settings for the SSID.
		/// List the VPN settings for the SSID.
		/// GetNetworkWirelessSsidVpn networks/{networkId}/wireless/ssids/{number}/vpn
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetNetworkWirelessSsidVpnAsync(string networkId, string number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/vpn";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the VPN settings for the SSID
		/// Update the VPN settings for the SSID
		/// UpdateNetworkWirelessSsidVpn networks/{networkId}/wireless/ssids/{number}/vpn
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateNetworkWirelessSsidVpnAsync(string networkId, string number, UpdateNetworkWirelessSsidVpnPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/ssids/"+ (number==null? "" : System.Uri.EscapeDataString(number))+"/vpn";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return AP usage over time for a device or network client
		/// Return AP usage over time for a device or network client
		/// GetNetworkWirelessUsageHistory networks/{networkId}/wireless/usageHistory
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.</param>
		/// <param name="resolution">The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.</param>
		/// <param name="autoResolution">Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.</param>
		/// <param name="clientId">Filter results by network client to return per-device AP usage over time inner joined by the queried client's connection history.</param>
		/// <param name="deviceSerial">Filter results by device. Requires :band.</param>
		/// <param name="apTag">Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.</param>
		/// <param name="band">Filter results by band (either '2.4', '5' or '6').</param>
		/// <param name="ssid">Filter results by SSID number.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetNetworkWirelessUsageHistoryReturn[]> GetNetworkWirelessUsageHistoryAsync(string networkId, string t0, string t1, float timespan, int resolution, bool autoResolution, string clientId, string deviceSerial, string apTag, GetNetworkWirelessUsageHistoryBand band, int ssid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"/wireless/usageHistory&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&resolution="+resolution+"&autoResolution="+autoResolution+"&clientId=" + (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"&deviceSerial=" + (deviceSerial==null? "" : System.Uri.EscapeDataString(deviceSerial))+"&apTag=" + (apTag==null? "" : System.Uri.EscapeDataString(apTag))+"&band=" + band+"&ssid="+ssid;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNetworkWirelessUsageHistoryReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the organizations that the user has privileges on
		/// List the organizations that the user has privileges on
		/// GetOrganizations organizations
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationsReturn[]> GetOrganizationsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a new organization
		/// Create a new organization
		/// CreateOrganization organizations
		/// </summary>
		public async Task CreateOrganizationAsync(CreateOrganizationPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete an organization
		/// Delete an organization
		/// DeleteOrganization organizations/{organizationId}
		/// </summary>
		public async Task DeleteOrganizationAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return an organization
		/// Return an organization
		/// GetOrganization organizations/{organizationId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationReturn> GetOrganizationAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update an organization
		/// Update an organization
		/// UpdateOrganization organizations/{organizationId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateOrganizationReturn> UpdateOrganizationAsync(string organizationId, UpdateOrganizationPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateOrganizationReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the list of action batches in the organization
		/// Return the list of action batches in the organization
		/// GetOrganizationActionBatches organizations/{organizationId}/actionBatches
		/// </summary>
		/// <param name="status">Filter batches by status. Valid types are pending, completed, and failed.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationActionBatchesAsync(string organizationId, GetOrganizationActionBatchesStatus status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/actionBatches&status=" + status;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create an action batch
		/// Create an action batch
		/// CreateOrganizationActionBatch organizations/{organizationId}/actionBatches
		/// </summary>
		public async Task CreateOrganizationActionBatchAsync(string organizationId, CreateOrganizationActionBatchPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/actionBatches";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete an action batch
		/// Delete an action batch
		/// DeleteOrganizationActionBatch organizations/{organizationId}/actionBatches/{actionBatchId}
		/// </summary>
		public async Task DeleteOrganizationActionBatchAsync(string organizationId, string actionBatchId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/actionBatches/"+ (actionBatchId==null? "" : System.Uri.EscapeDataString(actionBatchId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return an action batch
		/// Return an action batch
		/// GetOrganizationActionBatch organizations/{organizationId}/actionBatches/{actionBatchId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationActionBatchReturn> GetOrganizationActionBatchAsync(string organizationId, string actionBatchId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/actionBatches/"+ (actionBatchId==null? "" : System.Uri.EscapeDataString(actionBatchId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationActionBatchReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update an action batch
		/// Update an action batch
		/// UpdateOrganizationActionBatch organizations/{organizationId}/actionBatches/{actionBatchId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationActionBatchAsync(string organizationId, string actionBatchId, UpdateOrganizationActionBatchPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/actionBatches/"+ (actionBatchId==null? "" : System.Uri.EscapeDataString(actionBatchId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List adaptive policy ACLs in a organization
		/// List adaptive policy ACLs in a organization
		/// GetOrganizationAdaptivePolicyAcls organizations/{organizationId}/adaptivePolicy/acls
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationAdaptivePolicyAclsAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/adaptivePolicy/acls";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Creates new adaptive policy ACL
		/// Creates new adaptive policy ACL
		/// CreateOrganizationAdaptivePolicyAcl organizations/{organizationId}/adaptivePolicy/acls
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> CreateOrganizationAdaptivePolicyAclAsync(string organizationId, CreateOrganizationAdaptivePolicyAclPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/adaptivePolicy/acls";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Deletes the specified adaptive policy ACL
		/// Deletes the specified adaptive policy ACL. Note this adaptive policy ACL will also be removed from policies using it.
		/// DeleteOrganizationAdaptivePolicyAcl organizations/{organizationId}/adaptivePolicy/acls/{aclId}
		/// </summary>
		public async Task DeleteOrganizationAdaptivePolicyAclAsync(string organizationId, string aclId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/adaptivePolicy/acls/"+ (aclId==null? "" : System.Uri.EscapeDataString(aclId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns the adaptive policy ACL information
		/// Returns the adaptive policy ACL information
		/// GetOrganizationAdaptivePolicyAcl organizations/{organizationId}/adaptivePolicy/acls/{aclId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationAdaptivePolicyAclAsync(string organizationId, string aclId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/adaptivePolicy/acls/"+ (aclId==null? "" : System.Uri.EscapeDataString(aclId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates an adaptive policy ACL
		/// Updates an adaptive policy ACL
		/// UpdateOrganizationAdaptivePolicyAcl organizations/{organizationId}/adaptivePolicy/acls/{aclId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationAdaptivePolicyAclAsync(string organizationId, string aclId, UpdateOrganizationAdaptivePolicyAclPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/adaptivePolicy/acls/"+ (aclId==null? "" : System.Uri.EscapeDataString(aclId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List adaptive policy groups in a organization
		/// List adaptive policy groups in a organization
		/// GetOrganizationAdaptivePolicyGroups organizations/{organizationId}/adaptivePolicy/groups
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationAdaptivePolicyGroupsAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/adaptivePolicy/groups";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Creates a new adaptive policy group
		/// Creates a new adaptive policy group
		/// CreateOrganizationAdaptivePolicyGroup organizations/{organizationId}/adaptivePolicy/groups
		/// </summary>
		public async Task CreateOrganizationAdaptivePolicyGroupAsync(string organizationId, CreateOrganizationAdaptivePolicyGroupPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/adaptivePolicy/groups";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Deletes the specified adaptive policy group and any associated policies and references
		/// Deletes the specified adaptive policy group and any associated policies and references
		/// DeleteOrganizationAdaptivePolicyGroup organizations/{organizationId}/adaptivePolicy/groups/{id}
		/// </summary>
		public async Task DeleteOrganizationAdaptivePolicyGroupAsync(string organizationId, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/adaptivePolicy/groups/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns an adaptive policy group
		/// Returns an adaptive policy group
		/// GetOrganizationAdaptivePolicyGroup organizations/{organizationId}/adaptivePolicy/groups/{id}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationAdaptivePolicyGroupAsync(string organizationId, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/adaptivePolicy/groups/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates an adaptive policy group
		/// Updates an adaptive policy group. If updating "Infrastructure", only the SGT is allowed. Cannot update "Unknown".
		/// UpdateOrganizationAdaptivePolicyGroup organizations/{organizationId}/adaptivePolicy/groups/{id}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationAdaptivePolicyGroupAsync(string organizationId, string id, UpdateOrganizationAdaptivePolicyGroupPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/adaptivePolicy/groups/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns adaptive policy aggregate statistics for an organization
		/// Returns adaptive policy aggregate statistics for an organization
		/// GetOrganizationAdaptivePolicyOverview organizations/{organizationId}/adaptivePolicy/overview
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationAdaptivePolicyOverviewReturn> GetOrganizationAdaptivePolicyOverviewAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/adaptivePolicy/overview";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationAdaptivePolicyOverviewReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List adaptive policies in an organization
		/// List adaptive policies in an organization
		/// GetOrganizationAdaptivePolicyPolicies organizations/{organizationId}/adaptivePolicy/policies
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationAdaptivePolicyPoliciesAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/adaptivePolicy/policies";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add an Adaptive Policy
		/// Add an Adaptive Policy
		/// CreateOrganizationAdaptivePolicyPolicy organizations/{organizationId}/adaptivePolicy/policies
		/// </summary>
		public async Task CreateOrganizationAdaptivePolicyPolicyAsync(string organizationId, CreateOrganizationAdaptivePolicyPolicyPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/adaptivePolicy/policies";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete an Adaptive Policy
		/// Delete an Adaptive Policy
		/// DeleteOrganizationAdaptivePolicyPolicy organizations/{organizationId}/adaptivePolicy/policies/{id}
		/// </summary>
		public async Task DeleteOrganizationAdaptivePolicyPolicyAsync(string organizationId, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/adaptivePolicy/policies/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return an adaptive policy
		/// Return an adaptive policy
		/// GetOrganizationAdaptivePolicyPolicy organizations/{organizationId}/adaptivePolicy/policies/{id}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationAdaptivePolicyPolicyAsync(string organizationId, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/adaptivePolicy/policies/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update an Adaptive Policy
		/// Update an Adaptive Policy
		/// UpdateOrganizationAdaptivePolicyPolicy organizations/{organizationId}/adaptivePolicy/policies/{id}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationAdaptivePolicyPolicyAsync(string organizationId, string id, UpdateOrganizationAdaptivePolicyPolicyPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/adaptivePolicy/policies/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns global adaptive policy settings in an organization
		/// Returns global adaptive policy settings in an organization
		/// GetOrganizationAdaptivePolicySettings organizations/{organizationId}/adaptivePolicy/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationAdaptivePolicySettingsAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/adaptivePolicy/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update global adaptive policy settings
		/// Update global adaptive policy settings
		/// UpdateOrganizationAdaptivePolicySettings organizations/{organizationId}/adaptivePolicy/settings
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationAdaptivePolicySettingsAsync(string organizationId, UpdateOrganizationAdaptivePolicySettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/adaptivePolicy/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the dashboard administrators in this organization
		/// List the dashboard administrators in this organization
		/// GetOrganizationAdmins organizations/{organizationId}/admins
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationAdminsAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/admins";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a new dashboard administrator
		/// Create a new dashboard administrator
		/// CreateOrganizationAdmin organizations/{organizationId}/admins
		/// </summary>
		public async Task CreateOrganizationAdminAsync(string organizationId, CreateOrganizationAdminPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/admins";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Revoke all access for a dashboard administrator within this organization
		/// Revoke all access for a dashboard administrator within this organization
		/// DeleteOrganizationAdmin organizations/{organizationId}/admins/{adminId}
		/// </summary>
		public async Task DeleteOrganizationAdminAsync(string organizationId, string adminId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/admins/"+ (adminId==null? "" : System.Uri.EscapeDataString(adminId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update an administrator
		/// Update an administrator
		/// UpdateOrganizationAdmin organizations/{organizationId}/admins/{adminId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationAdminAsync(string organizationId, string adminId, UpdateOrganizationAdminPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/admins/"+ (adminId==null? "" : System.Uri.EscapeDataString(adminId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List all organization-wide alert configurations
		/// List all organization-wide alert configurations
		/// GetOrganizationAlertsProfiles organizations/{organizationId}/alerts/profiles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationAlertsProfilesAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/alerts/profiles";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create an organization-wide alert configuration
		/// Create an organization-wide alert configuration
		/// CreateOrganizationAlertsProfile organizations/{organizationId}/alerts/profiles
		/// </summary>
		public async Task CreateOrganizationAlertsProfileAsync(string organizationId, CreateOrganizationAlertsProfilePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/alerts/profiles";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Removes an organization-wide alert config
		/// Removes an organization-wide alert config
		/// DeleteOrganizationAlertsProfile organizations/{organizationId}/alerts/profiles/{alertConfigId}
		/// </summary>
		public async Task DeleteOrganizationAlertsProfileAsync(string organizationId, string alertConfigId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/alerts/profiles/"+ (alertConfigId==null? "" : System.Uri.EscapeDataString(alertConfigId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update an organization-wide alert config
		/// Update an organization-wide alert config
		/// UpdateOrganizationAlertsProfile organizations/{organizationId}/alerts/profiles/{alertConfigId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationAlertsProfileAsync(string organizationId, string alertConfigId, UpdateOrganizationAlertsProfilePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/alerts/profiles/"+ (alertConfigId==null? "" : System.Uri.EscapeDataString(alertConfigId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the API requests made by an organization
		/// List the API requests made by an organization
		/// GetOrganizationApiRequests organizations/{organizationId}/apiRequests
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="adminId">Filter the results by the ID of the admin who made the API requests</param>
		/// <param name="path">Filter the results by the path of the API requests</param>
		/// <param name="method">Filter the results by the method of the API requests (must be 'GET', 'PUT', 'POST' or 'DELETE')</param>
		/// <param name="responseCode">Filter the results by the response code of the API requests</param>
		/// <param name="sourceIp">Filter the results by the IP address of the originating API request</param>
		/// <param name="userAgent">Filter the results by the user agent string of the API request</param>
		/// <param name="version">Filter the results by the API version of the API request</param>
		/// <param name="operationIds">Filter the results by one or more operation IDs for the API request</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationApiRequestsReturn[]> GetOrganizationApiRequestsAsync(
					string organizationId, 
					string t0, 
					string t1, 
					float timespan, 
					int perPage, 
					string startingAfter, 
					string endingBefore, 
					string adminId, 
					string path, 
					GetOrganizationApiRequestsMethod method, 
					int responseCode, 
					string sourceIp, 
					string userAgent, 
					GetOrganizationApiRequestsVersion version, 
					string[] operationIds, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/apiRequests&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&adminId=" + (adminId==null? "" : System.Uri.EscapeDataString(adminId))+"&path=" + (path==null? "" : System.Uri.EscapeDataString(path))+"&method=" + method+"&responseCode="+responseCode+"&sourceIp=" + (sourceIp==null? "" : System.Uri.EscapeDataString(sourceIp))+"&userAgent=" + (userAgent==null? "" : System.Uri.EscapeDataString(userAgent))+"&version="+version+"&"+string.Join("&", operationIds.Select(z => $"operationIds={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationApiRequestsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return an aggregated overview of API requests data
		/// Return an aggregated overview of API requests data
		/// GetOrganizationApiRequestsOverview organizations/{organizationId}/apiRequests/overview
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days.</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationApiRequestsOverviewAsync(string organizationId, string t0, string t1, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/apiRequests/overview&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Tracks organizations' API requests by response code across a given time period
		/// Tracks organizations' API requests by response code across a given time period
		/// GetOrganizationApiRequestsOverviewResponseCodesByInterval organizations/{organizationId}/apiRequests/overview/responseCodes/byInterval
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days. If interval is provided, the timespan will be autocalculated.</param>
		/// <param name="interval">The time interval in seconds for returned data. The valid intervals are: 120, 3600, 14400, 21600. The default is 21600. Interval is calculated if time params are provided.</param>
		/// <param name="version">Filter by API version of the endpoint. Allowable values are: [0, 1]</param>
		/// <param name="operationIds">Filter by operation ID of the endpoint</param>
		/// <param name="sourceIps">Filter by source IP that made the API request</param>
		/// <param name="adminIds">Filter by admin ID of user that made the API request</param>
		/// <param name="userAgent">Filter by user agent string for API request. This will filter by a complete or partial match.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationApiRequestsOverviewResponseCodesByIntervalReturn[]> GetOrganizationApiRequestsOverviewResponseCodesByIntervalAsync(string organizationId, string t0, string t1, float timespan, int interval, GetOrganizationApiRequestsOverviewResponseCodesByIntervalVersion version, string[] operationIds, string[] sourceIps, string[] adminIds, string userAgent, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/apiRequests/overview/responseCodes/byInterval&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&interval="+interval+"&version="+version+"&"+string.Join("&", operationIds.Select(z => $"operationIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", sourceIps.Select(z => $"sourceIps={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", adminIds.Select(z => $"adminIds={System.Uri.EscapeDataString(z.ToString())}"))+"&userAgent=" + (userAgent==null? "" : System.Uri.EscapeDataString(userAgent));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationApiRequestsOverviewResponseCodesByIntervalReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the security events for an organization
		/// List the security events for an organization
		/// GetOrganizationApplianceSecurityEvents organizations/{organizationId}/appliance/security/events
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 365 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="sortOrder">Sorted order of security events based on event detection time. Order options are 'ascending' or 'descending'. Default is ascending order.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationApplianceSecurityEventsAsync(string organizationId, string t0, string t1, float timespan, int perPage, string startingAfter, string endingBefore, GetNetworkApplianceClientSecurityEventsSortOrder sortOrder, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/appliance/security/events&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&sortOrder=" + sortOrder;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns all supported intrusion settings for an organization
		/// Returns all supported intrusion settings for an organization
		/// GetOrganizationApplianceSecurityIntrusion organizations/{organizationId}/appliance/security/intrusion
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationApplianceSecurityIntrusionAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/appliance/security/intrusion";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Sets supported intrusion settings for an organization
		/// Sets supported intrusion settings for an organization
		/// UpdateOrganizationApplianceSecurityIntrusion organizations/{organizationId}/appliance/security/intrusion
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationApplianceSecurityIntrusionAsync(string organizationId, UpdateOrganizationApplianceSecurityIntrusionPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/appliance/security/intrusion";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the uplink status of every Meraki MX and Z series appliances in the organization
		/// List the uplink status of every Meraki MX and Z series appliances in the organization
		/// GetOrganizationApplianceUplinkStatuses organizations/{organizationId}/appliance/uplink/statuses
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="networkIds">A list of network IDs. The returned devices will be filtered to only include these networks.</param>
		/// <param name="serials">A list of serial numbers. The returned devices will be filtered to only include these serials.</param>
		/// <param name="iccids">A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationApplianceUplinkStatusesAsync(string organizationId, int perPage, string startingAfter, string endingBefore, string[] networkIds, string[] serials, string[] iccids, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/appliance/uplink/statuses&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&"+string.Join("&", networkIds.Select(z => $"networkIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", serials.Select(z => $"serials={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", iccids.Select(z => $"iccids={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Show VPN history stat for networks in an organization
		/// Show VPN history stat for networks in an organization
		/// GetOrganizationApplianceVpnStats organizations/{organizationId}/appliance/vpn/stats
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 300. Default is 300.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="networkIds">A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456</param>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 31 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationApplianceVpnStatsAsync(string organizationId, int perPage, string startingAfter, string endingBefore, string[] networkIds, string t0, string t1, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/appliance/vpn/stats&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&"+string.Join("&", networkIds.Select(z => $"networkIds={System.Uri.EscapeDataString(z.ToString())}"))+"&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Show VPN status for networks in an organization
		/// Show VPN status for networks in an organization
		/// GetOrganizationApplianceVpnStatuses organizations/{organizationId}/appliance/vpn/statuses
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 300. Default is 300.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="networkIds">A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationApplianceVpnStatusesAsync(string organizationId, int perPage, string startingAfter, string endingBefore, string[] networkIds, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/appliance/vpn/statuses&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&"+string.Join("&", networkIds.Select(z => $"networkIds={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the third party VPN peers for an organization
		/// Return the third party VPN peers for an organization
		/// GetOrganizationApplianceVpnThirdPartyVPNPeers organizations/{organizationId}/appliance/vpn/thirdPartyVPNPeers
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationApplianceVpnThirdPartyVPNPeersReturn> GetOrganizationApplianceVpnThirdPartyVPNPeersAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/appliance/vpn/thirdPartyVPNPeers";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationApplianceVpnThirdPartyVPNPeersReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the third party VPN peers for an organization
		/// Update the third party VPN peers for an organization
		/// UpdateOrganizationApplianceVpnThirdPartyVPNPeers organizations/{organizationId}/appliance/vpn/thirdPartyVPNPeers
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturn> UpdateOrganizationApplianceVpnThirdPartyVPNPeersAsync(string organizationId, UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/appliance/vpn/thirdPartyVPNPeers";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the firewall rules for an organization's site-to-site VPN
		/// Return the firewall rules for an organization's site-to-site VPN
		/// GetOrganizationApplianceVpnVpnFirewallRules organizations/{organizationId}/appliance/vpn/vpnFirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationApplianceVpnVpnFirewallRulesAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/appliance/vpn/vpnFirewallRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the firewall rules of an organization's site-to-site VPN
		/// Update the firewall rules of an organization's site-to-site VPN
		/// UpdateOrganizationApplianceVpnVpnFirewallRules organizations/{organizationId}/appliance/vpn/vpnFirewallRules
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationApplianceVpnVpnFirewallRulesAsync(string organizationId, UpdateOrganizationApplianceVpnVpnFirewallRulesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/appliance/vpn/vpnFirewallRules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the branding policies of an organization
		/// List the branding policies of an organization
		/// GetOrganizationBrandingPolicies organizations/{organizationId}/brandingPolicies
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationBrandingPoliciesReturn[]> GetOrganizationBrandingPoliciesAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/brandingPolicies";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationBrandingPoliciesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add a new branding policy to an organization
		/// Add a new branding policy to an organization
		/// CreateOrganizationBrandingPolicy organizations/{organizationId}/brandingPolicies
		/// </summary>
		public async Task CreateOrganizationBrandingPolicyAsync(string organizationId, CreateOrganizationBrandingPolicyPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/brandingPolicies";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the branding policy IDs of an organization in priority order
		/// Return the branding policy IDs of an organization in priority order. IDs are ordered in ascending order of priority (IDs later in the array have higher priority).
		/// GetOrganizationBrandingPoliciesPriorities organizations/{organizationId}/brandingPolicies/priorities
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationBrandingPoliciesPrioritiesReturn> GetOrganizationBrandingPoliciesPrioritiesAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/brandingPolicies/priorities";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationBrandingPoliciesPrioritiesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the priority ordering of an organization's branding policies.
		/// Update the priority ordering of an organization's branding policies.
		/// UpdateOrganizationBrandingPoliciesPriorities organizations/{organizationId}/brandingPolicies/priorities
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateOrganizationBrandingPoliciesPrioritiesReturn> UpdateOrganizationBrandingPoliciesPrioritiesAsync(string organizationId, UpdateOrganizationBrandingPoliciesPrioritiesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/brandingPolicies/priorities";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateOrganizationBrandingPoliciesPrioritiesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a branding policy
		/// Delete a branding policy
		/// DeleteOrganizationBrandingPolicy organizations/{organizationId}/brandingPolicies/{brandingPolicyId}
		/// </summary>
		public async Task DeleteOrganizationBrandingPolicyAsync(string organizationId, string brandingPolicyId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/brandingPolicies/"+ (brandingPolicyId==null? "" : System.Uri.EscapeDataString(brandingPolicyId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a branding policy
		/// Return a branding policy
		/// GetOrganizationBrandingPolicy organizations/{organizationId}/brandingPolicies/{brandingPolicyId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationBrandingPolicyReturn> GetOrganizationBrandingPolicyAsync(string organizationId, string brandingPolicyId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/brandingPolicies/"+ (brandingPolicyId==null? "" : System.Uri.EscapeDataString(brandingPolicyId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationBrandingPolicyReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a branding policy
		/// Update a branding policy
		/// UpdateOrganizationBrandingPolicy organizations/{organizationId}/brandingPolicies/{brandingPolicyId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateOrganizationBrandingPolicyReturn> UpdateOrganizationBrandingPolicyAsync(string organizationId, string brandingPolicyId, UpdateOrganizationBrandingPolicyPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/brandingPolicies/"+ (brandingPolicyId==null? "" : System.Uri.EscapeDataString(brandingPolicyId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateOrganizationBrandingPolicyReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List Custom Analytics Artifacts
		/// List Custom Analytics Artifacts
		/// GetOrganizationCameraCustomAnalyticsArtifacts organizations/{organizationId}/camera/customAnalytics/artifacts
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationCameraCustomAnalyticsArtifactsAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/camera/customAnalytics/artifacts";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create custom analytics artifact
		/// Create custom analytics artifact. Returns an artifact upload URL with expiry time. Upload the artifact file with a put request to the returned upload URL before its expiry.
		/// CreateOrganizationCameraCustomAnalyticsArtifact organizations/{organizationId}/camera/customAnalytics/artifacts
		/// </summary>
		public async Task CreateOrganizationCameraCustomAnalyticsArtifactAsync(string organizationId, CreateOrganizationCameraCustomAnalyticsArtifactPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/camera/customAnalytics/artifacts";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete Custom Analytics Artifact
		/// Delete Custom Analytics Artifact
		/// DeleteOrganizationCameraCustomAnalyticsArtifact organizations/{organizationId}/camera/customAnalytics/artifacts/{artifactId}
		/// </summary>
		public async Task DeleteOrganizationCameraCustomAnalyticsArtifactAsync(string organizationId, string artifactId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/camera/customAnalytics/artifacts/"+ (artifactId==null? "" : System.Uri.EscapeDataString(artifactId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get Custom Analytics Artifact
		/// Get Custom Analytics Artifact
		/// GetOrganizationCameraCustomAnalyticsArtifact organizations/{organizationId}/camera/customAnalytics/artifacts/{artifactId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationCameraCustomAnalyticsArtifactAsync(string organizationId, string artifactId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/camera/customAnalytics/artifacts/"+ (artifactId==null? "" : System.Uri.EscapeDataString(artifactId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Fetch onboarding status of cameras
		/// Fetch onboarding status of cameras
		/// GetOrganizationCameraOnboardingStatuses organizations/{organizationId}/camera/onboarding/statuses
		/// </summary>
		/// <param name="serials">A list of serial numbers. The returned cameras will be filtered to only include these serials.</param>
		/// <param name="networkIds">A list of network IDs. The returned cameras will be filtered to only include these networks.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationCameraOnboardingStatusesAsync(string organizationId, string[] serials, string[] networkIds, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/camera/onboarding/statuses&"+string.Join("&", serials.Select(z => $"serials={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", networkIds.Select(z => $"networkIds={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Notify that credential handoff to camera has completed
		/// Notify that credential handoff to camera has completed
		/// UpdateOrganizationCameraOnboardingStatuses organizations/{organizationId}/camera/onboarding/statuses
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationCameraOnboardingStatusesAsync(string organizationId, UpdateOrganizationCameraOnboardingStatusesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/camera/onboarding/statuses";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the uplink status of every Meraki MG cellular gateway in the organization
		/// List the uplink status of every Meraki MG cellular gateway in the organization
		/// GetOrganizationCellularGatewayUplinkStatuses organizations/{organizationId}/cellularGateway/uplink/statuses
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="networkIds">A list of network IDs. The returned devices will be filtered to only include these networks.</param>
		/// <param name="serials">A list of serial numbers. The returned devices will be filtered to only include these serials.</param>
		/// <param name="iccids">A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationCellularGatewayUplinkStatusesReturn[]> GetOrganizationCellularGatewayUplinkStatusesAsync(string organizationId, int perPage, string startingAfter, string endingBefore, string[] networkIds, string[] serials, string[] iccids, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/cellularGateway/uplink/statuses&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&"+string.Join("&", networkIds.Select(z => $"networkIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", serials.Select(z => $"serials={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", iccids.Select(z => $"iccids={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationCellularGatewayUplinkStatusesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Claim a list of devices, licenses, and/or orders into an organization
		/// Claim a list of devices, licenses, and/or orders into an organization. When claiming by order, all devices and licenses in the order will be claimed; licenses will be added to the organization and devices will be placed in the organization's inventory.
		/// ClaimIntoOrganization organizations/{organizationId}/claim
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> ClaimIntoOrganizationAsync(string organizationId, ClaimIntoOrganizationPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/claim";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return data usage (in megabits per second) over time for all clients in the given organization within a given time range.
		/// Return data usage (in megabits per second) over time for all clients in the given organization within a given time range.
		/// GetOrganizationClientsBandwidthUsageHistory organizations/{organizationId}/clients/bandwidthUsageHistory
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationClientsBandwidthUsageHistoryReturn[]> GetOrganizationClientsBandwidthUsageHistoryAsync(string organizationId, string t0, string t1, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/clients/bandwidthUsageHistory&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationClientsBandwidthUsageHistoryReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return summary information around client data usage (in mb) across the given organization.
		/// Return summary information around client data usage (in mb) across the given organization.
		/// GetOrganizationClientsOverview organizations/{organizationId}/clients/overview
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationClientsOverviewReturn> GetOrganizationClientsOverviewAsync(string organizationId, string t0, string t1, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/clients/overview&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationClientsOverviewReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the client details in an organization
		/// Return the client details in an organization
		/// GetOrganizationClientsSearch organizations/{organizationId}/clients/search
		/// </summary>
		/// <param name="mac">The MAC address of the client. Required.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 5. Default is 5.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationClientsSearchAsync(string organizationId, string mac, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/clients/search&mac=" + (mac==null? "" : System.Uri.EscapeDataString(mac))+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a new organization by cloning the addressed organization
		/// Create a new organization by cloning the addressed organization
		/// CloneOrganization organizations/{organizationId}/clone
		/// </summary>
		public async Task CloneOrganizationAsync(string organizationId, CloneOrganizationPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/clone";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the configuration templates for this organization
		/// List the configuration templates for this organization
		/// GetOrganizationConfigTemplates organizations/{organizationId}/configTemplates
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationConfigTemplatesAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/configTemplates";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a new configuration template
		/// Create a new configuration template
		/// CreateOrganizationConfigTemplate organizations/{organizationId}/configTemplates
		/// </summary>
		public async Task CreateOrganizationConfigTemplateAsync(string organizationId, CreateOrganizationConfigTemplatePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/configTemplates";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove a configuration template
		/// Remove a configuration template
		/// DeleteOrganizationConfigTemplate organizations/{organizationId}/configTemplates/{configTemplateId}
		/// </summary>
		public async Task DeleteOrganizationConfigTemplateAsync(string organizationId, string configTemplateId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/configTemplates/"+ (configTemplateId==null? "" : System.Uri.EscapeDataString(configTemplateId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a single configuration template
		/// Return a single configuration template
		/// GetOrganizationConfigTemplate organizations/{organizationId}/configTemplates/{configTemplateId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationConfigTemplateAsync(string organizationId, string configTemplateId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/configTemplates/"+ (configTemplateId==null? "" : System.Uri.EscapeDataString(configTemplateId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a configuration template
		/// Update a configuration template
		/// UpdateOrganizationConfigTemplate organizations/{organizationId}/configTemplates/{configTemplateId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationConfigTemplateAsync(string organizationId, string configTemplateId, UpdateOrganizationConfigTemplatePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/configTemplates/"+ (configTemplateId==null? "" : System.Uri.EscapeDataString(configTemplateId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the switch profiles for your switch template configuration
		/// List the switch profiles for your switch template configuration
		/// GetOrganizationConfigTemplateSwitchProfiles organizations/{organizationId}/configTemplates/{configTemplateId}/switch/profiles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationConfigTemplateSwitchProfilesReturn> GetOrganizationConfigTemplateSwitchProfilesAsync(string organizationId, string configTemplateId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/configTemplates/"+ (configTemplateId==null? "" : System.Uri.EscapeDataString(configTemplateId))+"/switch/profiles";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationConfigTemplateSwitchProfilesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return all the ports of a switch profile
		/// Return all the ports of a switch profile
		/// GetOrganizationConfigTemplateSwitchProfilePorts organizations/{organizationId}/configTemplates/{configTemplateId}/switch/profiles/{profileId}/ports
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationConfigTemplateSwitchProfilePortsReturn[]> GetOrganizationConfigTemplateSwitchProfilePortsAsync(string organizationId, string configTemplateId, string profileId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/configTemplates/"+ (configTemplateId==null? "" : System.Uri.EscapeDataString(configTemplateId))+"/switch/profiles/"+ (profileId==null? "" : System.Uri.EscapeDataString(profileId))+"/ports";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationConfigTemplateSwitchProfilePortsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a switch profile port
		/// Return a switch profile port
		/// GetOrganizationConfigTemplateSwitchProfilePort organizations/{organizationId}/configTemplates/{configTemplateId}/switch/profiles/{profileId}/ports/{portId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationConfigTemplateSwitchProfilePortReturn> GetOrganizationConfigTemplateSwitchProfilePortAsync(string organizationId, string configTemplateId, string profileId, string portId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/configTemplates/"+ (configTemplateId==null? "" : System.Uri.EscapeDataString(configTemplateId))+"/switch/profiles/"+ (profileId==null? "" : System.Uri.EscapeDataString(profileId))+"/ports/"+ (portId==null? "" : System.Uri.EscapeDataString(portId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationConfigTemplateSwitchProfilePortReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a switch profile port
		/// Update a switch profile port
		/// UpdateOrganizationConfigTemplateSwitchProfilePort organizations/{organizationId}/configTemplates/{configTemplateId}/switch/profiles/{profileId}/ports/{portId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateOrganizationConfigTemplateSwitchProfilePortReturn> UpdateOrganizationConfigTemplateSwitchProfilePortAsync(string organizationId, string configTemplateId, string profileId, string portId, UpdateOrganizationConfigTemplateSwitchProfilePortPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/configTemplates/"+ (configTemplateId==null? "" : System.Uri.EscapeDataString(configTemplateId))+"/switch/profiles/"+ (profileId==null? "" : System.Uri.EscapeDataString(profileId))+"/ports/"+ (portId==null? "" : System.Uri.EscapeDataString(portId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateOrganizationConfigTemplateSwitchProfilePortReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View the Change Log for your organization
		/// View the Change Log for your organization
		/// GetOrganizationConfigurationChanges organizations/{organizationId}/configurationChanges
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 365 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 365 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 365 days.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 5000. Default is 5000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="networkId">Filters on the given network</param>
		/// <param name="adminId">Filters on the given Admin</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationConfigurationChangesAsync(string organizationId, string t0, string t1, float timespan, int perPage, string startingAfter, string endingBefore, string networkId, string adminId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/configurationChanges&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&networkId=" + (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"&adminId=" + (adminId==null? "" : System.Uri.EscapeDataString(adminId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the devices in an organization
		/// List the devices in an organization
		/// GetOrganizationDevices organizations/{organizationId}/devices
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="configurationUpdatedAfter">Filter results by whether or not the device's configuration has been updated after the given timestamp</param>
		/// <param name="networkIds">Optional parameter to filter devices by network.</param>
		/// <param name="productTypes">Optional parameter to filter devices by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, and sensor.</param>
		/// <param name="tags">Optional parameter to filter devices by tags.</param>
		/// <param name="tagsFilterType">Optional parameter of value 'withAnyTags' or 'withAllTags' to indicate whether to return networks which contain ANY or ALL of the included tags. If no type is included, 'withAnyTags' will be selected.</param>
		/// <param name="name">Optional parameter to filter devices by name. All returned devices will have a name that contains the search term or is an exact match.</param>
		/// <param name="mac">Optional parameter to filter devices by MAC address. All returned devices will have a MAC address that contains the search term or is an exact match.</param>
		/// <param name="serial">Optional parameter to filter devices by serial number. All returned devices will have a serial number that contains the search term or is an exact match.</param>
		/// <param name="model">Optional parameter to filter devices by model. All returned devices will have a model that contains the search term or is an exact match.</param>
		/// <param name="macs">Optional parameter to filter devices by one or more MAC addresses. All returned devices will have a MAC address that is an exact match.</param>
		/// <param name="serials">Optional parameter to filter devices by one or more serial numbers. All returned devices will have a serial number that is an exact match.</param>
		/// <param name="sensorMetrics">Optional parameter to filter devices by the metrics that they provide. Only applies to sensor devices.</param>
		/// <param name="sensorAlertProfileIds">Optional parameter to filter devices by the alert profiles that are bound to them. Only applies to sensor devices.</param>
		/// <param name="models">Optional parameter to filter devices by one or more models. All returned devices will have a model that is an exact match.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationDevicesReturn[]> GetOrganizationDevicesAsync(
					string organizationId, 
					int perPage, 
					string startingAfter, 
					string endingBefore, 
					string configurationUpdatedAfter, 
					string[] networkIds, 
					string[] productTypes, 
					string[] tags, 
					GetOrganizationDevicesTagsFilterType tagsFilterType, 
					string name, 
					string mac, 
					string serial, 
					string model, 
					string[] macs, 
					string[] serials, 
					string[] sensorMetrics, 
					string[] sensorAlertProfileIds, 
					string[] models, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/devices&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&configurationUpdatedAfter=" + (configurationUpdatedAfter==null? "" : System.Uri.EscapeDataString(configurationUpdatedAfter))+"&"+string.Join("&", networkIds.Select(z => $"networkIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", productTypes.Select(z => $"productTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", tags.Select(z => $"tags={System.Uri.EscapeDataString(z.ToString())}"))+"&tagsFilterType=" + tagsFilterType+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&mac=" + (mac==null? "" : System.Uri.EscapeDataString(mac))+"&serial=" + (serial==null? "" : System.Uri.EscapeDataString(serial))+"&model=" + (model==null? "" : System.Uri.EscapeDataString(model))+"&"+string.Join("&", macs.Select(z => $"macs={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", serials.Select(z => $"serials={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", sensorMetrics.Select(z => $"sensorMetrics={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", sensorAlertProfileIds.Select(z => $"sensorAlertProfileIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", models.Select(z => $"models={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationDevicesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the availability information for devices in an organization
		/// List the availability information for devices in an organization. The data returned by this endpoint is updated every 5 minutes.
		/// GetOrganizationDevicesAvailabilities organizations/{organizationId}/devices/availabilities
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="networkIds">Optional parameter to filter device availabilities by network ID. This filter uses multiple exact matches.</param>
		/// <param name="productTypes">Optional parameter to filter device availabilities by device product types. This filter uses multiple exact matches.</param>
		/// <param name="serials">Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches.</param>
		/// <param name="tags">An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, 'tagsFilterType' should also be included (see below). This filter uses multiple exact matches.</param>
		/// <param name="tagsFilterType">An optional parameter of value 'withAnyTags' or 'withAllTags' to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, 'withAnyTags' will be selected.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationDevicesAvailabilitiesReturn[]> GetOrganizationDevicesAvailabilitiesAsync(string organizationId, int perPage, string startingAfter, string endingBefore, string[] networkIds, string[] productTypes, string[] serials, string[] tags, GetOrganizationDevicesTagsFilterType tagsFilterType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/devices/availabilities&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&"+string.Join("&", networkIds.Select(z => $"networkIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", productTypes.Select(z => $"productTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", serials.Select(z => $"serials={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", tags.Select(z => $"tags={System.Uri.EscapeDataString(z.ToString())}"))+"&tagsFilterType=" + tagsFilterType;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationDevicesAvailabilitiesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the power status information for devices in an organization
		/// List the power status information for devices in an organization. The data returned by this endpoint is updated every 5 minutes.
		/// GetOrganizationDevicesPowerModulesStatusesByDevice organizations/{organizationId}/devices/powerModules/statuses/byDevice
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="networkIds">Optional parameter to filter device availabilities by network ID. This filter uses multiple exact matches.</param>
		/// <param name="productTypes">Optional parameter to filter device availabilities by device product types. This filter uses multiple exact matches.</param>
		/// <param name="serials">Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches.</param>
		/// <param name="tags">An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, 'tagsFilterType' should also be included (see below). This filter uses multiple exact matches.</param>
		/// <param name="tagsFilterType">An optional parameter of value 'withAnyTags' or 'withAllTags' to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, 'withAnyTags' will be selected.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationDevicesPowerModulesStatusesByDeviceReturn[]> GetOrganizationDevicesPowerModulesStatusesByDeviceAsync(string organizationId, int perPage, string startingAfter, string endingBefore, string[] networkIds, string[] productTypes, string[] serials, string[] tags, GetOrganizationDevicesTagsFilterType tagsFilterType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/devices/powerModules/statuses/byDevice&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&"+string.Join("&", networkIds.Select(z => $"networkIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", productTypes.Select(z => $"productTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", serials.Select(z => $"serials={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", tags.Select(z => $"tags={System.Uri.EscapeDataString(z.ToString())}"))+"&tagsFilterType=" + tagsFilterType;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationDevicesPowerModulesStatusesByDeviceReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the status of every Meraki device in the organization
		/// List the status of every Meraki device in the organization
		/// GetOrganizationDevicesStatuses organizations/{organizationId}/devices/statuses
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="networkIds">Optional parameter to filter devices by network ids.</param>
		/// <param name="serials">Optional parameter to filter devices by serials.</param>
		/// <param name="statuses">Optional parameter to filter devices by statuses. Valid statuses are ["online", "alerting", "offline", "dormant"].</param>
		/// <param name="productTypes">An optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, and sensor.</param>
		/// <param name="models">Optional parameter to filter devices by models.</param>
		/// <param name="tags">An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, 'tagsFilterType' should also be included (see below).</param>
		/// <param name="tagsFilterType">An optional parameter of value 'withAnyTags' or 'withAllTags' to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, 'withAnyTags' will be selected.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationDevicesStatusesReturn> GetOrganizationDevicesStatusesAsync(string organizationId, int perPage, string startingAfter, string endingBefore, string[] networkIds, string[] serials, GetOrganizationDevicesAvailabilitiesReturnStatus[] statuses, string[] productTypes, string[] models, string[] tags, GetOrganizationDevicesTagsFilterType tagsFilterType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/devices/statuses&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&"+string.Join("&", networkIds.Select(z => $"networkIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", serials.Select(z => $"serials={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", statuses.Select(z => $"statuses={z}"))+"&"+string.Join("&", productTypes.Select(z => $"productTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", models.Select(z => $"models={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", tags.Select(z => $"tags={System.Uri.EscapeDataString(z.ToString())}"))+"&tagsFilterType=" + tagsFilterType;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationDevicesStatusesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return an overview of current device statuses
		/// Return an overview of current device statuses
		/// GetOrganizationDevicesStatusesOverview organizations/{organizationId}/devices/statuses/overview
		/// </summary>
		/// <param name="productTypes">An optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, and sensor.</param>
		/// <param name="networkIds">An optional parameter to filter device statuses by network.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationDevicesStatusesOverviewReturn> GetOrganizationDevicesStatusesOverviewAsync(string organizationId, string[] productTypes, string[] networkIds, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/devices/statuses/overview&"+string.Join("&", productTypes.Select(z => $"productTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", networkIds.Select(z => $"networkIds={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationDevicesStatusesOverviewReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the current uplink addresses for devices in an organization.
		/// List the current uplink addresses for devices in an organization.
		/// GetOrganizationDevicesUplinksAddressesByDevice organizations/{organizationId}/devices/uplinks/addresses/byDevice
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="networkIds">Optional parameter to filter device uplinks by network ID. This filter uses multiple exact matches.</param>
		/// <param name="productTypes">Optional parameter to filter device uplinks by device product types. This filter uses multiple exact matches.</param>
		/// <param name="serials">Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches.</param>
		/// <param name="tags">An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, 'tagsFilterType' should also be included (see below). This filter uses multiple exact matches.</param>
		/// <param name="tagsFilterType">An optional parameter of value 'withAnyTags' or 'withAllTags' to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, 'withAnyTags' will be selected.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationDevicesUplinksAddressesByDeviceReturn[]> GetOrganizationDevicesUplinksAddressesByDeviceAsync(string organizationId, int perPage, string startingAfter, string endingBefore, string[] networkIds, string[] productTypes, string[] serials, string[] tags, GetOrganizationDevicesTagsFilterType tagsFilterType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/devices/uplinks/addresses/byDevice&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&"+string.Join("&", networkIds.Select(z => $"networkIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", productTypes.Select(z => $"productTypes={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", serials.Select(z => $"serials={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", tags.Select(z => $"tags={System.Uri.EscapeDataString(z.ToString())}"))+"&tagsFilterType=" + tagsFilterType;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationDevicesUplinksAddressesByDeviceReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the uplink loss and latency for every MX in the organization from at latest 2 minutes ago
		/// Return the uplink loss and latency for every MX in the organization from at latest 2 minutes ago
		/// GetOrganizationDevicesUplinksLossAndLatency organizations/{organizationId}/devices/uplinksLossAndLatency
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 60 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes.</param>
		/// <param name="uplink">Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, cellular. Default will return all uplinks.</param>
		/// <param name="ip">Optional filter for a specific destination IP. Default will return all destination IPs.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationDevicesUplinksLossAndLatencyReturn[]> GetOrganizationDevicesUplinksLossAndLatencyAsync(string organizationId, string t0, string t1, float timespan, GetDeviceLossAndLatencyHistoryUplink uplink, string ip, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/devices/uplinksLossAndLatency&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&uplink=" + uplink+"&ip=" + (ip==null? "" : System.Uri.EscapeDataString(ip));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationDevicesUplinksLossAndLatencyReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the available early access features for organization
		/// List the available early access features for organization
		/// GetOrganizationEarlyAccessFeatures organizations/{organizationId}/earlyAccess/features
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationEarlyAccessFeaturesAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/earlyAccess/features";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the early access feature opt-ins for an organization
		/// List the early access feature opt-ins for an organization
		/// GetOrganizationEarlyAccessFeaturesOptIns organizations/{organizationId}/earlyAccess/features/optIns
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationEarlyAccessFeaturesOptInsAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/earlyAccess/features/optIns";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a new early access feature opt-in for an organization
		/// Create a new early access feature opt-in for an organization
		/// CreateOrganizationEarlyAccessFeaturesOptIn organizations/{organizationId}/earlyAccess/features/optIns
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> CreateOrganizationEarlyAccessFeaturesOptInAsync(string organizationId, CreateOrganizationEarlyAccessFeaturesOptInPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/earlyAccess/features/optIns";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete an early access feature opt-in
		/// Delete an early access feature opt-in
		/// DeleteOrganizationEarlyAccessFeaturesOptIn organizations/{organizationId}/earlyAccess/features/optIns/{optInId}
		/// </summary>
		public async Task DeleteOrganizationEarlyAccessFeaturesOptInAsync(string organizationId, string optInId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/earlyAccess/features/optIns/"+ (optInId==null? "" : System.Uri.EscapeDataString(optInId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Show an early access feature opt-in for an organization
		/// Show an early access feature opt-in for an organization
		/// GetOrganizationEarlyAccessFeaturesOptIn organizations/{organizationId}/earlyAccess/features/optIns/{optInId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationEarlyAccessFeaturesOptInAsync(string organizationId, string optInId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/earlyAccess/features/optIns/"+ (optInId==null? "" : System.Uri.EscapeDataString(optInId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update an early access feature opt-in for an organization
		/// Update an early access feature opt-in for an organization
		/// UpdateOrganizationEarlyAccessFeaturesOptIn organizations/{organizationId}/earlyAccess/features/optIns/{optInId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationEarlyAccessFeaturesOptInAsync(string organizationId, string optInId, UpdateOrganizationEarlyAccessFeaturesOptInPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/earlyAccess/features/optIns/"+ (optInId==null? "" : System.Uri.EscapeDataString(optInId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get firmware upgrade information for an organization
		/// Get firmware upgrade information for an organization
		/// GetOrganizationFirmwareUpgrades organizations/{organizationId}/firmware/upgrades
		/// </summary>
		/// <param name="status">The status of an upgrade </param>
		/// <param name="productType">The product type in a given upgrade ID</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationFirmwareUpgradesReturn[]> GetOrganizationFirmwareUpgradesAsync(string organizationId, string[] status, string[] productType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/firmware/upgrades&"+string.Join("&", status.Select(z => $"status={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", productType.Select(z => $"productType={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationFirmwareUpgradesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get firmware upgrade status for the filtered devices
		/// Get firmware upgrade status for the filtered devices
		/// GetOrganizationFirmwareUpgradesByDevice organizations/{organizationId}/firmware/upgrades/byDevice
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 50. Default is 50.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="networkIds">Optional parameter to filter by network</param>
		/// <param name="serials">Optional parameter to filter by serial number.  All returned devices will have a serial number that is an exact match.</param>
		/// <param name="macs">Optional parameter to filter by one or more MAC addresses belonging to devices. All devices returned belong to MAC addresses that are an exact match.</param>
		/// <param name="firmwareUpgradeIds">Optional parameter to filter by firmware upgrade ids.</param>
		/// <param name="firmwareUpgradeBatchIds">Optional parameter to filter by firmware upgrade batch ids.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationFirmwareUpgradesByDeviceReturn[]> GetOrganizationFirmwareUpgradesByDeviceAsync(string organizationId, int perPage, string startingAfter, string endingBefore, string[] networkIds, string[] serials, string[] macs, string[] firmwareUpgradeIds, string[] firmwareUpgradeBatchIds, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/firmware/upgrades/byDevice&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&"+string.Join("&", networkIds.Select(z => $"networkIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", serials.Select(z => $"serials={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", macs.Select(z => $"macs={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", firmwareUpgradeIds.Select(z => $"firmwareUpgradeIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", firmwareUpgradeBatchIds.Select(z => $"firmwareUpgradeBatchIds={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationFirmwareUpgradesByDeviceReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List all Insight tracked applications
		/// List all Insight tracked applications
		/// GetOrganizationInsightApplications organizations/{organizationId}/insight/applications
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationInsightApplicationsReturn[]> GetOrganizationInsightApplicationsAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/insight/applications";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationInsightApplicationsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the monitored media servers for this organization
		/// List the monitored media servers for this organization. Only valid for organizations with Meraki Insight.
		/// GetOrganizationInsightMonitoredMediaServers organizations/{organizationId}/insight/monitoredMediaServers
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationInsightMonitoredMediaServersReturn[]> GetOrganizationInsightMonitoredMediaServersAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/insight/monitoredMediaServers";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationInsightMonitoredMediaServersReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add a media server to be monitored for this organization
		/// Add a media server to be monitored for this organization. Only valid for organizations with Meraki Insight.
		/// CreateOrganizationInsightMonitoredMediaServer organizations/{organizationId}/insight/monitoredMediaServers
		/// </summary>
		public async Task CreateOrganizationInsightMonitoredMediaServerAsync(string organizationId, CreateOrganizationInsightMonitoredMediaServerPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/insight/monitoredMediaServers";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a monitored media server from this organization
		/// Delete a monitored media server from this organization. Only valid for organizations with Meraki Insight.
		/// DeleteOrganizationInsightMonitoredMediaServer organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}
		/// </summary>
		public async Task DeleteOrganizationInsightMonitoredMediaServerAsync(string organizationId, string monitoredMediaServerId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/insight/monitoredMediaServers/"+ (monitoredMediaServerId==null? "" : System.Uri.EscapeDataString(monitoredMediaServerId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a monitored media server for this organization
		/// Return a monitored media server for this organization. Only valid for organizations with Meraki Insight.
		/// GetOrganizationInsightMonitoredMediaServer organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationInsightMonitoredMediaServerAsync(string organizationId, string monitoredMediaServerId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/insight/monitoredMediaServers/"+ (monitoredMediaServerId==null? "" : System.Uri.EscapeDataString(monitoredMediaServerId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a monitored media server for this organization
		/// Update a monitored media server for this organization. Only valid for organizations with Meraki Insight.
		/// UpdateOrganizationInsightMonitoredMediaServer organizations/{organizationId}/insight/monitoredMediaServers/{monitoredMediaServerId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationInsightMonitoredMediaServerAsync(string organizationId, string monitoredMediaServerId, UpdateOrganizationInsightMonitoredMediaServerPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/insight/monitoredMediaServers/"+ (monitoredMediaServerId==null? "" : System.Uri.EscapeDataString(monitoredMediaServerId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Claim a list of devices, licenses, and/or orders into an organization inventory
		/// Claim a list of devices, licenses, and/or orders into an organization inventory. When claiming by order, all devices and licenses in the order will be claimed; licenses will be added to the organization and devices will be placed in the organization's inventory. Use /organizations/{organizationId}/inventory/release to release devices from an organization.
		/// ClaimIntoOrganizationInventory organizations/{organizationId}/inventory/claim
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> ClaimIntoOrganizationInventoryAsync(string organizationId, ClaimIntoOrganizationInventoryPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/inventory/claim";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the device inventory for an organization
		/// Return the device inventory for an organization
		/// GetOrganizationInventoryDevices organizations/{organizationId}/inventory/devices
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="usedState">Filter results by used or unused inventory. Accepted values are 'used' or 'unused'.</param>
		/// <param name="search">Search for devices in inventory based on serial number, mac address, or model.</param>
		/// <param name="macs">Search for devices in inventory based on mac addresses.</param>
		/// <param name="networkIds">Search for devices in inventory based on network ids.</param>
		/// <param name="serials">Search for devices in inventory based on serials.</param>
		/// <param name="models">Search for devices in inventory based on model.</param>
		/// <param name="orderNumbers">Search for devices in inventory based on order numbers.</param>
		/// <param name="tags">Filter devices by tags. The filtering is case-sensitive. If tags are included, 'tagsFilterType' should also be included (see below).</param>
		/// <param name="tagsFilterType">To use with 'tags' parameter, to filter devices which contain ANY or ALL given tags. Accepted values are 'withAnyTags' or 'withAllTags', default is 'withAnyTags'.</param>
		/// <param name="productTypes">Filter devices by product type. Accepted values are appliance, camera, cellularGateway, sensor, switch, systemsManager, and wireless.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationInventoryDevicesReturn[]> GetOrganizationInventoryDevicesAsync(string organizationId, int perPage, string startingAfter, string endingBefore, GetOrganizationInventoryDevicesUsedState usedState, string search, string[] macs, string[] networkIds, string[] serials, string[] models, string[] orderNumbers, string[] tags, GetOrganizationDevicesTagsFilterType tagsFilterType, string[] productTypes, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/inventory/devices&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&usedState=" + usedState+"&search=" + (search==null? "" : System.Uri.EscapeDataString(search))+"&"+string.Join("&", macs.Select(z => $"macs={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", networkIds.Select(z => $"networkIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", serials.Select(z => $"serials={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", models.Select(z => $"models={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", orderNumbers.Select(z => $"orderNumbers={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", tags.Select(z => $"tags={System.Uri.EscapeDataString(z.ToString())}"))+"&tagsFilterType=" + tagsFilterType+"&"+string.Join("&", productTypes.Select(z => $"productTypes={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationInventoryDevicesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a single device from the inventory of an organization
		/// Return a single device from the inventory of an organization
		/// GetOrganizationInventoryDevice organizations/{organizationId}/inventory/devices/{serial}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationInventoryDeviceReturn> GetOrganizationInventoryDeviceAsync(string organizationId, string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/inventory/devices/"+ (serial==null? "" : System.Uri.EscapeDataString(serial));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationInventoryDeviceReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Imports event logs related to the onboarding app into elastisearch
		/// Imports event logs related to the onboarding app into elastisearch
		/// CreateOrganizationInventoryOnboardingCloudMonitoringExportEvent organizations/{organizationId}/inventory/onboarding/cloudMonitoring/exportEvents
		/// </summary>
		public async Task CreateOrganizationInventoryOnboardingCloudMonitoringExportEventAsync(string organizationId, CreateOrganizationInventoryOnboardingCloudMonitoringExportEventPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/inventory/onboarding/cloudMonitoring/exportEvents";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Check the status of a committed Import operation
		/// Check the status of a committed Import operation
		/// GetOrganizationInventoryOnboardingCloudMonitoringImports organizations/{organizationId}/inventory/onboarding/cloudMonitoring/imports
		/// </summary>
		/// <param name="importIds">import ids from an imports</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationInventoryOnboardingCloudMonitoringImportsReturn[]> GetOrganizationInventoryOnboardingCloudMonitoringImportsAsync(string organizationId, string[] importIds, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/inventory/onboarding/cloudMonitoring/imports&"+string.Join("&", importIds.Select(z => $"importIds={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationInventoryOnboardingCloudMonitoringImportsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Commits the import operation to complete the onboarding of a device into Dashboard for monitoring.
		/// Commits the import operation to complete the onboarding of a device into Dashboard for monitoring.
		/// CreateOrganizationInventoryOnboardingCloudMonitoringImport organizations/{organizationId}/inventory/onboarding/cloudMonitoring/imports
		/// </summary>
		public async Task CreateOrganizationInventoryOnboardingCloudMonitoringImportAsync(string organizationId, CreateOrganizationInventoryOnboardingCloudMonitoringImportPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/inventory/onboarding/cloudMonitoring/imports";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of networks eligible for adding cloud monitored device
		/// Returns list of networks eligible for adding cloud monitored device
		/// GetOrganizationInventoryOnboardingCloudMonitoringNetworks organizations/{organizationId}/inventory/onboarding/cloudMonitoring/networks
		/// </summary>
		/// <param name="deviceType">Device Type switch or wireless controller</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 100000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		public async Task GetOrganizationInventoryOnboardingCloudMonitoringNetworksAsync(string organizationId, GetOrganizationInventoryOnboardingCloudMonitoringNetworksDeviceType deviceType, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/inventory/onboarding/cloudMonitoring/networks&deviceType=" + deviceType+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Initiates or updates an import session
		/// Initiates or updates an import session. An import ID will be generated and used when you are ready to commit the import.
		/// CreateOrganizationInventoryOnboardingCloudMonitoringPrepare organizations/{organizationId}/inventory/onboarding/cloudMonitoring/prepare
		/// </summary>
		public async Task CreateOrganizationInventoryOnboardingCloudMonitoringPrepareAsync(string organizationId, CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/inventory/onboarding/cloudMonitoring/prepare";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Release a list of claimed devices from an organization.
		/// Release a list of claimed devices from an organization.
		/// ReleaseFromOrganizationInventory organizations/{organizationId}/inventory/release
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> ReleaseFromOrganizationInventoryAsync(string organizationId, ReleaseFromOrganizationInventoryPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/inventory/release";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the licenses for an organization
		/// List the licenses for an organization
		/// GetOrganizationLicenses organizations/{organizationId}/licenses
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="deviceSerial">Filter the licenses to those assigned to a particular device. Returned in the same order that they are queued to the device.</param>
		/// <param name="networkId">Filter the licenses to those assigned in a particular network</param>
		/// <param name="state">Filter the licenses to those in a particular state. Can be one of 'active', 'expired', 'expiring', 'recentlyQueued', 'unused' or 'unusedActive'</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationLicensesReturn[]> GetOrganizationLicensesAsync(string organizationId, int perPage, string startingAfter, string endingBefore, string deviceSerial, string networkId, GetOrganizationLicensesState state, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/licenses&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&deviceSerial=" + (deviceSerial==null? "" : System.Uri.EscapeDataString(deviceSerial))+"&networkId=" + (networkId==null? "" : System.Uri.EscapeDataString(networkId))+"&state=" + state;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationLicensesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Assign SM seats to a network
		/// Assign SM seats to a network. This will increase the managed SM device limit of the network
		/// AssignOrganizationLicensesSeats organizations/{organizationId}/licenses/assignSeats
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<AssignOrganizationLicensesSeatsReturn> AssignOrganizationLicensesSeatsAsync(string organizationId, AssignOrganizationLicensesSeatsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/licenses/assignSeats";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssignOrganizationLicensesSeatsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Move licenses to another organization
		/// Move licenses to another organization. This will also move any devices that the licenses are assigned to
		/// MoveOrganizationLicenses organizations/{organizationId}/licenses/move
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<MoveOrganizationLicensesReturn> MoveOrganizationLicensesAsync(string organizationId, MoveOrganizationLicensesPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/licenses/move";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<MoveOrganizationLicensesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Move SM seats to another organization
		/// Move SM seats to another organization
		/// MoveOrganizationLicensesSeats organizations/{organizationId}/licenses/moveSeats
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<MoveOrganizationLicensesSeatsReturn> MoveOrganizationLicensesSeatsAsync(string organizationId, MoveOrganizationLicensesSeatsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/licenses/moveSeats";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<MoveOrganizationLicensesSeatsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return an overview of the license state for an organization
		/// Return an overview of the license state for an organization
		/// GetOrganizationLicensesOverview organizations/{organizationId}/licenses/overview
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationLicensesOverviewAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/licenses/overview";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Renew SM seats of a license
		/// Renew SM seats of a license. This will extend the license expiration date of managed SM devices covered by this license
		/// RenewOrganizationLicensesSeats organizations/{organizationId}/licenses/renewSeats
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<RenewOrganizationLicensesSeatsReturn> RenewOrganizationLicensesSeatsAsync(string organizationId, RenewOrganizationLicensesSeatsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/licenses/renewSeats";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<RenewOrganizationLicensesSeatsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Display a license
		/// Display a license
		/// GetOrganizationLicense organizations/{organizationId}/licenses/{licenseId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationLicenseReturn> GetOrganizationLicenseAsync(string organizationId, string licenseId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/licenses/"+ (licenseId==null? "" : System.Uri.EscapeDataString(licenseId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationLicenseReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a license
		/// Update a license
		/// UpdateOrganizationLicense organizations/{organizationId}/licenses/{licenseId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateOrganizationLicenseReturn> UpdateOrganizationLicenseAsync(string organizationId, string licenseId, UpdateOrganizationLicensePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/licenses/"+ (licenseId==null? "" : System.Uri.EscapeDataString(licenseId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateOrganizationLicenseReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the licenses in a coterm organization
		/// List the licenses in a coterm organization
		/// GetOrganizationLicensingCotermLicenses organizations/{organizationId}/licensing/coterm/licenses
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="invalidated">Filter for licenses that are invalidated</param>
		/// <param name="expired">Filter for licenses that are expired</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationLicensingCotermLicensesReturn[]> GetOrganizationLicensingCotermLicensesAsync(string organizationId, int perPage, string startingAfter, string endingBefore, bool invalidated, bool expired, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/licensing/coterm/licenses&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&invalidated="+invalidated+"&expired="+expired;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationLicensingCotermLicensesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Moves a license to a different organization (coterm only)
		/// Moves a license to a different organization (coterm only)
		/// MoveOrganizationLicensingCotermLicenses organizations/{organizationId}/licensing/coterm/licenses/move
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<MoveOrganizationLicensingCotermLicensesReturn> MoveOrganizationLicensingCotermLicensesAsync(string organizationId, MoveOrganizationLicensingCotermLicensesPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/licensing/coterm/licenses/move";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<MoveOrganizationLicensingCotermLicensesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns the login security settings for an organization.
		/// Returns the login security settings for an organization.
		/// GetOrganizationLoginSecurity organizations/{organizationId}/loginSecurity
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationLoginSecurityReturn> GetOrganizationLoginSecurityAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/loginSecurity";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationLoginSecurityReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the login security settings for an organization
		/// Update the login security settings for an organization
		/// UpdateOrganizationLoginSecurity organizations/{organizationId}/loginSecurity
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateOrganizationLoginSecurityReturn> UpdateOrganizationLoginSecurityAsync(string organizationId, UpdateOrganizationLoginSecurityPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/loginSecurity";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateOrganizationLoginSecurityReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the networks that the user has privileges on in an organization
		/// List the networks that the user has privileges on in an organization
		/// GetOrganizationNetworks organizations/{organizationId}/networks
		/// </summary>
		/// <param name="configTemplateId">An optional parameter that is the ID of a config template. Will return all networks bound to that template.</param>
		/// <param name="isBoundToConfigTemplate">An optional parameter to filter config template bound networks. If configTemplateId is set, this cannot be false.</param>
		/// <param name="tags">An optional parameter to filter networks by tags. The filtering is case-sensitive. If tags are included, 'tagsFilterType' should also be included (see below).</param>
		/// <param name="tagsFilterType">An optional parameter of value 'withAnyTags' or 'withAllTags' to indicate whether to return networks which contain ANY or ALL of the included tags. If no type is included, 'withAnyTags' will be selected.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 100000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationNetworksReturn[]> GetOrganizationNetworksAsync(string organizationId, string configTemplateId, bool isBoundToConfigTemplate, string[] tags, GetOrganizationDevicesTagsFilterType tagsFilterType, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/networks&configTemplateId=" + (configTemplateId==null? "" : System.Uri.EscapeDataString(configTemplateId))+"&isBoundToConfigTemplate="+isBoundToConfigTemplate+"&"+string.Join("&", tags.Select(z => $"tags={System.Uri.EscapeDataString(z.ToString())}"))+"&tagsFilterType=" + tagsFilterType+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationNetworksReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a network
		/// Create a network
		/// CreateOrganizationNetwork organizations/{organizationId}/networks
		/// </summary>
		public async Task CreateOrganizationNetworkAsync(string organizationId, CreateOrganizationNetworkPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/networks";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Combine multiple networks into a single network
		/// Combine multiple networks into a single network
		/// CombineOrganizationNetworks organizations/{organizationId}/networks/combine
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<CombineOrganizationNetworksReturn> CombineOrganizationNetworksAsync(string organizationId, CombineOrganizationNetworksPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/networks/combine";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<CombineOrganizationNetworksReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the OpenAPI 2.0 Specification of the organization's API documentation in JSON
		/// Return the OpenAPI 2.0 Specification of the organization's API documentation in JSON
		/// GetOrganizationOpenapiSpec organizations/{organizationId}/openapiSpec
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationOpenapiSpecAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/openapiSpec";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Lists Policy Objects belonging to the organization.
		/// Lists Policy Objects belonging to the organization.
		/// GetOrganizationPolicyObjects organizations/{organizationId}/policyObjects
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 10 - 5000. Default is 5000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationPolicyObjectsAsync(string organizationId, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/policyObjects&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Creates a new Policy Object.
		/// Creates a new Policy Object.
		/// CreateOrganizationPolicyObject organizations/{organizationId}/policyObjects
		/// </summary>
		public async Task CreateOrganizationPolicyObjectAsync(string organizationId, CreateOrganizationPolicyObjectPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/policyObjects";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Lists Policy Object Groups belonging to the organization.
		/// Lists Policy Object Groups belonging to the organization.
		/// GetOrganizationPolicyObjectsGroups organizations/{organizationId}/policyObjects/groups
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 10 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationPolicyObjectsGroupsAsync(string organizationId, int perPage, string startingAfter, string endingBefore, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/policyObjects/groups&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Creates a new Policy Object Group.
		/// Creates a new Policy Object Group.
		/// CreateOrganizationPolicyObjectsGroup organizations/{organizationId}/policyObjects/groups
		/// </summary>
		public async Task CreateOrganizationPolicyObjectsGroupAsync(string organizationId, CreateOrganizationPolicyObjectsGroupPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/policyObjects/groups";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Deletes a Policy Object Group.
		/// Deletes a Policy Object Group.
		/// DeleteOrganizationPolicyObjectsGroup organizations/{organizationId}/policyObjects/groups/{policyObjectGroupId}
		/// </summary>
		public async Task DeleteOrganizationPolicyObjectsGroupAsync(string organizationId, string policyObjectGroupId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/policyObjects/groups/"+ (policyObjectGroupId==null? "" : System.Uri.EscapeDataString(policyObjectGroupId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Shows details of a Policy Object Group.
		/// Shows details of a Policy Object Group.
		/// GetOrganizationPolicyObjectsGroup organizations/{organizationId}/policyObjects/groups/{policyObjectGroupId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationPolicyObjectsGroupAsync(string organizationId, string policyObjectGroupId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/policyObjects/groups/"+ (policyObjectGroupId==null? "" : System.Uri.EscapeDataString(policyObjectGroupId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates a Policy Object Group.
		/// Updates a Policy Object Group.
		/// UpdateOrganizationPolicyObjectsGroup organizations/{organizationId}/policyObjects/groups/{policyObjectGroupId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationPolicyObjectsGroupAsync(string organizationId, string policyObjectGroupId, UpdateOrganizationPolicyObjectsGroupPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/policyObjects/groups/"+ (policyObjectGroupId==null? "" : System.Uri.EscapeDataString(policyObjectGroupId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Deletes a Policy Object.
		/// Deletes a Policy Object.
		/// DeleteOrganizationPolicyObject organizations/{organizationId}/policyObjects/{policyObjectId}
		/// </summary>
		public async Task DeleteOrganizationPolicyObjectAsync(string organizationId, string policyObjectId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/policyObjects/"+ (policyObjectId==null? "" : System.Uri.EscapeDataString(policyObjectId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Shows details of a Policy Object.
		/// Shows details of a Policy Object.
		/// GetOrganizationPolicyObject organizations/{organizationId}/policyObjects/{policyObjectId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationPolicyObjectAsync(string organizationId, string policyObjectId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/policyObjects/"+ (policyObjectId==null? "" : System.Uri.EscapeDataString(policyObjectId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates a Policy Object.
		/// Updates a Policy Object.
		/// UpdateOrganizationPolicyObject organizations/{organizationId}/policyObjects/{policyObjectId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationPolicyObjectAsync(string organizationId, string policyObjectId, UpdateOrganizationPolicyObjectPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/policyObjects/"+ (policyObjectId==null? "" : System.Uri.EscapeDataString(policyObjectId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns the SAML SSO enabled settings for an organization.
		/// Returns the SAML SSO enabled settings for an organization.
		/// GetOrganizationSaml organizations/{organizationId}/saml
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationSamlReturn> GetOrganizationSamlAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/saml";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationSamlReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates the SAML SSO enabled settings for an organization.
		/// Updates the SAML SSO enabled settings for an organization.
		/// UpdateOrganizationSaml organizations/{organizationId}/saml
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateOrganizationSamlReturn> UpdateOrganizationSamlAsync(string organizationId, UpdateOrganizationSamlPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/saml";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateOrganizationSamlReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the SAML IdPs in your organization.
		/// List the SAML IdPs in your organization.
		/// GetOrganizationSamlIdps organizations/{organizationId}/saml/idps
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationSamlIdpsReturn[]> GetOrganizationSamlIdpsAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/saml/idps";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationSamlIdpsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a SAML IdP for your organization.
		/// Create a SAML IdP for your organization.
		/// CreateOrganizationSamlIdp organizations/{organizationId}/saml/idps
		/// </summary>
		public async Task CreateOrganizationSamlIdpAsync(string organizationId, CreateOrganizationSamlIdpPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/saml/idps";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove a SAML IdP in your organization.
		/// Remove a SAML IdP in your organization.
		/// DeleteOrganizationSamlIdp organizations/{organizationId}/saml/idps/{idpId}
		/// </summary>
		public async Task DeleteOrganizationSamlIdpAsync(string organizationId, string idpId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/saml/idps/"+ (idpId==null? "" : System.Uri.EscapeDataString(idpId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a SAML IdP from your organization.
		/// Get a SAML IdP from your organization.
		/// GetOrganizationSamlIdp organizations/{organizationId}/saml/idps/{idpId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationSamlIdpReturn> GetOrganizationSamlIdpAsync(string organizationId, string idpId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/saml/idps/"+ (idpId==null? "" : System.Uri.EscapeDataString(idpId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationSamlIdpReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a SAML IdP in your organization
		/// Update a SAML IdP in your organization
		/// UpdateOrganizationSamlIdp organizations/{organizationId}/saml/idps/{idpId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateOrganizationSamlIdpReturn[]> UpdateOrganizationSamlIdpAsync(string organizationId, string idpId, UpdateOrganizationSamlIdpPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/saml/idps/"+ (idpId==null? "" : System.Uri.EscapeDataString(idpId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateOrganizationSamlIdpReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the SAML roles for this organization
		/// List the SAML roles for this organization
		/// GetOrganizationSamlRoles organizations/{organizationId}/samlRoles
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationSamlRolesAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/samlRoles";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a SAML role
		/// Create a SAML role
		/// CreateOrganizationSamlRole organizations/{organizationId}/samlRoles
		/// </summary>
		public async Task CreateOrganizationSamlRoleAsync(string organizationId, CreateOrganizationSamlRolePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/samlRoles";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove a SAML role
		/// Remove a SAML role
		/// DeleteOrganizationSamlRole organizations/{organizationId}/samlRoles/{samlRoleId}
		/// </summary>
		public async Task DeleteOrganizationSamlRoleAsync(string organizationId, string samlRoleId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/samlRoles/"+ (samlRoleId==null? "" : System.Uri.EscapeDataString(samlRoleId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a SAML role
		/// Return a SAML role
		/// GetOrganizationSamlRole organizations/{organizationId}/samlRoles/{samlRoleId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationSamlRoleAsync(string organizationId, string samlRoleId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/samlRoles/"+ (samlRoleId==null? "" : System.Uri.EscapeDataString(samlRoleId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a SAML role
		/// Update a SAML role
		/// UpdateOrganizationSamlRole organizations/{organizationId}/samlRoles/{samlRoleId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<UpdateOrganizationSamlRoleReturn> UpdateOrganizationSamlRoleAsync(string organizationId, string samlRoleId, UpdateOrganizationSamlRolePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/samlRoles/"+ (samlRoleId==null? "" : System.Uri.EscapeDataString(samlRoleId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateOrganizationSamlRoleReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return all reported readings from sensors in a given timespan, sorted by timestamp
		/// Return all reported readings from sensors in a given timespan, sorted by timestamp
		/// GetOrganizationSensorReadingsHistory organizations/{organizationId}/sensor/readings/history
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 365 days and 6 hours from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 7 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 2 hours.</param>
		/// <param name="networkIds">Optional parameter to filter readings by network.</param>
		/// <param name="serials">Optional parameter to filter readings by sensor.</param>
		/// <param name="metrics">Types of sensor readings to retrieve. If no metrics are supplied, all available types of readings will be retrieved. Allowed values are battery, button, door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationSensorReadingsHistoryReturn[]> GetOrganizationSensorReadingsHistoryAsync(string organizationId, int perPage, string startingAfter, string endingBefore, string t0, string t1, float timespan, string[] networkIds, string[] serials, string[] metrics, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/sensor/readings/history&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&"+string.Join("&", networkIds.Select(z => $"networkIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", serials.Select(z => $"serials={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", metrics.Select(z => $"metrics={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationSensorReadingsHistoryReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the latest available reading for each metric from each sensor, sorted by sensor serial
		/// Return the latest available reading for each metric from each sensor, sorted by sensor serial
		/// GetOrganizationSensorReadingsLatest organizations/{organizationId}/sensor/readings/latest
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 100. Default is 100.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="networkIds">Optional parameter to filter readings by network.</param>
		/// <param name="serials">Optional parameter to filter readings by sensor.</param>
		/// <param name="metrics">Types of sensor readings to retrieve. If no metrics are supplied, all available types of readings will be retrieved. Allowed values are battery, button, door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationSensorReadingsLatestReturn[]> GetOrganizationSensorReadingsLatestAsync(string organizationId, int perPage, string startingAfter, string endingBefore, string[] networkIds, string[] serials, string[] metrics, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/sensor/readings/latest&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&"+string.Join("&", networkIds.Select(z => $"networkIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", serials.Select(z => $"serials={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", metrics.Select(z => $"metrics={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationSensorReadingsLatestReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get the organization's APNS certificate
		/// Get the organization's APNS certificate
		/// GetOrganizationSmApnsCert organizations/{organizationId}/sm/apnsCert
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationSmApnsCertReturn> GetOrganizationSmApnsCertAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/sm/apnsCert";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationSmApnsCertReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the VPP accounts in the organization
		/// List the VPP accounts in the organization
		/// GetOrganizationSmVppAccounts organizations/{organizationId}/sm/vppAccounts
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationSmVppAccountsReturn[]> GetOrganizationSmVppAccountsAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/sm/vppAccounts";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationSmVppAccountsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a hash containing the unparsed token of the VPP account with the given ID
		/// Get a hash containing the unparsed token of the VPP account with the given ID
		/// GetOrganizationSmVppAccount organizations/{organizationId}/sm/vppAccounts/{vppAccountId}
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationSmVppAccountReturn> GetOrganizationSmVppAccountAsync(string organizationId, string vppAccountId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/sm/vppAccounts/"+ (vppAccountId==null? "" : System.Uri.EscapeDataString(vppAccountId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationSmVppAccountReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the SNMP settings for an organization
		/// Return the SNMP settings for an organization
		/// GetOrganizationSnmp organizations/{organizationId}/snmp
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> GetOrganizationSnmpAsync(string organizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/snmp";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update the SNMP settings for an organization
		/// Update the SNMP settings for an organization
		/// UpdateOrganizationSnmp organizations/{organizationId}/snmp
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> UpdateOrganizationSnmpAsync(string organizationId, UpdateOrganizationSnmpPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/snmp";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the top 10 appliances sorted by utilization over given time range.
		/// Return the top 10 appliances sorted by utilization over given time range.
		/// GetOrganizationSummaryTopAppliancesByUtilization organizations/{organizationId}/summary/top/appliances/byUtilization
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationSummaryTopAppliancesByUtilizationReturn[]> GetOrganizationSummaryTopAppliancesByUtilizationAsync(string organizationId, string t0, string t1, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/summary/top/appliances/byUtilization&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationSummaryTopAppliancesByUtilizationReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return metrics for organization's top 10 clients by data usage (in mb) over given time range.
		/// Return metrics for organization's top 10 clients by data usage (in mb) over given time range.
		/// GetOrganizationSummaryTopClientsByUsage organizations/{organizationId}/summary/top/clients/byUsage
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationSummaryTopClientsByUsageReturn[]> GetOrganizationSummaryTopClientsByUsageAsync(string organizationId, string t0, string t1, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/summary/top/clients/byUsage&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationSummaryTopClientsByUsageReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return metrics for organization's top clients by data usage (in mb) over given time range, grouped by manufacturer.
		/// Return metrics for organization's top clients by data usage (in mb) over given time range, grouped by manufacturer.
		/// GetOrganizationSummaryTopClientsManufacturersByUsage organizations/{organizationId}/summary/top/clients/manufacturers/byUsage
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationSummaryTopClientsManufacturersByUsageReturn[]> GetOrganizationSummaryTopClientsManufacturersByUsageAsync(string organizationId, string t0, string t1, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/summary/top/clients/manufacturers/byUsage&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationSummaryTopClientsManufacturersByUsageReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return metrics for organization's top 10 devices sorted by data usage over given time range
		/// Return metrics for organization's top 10 devices sorted by data usage over given time range. Default unit is megabytes.
		/// GetOrganizationSummaryTopDevicesByUsage organizations/{organizationId}/summary/top/devices/byUsage
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationSummaryTopDevicesByUsageReturn[]> GetOrganizationSummaryTopDevicesByUsageAsync(string organizationId, string t0, string t1, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/summary/top/devices/byUsage&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationSummaryTopDevicesByUsageReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return metrics for organization's top 10 device models sorted by data usage over given time range
		/// Return metrics for organization's top 10 device models sorted by data usage over given time range. Default unit is megabytes.
		/// GetOrganizationSummaryTopDevicesModelsByUsage organizations/{organizationId}/summary/top/devices/models/byUsage
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationSummaryTopDevicesModelsByUsageReturn[]> GetOrganizationSummaryTopDevicesModelsByUsageAsync(string organizationId, string t0, string t1, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/summary/top/devices/models/byUsage&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationSummaryTopDevicesModelsByUsageReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return metrics for organization's top 10 ssids by data usage over given time range
		/// Return metrics for organization's top 10 ssids by data usage over given time range. Default unit is megabytes.
		/// GetOrganizationSummaryTopSsidsByUsage organizations/{organizationId}/summary/top/ssids/byUsage
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationSummaryTopSsidsByUsageReturn[]> GetOrganizationSummaryTopSsidsByUsageAsync(string organizationId, string t0, string t1, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/summary/top/ssids/byUsage&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationSummaryTopSsidsByUsageReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return metrics for organization's top 10 switches by energy usage over given time range
		/// Return metrics for organization's top 10 switches by energy usage over given time range. Default unit is joules.
		/// GetOrganizationSummaryTopSwitchesByEnergyUsage organizations/{organizationId}/summary/top/switches/byEnergyUsage
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationSummaryTopSwitchesByEnergyUsageReturn[]> GetOrganizationSummaryTopSwitchesByEnergyUsageAsync(string organizationId, string t0, string t1, float timespan, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/summary/top/switches/byEnergyUsage&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationSummaryTopSwitchesByEnergyUsageReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Clone port-level and some switch-level configuration settings from a source switch to one or more target switches
		/// Clone port-level and some switch-level configuration settings from a source switch to one or more target switches. Cloned settings include: Aggregation Groups, Power Settings, Multicast Settings, MTU Configuration, STP Bridge priority, Port Mirroring
		/// CloneOrganizationSwitchDevices organizations/{organizationId}/switch/devices/clone
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> CloneOrganizationSwitchDevicesAsync(string organizationId, CloneOrganizationSwitchDevicesPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/switch/devices/clone";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the switchports in an organization by switch
		/// List the switchports in an organization by switch
		/// GetOrganizationSwitchPortsBySwitch organizations/{organizationId}/switch/ports/bySwitch
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 50. Default is 50.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="networkIds">Optional parameter to filter switchports by network.</param>
		/// <param name="portProfileIds">Optional parameter to filter switchports belonging to the specified switchport profiles.</param>
		/// <param name="name">Optional parameter to filter switchports belonging to switches by name. All returned switches will have a name that contains the search term or is an exact match.</param>
		/// <param name="mac">Optional parameter to filter switchports belonging to switches by MAC address. All returned switches will have a MAC address that contains the search term or is an exact match.</param>
		/// <param name="macs">Optional parameter to filter switchports by one or more MAC addresses belonging to devices. All switchports returned belong to MAC addresses of switches that are an exact match.</param>
		/// <param name="serial">Optional parameter to filter switchports belonging to switches by serial number. All returned switches will have a serial number that contains the search term or is an exact match.</param>
		/// <param name="serials">Optional parameter to filter switchports belonging to switches with one or more serial numbers. All switchports returned belong to serial numbers of switches that are an exact match.</param>
		/// <param name="configurationUpdatedAfter">Optional parameter to filter results by switches where the configuration has been updated after the given timestamp.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationSwitchPortsBySwitchReturn[]> GetOrganizationSwitchPortsBySwitchAsync(string organizationId, int perPage, string startingAfter, string endingBefore, string[] networkIds, string[] portProfileIds, string name, string mac, string[] macs, string serial, string[] serials, string configurationUpdatedAfter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/switch/ports/bySwitch&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&"+string.Join("&", networkIds.Select(z => $"networkIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", portProfileIds.Select(z => $"portProfileIds={System.Uri.EscapeDataString(z.ToString())}"))+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&mac=" + (mac==null? "" : System.Uri.EscapeDataString(mac))+"&"+string.Join("&", macs.Select(z => $"macs={System.Uri.EscapeDataString(z.ToString())}"))+"&serial=" + (serial==null? "" : System.Uri.EscapeDataString(serial))+"&"+string.Join("&", serials.Select(z => $"serials={System.Uri.EscapeDataString(z.ToString())}"))+"&configurationUpdatedAfter=" + (configurationUpdatedAfter==null? "" : System.Uri.EscapeDataString(configurationUpdatedAfter));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationSwitchPortsBySwitchReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the uplink status of every Meraki MX, MG and Z series devices in the organization
		/// List the uplink status of every Meraki MX, MG and Z series devices in the organization
		/// GetOrganizationUplinksStatuses organizations/{organizationId}/uplinks/statuses
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="networkIds">A list of network IDs. The returned devices will be filtered to only include these networks.</param>
		/// <param name="serials">A list of serial numbers. The returned devices will be filtered to only include these serials.</param>
		/// <param name="iccids">A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs.</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationUplinksStatusesReturn[]> GetOrganizationUplinksStatusesAsync(string organizationId, int perPage, string startingAfter, string endingBefore, string[] networkIds, string[] serials, string[] iccids, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/uplinks/statuses&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&"+string.Join("&", networkIds.Select(z => $"networkIds={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", serials.Select(z => $"serials={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", iccids.Select(z => $"iccids={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationUplinksStatusesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a user and all of its authentication methods.
		/// Delete a user and all of its authentication methods.
		/// DeleteOrganizationUser organizations/{organizationId}/users/{userId}
		/// </summary>
		public async Task DeleteOrganizationUserAsync(string organizationId, string userId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a list of alert types to be used with managing webhook alerts
		/// Return a list of alert types to be used with managing webhook alerts
		/// GetOrganizationWebhooksAlertTypes organizations/{organizationId}/webhooks/alertTypes
		/// </summary>
		/// <param name="productType">Filter sample alerts to a specific product type</param>
		/// <returns>Successful operation</returns>
		public async Task<string[]> GetOrganizationWebhooksAlertTypesAsync(string organizationId, GetOrganizationWebhooksAlertTypesProductType productType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/webhooks/alertTypes&productType=" + productType;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return the log of webhook POSTs sent
		/// Return the log of webhook POSTs sent
		/// GetOrganizationWebhooksLogs organizations/{organizationId}/webhooks/logs
		/// </summary>
		/// <param name="t0">The beginning of the timespan for the data. The maximum lookback period is 90 days from today.</param>
		/// <param name="t1">The end of the timespan for the data. t1 can be a maximum of 31 days after t0.</param>
		/// <param name="timespan">The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.</param>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="url">The URL the webhook was sent to</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationWebhooksLogsReturn[]> GetOrganizationWebhooksLogsAsync(string organizationId, string t0, string t1, float timespan, int perPage, string startingAfter, string endingBefore, string url, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/webhooks/logs&t0=" + (t0==null? "" : System.Uri.EscapeDataString(t0))+"&t1=" + (t1==null? "" : System.Uri.EscapeDataString(t1))+"&timespan="+timespan+"&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&url=" + (url==null? "" : System.Uri.EscapeDataString(url));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationWebhooksLogsReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Endpoint to see power status for wireless devices
		/// Endpoint to see power status for wireless devices
		/// GetOrganizationWirelessDevicesEthernetStatuses organizations/{organizationId}/wireless/devices/ethernet/statuses
		/// </summary>
		/// <param name="perPage">The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.</param>
		/// <param name="startingAfter">A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="endingBefore">A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.</param>
		/// <param name="networkIds">A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456</param>
		/// <returns>Successful operation</returns>
		public async Task<GetOrganizationWirelessDevicesEthernetStatusesReturn[]> GetOrganizationWirelessDevicesEthernetStatusesAsync(string organizationId, int perPage, string startingAfter, string endingBefore, string[] networkIds, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "organizations/"+ (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"/wireless/devices/ethernet/statuses&perPage="+perPage+"&startingAfter=" + (startingAfter==null? "" : System.Uri.EscapeDataString(startingAfter))+"&endingBefore=" + (endingBefore==null? "" : System.Uri.EscapeDataString(endingBefore))+"&"+string.Join("&", networkIds.Select(z => $"networkIds={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetOrganizationWirelessDevicesEthernetStatusesReturn[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
	}
	
	public class GetAdministeredIdentitiesMeReturn
	{
		
		/// <summary>
		/// Authentication info
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public GetAdministeredIdentitiesMeReturnAuthentication Authentication { get; set; }
		
		/// <summary>
		/// User email
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Last seen active on Dashboard UI
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUsedDashboardAt")]
		public System.Nullable<System.DateTimeOffset> LastUsedDashboardAt { get; set; }
		
		/// <summary>
		/// Username
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetAdministeredIdentitiesMeReturnAuthentication
	{
		
		/// <summary>
		/// API authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="api")]
		public GetAdministeredIdentitiesMeReturnAuthenticationApi Api { get; set; }
		
		/// <summary>
		/// Authentication mode
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public string Mode { get; set; }
		
		/// <summary>
		/// SAML authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="saml")]
		public GetAdministeredIdentitiesMeReturnAuthenticationSaml Saml { get; set; }
		
		/// <summary>
		/// TwoFactor authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="twoFactor")]
		public GetAdministeredIdentitiesMeReturnAuthenticationTwoFactor TwoFactor { get; set; }
	}
	
	public class GetAdministeredIdentitiesMeReturnAuthenticationApi
	{
		
		/// <summary>
		/// API key
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public GetAdministeredIdentitiesMeReturnAuthenticationApiKey Key { get; set; }
	}
	
	public class GetAdministeredIdentitiesMeReturnAuthenticationApiKey
	{
		
		/// <summary>
		/// If API key is created for this user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.Boolean> Created { get; set; }
	}
	
	public class GetAdministeredIdentitiesMeReturnAuthenticationSaml
	{
		
		/// <summary>
		/// If SAML authentication is enabled for this user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class GetAdministeredIdentitiesMeReturnAuthenticationTwoFactor
	{
		
		/// <summary>
		/// If twoFactor authentication is enabled for this user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateDevicePutBody
	{
		
		/// <summary>
		/// The address of a device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The floor plan to associate to this device. null disassociates the device from the floorplan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="floorPlanId")]
		public string FloorPlanId { get; set; }
		
		/// <summary>
		/// The latitude of a device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// The longitude of a device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
		
		/// <summary>
		/// Whether or not to set the latitude and longitude of a device based on the new address. Only applies when lat and lng are not specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="moveMapMarker")]
		public System.Nullable<System.Boolean> MoveMapMarker { get; set; }
		
		/// <summary>
		/// The name of a device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The notes for the device. String. Limited to 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// The ID of a switch profile to bind to the device (for available switch profiles, see the 'Switch Profiles' endpoint). Use null to unbind the switch device from the current profile. For a device to be bindable to a switch profile, it must (1) be a switch, and (2) belong to a network that is bound to a configuration template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchProfileId")]
		public string SwitchProfileId { get; set; }
		
		/// <summary>
		/// The list of tags of a device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
	}
	
	public class GetDeviceApplianceUplinksSettingsReturn
	{
		
		/// <summary>
		/// Interface settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaces")]
		public GetDeviceApplianceUplinksSettingsReturnInterfaces Interfaces { get; set; }
	}
	
	public class GetDeviceApplianceUplinksSettingsReturnInterfaces
	{
		
		/// <summary>
		/// WAN 1 settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wan1")]
		public GetDeviceApplianceUplinksSettingsReturnInterfacesWan1 Wan1 { get; set; }
		
		/// <summary>
		/// WAN 2 settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wan2")]
		public GetDeviceApplianceUplinksSettingsReturnInterfacesWan2 Wan2 { get; set; }
	}
	
	public class GetDeviceApplianceUplinksSettingsReturnInterfacesWan1
	{
		
		/// <summary>
		/// Enable or disable the interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Configuration options for PPPoE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pppoe")]
		public GetDeviceApplianceUplinksSettingsReturnInterfacesWan1Pppoe Pppoe { get; set; }
		
		/// <summary>
		/// SVI settings by protocol.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="svis")]
		public GetDeviceApplianceUplinksSettingsReturnInterfacesWan1Svis Svis { get; set; }
		
		/// <summary>
		/// VLAN tagging settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanTagging")]
		public GetDeviceApplianceUplinksSettingsReturnInterfacesWan1VlanTagging VlanTagging { get; set; }
	}
	
	public class GetDeviceApplianceUplinksSettingsReturnInterfacesWan1Pppoe
	{
		
		/// <summary>
		/// Settings for PPPoE Authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public GetDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeAuthentication Authentication { get; set; }
		
		/// <summary>
		/// Whether PPPoE is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class GetDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeAuthentication
	{
		
		/// <summary>
		/// Whether PPPoE authentication is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Username for PPPoE authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	public class GetDeviceApplianceUplinksSettingsReturnInterfacesWan1Svis
	{
		
		/// <summary>
		/// IPv4 settings for static/dynamic mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// IPv6 settings for static/dynamic mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6 Ipv6 { get; set; }
	}
	
	public class GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4
	{
		
		/// <summary>
		/// IP address and subnet mask when in static mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The assignment mode for this SVI. Applies only when PPPoE is disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignmentMode")]
		public System.Nullable<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode> AssignmentMode { get; set; }
		
		/// <summary>
		/// Gateway IP address when in static mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The nameserver settings for this SVI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nameservers")]
		public GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4Nameservers Nameservers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dynamic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="static")]
		_static = 1,
	}
	
	public class GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4Nameservers
	{
		
		/// <summary>
		/// Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public string[] Addresses { get; set; }
	}
	
	public class GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6
	{
		
		/// <summary>
		/// Static address that will override the one(s) received by SLAAC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The assignment mode for this SVI. Applies only when PPPoE is disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignmentMode")]
		public System.Nullable<GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6AssignmentMode> AssignmentMode { get; set; }
		
		/// <summary>
		/// Static gateway that will override the one received by autoconf.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The nameserver settings for this SVI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nameservers")]
		public GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6Nameservers Nameservers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6AssignmentMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dynamic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="static")]
		_static = 1,
	}
	
	public class GetDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6Nameservers
	{
		
		/// <summary>
		/// Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public string[] Addresses { get; set; }
	}
	
	public class GetDeviceApplianceUplinksSettingsReturnInterfacesWan1VlanTagging
	{
		
		/// <summary>
		/// Whether VLAN tagging is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The ID of the VLAN to use for VLAN tagging.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public System.Nullable<System.Int32> VlanId { get; set; }
	}
	
	public class GetDeviceApplianceUplinksSettingsReturnInterfacesWan2
	{
		
		/// <summary>
		/// Enable or disable the interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Configuration options for PPPoE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pppoe")]
		public GetDeviceApplianceUplinksSettingsReturnInterfacesWan2Pppoe Pppoe { get; set; }
		
		/// <summary>
		/// SVI settings by protocol.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="svis")]
		public GetDeviceApplianceUplinksSettingsReturnInterfacesWan2Svis Svis { get; set; }
		
		/// <summary>
		/// VLAN tagging settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanTagging")]
		public GetDeviceApplianceUplinksSettingsReturnInterfacesWan2VlanTagging VlanTagging { get; set; }
	}
	
	public class GetDeviceApplianceUplinksSettingsReturnInterfacesWan2Pppoe
	{
		
		/// <summary>
		/// Settings for PPPoE Authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public GetDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeAuthentication Authentication { get; set; }
		
		/// <summary>
		/// Whether PPPoE is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class GetDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeAuthentication
	{
		
		/// <summary>
		/// Whether PPPoE authentication is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Username for PPPoE authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	public class GetDeviceApplianceUplinksSettingsReturnInterfacesWan2Svis
	{
		
		/// <summary>
		/// IPv4 settings for static/dynamic mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// IPv6 settings for static/dynamic mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6 Ipv6 { get; set; }
	}
	
	public class GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4
	{
		
		/// <summary>
		/// IP address and subnet mask when in static mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The assignment mode for this SVI. Applies only when PPPoE is disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignmentMode")]
		public System.Nullable<GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4AssignmentMode> AssignmentMode { get; set; }
		
		/// <summary>
		/// Gateway IP address when in static mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The nameserver settings for this SVI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nameservers")]
		public GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4Nameservers Nameservers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4AssignmentMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dynamic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="static")]
		_static = 1,
	}
	
	public class GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4Nameservers
	{
		
		/// <summary>
		/// Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public string[] Addresses { get; set; }
	}
	
	public class GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6
	{
		
		/// <summary>
		/// Static address that will override the one(s) received by SLAAC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The assignment mode for this SVI. Applies only when PPPoE is disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignmentMode")]
		public System.Nullable<GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6AssignmentMode> AssignmentMode { get; set; }
		
		/// <summary>
		/// Static gateway that will override the one received by autoconf.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The nameserver settings for this SVI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nameservers")]
		public GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6Nameservers Nameservers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6AssignmentMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dynamic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="static")]
		_static = 1,
	}
	
	public class GetDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6Nameservers
	{
		
		/// <summary>
		/// Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public string[] Addresses { get; set; }
	}
	
	public class GetDeviceApplianceUplinksSettingsReturnInterfacesWan2VlanTagging
	{
		
		/// <summary>
		/// Whether VLAN tagging is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The ID of the VLAN to use for VLAN tagging.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public System.Nullable<System.Int32> VlanId { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBody
	{
		
		/// <summary>
		/// Interface settings.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="interfaces")]
		public UpdateDeviceApplianceUplinksSettingsPutBodyInterfaces Interfaces { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBodyInterfaces
	{
		
		/// <summary>
		/// WAN 1 settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wan1")]
		public UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1 Wan1 { get; set; }
		
		/// <summary>
		/// WAN 2 settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wan2")]
		public UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2 Wan2 { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1
	{
		
		/// <summary>
		/// Enable or disable the interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Configuration options for PPPoE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pppoe")]
		public UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1Pppoe Pppoe { get; set; }
		
		/// <summary>
		/// SVI settings by protocol.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="svis")]
		public UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1Svis Svis { get; set; }
		
		/// <summary>
		/// VLAN tagging settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanTagging")]
		public UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1VlanTagging VlanTagging { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1Pppoe
	{
		
		/// <summary>
		/// Settings for PPPoE Authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1PppoeAuthentication Authentication { get; set; }
		
		/// <summary>
		/// Whether PPPoE is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1PppoeAuthentication
	{
		
		/// <summary>
		/// Whether PPPoE authentication is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Password for PPPoE authentication. This parameter is not returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Username for PPPoE authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1Svis
	{
		
		/// <summary>
		/// IPv4 settings for static/dynamic mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// IPv6 settings for static/dynamic mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv6 Ipv6 { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv4
	{
		
		/// <summary>
		/// IP address and subnet mask when in static mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The assignment mode for this SVI. Applies only when PPPoE is disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignmentMode")]
		public System.Nullable<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv4AssignmentMode> AssignmentMode { get; set; }
		
		/// <summary>
		/// Gateway IP address when in static mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The nameserver settings for this SVI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nameservers")]
		public UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv4Nameservers Nameservers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv4AssignmentMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dynamic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="static")]
		_static = 1,
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv4Nameservers
	{
		
		/// <summary>
		/// Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public string[] Addresses { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv6
	{
		
		/// <summary>
		/// Static address that will override the one(s) received by SLAAC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The assignment mode for this SVI. Applies only when PPPoE is disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignmentMode")]
		public System.Nullable<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv6AssignmentMode> AssignmentMode { get; set; }
		
		/// <summary>
		/// Static gateway that will override the one received by autoconf.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The nameserver settings for this SVI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nameservers")]
		public UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv6Nameservers Nameservers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv6AssignmentMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dynamic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="static")]
		_static = 1,
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1SvisIpv6Nameservers
	{
		
		/// <summary>
		/// Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public string[] Addresses { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan1VlanTagging
	{
		
		/// <summary>
		/// Whether VLAN tagging is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The ID of the VLAN to use for VLAN tagging.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public System.Nullable<System.Int32> VlanId { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2
	{
		
		/// <summary>
		/// Enable or disable the interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Configuration options for PPPoE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pppoe")]
		public UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2Pppoe Pppoe { get; set; }
		
		/// <summary>
		/// SVI settings by protocol.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="svis")]
		public UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2Svis Svis { get; set; }
		
		/// <summary>
		/// VLAN tagging settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanTagging")]
		public UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2VlanTagging VlanTagging { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2Pppoe
	{
		
		/// <summary>
		/// Settings for PPPoE Authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2PppoeAuthentication Authentication { get; set; }
		
		/// <summary>
		/// Whether PPPoE is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2PppoeAuthentication
	{
		
		/// <summary>
		/// Whether PPPoE authentication is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Password for PPPoE authentication. This parameter is not returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Username for PPPoE authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2Svis
	{
		
		/// <summary>
		/// IPv4 settings for static/dynamic mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// IPv6 settings for static/dynamic mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv6 Ipv6 { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv4
	{
		
		/// <summary>
		/// IP address and subnet mask when in static mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The assignment mode for this SVI. Applies only when PPPoE is disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignmentMode")]
		public System.Nullable<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv4AssignmentMode> AssignmentMode { get; set; }
		
		/// <summary>
		/// Gateway IP address when in static mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The nameserver settings for this SVI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nameservers")]
		public UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv4Nameservers Nameservers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv4AssignmentMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dynamic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="static")]
		_static = 1,
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv4Nameservers
	{
		
		/// <summary>
		/// Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public string[] Addresses { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv6
	{
		
		/// <summary>
		/// Static address that will override the one(s) received by SLAAC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The assignment mode for this SVI. Applies only when PPPoE is disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignmentMode")]
		public System.Nullable<UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv6AssignmentMode> AssignmentMode { get; set; }
		
		/// <summary>
		/// Static gateway that will override the one received by autoconf.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The nameserver settings for this SVI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nameservers")]
		public UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv6Nameservers Nameservers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv6AssignmentMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dynamic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="static")]
		_static = 1,
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2SvisIpv6Nameservers
	{
		
		/// <summary>
		/// Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public string[] Addresses { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsPutBodyInterfacesWan2VlanTagging
	{
		
		/// <summary>
		/// Whether VLAN tagging is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The ID of the VLAN to use for VLAN tagging.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public System.Nullable<System.Int32> VlanId { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturn
	{
		
		/// <summary>
		/// Interface settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaces")]
		public UpdateDeviceApplianceUplinksSettingsReturnInterfaces Interfaces { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturnInterfaces
	{
		
		/// <summary>
		/// WAN 1 settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wan1")]
		public UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1 Wan1 { get; set; }
		
		/// <summary>
		/// WAN 2 settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wan2")]
		public UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2 Wan2 { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1
	{
		
		/// <summary>
		/// Enable or disable the interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Configuration options for PPPoE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pppoe")]
		public UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1Pppoe Pppoe { get; set; }
		
		/// <summary>
		/// SVI settings by protocol.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="svis")]
		public UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1Svis Svis { get; set; }
		
		/// <summary>
		/// VLAN tagging settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanTagging")]
		public UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1VlanTagging VlanTagging { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1Pppoe
	{
		
		/// <summary>
		/// Settings for PPPoE Authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeAuthentication Authentication { get; set; }
		
		/// <summary>
		/// Whether PPPoE is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1PppoeAuthentication
	{
		
		/// <summary>
		/// Whether PPPoE authentication is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Username for PPPoE authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1Svis
	{
		
		/// <summary>
		/// IPv4 settings for static/dynamic mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// IPv6 settings for static/dynamic mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6 Ipv6 { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4
	{
		
		/// <summary>
		/// IP address and subnet mask when in static mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The assignment mode for this SVI. Applies only when PPPoE is disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignmentMode")]
		public System.Nullable<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode> AssignmentMode { get; set; }
		
		/// <summary>
		/// Gateway IP address when in static mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The nameserver settings for this SVI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nameservers")]
		public UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4Nameservers Nameservers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4AssignmentMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dynamic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="static")]
		_static = 1,
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv4Nameservers
	{
		
		/// <summary>
		/// Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public string[] Addresses { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6
	{
		
		/// <summary>
		/// Static address that will override the one(s) received by SLAAC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The assignment mode for this SVI. Applies only when PPPoE is disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignmentMode")]
		public System.Nullable<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6AssignmentMode> AssignmentMode { get; set; }
		
		/// <summary>
		/// Static gateway that will override the one received by autoconf.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The nameserver settings for this SVI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nameservers")]
		public UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6Nameservers Nameservers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6AssignmentMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dynamic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="static")]
		_static = 1,
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1SvisIpv6Nameservers
	{
		
		/// <summary>
		/// Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public string[] Addresses { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan1VlanTagging
	{
		
		/// <summary>
		/// Whether VLAN tagging is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The ID of the VLAN to use for VLAN tagging.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public System.Nullable<System.Int32> VlanId { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2
	{
		
		/// <summary>
		/// Enable or disable the interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Configuration options for PPPoE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pppoe")]
		public UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2Pppoe Pppoe { get; set; }
		
		/// <summary>
		/// SVI settings by protocol.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="svis")]
		public UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2Svis Svis { get; set; }
		
		/// <summary>
		/// VLAN tagging settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanTagging")]
		public UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2VlanTagging VlanTagging { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2Pppoe
	{
		
		/// <summary>
		/// Settings for PPPoE Authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeAuthentication Authentication { get; set; }
		
		/// <summary>
		/// Whether PPPoE is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2PppoeAuthentication
	{
		
		/// <summary>
		/// Whether PPPoE authentication is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Username for PPPoE authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2Svis
	{
		
		/// <summary>
		/// IPv4 settings for static/dynamic mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// IPv6 settings for static/dynamic mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6 Ipv6 { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4
	{
		
		/// <summary>
		/// IP address and subnet mask when in static mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The assignment mode for this SVI. Applies only when PPPoE is disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignmentMode")]
		public System.Nullable<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4AssignmentMode> AssignmentMode { get; set; }
		
		/// <summary>
		/// Gateway IP address when in static mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The nameserver settings for this SVI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nameservers")]
		public UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4Nameservers Nameservers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4AssignmentMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dynamic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="static")]
		_static = 1,
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv4Nameservers
	{
		
		/// <summary>
		/// Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public string[] Addresses { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6
	{
		
		/// <summary>
		/// Static address that will override the one(s) received by SLAAC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The assignment mode for this SVI. Applies only when PPPoE is disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignmentMode")]
		public System.Nullable<UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6AssignmentMode> AssignmentMode { get; set; }
		
		/// <summary>
		/// Static gateway that will override the one received by autoconf.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The nameserver settings for this SVI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nameservers")]
		public UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6Nameservers Nameservers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6AssignmentMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dynamic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="static")]
		_static = 1,
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2SvisIpv6Nameservers
	{
		
		/// <summary>
		/// Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public string[] Addresses { get; set; }
	}
	
	public class UpdateDeviceApplianceUplinksSettingsReturnInterfacesWan2VlanTagging
	{
		
		/// <summary>
		/// Whether VLAN tagging is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The ID of the VLAN to use for VLAN tagging.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public System.Nullable<System.Int32> VlanId { get; set; }
	}
	
	public class BlinkDeviceLedsPostBody
	{
		
		/// <summary>
		/// The duration in seconds. Must be between 5 and 120. Default is 20 seconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<System.Int32> Duration { get; set; }
		
		/// <summary>
		/// The duty cycle as the percent active. Must be between 10 and 90. Default is 50.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duty")]
		public System.Nullable<System.Int32> Duty { get; set; }
		
		/// <summary>
		/// The period in milliseconds. Must be between 100 and 1000. Default is 160 milliseconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="period")]
		public System.Nullable<System.Int32> Period { get; set; }
	}
	
	public enum GetDeviceCameraAnalyticsOverviewObjectType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		person = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		vehicle = 1,
	}
	
	public class UpdateDeviceCameraCustomAnalyticsPutBody
	{
		
		/// <summary>
		/// The ID of the custom analytics artifact
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="artifactId")]
		public string ArtifactId { get; set; }
		
		/// <summary>
		/// Enable custom analytics
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Parameters for the custom analytics workload
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parameters")]
		public UpdateDeviceCameraCustomAnalyticsPutBodyParameters[] UpdateDeviceCameraCustomAnalyticsPutBodyParameters { get; set; }
	}
	
	public class UpdateDeviceCameraCustomAnalyticsPutBodyParameters
	{
		
		/// <summary>
		/// Name of the parameter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Value of the parameter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class GenerateDeviceCameraSnapshotPostBody
	{
		
		/// <summary>
		/// [optional] If set to "true" the snapshot will be taken at full sensor resolution. This will error if used with timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fullframe")]
		public System.Nullable<System.Boolean> Fullframe { get; set; }
		
		/// <summary>
		/// [optional] The snapshot will be taken from this time on the camera. The timestamp is expected to be in ISO 8601 format. If no timestamp is specified, we will assume current time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public System.Nullable<System.DateTimeOffset> Timestamp { get; set; }
	}
	
	public class UpdateDeviceCameraQualityAndRetentionPutBody
	{
		
		/// <summary>
		/// Boolean indicating if audio recording is enabled(true) or disabled(false) on the camera
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="audioRecordingEnabled")]
		public System.Nullable<System.Boolean> AudioRecordingEnabled { get; set; }
		
		/// <summary>
		/// Boolean indicating if motion-based retention is enabled(true) or disabled(false) on the camera.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="motionBasedRetentionEnabled")]
		public System.Nullable<System.Boolean> MotionBasedRetentionEnabled { get; set; }
		
		/// <summary>
		/// The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="motionDetectorVersion")]
		public System.Nullable<UpdateDeviceCameraQualityAndRetentionPutBodyMotionDetectorVersion> MotionDetectorVersion { get; set; }
		
		/// <summary>
		/// The ID of a quality and retention profile to assign to the camera. The profile's settings will override all of the per-camera quality and retention settings. If the value of this parameter is null, any existing profile will be unassigned from the camera.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profileId")]
		public string ProfileId { get; set; }
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'High' or 'Enhanced'. Not all qualities are supported by every camera model.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public System.Nullable<UpdateDeviceCameraQualityAndRetentionPutBodyQuality> Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720', '1920x1080', '1080x1080', '2058x2058', '2112x2112', '2880x2880', '2688x1512' or '3840x2160'.Not all resolutions are supported by every camera model.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public System.Nullable<UpdateDeviceCameraQualityAndRetentionPutBodyResolution> Resolution { get; set; }
		
		/// <summary>
		/// Boolean indicating if restricted bandwidth is enabled(true) or disabled(false) on the camera. This setting does not apply to MV2 cameras.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restrictedBandwidthModeEnabled")]
		public System.Nullable<System.Boolean> RestrictedBandwidthModeEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceCameraQualityAndRetentionPutBodyMotionDetectorVersion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2 = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceCameraQualityAndRetentionPutBodyQuality
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enhanced = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		High = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Standard = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceCameraQualityAndRetentionPutBodyResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2058x2058")]
		_2058x2058 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2112x2112")]
		_2112x2112 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2880x2880")]
		_2880x2880 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="3840x2160")]
		_3840x2160 = 7,
	}
	
	public class UpdateDeviceCameraSensePutBody
	{
		
		/// <summary>
		/// The details of the audio detection config.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="audioDetection")]
		public UpdateDeviceCameraSensePutBodyAudioDetection AudioDetection { get; set; }
		
		/// <summary>
		/// The ID of the object detection model
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="detectionModelId")]
		public string DetectionModelId { get; set; }
		
		/// <summary>
		/// The ID of the MQTT broker to be enabled on the camera. A value of null will disable MQTT on the camera
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mqttBrokerId")]
		public string MqttBrokerId { get; set; }
		
		/// <summary>
		/// Boolean indicating if sense(license) is enabled(true) or disabled(false) on the camera
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="senseEnabled")]
		public System.Nullable<System.Boolean> SenseEnabled { get; set; }
	}
	
	public class UpdateDeviceCameraSensePutBodyAudioDetection
	{
		
		/// <summary>
		/// Boolean indicating if audio detection is enabled(true) or disabled(false) on the camera
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateDeviceCameraVideoSettingsPutBody
	{
		
		/// <summary>
		/// Boolean indicating if external rtsp stream is exposed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="externalRtspEnabled")]
		public System.Nullable<System.Boolean> ExternalRtspEnabled { get; set; }
	}
	
	public class UpdateDeviceCameraWirelessProfilesPutBody
	{
		
		/// <summary>
		/// The ids of the wireless profile to assign to the given camera
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public UpdateDeviceCameraWirelessProfilesPutBodyIds Ids { get; set; }
	}
	
	public class UpdateDeviceCameraWirelessProfilesPutBodyIds
	{
		
		/// <summary>
		/// The id of the backup wireless profile
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backup")]
		public string Backup { get; set; }
		
		/// <summary>
		/// The id of the primary wireless profile
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary")]
		public string Primary { get; set; }
		
		/// <summary>
		/// The id of the secondary wireless profile
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondary")]
		public string Secondary { get; set; }
	}
	
	public class UpdateDeviceCellularSimsPutBody
	{
		
		/// <summary>
		/// SIM Failover settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="simFailover")]
		public UpdateDeviceCellularSimsPutBodySimFailover SimFailover { get; set; }
		
		/// <summary>
		/// List of SIMs. If a SIM was previously configured and not specified in this request, it will remain unchanged.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sims")]
		public UpdateDeviceCellularSimsPutBodySims[] UpdateDeviceCellularSimsPutBodySims { get; set; }
	}
	
	public class UpdateDeviceCellularSimsPutBodySimFailover
	{
		
		/// <summary>
		/// Failover to secondary SIM (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateDeviceCellularSimsPutBodySims
	{
		
		/// <summary>
		/// APN configurations. If empty, the default APN will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apns")]
		public UpdateDeviceCellularSimsPutBodySimsApns[] UpdateDeviceCellularSimsPutBodySimsApns { get; set; }
		
		/// <summary>
		/// If true, this SIM is used for boot. Must be true on single-sim devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPrimary")]
		public System.Nullable<System.Boolean> IsPrimary { get; set; }
		
		/// <summary>
		/// SIM slot being configured. Must be 'sim1' on single-sim devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slot")]
		public System.Nullable<UpdateDeviceCellularSimsPutBodySimsSlot> Slot { get; set; }
	}
	
	public class UpdateDeviceCellularSimsPutBodySimsApns
	{
		
		/// <summary>
		/// IP versions to support (permitted values include 'ipv4', 'ipv6').
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="allowedIpTypes")]
		public string[] AllowedIpTypes { get; set; }
		
		/// <summary>
		/// APN authentication configurations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public UpdateDeviceCellularSimsPutBodySimsApnsAuthentication Authentication { get; set; }
		
		/// <summary>
		/// APN name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateDeviceCellularSimsPutBodySimsApnsAuthentication
	{
		
		/// <summary>
		/// APN password, if type is set (if APN password is not supplied, the password is left unchanged).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// APN auth type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<UpdateDeviceCellularSimsPutBodySimsApnsAuthenticationType> Type { get; set; }
		
		/// <summary>
		/// APN username, if type is set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceCellularSimsPutBodySimsApnsAuthenticationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		chap = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pap = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceCellularSimsPutBodySimsSlot
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sim1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sim2 = 1,
	}
	
	public class UpdateDeviceCellularGatewayLanPutBody
	{
		
		/// <summary>
		/// list of all fixed IP assignments for a single MG
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixedIpAssignments")]
		public UpdateDeviceCellularGatewayLanPutBodyFixedIpAssignments[] UpdateDeviceCellularGatewayLanPutBodyFixedIpAssignments { get; set; }
		
		/// <summary>
		/// list of all reserved IP ranges for a single MG
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservedIpRanges")]
		public UpdateDeviceCellularGatewayLanPutBodyReservedIpRanges[] UpdateDeviceCellularGatewayLanPutBodyReservedIpRanges { get; set; }
	}
	
	public class UpdateDeviceCellularGatewayLanPutBodyFixedIpAssignments
	{
		
		/// <summary>
		/// The IP address you want to assign to a specific server or device
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// The MAC address of the server or device that hosts the internal resource that you wish to receive the specified IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// A descriptive name of the assignment
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateDeviceCellularGatewayLanPutBodyReservedIpRanges
	{
		
		/// <summary>
		/// Comment explaining the reserved IP range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Ending IP included in the reserved range of IPs
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="end")]
		public string End { get; set; }
		
		/// <summary>
		/// Starting IP included in the reserved range of IPs
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start")]
		public string Start { get; set; }
	}
	
	public class UpdateDeviceCellularGatewayPortForwardingRulesPutBody
	{
		
		/// <summary>
		/// An array of port forwarding params
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateDeviceCellularGatewayPortForwardingRulesPutBodyRules[] UpdateDeviceCellularGatewayPortForwardingRulesPutBodyRules { get; set; }
	}
	
	public class UpdateDeviceCellularGatewayPortForwardingRulesPutBodyRules
	{
		
		/// <summary>
		/// `any` or `restricted`. Specify the right to make inbound connections on the specified ports or port ranges. If `restricted`, a list of allowed IPs is mandatory.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public string Access { get; set; }
		
		/// <summary>
		/// An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedIps")]
		public string[] AllowedIps { get; set; }
		
		/// <summary>
		/// The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lanIp")]
		public string LanIp { get; set; }
		
		/// <summary>
		/// A port or port ranges that will receive the forwarded traffic from the WAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="localPort")]
		public string LocalPort { get; set; }
		
		/// <summary>
		/// A descriptive name for the rule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// TCP or UDP
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public string Protocol { get; set; }
		
		/// <summary>
		/// A port or port ranges that will be forwarded to the host on the LAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="publicPort")]
		public string PublicPort { get; set; }
	}
	
	public class CreateDeviceLiveToolsPingPostBody
	{
		
		/// <summary>
		/// Count parameter to pass to ping. [1..5], default 5
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public System.Nullable<System.Int32> Count { get; set; }
		
		/// <summary>
		/// FQDN, IPv4 or IPv6 address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
	}
	
	public class GetDeviceLiveToolsPingReturn
	{
		
		/// <summary>
		/// Id to check the status of your ping request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pingId")]
		public string PingId { get; set; }
		
		/// <summary>
		/// Ping request parameters
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="request")]
		public GetDeviceLiveToolsPingReturnRequest Request { get; set; }
		
		/// <summary>
		/// Results of the ping request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public GetDeviceLiveToolsPingReturnResults Results { get; set; }
		
		/// <summary>
		/// Status of the ping request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// GET this url to check the status of your ping request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetDeviceLiveToolsPingReturnRequest
	{
		
		/// <summary>
		/// Number of pings to send
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public System.Nullable<System.Int32> Count { get; set; }
		
		/// <summary>
		/// Device serial number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// IP address or FQDN to ping
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
	}
	
	public class GetDeviceLiveToolsPingReturnResults
	{
		
		/// <summary>
		/// Packet latency stats
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latencies")]
		public GetDeviceLiveToolsPingReturnResultsLatencies Latencies { get; set; }
		
		/// <summary>
		/// Lost packets
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loss")]
		public GetDeviceLiveToolsPingReturnResultsLoss Loss { get; set; }
		
		/// <summary>
		/// Number of packets received
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="received")]
		public System.Nullable<System.Int32> Received { get; set; }
		
		/// <summary>
		/// Received packets
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replies")]
		public GetDeviceLiveToolsPingReturnResultsReplies[] GetDeviceLiveToolsPingReturnResultsReplies { get; set; }
		
		/// <summary>
		/// Number of packets sent
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sent")]
		public System.Nullable<System.Int32> Sent { get; set; }
	}
	
	public class GetDeviceLiveToolsPingReturnResultsLatencies
	{
		
		/// <summary>
		/// Average latency
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="average")]
		public System.Nullable<System.Single> Average { get; set; }
		
		/// <summary>
		/// Maximum latency
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximum")]
		public System.Nullable<System.Single> Maximum { get; set; }
		
		/// <summary>
		/// Minimum latency
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimum")]
		public System.Nullable<System.Single> Minimum { get; set; }
	}
	
	public class GetDeviceLiveToolsPingReturnResultsLoss
	{
		
		/// <summary>
		/// Percentage of packets lost
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage")]
		public System.Nullable<System.Single> Percentage { get; set; }
	}
	
	public class GetDeviceLiveToolsPingReturnResultsReplies
	{
		
		/// <summary>
		/// Latency of the packet in milliseconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latency")]
		public System.Nullable<System.Single> Latency { get; set; }
		
		/// <summary>
		/// Sequence ID of the packet
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sequenceId")]
		public System.Nullable<System.Int32> SequenceId { get; set; }
		
		/// <summary>
		/// Size of the packet in bytes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
	}
	
	public class CreateDeviceLiveToolsPingDevicePostBody
	{
		
		/// <summary>
		/// Count parameter to pass to ping. [1..5], default 5
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public System.Nullable<System.Int32> Count { get; set; }
	}
	
	public class GetDeviceLiveToolsPingDeviceReturn
	{
		
		/// <summary>
		/// Id to check the status of your ping request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pingId")]
		public string PingId { get; set; }
		
		/// <summary>
		/// Ping request parameters
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="request")]
		public GetDeviceLiveToolsPingDeviceReturnRequest Request { get; set; }
		
		/// <summary>
		/// Results of the ping request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public GetDeviceLiveToolsPingDeviceReturnResults Results { get; set; }
		
		/// <summary>
		/// Status of the ping request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// GET this url to check the status of your ping request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetDeviceLiveToolsPingDeviceReturnRequest
	{
		
		/// <summary>
		/// Number of pings to send
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public System.Nullable<System.Int32> Count { get; set; }
		
		/// <summary>
		/// Device serial number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// IP address or FQDN to ping
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
	}
	
	public class GetDeviceLiveToolsPingDeviceReturnResults
	{
		
		/// <summary>
		/// Packet latency stats
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latencies")]
		public GetDeviceLiveToolsPingDeviceReturnResultsLatencies Latencies { get; set; }
		
		/// <summary>
		/// Lost packets
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loss")]
		public GetDeviceLiveToolsPingDeviceReturnResultsLoss Loss { get; set; }
		
		/// <summary>
		/// Number of packets received
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="received")]
		public System.Nullable<System.Int32> Received { get; set; }
		
		/// <summary>
		/// Received packets
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replies")]
		public GetDeviceLiveToolsPingDeviceReturnResultsReplies[] GetDeviceLiveToolsPingDeviceReturnResultsReplies { get; set; }
		
		/// <summary>
		/// Number of packets sent
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sent")]
		public System.Nullable<System.Int32> Sent { get; set; }
	}
	
	public class GetDeviceLiveToolsPingDeviceReturnResultsLatencies
	{
		
		/// <summary>
		/// Average latency
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="average")]
		public System.Nullable<System.Single> Average { get; set; }
		
		/// <summary>
		/// Maximum latency
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximum")]
		public System.Nullable<System.Single> Maximum { get; set; }
		
		/// <summary>
		/// Minimum latency
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimum")]
		public System.Nullable<System.Single> Minimum { get; set; }
	}
	
	public class GetDeviceLiveToolsPingDeviceReturnResultsLoss
	{
		
		/// <summary>
		/// Percentage of packets lost
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage")]
		public System.Nullable<System.Single> Percentage { get; set; }
	}
	
	public class GetDeviceLiveToolsPingDeviceReturnResultsReplies
	{
		
		/// <summary>
		/// Latency of the packet in milliseconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latency")]
		public System.Nullable<System.Single> Latency { get; set; }
		
		/// <summary>
		/// Sequence ID of the packet
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sequenceId")]
		public System.Nullable<System.Int32> SequenceId { get; set; }
		
		/// <summary>
		/// Size of the packet in bytes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
	}
	
	public enum GetDeviceLossAndLatencyHistoryUplink
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cellular = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wan1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wan2 = 2,
	}
	
	public class UpdateDeviceManagementInterfacePutBody
	{
		
		/// <summary>
		/// WAN 1 settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wan1")]
		public UpdateDeviceManagementInterfacePutBodyWan1 Wan1 { get; set; }
		
		/// <summary>
		/// WAN 2 settings (only for MX devices)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wan2")]
		public UpdateDeviceManagementInterfacePutBodyWan2 Wan2 { get; set; }
	}
	
	public class UpdateDeviceManagementInterfacePutBodyWan1
	{
		
		/// <summary>
		/// Up to two DNS IPs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticDns")]
		public string[] StaticDns { get; set; }
		
		/// <summary>
		/// The IP of the gateway on the WAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticGatewayIp")]
		public string StaticGatewayIp { get; set; }
		
		/// <summary>
		/// The IP the device should use on the WAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticIp")]
		public string StaticIp { get; set; }
		
		/// <summary>
		/// The subnet mask for the WAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticSubnetMask")]
		public string StaticSubnetMask { get; set; }
		
		/// <summary>
		/// Configure the interface to have static IP settings or use DHCP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usingStaticIp")]
		public System.Nullable<System.Boolean> UsingStaticIp { get; set; }
		
		/// <summary>
		/// The VLAN that management traffic should be tagged with. Applies whether usingStaticIp is true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
		
		/// <summary>
		/// Enable or disable the interface (only for MX devices). Valid values are 'enabled', 'disabled', and 'not configured'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wanEnabled")]
		public System.Nullable<UpdateDeviceManagementInterfacePutBodyWan1WanEnabled> WanEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceManagementInterfacePutBodyWan1WanEnabled
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="not configured")]
		not_configured = 2,
	}
	
	public class UpdateDeviceManagementInterfacePutBodyWan2
	{
		
		/// <summary>
		/// Up to two DNS IPs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticDns")]
		public string[] StaticDns { get; set; }
		
		/// <summary>
		/// The IP of the gateway on the WAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticGatewayIp")]
		public string StaticGatewayIp { get; set; }
		
		/// <summary>
		/// The IP the device should use on the WAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticIp")]
		public string StaticIp { get; set; }
		
		/// <summary>
		/// The subnet mask for the WAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticSubnetMask")]
		public string StaticSubnetMask { get; set; }
		
		/// <summary>
		/// Configure the interface to have static IP settings or use DHCP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usingStaticIp")]
		public System.Nullable<System.Boolean> UsingStaticIp { get; set; }
		
		/// <summary>
		/// The VLAN that management traffic should be tagged with. Applies whether usingStaticIp is true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
		
		/// <summary>
		/// Enable or disable the interface (only for MX devices). Valid values are 'enabled', 'disabled', and 'not configured'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wanEnabled")]
		public System.Nullable<UpdateDeviceManagementInterfacePutBodyWan2WanEnabled> WanEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceManagementInterfacePutBodyWan2WanEnabled
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="not configured")]
		not_configured = 2,
	}
	
	public class GetDeviceSensorRelationshipsReturn
	{
		
		/// <summary>
		/// A role defined between an MT sensor and an MV camera that adds the camera's livestream to the sensor's details page. Snapshots from the camera will also appear in alert notifications that the sensor triggers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="livestream")]
		public GetDeviceSensorRelationshipsReturnLivestream Livestream { get; set; }
	}
	
	public class GetDeviceSensorRelationshipsReturnLivestream
	{
		
		/// <summary>
		/// An array of the related devices for the role
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relatedDevices")]
		public GetDeviceSensorRelationshipsReturnLivestreamRelatedDevices[] GetDeviceSensorRelationshipsReturnLivestreamRelatedDevices { get; set; }
	}
	
	public class GetDeviceSensorRelationshipsReturnLivestreamRelatedDevices
	{
		
		/// <summary>
		/// The product type of the related device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productType")]
		public System.Nullable<GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesProductType> ProductType { get; set; }
		
		/// <summary>
		/// The serial of the related device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesProductType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		camera = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sensor = 1,
	}
	
	public class UpdateDeviceSensorRelationshipsPutBody
	{
		
		/// <summary>
		/// A role defined between an MT sensor and an MV camera that adds the camera's livestream to the sensor's details page. Snapshots from the camera will also appear in alert notifications that the sensor triggers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="livestream")]
		public UpdateDeviceSensorRelationshipsPutBodyLivestream Livestream { get; set; }
	}
	
	public class UpdateDeviceSensorRelationshipsPutBodyLivestream
	{
		
		/// <summary>
		/// An array of the related devices for the role
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relatedDevices")]
		public UpdateDeviceSensorRelationshipsPutBodyLivestreamRelatedDevices[] UpdateDeviceSensorRelationshipsPutBodyLivestreamRelatedDevices { get; set; }
	}
	
	public class UpdateDeviceSensorRelationshipsPutBodyLivestreamRelatedDevices
	{
		
		/// <summary>
		/// The serial of the related device
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class UpdateDeviceSensorRelationshipsReturn
	{
		
		/// <summary>
		/// A role defined between an MT sensor and an MV camera that adds the camera's livestream to the sensor's details page. Snapshots from the camera will also appear in alert notifications that the sensor triggers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="livestream")]
		public UpdateDeviceSensorRelationshipsReturnLivestream Livestream { get; set; }
	}
	
	public class UpdateDeviceSensorRelationshipsReturnLivestream
	{
		
		/// <summary>
		/// An array of the related devices for the role
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relatedDevices")]
		public UpdateDeviceSensorRelationshipsReturnLivestreamRelatedDevices[] UpdateDeviceSensorRelationshipsReturnLivestreamRelatedDevices { get; set; }
	}
	
	public class UpdateDeviceSensorRelationshipsReturnLivestreamRelatedDevices
	{
		
		/// <summary>
		/// The product type of the related device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productType")]
		public GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesProductType ProductType { get; set; }
		
		/// <summary>
		/// The serial of the related device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class GetDeviceSwitchPortsReturn
	{
		
		/// <summary>
		/// The number of a custom access policy to configure on the switch port. Only applicable when 'accessPolicyType' is 'Custom access policy'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyNumber")]
		public System.Nullable<System.Int32> AccessPolicyNumber { get; set; }
		
		/// <summary>
		/// The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyType")]
		public System.Nullable<GetDeviceSwitchPortsReturnAccessPolicyType> AccessPolicyType { get; set; }
		
		/// <summary>
		/// The adaptive policy group ID that will be used to tag traffic through this switch port. This ID must pre-exist during the configuration, else needs to be created using adaptivePolicy/groups API. Cannot be applied to a port on a switch bound to profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adaptivePolicyGroupId")]
		public string AdaptivePolicyGroupId { get; set; }
		
		/// <summary>
		/// The VLANs allowed on the switch port. Only applicable to trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedVlans")]
		public string AllowedVlans { get; set; }
		
		/// <summary>
		/// If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="daiTrusted")]
		public System.Nullable<System.Boolean> DaiTrusted { get; set; }
		
		/// <summary>
		/// The status of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="flexibleStackingEnabled")]
		public System.Nullable<System.Boolean> FlexibleStackingEnabled { get; set; }
		
		/// <summary>
		/// The isolation status of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isolationEnabled")]
		public System.Nullable<System.Boolean> IsolationEnabled { get; set; }
		
		/// <summary>
		/// The link speed for the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkNegotiation")]
		public string LinkNegotiation { get; set; }
		
		/// <summary>
		/// Available link speeds for the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkNegotiationCapabilities")]
		public string[] LinkNegotiationCapabilities { get; set; }
		
		/// <summary>
		/// Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="macAllowList")]
		public string[] MacAllowList { get; set; }
		
		/// <summary>
		/// The name of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// If true, Peer SGT is enabled for traffic through this switch port. Applicable to trunk port only, not access port. Cannot be applied to a port on a switch bound to profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerSgtCapable")]
		public System.Nullable<System.Boolean> PeerSgtCapable { get; set; }
		
		/// <summary>
		/// The PoE status of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="poeEnabled")]
		public System.Nullable<System.Boolean> PoeEnabled { get; set; }
		
		/// <summary>
		/// The identifier of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portId")]
		public string PortId { get; set; }
		
		/// <summary>
		/// The ID of the port schedule. A value of null will clear the port schedule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portScheduleId")]
		public string PortScheduleId { get; set; }
		
		/// <summary>
		/// Profile attributes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile")]
		public GetDeviceSwitchPortsReturnProfile Profile { get; set; }
		
		/// <summary>
		/// The rapid spanning tree protocol status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rstpEnabled")]
		public System.Nullable<System.Boolean> RstpEnabled { get; set; }
		
		/// <summary>
		/// The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stickyMacAllowList")]
		public string[] StickyMacAllowList { get; set; }
		
		/// <summary>
		/// The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stickyMacAllowListLimit")]
		public System.Nullable<System.Int32> StickyMacAllowListLimit { get; set; }
		
		/// <summary>
		/// The storm control status of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stormControlEnabled")]
		public System.Nullable<System.Boolean> StormControlEnabled { get; set; }
		
		/// <summary>
		/// The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stpGuard")]
		public System.Nullable<GetDeviceSwitchPortsReturnStpGuard> StpGuard { get; set; }
		
		/// <summary>
		/// The list of tags of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// The type of the switch port ('trunk' or 'access').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<GetDeviceSwitchPortsReturnType> Type { get; set; }
		
		/// <summary>
		/// The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="udld")]
		public System.Nullable<GetDeviceSwitchPortsReturnUdld> Udld { get; set; }
		
		/// <summary>
		/// The VLAN of the switch port. A null value will clear the value set for trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
		
		/// <summary>
		/// The voice VLAN of the switch port. Only applicable to access ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlan")]
		public System.Nullable<System.Int32> VoiceVlan { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetDeviceSwitchPortsReturnAccessPolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Custom access policy")]
		Custom_access_policy = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAC allow list")]
		MAC_allow_list = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Open = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Sticky MAC allow list")]
		Sticky_MAC_allow_list = 3,
	}
	
	public class GetDeviceSwitchPortsReturnProfile
	{
		
		/// <summary>
		/// When enabled, override this port's configuration with a port profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// When enabled, the ID of the port profile used to override the port's configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// When enabled, the IName of the profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iname")]
		public string Iname { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetDeviceSwitchPortsReturnStpGuard
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bpdu guard")]
		bpdu_guard = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="loop guard")]
		loop_guard = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="root guard")]
		root_guard = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetDeviceSwitchPortsReturnType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		access = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		trunk = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetDeviceSwitchPortsReturnUdld
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Alert only")]
		Alert_only = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enforce = 1,
	}
	
	public class CycleDeviceSwitchPortsPostBody
	{
		
		/// <summary>
		/// List of switch ports. Example: [1, 2-5, 1_MA-MOD-8X10G_1, 1_MA-MOD-8X10G_2-1_MA-MOD-8X10G_8]
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ports")]
		public string[] Ports { get; set; }
	}
	
	public class GetDeviceSwitchPortsStatusesReturn
	{
		
		/// <summary>
		/// The Cisco Discovery Protocol (CDP) information of the connected device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cdp")]
		public GetDeviceSwitchPortsStatusesReturnCdp Cdp { get; set; }
		
		/// <summary>
		/// The number of clients connected through this port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientCount")]
		public System.Nullable<System.Int32> ClientCount { get; set; }
		
		/// <summary>
		/// The current duplex of a connected port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duplex")]
		public System.Nullable<GetDeviceSwitchPortsStatusesReturnDuplex> Duplex { get; set; }
		
		/// <summary>
		/// Whether the port is configured to be enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// All errors present on the port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public string[] Errors { get; set; }
		
		/// <summary>
		/// Whether the port is the switch's uplink.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isUplink")]
		public System.Nullable<System.Boolean> IsUplink { get; set; }
		
		/// <summary>
		/// The Link Layer Discovery Protocol (LLDP) information of the connected device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lldp")]
		public GetDeviceSwitchPortsStatusesReturnLldp Lldp { get; set; }
		
		/// <summary>
		/// The string identifier of this port on the switch. This is commonly just the port number but may contain additional identifying information such as the slot and module-type if the port is located on a port module.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portId")]
		public string PortId { get; set; }
		
		/// <summary>
		/// How much power (in watt-hours) has been delivered by this port during the timespan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="powerUsageInWh")]
		public System.Nullable<System.Single> PowerUsageInWh { get; set; }
		
		/// <summary>
		/// The Secure Port status of the port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="securePort")]
		public GetDeviceSwitchPortsStatusesReturnSecurePort SecurePort { get; set; }
		
		/// <summary>
		/// The current data transfer rate which the port is operating at.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="speed")]
		public System.Nullable<GetDeviceSwitchPortsStatusesReturnSpeed> Speed { get; set; }
		
		/// <summary>
		/// The current connection status of the port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<GetDeviceSwitchPortsStatusesReturnStatus> Status { get; set; }
		
		/// <summary>
		/// A breakdown of the average speed of data that has passed through this port during the timespan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trafficInKbps")]
		public GetDeviceSwitchPortsStatusesReturnTrafficInKbps TrafficInKbps { get; set; }
		
		/// <summary>
		/// A breakdown of how many kilobytes have passed through this port during the timespan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usageInKb")]
		public GetDeviceSwitchPortsStatusesReturnUsageInKb UsageInKb { get; set; }
		
		/// <summary>
		/// All warnings present on the port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warnings")]
		public string[] Warnings { get; set; }
	}
	
	public class GetDeviceSwitchPortsStatusesReturnCdp
	{
		
		/// <summary>
		/// Contains network addresses of both receiving and sending devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// Identifies the device type, which indicates the functional capabilities of the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="capabilities")]
		public string Capabilities { get; set; }
		
		/// <summary>
		/// Identifies the device name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceId")]
		public string DeviceId { get; set; }
		
		/// <summary>
		/// The device's management IP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managementAddress")]
		public string ManagementAddress { get; set; }
		
		/// <summary>
		/// Indicates, per interface, the assumed VLAN for untagged packets on the interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nativeVlan")]
		public System.Nullable<System.Int32> NativeVlan { get; set; }
		
		/// <summary>
		/// Identifies the hardware platform of the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platform")]
		public string Platform { get; set; }
		
		/// <summary>
		/// Identifies the port from which the CDP packet was sent.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portId")]
		public string PortId { get; set; }
		
		/// <summary>
		/// The system name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="systemName")]
		public string SystemName { get; set; }
		
		/// <summary>
		/// Contains the device software release information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
		
		/// <summary>
		/// Advertises the configured VLAN Trunking Protocl (VTP)-management-domain name of the system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vtpManagementDomain")]
		public string VtpManagementDomain { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetDeviceSwitchPortsStatusesReturnDuplex
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="")]
		_ = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		full = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		half = 2,
	}
	
	public class GetDeviceSwitchPortsStatusesReturnLldp
	{
		
		/// <summary>
		/// The device's chassis ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="chassisId")]
		public string ChassisId { get; set; }
		
		/// <summary>
		/// The device's management IP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managementAddress")]
		public string ManagementAddress { get; set; }
		
		/// <summary>
		/// The device's management VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managementVlan")]
		public System.Nullable<System.Int32> ManagementVlan { get; set; }
		
		/// <summary>
		/// Description of the port from which the LLDP packet was sent.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portDescription")]
		public string PortDescription { get; set; }
		
		/// <summary>
		/// Identifies the port from which the LLDP packet was sent
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portId")]
		public string PortId { get; set; }
		
		/// <summary>
		/// The port's VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portVlan")]
		public System.Nullable<System.Int32> PortVlan { get; set; }
		
		/// <summary>
		/// Identifies the device type, which indicates the functional capabilities of the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="systemCapabilities")]
		public string SystemCapabilities { get; set; }
		
		/// <summary>
		/// The device's system description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="systemDescription")]
		public string SystemDescription { get; set; }
		
		/// <summary>
		/// The device's system name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="systemName")]
		public string SystemName { get; set; }
	}
	
	public class GetDeviceSwitchPortsStatusesReturnSecurePort
	{
		
		/// <summary>
		/// Whether Secure Port is currently active for this port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The current Secure Port status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authenticationStatus")]
		public System.Nullable<GetDeviceSwitchPortsStatusesReturnSecurePortAuthenticationStatus> AuthenticationStatus { get; set; }
		
		/// <summary>
		/// The configuration overrides applied to this port when Secure Port is active.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configOverrides")]
		public GetDeviceSwitchPortsStatusesReturnSecurePortConfigOverrides ConfigOverrides { get; set; }
		
		/// <summary>
		/// Whether Secure Port is turned on for this port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetDeviceSwitchPortsStatusesReturnSecurePortAuthenticationStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Authentication failure")]
		Authentication_failure = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Authentication in progress")]
		Authentication_in_progress = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Authentication successful")]
		Authentication_successful = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Authentication timed out")]
		Authentication_timed_out = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disabled = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enabled = 5,
	}
	
	public class GetDeviceSwitchPortsStatusesReturnSecurePortConfigOverrides
	{
		
		/// <summary>
		/// The VLANs allowed on the . Only applicable to trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedVlans")]
		public string AllowedVlans { get; set; }
		
		/// <summary>
		/// The type of the  ('trunk' or 'access').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GetDeviceSwitchPortsReturnType Type { get; set; }
		
		/// <summary>
		/// The VLAN of the . A null value will clear the value set for trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
		
		/// <summary>
		/// The voice VLAN of the . Only applicable to access ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlan")]
		public System.Nullable<System.Int32> VoiceVlan { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetDeviceSwitchPortsStatusesReturnSpeed
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="")]
		_ = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 Gbps")]
		_1_Gbps = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="10 Gbps")]
		_10_Gbps = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="10 Mbps")]
		_10_Mbps = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="100 Gbps")]
		_100_Gbps = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="100 Mbps")]
		_100_Mbps = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.5 Gbps")]
		_2_5_Gbps = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="20 Gbps")]
		_20_Gbps = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="40 Gbps")]
		_40_Gbps = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5 Gbps")]
		_5_Gbps = 9,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetDeviceSwitchPortsStatusesReturnStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Connected = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Disconnected = 2,
	}
	
	public class GetDeviceSwitchPortsStatusesReturnTrafficInKbps
	{
		
		/// <summary>
		/// The average speed of the data received (in kilobits-per-second).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recv")]
		public System.Nullable<System.Single> Recv { get; set; }
		
		/// <summary>
		/// The average speed of the data sent (in kilobits-per-second).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sent")]
		public System.Nullable<System.Single> Sent { get; set; }
		
		/// <summary>
		/// The average speed of the data sent and received (in kilobits-per-second).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Single> Total { get; set; }
	}
	
	public class GetDeviceSwitchPortsStatusesReturnUsageInKb
	{
		
		/// <summary>
		/// The amount of data received (in kilobytes).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recv")]
		public System.Nullable<System.Int32> Recv { get; set; }
		
		/// <summary>
		/// The amount of data sent (in kilobytes).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sent")]
		public System.Nullable<System.Int32> Sent { get; set; }
		
		/// <summary>
		/// The total amount of data sent and received (in kilobytes).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	public class GetDeviceSwitchPortReturn
	{
		
		/// <summary>
		/// The number of a custom access policy to configure on the switch port. Only applicable when 'accessPolicyType' is 'Custom access policy'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyNumber")]
		public System.Nullable<System.Int32> AccessPolicyNumber { get; set; }
		
		/// <summary>
		/// The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyType")]
		public System.Nullable<GetDeviceSwitchPortReturnAccessPolicyType> AccessPolicyType { get; set; }
		
		/// <summary>
		/// The adaptive policy group ID that will be used to tag traffic through this switch port. This ID must pre-exist during the configuration, else needs to be created using adaptivePolicy/groups API. Cannot be applied to a port on a switch bound to profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adaptivePolicyGroupId")]
		public string AdaptivePolicyGroupId { get; set; }
		
		/// <summary>
		/// The VLANs allowed on the switch port. Only applicable to trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedVlans")]
		public string AllowedVlans { get; set; }
		
		/// <summary>
		/// If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="daiTrusted")]
		public System.Nullable<System.Boolean> DaiTrusted { get; set; }
		
		/// <summary>
		/// The status of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="flexibleStackingEnabled")]
		public System.Nullable<System.Boolean> FlexibleStackingEnabled { get; set; }
		
		/// <summary>
		/// The isolation status of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isolationEnabled")]
		public System.Nullable<System.Boolean> IsolationEnabled { get; set; }
		
		/// <summary>
		/// The link speed for the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkNegotiation")]
		public string LinkNegotiation { get; set; }
		
		/// <summary>
		/// Available link speeds for the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkNegotiationCapabilities")]
		public string[] LinkNegotiationCapabilities { get; set; }
		
		/// <summary>
		/// Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="macAllowList")]
		public string[] MacAllowList { get; set; }
		
		/// <summary>
		/// The name of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// If true, Peer SGT is enabled for traffic through this switch port. Applicable to trunk port only, not access port. Cannot be applied to a port on a switch bound to profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerSgtCapable")]
		public System.Nullable<System.Boolean> PeerSgtCapable { get; set; }
		
		/// <summary>
		/// The PoE status of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="poeEnabled")]
		public System.Nullable<System.Boolean> PoeEnabled { get; set; }
		
		/// <summary>
		/// The identifier of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portId")]
		public string PortId { get; set; }
		
		/// <summary>
		/// The ID of the port schedule. A value of null will clear the port schedule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portScheduleId")]
		public string PortScheduleId { get; set; }
		
		/// <summary>
		/// Profile attributes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile")]
		public GetDeviceSwitchPortReturnProfile Profile { get; set; }
		
		/// <summary>
		/// The rapid spanning tree protocol status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rstpEnabled")]
		public System.Nullable<System.Boolean> RstpEnabled { get; set; }
		
		/// <summary>
		/// The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stickyMacAllowList")]
		public string[] StickyMacAllowList { get; set; }
		
		/// <summary>
		/// The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stickyMacAllowListLimit")]
		public System.Nullable<System.Int32> StickyMacAllowListLimit { get; set; }
		
		/// <summary>
		/// The storm control status of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stormControlEnabled")]
		public System.Nullable<System.Boolean> StormControlEnabled { get; set; }
		
		/// <summary>
		/// The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stpGuard")]
		public System.Nullable<GetDeviceSwitchPortReturnStpGuard> StpGuard { get; set; }
		
		/// <summary>
		/// The list of tags of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// The type of the switch port ('trunk' or 'access').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GetDeviceSwitchPortsReturnType Type { get; set; }
		
		/// <summary>
		/// The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="udld")]
		public System.Nullable<GetDeviceSwitchPortReturnUdld> Udld { get; set; }
		
		/// <summary>
		/// The VLAN of the switch port. A null value will clear the value set for trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
		
		/// <summary>
		/// The voice VLAN of the switch port. Only applicable to access ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlan")]
		public System.Nullable<System.Int32> VoiceVlan { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetDeviceSwitchPortReturnAccessPolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Custom access policy")]
		Custom_access_policy = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAC allow list")]
		MAC_allow_list = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Open = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Sticky MAC allow list")]
		Sticky_MAC_allow_list = 3,
	}
	
	public class GetDeviceSwitchPortReturnProfile
	{
		
		/// <summary>
		/// When enabled, override this port's configuration with a port profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// When enabled, the ID of the port profile used to override the port's configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// When enabled, the IName of the profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iname")]
		public string Iname { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetDeviceSwitchPortReturnStpGuard
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bpdu guard")]
		bpdu_guard = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="loop guard")]
		loop_guard = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="root guard")]
		root_guard = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetDeviceSwitchPortReturnUdld
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Alert only")]
		Alert_only = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enforce = 1,
	}
	
	public class UpdateDeviceSwitchPortPutBody
	{
		
		/// <summary>
		/// The number of a custom access policy to configure on the switch port. Only applicable when 'accessPolicyType' is 'Custom access policy'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyNumber")]
		public System.Nullable<System.Int32> AccessPolicyNumber { get; set; }
		
		/// <summary>
		/// The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyType")]
		public System.Nullable<UpdateDeviceSwitchPortPutBodyAccessPolicyType> AccessPolicyType { get; set; }
		
		/// <summary>
		/// The adaptive policy group ID that will be used to tag traffic through this switch port. This ID must pre-exist during the configuration, else needs to be created using adaptivePolicy/groups API. Cannot be applied to a port on a switch bound to profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adaptivePolicyGroupId")]
		public string AdaptivePolicyGroupId { get; set; }
		
		/// <summary>
		/// The VLANs allowed on the switch port. Only applicable to trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedVlans")]
		public string AllowedVlans { get; set; }
		
		/// <summary>
		/// If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="daiTrusted")]
		public System.Nullable<System.Boolean> DaiTrusted { get; set; }
		
		/// <summary>
		/// The status of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="flexibleStackingEnabled")]
		public System.Nullable<System.Boolean> FlexibleStackingEnabled { get; set; }
		
		/// <summary>
		/// The isolation status of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isolationEnabled")]
		public System.Nullable<System.Boolean> IsolationEnabled { get; set; }
		
		/// <summary>
		/// The link speed for the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkNegotiation")]
		public string LinkNegotiation { get; set; }
		
		/// <summary>
		/// Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="macAllowList")]
		public string[] MacAllowList { get; set; }
		
		/// <summary>
		/// The name of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// If true, Peer SGT is enabled for traffic through this switch port. Applicable to trunk port only, not access port. Cannot be applied to a port on a switch bound to profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerSgtCapable")]
		public System.Nullable<System.Boolean> PeerSgtCapable { get; set; }
		
		/// <summary>
		/// The PoE status of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="poeEnabled")]
		public System.Nullable<System.Boolean> PoeEnabled { get; set; }
		
		/// <summary>
		/// The ID of the port schedule. A value of null will clear the port schedule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portScheduleId")]
		public string PortScheduleId { get; set; }
		
		/// <summary>
		/// Profile attributes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile")]
		public UpdateDeviceSwitchPortPutBodyProfile Profile { get; set; }
		
		/// <summary>
		/// The rapid spanning tree protocol status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rstpEnabled")]
		public System.Nullable<System.Boolean> RstpEnabled { get; set; }
		
		/// <summary>
		/// The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stickyMacAllowList")]
		public string[] StickyMacAllowList { get; set; }
		
		/// <summary>
		/// The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stickyMacAllowListLimit")]
		public System.Nullable<System.Int32> StickyMacAllowListLimit { get; set; }
		
		/// <summary>
		/// The storm control status of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stormControlEnabled")]
		public System.Nullable<System.Boolean> StormControlEnabled { get; set; }
		
		/// <summary>
		/// The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stpGuard")]
		public System.Nullable<UpdateDeviceSwitchPortPutBodyStpGuard> StpGuard { get; set; }
		
		/// <summary>
		/// The list of tags of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// The type of the switch port ('trunk' or 'access').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GetDeviceSwitchPortsReturnType Type { get; set; }
		
		/// <summary>
		/// The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="udld")]
		public System.Nullable<UpdateDeviceSwitchPortPutBodyUdld> Udld { get; set; }
		
		/// <summary>
		/// The VLAN of the switch port. A null value will clear the value set for trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
		
		/// <summary>
		/// The voice VLAN of the switch port. Only applicable to access ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlan")]
		public System.Nullable<System.Int32> VoiceVlan { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceSwitchPortPutBodyAccessPolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Custom access policy")]
		Custom_access_policy = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAC allow list")]
		MAC_allow_list = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Open = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Sticky MAC allow list")]
		Sticky_MAC_allow_list = 3,
	}
	
	public class UpdateDeviceSwitchPortPutBodyProfile
	{
		
		/// <summary>
		/// When enabled, override this port's configuration with a port profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// When enabled, the ID of the port profile used to override the port's configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// When enabled, the IName of the profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iname")]
		public string Iname { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceSwitchPortPutBodyStpGuard
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bpdu guard")]
		bpdu_guard = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="loop guard")]
		loop_guard = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="root guard")]
		root_guard = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceSwitchPortPutBodyUdld
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Alert only")]
		Alert_only = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enforce = 1,
	}
	
	public class UpdateDeviceSwitchPortReturn
	{
		
		/// <summary>
		/// The number of a custom access policy to configure on the switch port. Only applicable when 'accessPolicyType' is 'Custom access policy'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyNumber")]
		public System.Nullable<System.Int32> AccessPolicyNumber { get; set; }
		
		/// <summary>
		/// The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyType")]
		public System.Nullable<UpdateDeviceSwitchPortReturnAccessPolicyType> AccessPolicyType { get; set; }
		
		/// <summary>
		/// The adaptive policy group ID that will be used to tag traffic through this switch port. This ID must pre-exist during the configuration, else needs to be created using adaptivePolicy/groups API. Cannot be applied to a port on a switch bound to profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adaptivePolicyGroupId")]
		public string AdaptivePolicyGroupId { get; set; }
		
		/// <summary>
		/// The VLANs allowed on the switch port. Only applicable to trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedVlans")]
		public string AllowedVlans { get; set; }
		
		/// <summary>
		/// If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="daiTrusted")]
		public System.Nullable<System.Boolean> DaiTrusted { get; set; }
		
		/// <summary>
		/// The status of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="flexibleStackingEnabled")]
		public System.Nullable<System.Boolean> FlexibleStackingEnabled { get; set; }
		
		/// <summary>
		/// The isolation status of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isolationEnabled")]
		public System.Nullable<System.Boolean> IsolationEnabled { get; set; }
		
		/// <summary>
		/// The link speed for the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkNegotiation")]
		public string LinkNegotiation { get; set; }
		
		/// <summary>
		/// Available link speeds for the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkNegotiationCapabilities")]
		public string[] LinkNegotiationCapabilities { get; set; }
		
		/// <summary>
		/// Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="macAllowList")]
		public string[] MacAllowList { get; set; }
		
		/// <summary>
		/// The name of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// If true, Peer SGT is enabled for traffic through this switch port. Applicable to trunk port only, not access port. Cannot be applied to a port on a switch bound to profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerSgtCapable")]
		public System.Nullable<System.Boolean> PeerSgtCapable { get; set; }
		
		/// <summary>
		/// The PoE status of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="poeEnabled")]
		public System.Nullable<System.Boolean> PoeEnabled { get; set; }
		
		/// <summary>
		/// The identifier of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portId")]
		public string PortId { get; set; }
		
		/// <summary>
		/// The ID of the port schedule. A value of null will clear the port schedule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portScheduleId")]
		public string PortScheduleId { get; set; }
		
		/// <summary>
		/// Profile attributes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile")]
		public UpdateDeviceSwitchPortReturnProfile Profile { get; set; }
		
		/// <summary>
		/// The rapid spanning tree protocol status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rstpEnabled")]
		public System.Nullable<System.Boolean> RstpEnabled { get; set; }
		
		/// <summary>
		/// The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stickyMacAllowList")]
		public string[] StickyMacAllowList { get; set; }
		
		/// <summary>
		/// The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stickyMacAllowListLimit")]
		public System.Nullable<System.Int32> StickyMacAllowListLimit { get; set; }
		
		/// <summary>
		/// The storm control status of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stormControlEnabled")]
		public System.Nullable<System.Boolean> StormControlEnabled { get; set; }
		
		/// <summary>
		/// The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stpGuard")]
		public System.Nullable<UpdateDeviceSwitchPortReturnStpGuard> StpGuard { get; set; }
		
		/// <summary>
		/// The list of tags of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// The type of the switch port ('trunk' or 'access').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GetDeviceSwitchPortsReturnType Type { get; set; }
		
		/// <summary>
		/// The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="udld")]
		public System.Nullable<UpdateDeviceSwitchPortReturnUdld> Udld { get; set; }
		
		/// <summary>
		/// The VLAN of the switch port. A null value will clear the value set for trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
		
		/// <summary>
		/// The voice VLAN of the switch port. Only applicable to access ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlan")]
		public System.Nullable<System.Int32> VoiceVlan { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceSwitchPortReturnAccessPolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Custom access policy")]
		Custom_access_policy = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAC allow list")]
		MAC_allow_list = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Open = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Sticky MAC allow list")]
		Sticky_MAC_allow_list = 3,
	}
	
	public class UpdateDeviceSwitchPortReturnProfile
	{
		
		/// <summary>
		/// When enabled, override this port's configuration with a port profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// When enabled, the ID of the port profile used to override the port's configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// When enabled, the IName of the profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iname")]
		public string Iname { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceSwitchPortReturnStpGuard
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bpdu guard")]
		bpdu_guard = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="loop guard")]
		loop_guard = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="root guard")]
		root_guard = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceSwitchPortReturnUdld
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Alert only")]
		Alert_only = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enforce = 1,
	}
	
	public class GetDeviceSwitchRoutingInterfacesReturn
	{
		
		/// <summary>
		/// IPv4 default gateway
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultGateway")]
		public string DefaultGateway { get; set; }
		
		/// <summary>
		/// The id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaceId")]
		public string InterfaceId { get; set; }
		
		/// <summary>
		/// IPv4 address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaceIp")]
		public string InterfaceIp { get; set; }
		
		/// <summary>
		/// IPv6 addressing
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public GetDeviceSwitchRoutingInterfacesReturnIpv6 Ipv6 { get; set; }
		
		/// <summary>
		/// Multicast routing status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multicastRouting")]
		public string MulticastRouting { get; set; }
		
		/// <summary>
		/// The name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// IPv4 OSPF Settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ospfSettings")]
		public GetDeviceSwitchRoutingInterfacesReturnOspfSettings OspfSettings { get; set; }
		
		/// <summary>
		/// IPv6 OSPF Settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ospfV3")]
		public GetDeviceSwitchRoutingInterfacesReturnOspfV3 OspfV3 { get; set; }
		
		/// <summary>
		/// IPv4 subnet
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
		
		/// <summary>
		/// VLAN id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public System.Nullable<System.Int32> VlanId { get; set; }
	}
	
	public class GetDeviceSwitchRoutingInterfacesReturnIpv6
	{
		
		/// <summary>
		/// IPv6 address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// Assignment mode
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignmentMode")]
		public string AssignmentMode { get; set; }
		
		/// <summary>
		/// IPv6 gateway
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// IPv6 subnet
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
	}
	
	public class GetDeviceSwitchRoutingInterfacesReturnOspfSettings
	{
		
		/// <summary>
		/// Area id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="area")]
		public string Area { get; set; }
		
		/// <summary>
		/// OSPF Cost
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cost")]
		public System.Nullable<System.Int32> Cost { get; set; }
		
		/// <summary>
		/// Disable sending Hello packets on this interface's IPv4 area
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPassiveEnabled")]
		public System.Nullable<System.Boolean> IsPassiveEnabled { get; set; }
	}
	
	public class GetDeviceSwitchRoutingInterfacesReturnOspfV3
	{
		
		/// <summary>
		/// Area id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="area")]
		public string Area { get; set; }
		
		/// <summary>
		/// OSPF Cost
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cost")]
		public System.Nullable<System.Int32> Cost { get; set; }
		
		/// <summary>
		/// Disable sending Hello packets on this interface's IPv6 area
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPassiveEnabled")]
		public System.Nullable<System.Boolean> IsPassiveEnabled { get; set; }
	}
	
	public class GetDeviceSwitchRoutingInterfaceReturn
	{
		
		/// <summary>
		/// IPv4 default gateway
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultGateway")]
		public string DefaultGateway { get; set; }
		
		/// <summary>
		/// The id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaceId")]
		public string InterfaceId { get; set; }
		
		/// <summary>
		/// IPv4 address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaceIp")]
		public string InterfaceIp { get; set; }
		
		/// <summary>
		/// IPv6 addressing
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public GetDeviceSwitchRoutingInterfaceReturnIpv6 Ipv6 { get; set; }
		
		/// <summary>
		/// Multicast routing status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multicastRouting")]
		public string MulticastRouting { get; set; }
		
		/// <summary>
		/// The name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// IPv4 OSPF Settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ospfSettings")]
		public GetDeviceSwitchRoutingInterfaceReturnOspfSettings OspfSettings { get; set; }
		
		/// <summary>
		/// IPv6 OSPF Settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ospfV3")]
		public GetDeviceSwitchRoutingInterfaceReturnOspfV3 OspfV3 { get; set; }
		
		/// <summary>
		/// IPv4 subnet
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
		
		/// <summary>
		/// VLAN id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public System.Nullable<System.Int32> VlanId { get; set; }
	}
	
	public class GetDeviceSwitchRoutingInterfaceReturnIpv6
	{
		
		/// <summary>
		/// IPv6 address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// Assignment mode
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignmentMode")]
		public string AssignmentMode { get; set; }
		
		/// <summary>
		/// IPv6 gateway
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// IPv6 subnet
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
	}
	
	public class GetDeviceSwitchRoutingInterfaceReturnOspfSettings
	{
		
		/// <summary>
		/// Area id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="area")]
		public string Area { get; set; }
		
		/// <summary>
		/// OSPF Cost
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cost")]
		public System.Nullable<System.Int32> Cost { get; set; }
		
		/// <summary>
		/// Disable sending Hello packets on this interface's IPv4 area
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPassiveEnabled")]
		public System.Nullable<System.Boolean> IsPassiveEnabled { get; set; }
	}
	
	public class GetDeviceSwitchRoutingInterfaceReturnOspfV3
	{
		
		/// <summary>
		/// Area id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="area")]
		public string Area { get; set; }
		
		/// <summary>
		/// OSPF Cost
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cost")]
		public System.Nullable<System.Int32> Cost { get; set; }
		
		/// <summary>
		/// Disable sending Hello packets on this interface's IPv6 area
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPassiveEnabled")]
		public System.Nullable<System.Boolean> IsPassiveEnabled { get; set; }
	}
	
	public class UpdateDeviceSwitchRoutingInterfaceReturn
	{
		
		/// <summary>
		/// IPv4 default gateway
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultGateway")]
		public string DefaultGateway { get; set; }
		
		/// <summary>
		/// The id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaceId")]
		public string InterfaceId { get; set; }
		
		/// <summary>
		/// IPv4 address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaceIp")]
		public string InterfaceIp { get; set; }
		
		/// <summary>
		/// IPv6 addressing
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public UpdateDeviceSwitchRoutingInterfaceReturnIpv6 Ipv6 { get; set; }
		
		/// <summary>
		/// Multicast routing status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multicastRouting")]
		public string MulticastRouting { get; set; }
		
		/// <summary>
		/// The name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// IPv4 OSPF Settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ospfSettings")]
		public UpdateDeviceSwitchRoutingInterfaceReturnOspfSettings OspfSettings { get; set; }
		
		/// <summary>
		/// IPv6 OSPF Settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ospfV3")]
		public UpdateDeviceSwitchRoutingInterfaceReturnOspfV3 OspfV3 { get; set; }
		
		/// <summary>
		/// IPv4 subnet
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
		
		/// <summary>
		/// VLAN id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public System.Nullable<System.Int32> VlanId { get; set; }
	}
	
	public class UpdateDeviceSwitchRoutingInterfaceReturnIpv6
	{
		
		/// <summary>
		/// IPv6 address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// Assignment mode
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignmentMode")]
		public string AssignmentMode { get; set; }
		
		/// <summary>
		/// IPv6 gateway
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// IPv6 subnet
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
	}
	
	public class UpdateDeviceSwitchRoutingInterfaceReturnOspfSettings
	{
		
		/// <summary>
		/// Area id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="area")]
		public string Area { get; set; }
		
		/// <summary>
		/// OSPF Cost
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cost")]
		public System.Nullable<System.Int32> Cost { get; set; }
		
		/// <summary>
		/// Disable sending Hello packets on this interface's IPv4 area
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPassiveEnabled")]
		public System.Nullable<System.Boolean> IsPassiveEnabled { get; set; }
	}
	
	public class UpdateDeviceSwitchRoutingInterfaceReturnOspfV3
	{
		
		/// <summary>
		/// Area id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="area")]
		public string Area { get; set; }
		
		/// <summary>
		/// OSPF Cost
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cost")]
		public System.Nullable<System.Int32> Cost { get; set; }
		
		/// <summary>
		/// Disable sending Hello packets on this interface's IPv6 area
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPassiveEnabled")]
		public System.Nullable<System.Boolean> IsPassiveEnabled { get; set; }
	}
	
	public class UpdateDeviceSwitchRoutingInterfaceDhcpPutBody
	{
		
		/// <summary>
		/// The PXE boot server filename for the DHCP server running on the switch interface
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bootFileName")]
		public string BootFileName { get; set; }
		
		/// <summary>
		/// The PXE boot server IP for the DHCP server running on the switch interface
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bootNextServer")]
		public string BootNextServer { get; set; }
		
		/// <summary>
		/// Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch interface
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bootOptionsEnabled")]
		public System.Nullable<System.Boolean> BootOptionsEnabled { get; set; }
		
		/// <summary>
		/// The DHCP lease time config for the dhcp server running on switch interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpLeaseTime")]
		public System.Nullable<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime> DhcpLeaseTime { get; set; }
		
		/// <summary>
		/// The DHCP mode options for the switch interface ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpMode")]
		public System.Nullable<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpMode> DhcpMode { get; set; }
		
		/// <summary>
		/// Array of DHCP options consisting of code, type and value for the DHCP server running on the switch interface
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpOptions")]
		public UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptions[] UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptions { get; set; }
		
		/// <summary>
		/// The DHCP relay server IPs to which DHCP packets would get relayed for the switch interface
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpRelayServerIps")]
		public string[] DhcpRelayServerIps { get; set; }
		
		/// <summary>
		/// The DHCP name server IPs when DHCP name server option is 'custom'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsCustomNameservers")]
		public string[] DnsCustomNameservers { get; set; }
		
		/// <summary>
		/// The DHCP name server option for the dhcp server running on the switch interface ('googlePublicDns', 'openDns' or 'custom')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsNameserversOption")]
		public System.Nullable<UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDnsNameserversOption> DnsNameserversOption { get; set; }
		
		/// <summary>
		/// Array of DHCP fixed IP assignments for the DHCP server running on the switch interface
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixedIpAssignments")]
		public UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyFixedIpAssignments[] UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyFixedIpAssignments { get; set; }
		
		/// <summary>
		/// Array of DHCP reserved IP assignments for the DHCP server running on the switch interface
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservedIpRanges")]
		public UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyReservedIpRanges[] UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyReservedIpRanges { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpLeaseTime
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 day")]
		_1_day = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 hour")]
		_1_hour = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 week")]
		_1_week = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="12 hours")]
		_12_hours = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="30 minutes")]
		_30_minutes = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4 hours")]
		_4_hours = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dhcpDisabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dhcpRelay = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dhcpServer = 2,
	}
	
	public class UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptions
	{
		
		/// <summary>
		/// The code for DHCP option which should be from 2 to 254
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType Type { get; set; }
		
		/// <summary>
		/// The value of the DHCP option
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hex = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		integer = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ip = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		text = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDnsNameserversOption
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		googlePublicDns = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		openDns = 2,
	}
	
	public class UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyFixedIpAssignments
	{
		
		/// <summary>
		/// The IP address of the client which has fixed IP address assigned to it
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// The MAC address of the client which has fixed IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// The name of the client which has fixed IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyReservedIpRanges
	{
		
		/// <summary>
		/// The comment for the reserved IP range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// The ending IP address of the reserved IP range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="end")]
		public string End { get; set; }
		
		/// <summary>
		/// The starting IP address of the reserved IP range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start")]
		public string Start { get; set; }
	}
	
	public class GetDeviceSwitchRoutingStaticRouteReturn
	{
		
		/// <summary>
		/// Option to advertise static routes via OSPF
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advertiseViaOspfEnabled")]
		public System.Nullable<System.Boolean> AdvertiseViaOspfEnabled { get; set; }
		
		/// <summary>
		/// The name or description of the layer 3 static route
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		///  The IP address of the router to which traffic for this destination network should be sent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nextHopIp")]
		public string NextHopIp { get; set; }
		
		/// <summary>
		/// Option to prefer static routes over OSPF routes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preferOverOspfRoutesEnabled")]
		public System.Nullable<System.Boolean> PreferOverOspfRoutesEnabled { get; set; }
		
		/// <summary>
		/// The identifier of a layer 3 static route
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticRouteId")]
		public string StaticRouteId { get; set; }
		
		/// <summary>
		/// The IP address of the subnetwork specified in CIDR notation (ex. 1.2.3.0/24)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
	}
	
	public class UpdateDeviceSwitchWarmSparePutBody
	{
		
		/// <summary>
		/// Enable or disable warm spare for a switch
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Serial number of the warm spare switch
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="spareSerial")]
		public string SpareSerial { get; set; }
	}
	
	public class GetDeviceWirelessBluetoothSettingsReturn
	{
		
		/// <summary>
		/// Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="major")]
		public System.Nullable<System.Int32> Major { get; set; }
		
		/// <summary>
		/// Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minor")]
		public System.Nullable<System.Int32> Minor { get; set; }
		
		/// <summary>
		/// Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uuid")]
		public string Uuid { get; set; }
	}
	
	public class UpdateDeviceWirelessBluetoothSettingsPutBody
	{
		
		/// <summary>
		/// Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="major")]
		public System.Nullable<System.Int32> Major { get; set; }
		
		/// <summary>
		/// Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minor")]
		public System.Nullable<System.Int32> Minor { get; set; }
		
		/// <summary>
		/// Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uuid")]
		public string Uuid { get; set; }
	}
	
	public class UpdateDeviceWirelessBluetoothSettingsReturn
	{
		
		/// <summary>
		/// Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="major")]
		public System.Nullable<System.Int32> Major { get; set; }
		
		/// <summary>
		/// Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minor")]
		public System.Nullable<System.Int32> Minor { get; set; }
		
		/// <summary>
		/// Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uuid")]
		public string Uuid { get; set; }
	}
	
	public enum GetDeviceWirelessConnectionStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
	}
	
	public class GetDeviceWirelessConnectionStatsReturn
	{
		
		/// <summary>
		/// The connection stats of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionStats")]
		public GetDeviceWirelessConnectionStatsReturnConnectionStats ConnectionStats { get; set; }
		
		/// <summary>
		/// The serial number for the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class GetDeviceWirelessConnectionStatsReturnConnectionStats
	{
		
		/// <summary>
		/// The number of failed association attempts
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assoc")]
		public System.Nullable<System.Int32> Assoc { get; set; }
		
		/// <summary>
		/// The number of failed authentication attempts
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="auth")]
		public System.Nullable<System.Int32> Auth { get; set; }
		
		/// <summary>
		/// The number of failed DHCP attempts
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcp")]
		public System.Nullable<System.Int32> Dhcp { get; set; }
		
		/// <summary>
		/// The number of failed DNS attempts
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dns")]
		public System.Nullable<System.Int32> Dns { get; set; }
		
		/// <summary>
		/// The number of successful connection attempts
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="success")]
		public System.Nullable<System.Int32> Success { get; set; }
	}
	
	public enum GetDeviceWirelessLatencyStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
	}
	
	public class UpdateDeviceWirelessRadioSettingsPutBody
	{
		
		/// <summary>
		/// Manual radio settings for 5 GHz.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fiveGhzSettings")]
		public UpdateDeviceWirelessRadioSettingsPutBodyFiveGhzSettings FiveGhzSettings { get; set; }
		
		/// <summary>
		/// The ID of an RF profile to assign to the device. If the value of this parameter is null, the appropriate basic RF profile (indoor or outdoor) will be assigned to the device. Assigning an RF profile will clear ALL manually configured overrides on the device (channel width, channel, power).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rfProfileId")]
		public string RfProfileId { get; set; }
		
		/// <summary>
		/// Manual radio settings for 2.4 GHz.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="twoFourGhzSettings")]
		public UpdateDeviceWirelessRadioSettingsPutBodyTwoFourGhzSettings TwoFourGhzSettings { get; set; }
	}
	
	public class UpdateDeviceWirelessRadioSettingsPutBodyFiveGhzSettings
	{
		
		/// <summary>
		/// Sets a manual channel for 5 GHz. Can be '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161', '165', '169', '173' or '177' or null for using auto channel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="channel")]
		public System.Nullable<UpdateDeviceWirelessRadioSettingsPutBodyFiveGhzSettingsChannel> Channel { get; set; }
		
		/// <summary>
		/// Sets a manual channel for 5 GHz. Can be '0', '20', '40', '80' or '160' or null for using auto channel width.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="channelWidth")]
		public System.Nullable<UpdateDeviceWirelessRadioSettingsPutBodyFiveGhzSettingsChannelWidth> ChannelWidth { get; set; }
		
		/// <summary>
		/// Set a manual target power for 5 GHz. Can be between '8' or '30' or null for using auto power range.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetPower")]
		public System.Nullable<System.Int32> TargetPower { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceWirelessRadioSettingsPutBodyFiveGhzSettingsChannel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_36 = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_40 = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_44 = 44,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_48 = 48,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_52 = 52,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_56 = 56,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_60 = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_64 = 64,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_100 = 100,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_104 = 104,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_108 = 108,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_112 = 112,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_116 = 116,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_120 = 120,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_124 = 124,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_128 = 128,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_132 = 132,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_136 = 136,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_140 = 140,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_144 = 144,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_149 = 149,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_153 = 153,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_157 = 157,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_161 = 161,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_165 = 165,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_169 = 169,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_173 = 173,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_177 = 177,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceWirelessRadioSettingsPutBodyFiveGhzSettingsChannelWidth
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_20 = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_40 = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_80 = 80,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_160 = 160,
	}
	
	public class UpdateDeviceWirelessRadioSettingsPutBodyTwoFourGhzSettings
	{
		
		/// <summary>
		/// Sets a manual channel for 2.4 GHz. Can be '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13' or '14' or null for using auto channel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="channel")]
		public System.Nullable<UpdateDeviceWirelessRadioSettingsPutBodyTwoFourGhzSettingsChannel> Channel { get; set; }
		
		/// <summary>
		/// Set a manual target power for 2.4 GHz. Can be between '5' or '30' or null for using auto power range.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetPower")]
		public System.Nullable<System.Int32> TargetPower { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateDeviceWirelessRadioSettingsPutBodyTwoFourGhzSettingsChannel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_4 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_5 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_6 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_7 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_8 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_9 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_10 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_11 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_12 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_13 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_14 = 14,
	}
	
	public class GetNetworkReturn
	{
		
		/// <summary>
		/// Enrollment string for the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enrollmentString")]
		public string EnrollmentString { get; set; }
		
		/// <summary>
		/// Network ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// If the network is bound to a config template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isBoundToConfigTemplate")]
		public System.Nullable<System.Boolean> IsBoundToConfigTemplate { get; set; }
		
		/// <summary>
		/// Network name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Notes for the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// Organization ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organizationId")]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// List of the product types that the network supports
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productTypes")]
		public string[] ProductTypes { get; set; }
		
		/// <summary>
		/// Network tags
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// Timezone of the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeZone")]
		public string TimeZone { get; set; }
		
		/// <summary>
		/// URL to the network Dashboard UI
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class UpdateNetworkPutBody
	{
		
		/// <summary>
		/// A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enrollmentString")]
		public string EnrollmentString { get; set; }
		
		/// <summary>
		/// The name of the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Add any notes or additional information about this network here.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// A list of tags to be applied to the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// The timezone of the network. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeZone")]
		public string TimeZone { get; set; }
	}
	
	public class UpdateNetworkReturn
	{
		
		/// <summary>
		/// Enrollment string for the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enrollmentString")]
		public string EnrollmentString { get; set; }
		
		/// <summary>
		/// Network ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// If the network is bound to a config template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isBoundToConfigTemplate")]
		public System.Nullable<System.Boolean> IsBoundToConfigTemplate { get; set; }
		
		/// <summary>
		/// Network name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Notes for the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// Organization ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organizationId")]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// List of the product types that the network supports
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productTypes")]
		public string[] ProductTypes { get; set; }
		
		/// <summary>
		/// Network tags
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// Timezone of the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeZone")]
		public string TimeZone { get; set; }
		
		/// <summary>
		/// URL to the network Dashboard UI
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetNetworkAlertsHistoryReturn
	{
		
		/// <summary>
		/// relevant data about the event that caused the alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alertData")]
		public string AlertData { get; set; }
		
		/// <summary>
		/// user friendly alert type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alertType")]
		public string AlertType { get; set; }
		
		/// <summary>
		/// type of alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alertTypeId")]
		public string AlertTypeId { get; set; }
		
		/// <summary>
		/// the destinations this alert is configured to be delivered to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinations")]
		public GetNetworkAlertsHistoryReturnDestinations Destinations { get; set; }
		
		/// <summary>
		/// info related to the device that caused the alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="device")]
		public GetNetworkAlertsHistoryReturnDevice Device { get; set; }
		
		/// <summary>
		/// time when the event occurred
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="occurredAt")]
		public string OccurredAt { get; set; }
	}
	
	public class GetNetworkAlertsHistoryReturnDestinations
	{
		
		/// <summary>
		/// email destinations for this alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public GetNetworkAlertsHistoryReturnDestinationsEmail Email { get; set; }
		
		/// <summary>
		/// push destinations for this alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="push")]
		public GetNetworkAlertsHistoryReturnDestinationsPush Push { get; set; }
		
		/// <summary>
		/// sms destinations for this alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sms")]
		public GetNetworkAlertsHistoryReturnDestinationsSms Sms { get; set; }
		
		/// <summary>
		/// webhook destinations for this alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="webhook")]
		public GetNetworkAlertsHistoryReturnDestinationsWebhook Webhook { get; set; }
	}
	
	public class GetNetworkAlertsHistoryReturnDestinationsEmail
	{
		
		/// <summary>
		/// time when the alert was sent to the user(s) for this channel
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sentAt")]
		public string SentAt { get; set; }
	}
	
	public class GetNetworkAlertsHistoryReturnDestinationsPush
	{
		
		/// <summary>
		/// time when the alert was sent to the user(s) for this channel
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sentAt")]
		public string SentAt { get; set; }
	}
	
	public class GetNetworkAlertsHistoryReturnDestinationsSms
	{
		
		/// <summary>
		/// time when the alert was sent to the user(s) for this channel
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sentAt")]
		public string SentAt { get; set; }
	}
	
	public class GetNetworkAlertsHistoryReturnDestinationsWebhook
	{
		
		/// <summary>
		/// time when the alert was sent to the user(s) for this channel
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sentAt")]
		public string SentAt { get; set; }
	}
	
	public class GetNetworkAlertsHistoryReturnDevice
	{
		
		/// <summary>
		/// device serial
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class UpdateNetworkAlertsSettingsPutBody
	{
		
		/// <summary>
		/// Alert-specific configuration for each type. Only alerts that pertain to the network can be updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alerts")]
		public UpdateNetworkAlertsSettingsPutBodyAlerts[] UpdateNetworkAlertsSettingsPutBodyAlerts { get; set; }
		
		/// <summary>
		/// The network-wide destinations for all alerts on the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultDestinations")]
		public UpdateNetworkAlertsSettingsPutBodyDefaultDestinations DefaultDestinations { get; set; }
	}
	
	public class UpdateNetworkAlertsSettingsPutBodyAlerts
	{
		
		/// <summary>
		/// A hash of destinations for this specific alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alertDestinations")]
		public UpdateNetworkAlertsSettingsPutBodyAlertsAlertDestinations AlertDestinations { get; set; }
		
		/// <summary>
		/// A boolean depicting if the alert is turned on or off
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// A hash of specific configuration data for the alert. Only filters specific to the alert will be updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filters")]
		public string Filters { get; set; }
		
		/// <summary>
		/// The type of alert
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class UpdateNetworkAlertsSettingsPutBodyAlertsAlertDestinations
	{
		
		/// <summary>
		/// If true, then all network admins will receive emails for this alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allAdmins")]
		public System.Nullable<System.Boolean> AllAdmins { get; set; }
		
		/// <summary>
		/// A list of emails that will receive information about the alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emails")]
		public string[] Emails { get; set; }
		
		/// <summary>
		/// A list of HTTP server IDs to send a Webhook to for this alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpServerIds")]
		public string[] HttpServerIds { get; set; }
		
		/// <summary>
		/// If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snmp")]
		public System.Nullable<System.Boolean> Snmp { get; set; }
	}
	
	public class UpdateNetworkAlertsSettingsPutBodyDefaultDestinations
	{
		
		/// <summary>
		/// If true, then all network admins will receive emails.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allAdmins")]
		public System.Nullable<System.Boolean> AllAdmins { get; set; }
		
		/// <summary>
		/// A list of emails that will recieve the alert(s).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emails")]
		public string[] Emails { get; set; }
		
		/// <summary>
		/// A list of HTTP server IDs to send a Webhook to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpServerIds")]
		public string[] HttpServerIds { get; set; }
		
		/// <summary>
		/// If true, then an SNMP trap will be sent if there is an SNMP trap server configured for this network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snmp")]
		public System.Nullable<System.Boolean> Snmp { get; set; }
	}
	
	public enum GetNetworkApplianceClientSecurityEventsSortOrder
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ascending = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		descending = 1,
	}
	
	public class UpdateNetworkApplianceConnectivityMonitoringDestinationsPutBody
	{
		
		/// <summary>
		/// The list of connectivity monitoring destinations
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinations")]
		public UpdateNetworkApplianceConnectivityMonitoringDestinationsPutBodyDestinations[] UpdateNetworkApplianceConnectivityMonitoringDestinationsPutBodyDestinations { get; set; }
	}
	
	public class UpdateNetworkApplianceConnectivityMonitoringDestinationsPutBodyDestinations
	{
		
		/// <summary>
		/// Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="default")]
		public System.Nullable<System.Boolean> Default { get; set; }
		
		/// <summary>
		/// Description of the testing destination. Optional, defaults to null
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The IP address to test connectivity with
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class UpdateNetworkApplianceContentFilteringPutBody
	{
		
		/// <summary>
		/// A list of URL patterns that are allowed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedUrlPatterns")]
		public string[] AllowedUrlPatterns { get; set; }
		
		/// <summary>
		/// A list of URL categories to block
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockedUrlCategories")]
		public string[] BlockedUrlCategories { get; set; }
		
		/// <summary>
		/// A list of URL patterns that are blocked
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockedUrlPatterns")]
		public string[] BlockedUrlPatterns { get; set; }
		
		/// <summary>
		/// URL category list size which is either 'topSites' or 'fullList'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlCategoryListSize")]
		public System.Nullable<UpdateNetworkApplianceContentFilteringPutBodyUrlCategoryListSize> UrlCategoryListSize { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceContentFilteringPutBodyUrlCategoryListSize
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		fullList = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		topSites = 1,
	}
	
	public class UpdateNetworkApplianceFirewallFirewalledServicePutBody
	{
		
		/// <summary>
		/// A string indicating the rule for which IPs are allowed to use the specified service. Acceptable values are "blocked" (no remote IPs can access the service), "restricted" (only allowed IPs can access the service), and "unrestriced" (any remote IP can access the service). This field is required
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public UpdateNetworkApplianceFirewallFirewalledServicePutBodyAccess Access { get; set; }
		
		/// <summary>
		/// An array of allowed IPs that can access the service. This field is required if "access" is set to "restricted". Otherwise this field is ignored
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedIps")]
		public string[] AllowedIps { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceFirewallFirewalledServicePutBodyAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		blocked = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		restricted = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unrestricted = 2,
	}
	
	public class UpdateNetworkApplianceFirewallL7FirewallRulesPutBody
	{
		
		/// <summary>
		/// An ordered array of the MX L7 firewall rules
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRules[] UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRules { get; set; }
	}
	
	public class UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRules
	{
		
		/// <summary>
		/// 'Deny' traffic specified by this rule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public System.Nullable<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesPolicy> Policy { get; set; }
		
		/// <summary>
		/// Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesType> Type { get; set; }
		
		/// <summary>
		/// The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. The application categories and application ids can be retrieved from the the 'MX L7 application categories' endpoint. The countries follow the two-letter ISO 3166-1 alpha-2 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesPolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deny = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		application = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		applicationCategory = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		host = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ipRange = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		port = 4,
	}
	
	public class UpdateNetworkApplianceFirewallOneToManyNatRulesPutBody
	{
		
		/// <summary>
		/// An array of 1:Many nat rules
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRules[] UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRules { get; set; }
	}
	
	public class UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRules
	{
		
		/// <summary>
		/// An array of associated forwarding rules
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portRules")]
		public UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesPortRules[] UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesPortRules { get; set; }
		
		/// <summary>
		/// The IP address that will be used to access the internal resource from the WAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="publicIp")]
		public string PublicIp { get; set; }
		
		/// <summary>
		/// The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="uplink")]
		public UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesUplink Uplink { get; set; }
	}
	
	public class UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesPortRules
	{
		
		/// <summary>
		/// Remote IP addresses or ranges that are permitted to access the internal resource via this port forwarding rule, or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedIps")]
		public string[] AllowedIps { get; set; }
		
		/// <summary>
		/// Local IP address to which traffic will be forwarded
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localIp")]
		public string LocalIp { get; set; }
		
		/// <summary>
		/// Destination port of the forwarded traffic that will be sent from the MX to the specified host on the LAN. If you simply wish to forward the traffic without translating the port, this should be the same as the Public port
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localPort")]
		public string LocalPort { get; set; }
		
		/// <summary>
		/// A description of the rule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// 'tcp' or 'udp'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public System.Nullable<UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesPortRulesProtocol> Protocol { get; set; }
		
		/// <summary>
		/// Destination port of the traffic that is arriving on the WAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicPort")]
		public string PublicPort { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesPortRulesProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tcp = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		udp = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesUplink
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		internet1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		internet2 = 1,
	}
	
	public class UpdateNetworkApplianceFirewallOneToOneNatRulesPutBody
	{
		
		/// <summary>
		/// An array of 1:1 nat rules
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRules[] UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRules { get; set; }
	}
	
	public class UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRules
	{
		
		/// <summary>
		/// The ports this mapping will provide access on, and the remote IPs that will be allowed access to the resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedInbound")]
		public UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRulesAllowedInbound[] UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRulesAllowedInbound { get; set; }
		
		/// <summary>
		/// The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lanIp")]
		public string LanIp { get; set; }
		
		/// <summary>
		/// A descriptive name for the rule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The IP address that will be used to access the internal resource from the WAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicIp")]
		public string PublicIp { get; set; }
		
		/// <summary>
		/// The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uplink")]
		public UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesUplink Uplink { get; set; }
	}
	
	public class UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRulesAllowedInbound
	{
		
		/// <summary>
		/// An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges, or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedIps")]
		public string[] AllowedIps { get; set; }
		
		/// <summary>
		/// An array of ports or port ranges that will be forwarded to the host on the LAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinationPorts")]
		public string[] DestinationPorts { get; set; }
		
		/// <summary>
		/// Either of the following: 'tcp', 'udp', 'icmp-ping' or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public System.Nullable<UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRulesAllowedInboundProtocol> Protocol { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceFirewallOneToOneNatRulesPutBodyRulesAllowedInboundProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		any = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="icmp-ping")]
		icmpMinusping = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tcp = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		udp = 3,
	}
	
	public class UpdateNetworkApplianceFirewallPortForwardingRulesPutBody
	{
		
		/// <summary>
		/// An array of port forwarding params
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkApplianceFirewallPortForwardingRulesPutBodyRules[] UpdateNetworkApplianceFirewallPortForwardingRulesPutBodyRules { get; set; }
	}
	
	public class UpdateNetworkApplianceFirewallPortForwardingRulesPutBodyRules
	{
		
		/// <summary>
		/// An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges (or any)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="allowedIps")]
		public string[] AllowedIps { get; set; }
		
		/// <summary>
		/// The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lanIp")]
		public string LanIp { get; set; }
		
		/// <summary>
		/// A port or port ranges that will receive the forwarded traffic from the WAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="localPort")]
		public string LocalPort { get; set; }
		
		/// <summary>
		/// A descriptive name for the rule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// TCP or UDP
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public UpdateNetworkApplianceFirewallOneToManyNatRulesPutBodyRulesPortRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// A port or port ranges that will be forwarded to the host on the LAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="publicPort")]
		public string PublicPort { get; set; }
		
		/// <summary>
		/// The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2' or 'both')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uplink")]
		public System.Nullable<UpdateNetworkApplianceFirewallPortForwardingRulesPutBodyRulesUplink> Uplink { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceFirewallPortForwardingRulesPutBodyRulesUplink
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		both = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		internet1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		internet2 = 2,
	}
	
	public class UpdateNetworkApplianceFirewallSettingsPutBody
	{
		
		/// <summary>
		/// Spoofing protection settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="spoofingProtection")]
		public UpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtection SpoofingProtection { get; set; }
	}
	
	public class UpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtection
	{
		
		/// <summary>
		/// IP source address spoofing settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipSourceGuard")]
		public UpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtectionIpSourceGuard IpSourceGuard { get; set; }
	}
	
	public class UpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtectionIpSourceGuard
	{
		
		/// <summary>
		/// Mode of protection
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public System.Nullable<UpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtectionIpSourceGuardMode> Mode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceFirewallSettingsPutBodySpoofingProtectionIpSourceGuardMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		block = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		log = 1,
	}
	
	public class GetNetworkAppliancePortsReturn
	{
		
		/// <summary>
		/// The name of the policy. Only applicable to Access ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicy")]
		public string AccessPolicy { get; set; }
		
		/// <summary>
		/// Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedVlans")]
		public string AllowedVlans { get; set; }
		
		/// <summary>
		/// Whether the trunk port can drop all untagged traffic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dropUntaggedTraffic")]
		public System.Nullable<System.Boolean> DropUntaggedTraffic { get; set; }
		
		/// <summary>
		/// The status of the port
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Number of the port
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Int32> Number { get; set; }
		
		/// <summary>
		/// The type of the port: 'access' or 'trunk'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class GetNetworkAppliancePortReturn
	{
		
		/// <summary>
		/// The name of the policy. Only applicable to Access ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicy")]
		public string AccessPolicy { get; set; }
		
		/// <summary>
		/// Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedVlans")]
		public string AllowedVlans { get; set; }
		
		/// <summary>
		/// Whether the trunk port can drop all untagged traffic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dropUntaggedTraffic")]
		public System.Nullable<System.Boolean> DropUntaggedTraffic { get; set; }
		
		/// <summary>
		/// The status of the port
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Number of the port
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Int32> Number { get; set; }
		
		/// <summary>
		/// The type of the port: 'access' or 'trunk'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class UpdateNetworkAppliancePortPutBody
	{
		
		/// <summary>
		/// The name of the policy. Only applicable to Access ports. Valid values are: 'open', '8021x-radius', 'mac-radius', 'hybris-radius' for MX64 or Z3 or any MX supporting the per port authentication feature. Otherwise, 'open' is the only valid value and 'open' is the default value if the field is missing.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicy")]
		public string AccessPolicy { get; set; }
		
		/// <summary>
		/// Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedVlans")]
		public string AllowedVlans { get; set; }
		
		/// <summary>
		/// Trunk port can Drop all Untagged traffic. When true, no VLAN is required. Access ports cannot have dropUntaggedTraffic set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dropUntaggedTraffic")]
		public System.Nullable<System.Boolean> DropUntaggedTraffic { get; set; }
		
		/// <summary>
		/// The status of the port
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The type of the port: 'access' or 'trunk'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class UpdateNetworkAppliancePortReturn
	{
		
		/// <summary>
		/// The name of the policy. Only applicable to Access ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicy")]
		public string AccessPolicy { get; set; }
		
		/// <summary>
		/// Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedVlans")]
		public string AllowedVlans { get; set; }
		
		/// <summary>
		/// Whether the trunk port can drop all untagged traffic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dropUntaggedTraffic")]
		public System.Nullable<System.Boolean> DropUntaggedTraffic { get; set; }
		
		/// <summary>
		/// The status of the port
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Number of the port
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Int32> Number { get; set; }
		
		/// <summary>
		/// The type of the port: 'access' or 'trunk'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class GetNetworkAppliancePrefixesDelegatedStaticsReturn
	{
		
		/// <summary>
		/// Prefix creation time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.Nullable<System.DateTimeOffset> CreatedAt { get; set; }
		
		/// <summary>
		/// Identifying description for the prefix.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// WAN1/WAN2/Independent prefix.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public GetNetworkAppliancePrefixesDelegatedStaticsReturnOrigin Origin { get; set; }
		
		/// <summary>
		/// IPv6 prefix/prefix length.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
		
		/// <summary>
		/// Static delegated prefix id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticDelegatedPrefixId")]
		public string StaticDelegatedPrefixId { get; set; }
		
		/// <summary>
		/// Prefix Updated time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.Nullable<System.DateTimeOffset> UpdatedAt { get; set; }
	}
	
	public class GetNetworkAppliancePrefixesDelegatedStaticsReturnOrigin
	{
		
		/// <summary>
		/// Uplink provided or independent
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaces")]
		public string[] Interfaces { get; set; }
		
		/// <summary>
		/// Origin type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class CreateNetworkAppliancePrefixesDelegatedStaticPostBody
	{
		
		/// <summary>
		/// A name or description for the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The origin of the prefix
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOrigin Origin { get; set; }
		
		/// <summary>
		/// A static IPv6 prefix
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
	}
	
	public class CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOrigin
	{
		
		/// <summary>
		/// Interfaces associated with the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaces")]
		public string[] Interfaces { get; set; }
		
		/// <summary>
		/// Type of the origin
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		independent = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		internet = 1,
	}
	
	public class GetNetworkAppliancePrefixesDelegatedStaticReturn
	{
		
		/// <summary>
		/// Prefix creation time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.Nullable<System.DateTimeOffset> CreatedAt { get; set; }
		
		/// <summary>
		/// Identifying description for the prefix.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// WAN1/WAN2/Independent prefix.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public GetNetworkAppliancePrefixesDelegatedStaticReturnOrigin Origin { get; set; }
		
		/// <summary>
		/// IPv6 prefix/prefix length.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
		
		/// <summary>
		/// Static delegated prefix id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticDelegatedPrefixId")]
		public string StaticDelegatedPrefixId { get; set; }
		
		/// <summary>
		/// Prefix Updated time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.Nullable<System.DateTimeOffset> UpdatedAt { get; set; }
	}
	
	public class GetNetworkAppliancePrefixesDelegatedStaticReturnOrigin
	{
		
		/// <summary>
		/// Uplink provided or independent
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaces")]
		public string[] Interfaces { get; set; }
		
		/// <summary>
		/// Origin type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class UpdateNetworkAppliancePrefixesDelegatedStaticPutBody
	{
		
		/// <summary>
		/// A name or description for the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The origin of the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public UpdateNetworkAppliancePrefixesDelegatedStaticPutBodyOrigin Origin { get; set; }
		
		/// <summary>
		/// A static IPv6 prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
	}
	
	public class UpdateNetworkAppliancePrefixesDelegatedStaticPutBodyOrigin
	{
		
		/// <summary>
		/// Interfaces associated with the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaces")]
		public string[] Interfaces { get; set; }
		
		/// <summary>
		/// Type of the origin
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType Type { get; set; }
	}
	
	public class UpdateNetworkApplianceSecurityIntrusionPutBody
	{
		
		/// <summary>
		/// Set the detection ruleset 'connectivity'/'balanced'/'security' (optional - omitting will leave current config unchanged). Default value is 'balanced' if none currently saved
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="idsRulesets")]
		public System.Nullable<UpdateNetworkApplianceSecurityIntrusionPutBodyIdsRulesets> IdsRulesets { get; set; }
		
		/// <summary>
		/// Set mode to 'disabled'/'detection'/'prevention' (optional - omitting will leave current config unchanged)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public System.Nullable<UpdateNetworkApplianceSecurityIntrusionPutBodyMode> Mode { get; set; }
		
		/// <summary>
		/// Set the included/excluded networks from the intrusion engine (optional - omitting will leave current config unchanged). This is available only in 'passthrough' mode
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protectedNetworks")]
		public UpdateNetworkApplianceSecurityIntrusionPutBodyProtectedNetworks ProtectedNetworks { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceSecurityIntrusionPutBodyIdsRulesets
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		balanced = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		connectivity = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		security = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceSecurityIntrusionPutBodyMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		detection = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		prevention = 2,
	}
	
	public class UpdateNetworkApplianceSecurityIntrusionPutBodyProtectedNetworks
	{
		
		/// <summary>
		/// list of IP addresses or subnets being excluded from protection (required if 'useDefault' is false)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="excludedCidr")]
		public string[] ExcludedCidr { get; set; }
		
		/// <summary>
		/// list of IP addresses or subnets being protected (required if 'useDefault' is false)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includedCidr")]
		public string[] IncludedCidr { get; set; }
		
		/// <summary>
		/// true/false whether to use special IPv4 addresses: https://tools.ietf.org/html/rfc5735 (required). Default value is true if none currently saved
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useDefault")]
		public System.Nullable<System.Boolean> UseDefault { get; set; }
	}
	
	public class UpdateNetworkApplianceSecurityMalwarePutBody
	{
		
		/// <summary>
		/// The sha256 digests of files that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedFiles")]
		public UpdateNetworkApplianceSecurityMalwarePutBodyAllowedFiles[] UpdateNetworkApplianceSecurityMalwarePutBodyAllowedFiles { get; set; }
		
		/// <summary>
		/// The urls that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedUrls")]
		public UpdateNetworkApplianceSecurityMalwarePutBodyAllowedUrls[] UpdateNetworkApplianceSecurityMalwarePutBodyAllowedUrls { get; set; }
		
		/// <summary>
		/// Set mode to 'enabled' to enable malware prevention, otherwise 'disabled'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public UpdateNetworkApplianceSecurityMalwarePutBodyMode Mode { get; set; }
	}
	
	public class UpdateNetworkApplianceSecurityMalwarePutBodyAllowedFiles
	{
		
		/// <summary>
		/// Comment about the allowed entity
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// The file sha256 hash to allow
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sha256")]
		public string Sha256 { get; set; }
	}
	
	public class UpdateNetworkApplianceSecurityMalwarePutBodyAllowedUrls
	{
		
		/// <summary>
		/// Comment about the allowed entity
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// The url to allow
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceSecurityMalwarePutBodyMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 1,
	}
	
	public class GetNetworkApplianceSettingsReturn
	{
		
		/// <summary>
		/// Client tracking method of a network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientTrackingMethod")]
		public System.Nullable<GetNetworkApplianceSettingsReturnClientTrackingMethod> ClientTrackingMethod { get; set; }
		
		/// <summary>
		/// Deployment mode of a network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deploymentMode")]
		public System.Nullable<GetNetworkApplianceSettingsReturnDeploymentMode> DeploymentMode { get; set; }
		
		/// <summary>
		/// Dynamic DNS settings for a network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dynamicDns")]
		public GetNetworkApplianceSettingsReturnDynamicDns DynamicDns { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkApplianceSettingsReturnClientTrackingMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IP address")]
		IP_address = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAC address")]
		MAC_address = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unique client identifier")]
		Unique_client_identifier = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkApplianceSettingsReturnDeploymentMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		passthrough = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		routed = 1,
	}
	
	public class GetNetworkApplianceSettingsReturnDynamicDns
	{
		
		/// <summary>
		/// Dynamic DNS enabled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Dynamic DNS url prefix. DDNS must be enabled to update
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
		
		/// <summary>
		/// Dynamic DNS url. DDNS must be enabled to update
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class UpdateNetworkApplianceSettingsPutBody
	{
		
		/// <summary>
		/// Client tracking method of a network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientTrackingMethod")]
		public System.Nullable<UpdateNetworkApplianceSettingsPutBodyClientTrackingMethod> ClientTrackingMethod { get; set; }
		
		/// <summary>
		/// Deployment mode of a network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deploymentMode")]
		public GetNetworkApplianceSettingsReturnDeploymentMode DeploymentMode { get; set; }
		
		/// <summary>
		/// Dynamic DNS settings for a network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dynamicDns")]
		public UpdateNetworkApplianceSettingsPutBodyDynamicDns DynamicDns { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceSettingsPutBodyClientTrackingMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IP address")]
		IP_address = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAC address")]
		MAC_address = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unique client identifier")]
		Unique_client_identifier = 2,
	}
	
	public class UpdateNetworkApplianceSettingsPutBodyDynamicDns
	{
		
		/// <summary>
		/// Dynamic DNS enabled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Dynamic DNS url prefix. DDNS must be enabled to update
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
	}
	
	public class UpdateNetworkApplianceSettingsReturn
	{
		
		/// <summary>
		/// Client tracking method of a network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientTrackingMethod")]
		public System.Nullable<UpdateNetworkApplianceSettingsReturnClientTrackingMethod> ClientTrackingMethod { get; set; }
		
		/// <summary>
		/// Deployment mode of a network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deploymentMode")]
		public GetNetworkApplianceSettingsReturnDeploymentMode DeploymentMode { get; set; }
		
		/// <summary>
		/// Dynamic DNS settings for a network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dynamicDns")]
		public UpdateNetworkApplianceSettingsReturnDynamicDns DynamicDns { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceSettingsReturnClientTrackingMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IP address")]
		IP_address = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAC address")]
		MAC_address = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unique client identifier")]
		Unique_client_identifier = 2,
	}
	
	public class UpdateNetworkApplianceSettingsReturnDynamicDns
	{
		
		/// <summary>
		/// Dynamic DNS enabled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Dynamic DNS url prefix. DDNS must be enabled to update
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
		
		/// <summary>
		/// Dynamic DNS url. DDNS must be enabled to update
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetNetworkApplianceSingleLanReturn
	{
		
		/// <summary>
		/// The local IP of the appliance on the single LAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applianceIp")]
		public string ApplianceIp { get; set; }
		
		/// <summary>
		/// IPv6 configuration on the single LAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public GetNetworkApplianceSingleLanReturnIpv6 Ipv6 { get; set; }
		
		/// <summary>
		/// Mandatory DHCP will enforce that clients connecting to this single LAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mandatoryDhcp")]
		public GetNetworkApplianceSingleLanReturnMandatoryDhcp MandatoryDhcp { get; set; }
		
		/// <summary>
		/// The subnet of the single LAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
	}
	
	public class GetNetworkApplianceSingleLanReturnIpv6
	{
		
		/// <summary>
		/// Enable IPv6 on single LAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Prefix assignments on the single LAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefixAssignments")]
		public GetNetworkApplianceSingleLanReturnIpv6PrefixAssignments[] GetNetworkApplianceSingleLanReturnIpv6PrefixAssignments { get; set; }
	}
	
	public class GetNetworkApplianceSingleLanReturnIpv6PrefixAssignments
	{
		
		/// <summary>
		/// Auto assign a /64 prefix from the origin to the single LAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autonomous")]
		public System.Nullable<System.Boolean> Autonomous { get; set; }
		
		/// <summary>
		/// The origin of the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public GetNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsOrigin Origin { get; set; }
		
		/// <summary>
		/// Manual configuration of the IPv6 Appliance IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticApplianceIp6")]
		public string StaticApplianceIp6 { get; set; }
		
		/// <summary>
		/// Manual configuration of a /64 prefix on the single LAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticPrefix")]
		public string StaticPrefix { get; set; }
	}
	
	public class GetNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsOrigin
	{
		
		/// <summary>
		/// Interfaces associated with the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaces")]
		public string[] Interfaces { get; set; }
		
		/// <summary>
		/// Type of the origin
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType Type { get; set; }
	}
	
	public class GetNetworkApplianceSingleLanReturnMandatoryDhcp
	{
		
		/// <summary>
		/// Enable Mandatory DHCP on single LAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateNetworkApplianceSingleLanPutBody
	{
		
		/// <summary>
		/// The appliance IP address of the single LAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applianceIp")]
		public string ApplianceIp { get; set; }
		
		/// <summary>
		/// IPv6 configuration on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public UpdateNetworkApplianceSingleLanPutBodyIpv6 Ipv6 { get; set; }
		
		/// <summary>
		/// Mandatory DHCP will enforce that clients connecting to this LAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mandatoryDhcp")]
		public UpdateNetworkApplianceSingleLanPutBodyMandatoryDhcp MandatoryDhcp { get; set; }
		
		/// <summary>
		/// The subnet of the single LAN configuration
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
	}
	
	public class UpdateNetworkApplianceSingleLanPutBodyIpv6
	{
		
		/// <summary>
		/// Enable IPv6 on VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Prefix assignments on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefixAssignments")]
		public UpdateNetworkApplianceSingleLanPutBodyIpv6PrefixAssignments[] UpdateNetworkApplianceSingleLanPutBodyIpv6PrefixAssignments { get; set; }
	}
	
	public class UpdateNetworkApplianceSingleLanPutBodyIpv6PrefixAssignments
	{
		
		/// <summary>
		/// Auto assign a /64 prefix from the origin to the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autonomous")]
		public System.Nullable<System.Boolean> Autonomous { get; set; }
		
		/// <summary>
		/// The origin of the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public UpdateNetworkApplianceSingleLanPutBodyIpv6PrefixAssignmentsOrigin Origin { get; set; }
		
		/// <summary>
		/// Manual configuration of the IPv6 Appliance IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticApplianceIp6")]
		public string StaticApplianceIp6 { get; set; }
		
		/// <summary>
		/// Manual configuration of a /64 prefix on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticPrefix")]
		public string StaticPrefix { get; set; }
	}
	
	public class UpdateNetworkApplianceSingleLanPutBodyIpv6PrefixAssignmentsOrigin
	{
		
		/// <summary>
		/// Interfaces associated with the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaces")]
		public string[] Interfaces { get; set; }
		
		/// <summary>
		/// Type of the origin
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType Type { get; set; }
	}
	
	public class UpdateNetworkApplianceSingleLanPutBodyMandatoryDhcp
	{
		
		/// <summary>
		/// Enable Mandatory DHCP on LAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateNetworkApplianceSingleLanReturn
	{
		
		/// <summary>
		/// The local IP of the appliance on the single LAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applianceIp")]
		public string ApplianceIp { get; set; }
		
		/// <summary>
		/// IPv6 configuration on the single LAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public UpdateNetworkApplianceSingleLanReturnIpv6 Ipv6 { get; set; }
		
		/// <summary>
		/// Mandatory DHCP will enforce that clients connecting to this single LAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mandatoryDhcp")]
		public UpdateNetworkApplianceSingleLanReturnMandatoryDhcp MandatoryDhcp { get; set; }
		
		/// <summary>
		/// The subnet of the single LAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
	}
	
	public class UpdateNetworkApplianceSingleLanReturnIpv6
	{
		
		/// <summary>
		/// Enable IPv6 on single LAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Prefix assignments on the single LAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefixAssignments")]
		public UpdateNetworkApplianceSingleLanReturnIpv6PrefixAssignments[] UpdateNetworkApplianceSingleLanReturnIpv6PrefixAssignments { get; set; }
	}
	
	public class UpdateNetworkApplianceSingleLanReturnIpv6PrefixAssignments
	{
		
		/// <summary>
		/// Auto assign a /64 prefix from the origin to the single LAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autonomous")]
		public System.Nullable<System.Boolean> Autonomous { get; set; }
		
		/// <summary>
		/// The origin of the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public UpdateNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsOrigin Origin { get; set; }
		
		/// <summary>
		/// Manual configuration of the IPv6 Appliance IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticApplianceIp6")]
		public string StaticApplianceIp6 { get; set; }
		
		/// <summary>
		/// Manual configuration of a /64 prefix on the single LAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticPrefix")]
		public string StaticPrefix { get; set; }
	}
	
	public class UpdateNetworkApplianceSingleLanReturnIpv6PrefixAssignmentsOrigin
	{
		
		/// <summary>
		/// Interfaces associated with the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaces")]
		public string[] Interfaces { get; set; }
		
		/// <summary>
		/// Type of the origin
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType Type { get; set; }
	}
	
	public class UpdateNetworkApplianceSingleLanReturnMandatoryDhcp
	{
		
		/// <summary>
		/// Enable Mandatory DHCP on single LAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class GetNetworkApplianceSsidsReturn
	{
		
		/// <summary>
		/// The association control method for the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authMode")]
		public string AuthMode { get; set; }
		
		/// <summary>
		/// The VLAN ID of the VLAN associated to this SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultVlanId")]
		public System.Nullable<System.Int32> DefaultVlanId { get; set; }
		
		/// <summary>
		/// Whether or not the SSID is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The psk encryption mode for the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptionMode")]
		public string EncryptionMode { get; set; }
		
		/// <summary>
		/// The name of the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The number of the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Int32> Number { get; set; }
		
		/// <summary>
		/// The RADIUS 802.1x servers to be used for authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusServers")]
		public GetNetworkApplianceSsidsReturnRadiusServers[] GetNetworkApplianceSsidsReturnRadiusServers { get; set; }
		
		/// <summary>
		/// Boolean indicating whether the MX should advertise or hide this SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visible")]
		public System.Nullable<System.Boolean> Visible { get; set; }
		
		/// <summary>
		/// WPA encryption mode for the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wpaEncryptionMode")]
		public string WpaEncryptionMode { get; set; }
	}
	
	public class GetNetworkApplianceSsidsReturnRadiusServers
	{
		
		/// <summary>
		/// The IP address of your RADIUS server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// The UDP port your RADIUS servers listens on for Access-requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
	}
	
	public class GetNetworkApplianceSsidReturn
	{
		
		/// <summary>
		/// The association control method for the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authMode")]
		public string AuthMode { get; set; }
		
		/// <summary>
		/// The VLAN ID of the VLAN associated to this SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultVlanId")]
		public System.Nullable<System.Int32> DefaultVlanId { get; set; }
		
		/// <summary>
		/// Whether or not the SSID is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The psk encryption mode for the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptionMode")]
		public string EncryptionMode { get; set; }
		
		/// <summary>
		/// The name of the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The number of the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Int32> Number { get; set; }
		
		/// <summary>
		/// The RADIUS 802.1x servers to be used for authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusServers")]
		public GetNetworkApplianceSsidReturnRadiusServers[] GetNetworkApplianceSsidReturnRadiusServers { get; set; }
		
		/// <summary>
		/// Boolean indicating whether the MX should advertise or hide this SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visible")]
		public System.Nullable<System.Boolean> Visible { get; set; }
		
		/// <summary>
		/// WPA encryption mode for the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wpaEncryptionMode")]
		public string WpaEncryptionMode { get; set; }
	}
	
	public class GetNetworkApplianceSsidReturnRadiusServers
	{
		
		/// <summary>
		/// The IP address of your RADIUS server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// The UDP port your RADIUS servers listens on for Access-requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
	}
	
	public class UpdateNetworkApplianceSsidPutBody
	{
		
		/// <summary>
		/// The association control method for the SSID ('open', 'psk', '8021x-meraki' or '8021x-radius').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authMode")]
		public System.Nullable<UpdateNetworkApplianceSsidPutBodyAuthMode> AuthMode { get; set; }
		
		/// <summary>
		/// The VLAN ID of the VLAN associated to this SSID. This parameter is only valid if the network is in routed mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultVlanId")]
		public System.Nullable<System.Int32> DefaultVlanId { get; set; }
		
		/// <summary>
		/// DHCP Enforced Deauthentication enables the disassociation of wireless clients in addition to Mandatory DHCP. This param is only valid on firmware versions >= MX 17.0 where the associated LAN has Mandatory DHCP Enabled 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpEnforcedDeauthentication")]
		public UpdateNetworkApplianceSsidPutBodyDhcpEnforcedDeauthentication DhcpEnforcedDeauthentication { get; set; }
		
		/// <summary>
		/// Whether or not the SSID is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The psk encryption mode for the SSID ('wep' or 'wpa'). This param is only valid if the authMode is 'psk'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptionMode")]
		public System.Nullable<UpdateNetworkApplianceSsidPutBodyEncryptionMode> EncryptionMode { get; set; }
		
		/// <summary>
		/// The name of the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The passkey for the SSID. This param is only valid if the authMode is 'psk'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="psk")]
		public string Psk { get; set; }
		
		/// <summary>
		/// The RADIUS 802.1x servers to be used for authentication. This param is only valid if the authMode is '8021x-radius'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusServers")]
		public UpdateNetworkApplianceSsidPutBodyRadiusServers[] UpdateNetworkApplianceSsidPutBodyRadiusServers { get; set; }
		
		/// <summary>
		/// Boolean indicating whether the MX should advertise or hide this SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visible")]
		public System.Nullable<System.Boolean> Visible { get; set; }
		
		/// <summary>
		/// The types of WPA encryption. ('WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode' or 'WPA3 only'). This param is only valid if (1) the authMode is 'psk' & the encryptionMode is 'wpa' OR (2) the authMode is '8021x-meraki' OR (3) the authMode is '8021x-radius'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wpaEncryptionMode")]
		public System.Nullable<UpdateNetworkApplianceSsidPutBodyWpaEncryptionMode> WpaEncryptionMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceSsidPutBodyAuthMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8021x-meraki")]
		_8021xMinusmeraki = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8021x-radius")]
		_8021xMinusradius = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		open = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		psk = 3,
	}
	
	public class UpdateNetworkApplianceSsidPutBodyDhcpEnforcedDeauthentication
	{
		
		/// <summary>
		/// Enable DCHP Enforced Deauthentication on the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceSsidPutBodyEncryptionMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wep = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wpa = 1,
	}
	
	public class UpdateNetworkApplianceSsidPutBodyRadiusServers
	{
		
		/// <summary>
		/// The IP address of your RADIUS server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// The UDP port your RADIUS servers listens on for Access-requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// The RADIUS client shared secret.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceSsidPutBodyWpaEncryptionMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WPA1 and WPA2")]
		WPA1_and_WPA2 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WPA2 only")]
		WPA2_only = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WPA3 Transition Mode")]
		WPA3_Transition_Mode = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WPA3 only")]
		WPA3_only = 3,
	}
	
	public class UpdateNetworkApplianceSsidReturn
	{
		
		/// <summary>
		/// The association control method for the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authMode")]
		public string AuthMode { get; set; }
		
		/// <summary>
		/// The VLAN ID of the VLAN associated to this SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultVlanId")]
		public System.Nullable<System.Int32> DefaultVlanId { get; set; }
		
		/// <summary>
		/// Whether or not the SSID is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The psk encryption mode for the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptionMode")]
		public string EncryptionMode { get; set; }
		
		/// <summary>
		/// The name of the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The number of the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Int32> Number { get; set; }
		
		/// <summary>
		/// The RADIUS 802.1x servers to be used for authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusServers")]
		public UpdateNetworkApplianceSsidReturnRadiusServers[] UpdateNetworkApplianceSsidReturnRadiusServers { get; set; }
		
		/// <summary>
		/// Boolean indicating whether the MX should advertise or hide this SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visible")]
		public System.Nullable<System.Boolean> Visible { get; set; }
		
		/// <summary>
		/// WPA encryption mode for the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wpaEncryptionMode")]
		public string WpaEncryptionMode { get; set; }
	}
	
	public class UpdateNetworkApplianceSsidReturnRadiusServers
	{
		
		/// <summary>
		/// The IP address of your RADIUS server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// The UDP port your RADIUS servers listens on for Access-requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
	}
	
	public class CreateNetworkApplianceStaticRoutePostBody
	{
		
		/// <summary>
		/// The gateway IP (next hop) of the static route
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gatewayIp")]
		public string GatewayIp { get; set; }
		
		/// <summary>
		/// The gateway IP (next hop) VLAN ID of the static route
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gatewayVlanId")]
		public string GatewayVlanId { get; set; }
		
		/// <summary>
		/// The name of the new static route
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The subnet of the static route
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
	}
	
	public class UpdateNetworkApplianceStaticRoutePutBody
	{
		
		/// <summary>
		/// The enabled state of the static route
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The DHCP fixed IP assignments on the static route. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixedIpAssignments")]
		public string FixedIpAssignments { get; set; }
		
		/// <summary>
		/// The gateway IP (next hop) of the static route
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gatewayIp")]
		public string GatewayIp { get; set; }
		
		/// <summary>
		/// The gateway IP (next hop) VLAN ID of the static route
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gatewayVlanId")]
		public string GatewayVlanId { get; set; }
		
		/// <summary>
		/// The name of the static route
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The DHCP reserved IP ranges on the static route
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservedIpRanges")]
		public UpdateNetworkApplianceStaticRoutePutBodyReservedIpRanges[] UpdateNetworkApplianceStaticRoutePutBodyReservedIpRanges { get; set; }
		
		/// <summary>
		/// The subnet of the static route
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
	}
	
	public class UpdateNetworkApplianceStaticRoutePutBodyReservedIpRanges
	{
		
		/// <summary>
		/// A text comment for the reserved range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// The last IP in the reserved range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="end")]
		public string End { get; set; }
		
		/// <summary>
		/// The first IP in the reserved range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start")]
		public string Start { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingPutBody
	{
		
		/// <summary>
		/// Global per-client bandwidth limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="globalBandwidthLimits")]
		public UpdateNetworkApplianceTrafficShapingPutBodyGlobalBandwidthLimits GlobalBandwidthLimits { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingPutBodyGlobalBandwidthLimits
	{
		
		/// <summary>
		/// The download bandwidth limit in Kbps. (0 represents no limit.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitDown")]
		public System.Nullable<System.Int32> LimitDown { get; set; }
		
		/// <summary>
		/// The upload bandwidth limit in Kbps. (0 represents no limit.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitUp")]
		public System.Nullable<System.Int32> LimitUp { get; set; }
	}
	
	public class CreateNetworkApplianceTrafficShapingCustomPerformanceClassPostBody
	{
		
		/// <summary>
		/// Maximum jitter in milliseconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxJitter")]
		public System.Nullable<System.Int32> MaxJitter { get; set; }
		
		/// <summary>
		/// Maximum latency in milliseconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxLatency")]
		public System.Nullable<System.Int32> MaxLatency { get; set; }
		
		/// <summary>
		/// Maximum percentage of packet loss
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxLossPercentage")]
		public System.Nullable<System.Int32> MaxLossPercentage { get; set; }
		
		/// <summary>
		/// Name of the custom performance class
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingCustomPerformanceClassPutBody
	{
		
		/// <summary>
		/// Maximum jitter in milliseconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxJitter")]
		public System.Nullable<System.Int32> MaxJitter { get; set; }
		
		/// <summary>
		/// Maximum latency in milliseconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxLatency")]
		public System.Nullable<System.Int32> MaxLatency { get; set; }
		
		/// <summary>
		/// Maximum percentage of packet loss
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxLossPercentage")]
		public System.Nullable<System.Int32> MaxLossPercentage { get; set; }
		
		/// <summary>
		/// Name of the custom performance class
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingRulesPutBody
	{
		
		/// <summary>
		/// Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultRulesEnabled")]
		public System.Nullable<System.Boolean> DefaultRulesEnabled { get; set; }
		
		/// <summary>
		///     An array of traffic shaping rules. Rules are applied in the order that
		///    they are specified in. An empty list (or null) means no rules. Note that
		///    you are allowed a maximum of 8 rules.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkApplianceTrafficShapingRulesPutBodyRules[] UpdateNetworkApplianceTrafficShapingRulesPutBodyRules { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingRulesPutBodyRules
	{
		
		/// <summary>
		///     A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="definitions")]
		public UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitions[] UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitions { get; set; }
		
		/// <summary>
		///     The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
		///    For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dscpTagValue")]
		public System.Nullable<System.Int32> DscpTagValue { get; set; }
		
		/// <summary>
		///     An object describing the bandwidth settings for your rule.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perClientBandwidthLimits")]
		public UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesPerClientBandwidthLimits PerClientBandwidthLimits { get; set; }
		
		/// <summary>
		///     A string, indicating the priority level for packets bound to your rule.
		///    Can be 'low', 'normal' or 'high'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public string Priority { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitions
	{
		
		/// <summary>
		/// The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsType Type { get; set; }
		
		/// <summary>
		///     If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
		///    a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
		///    "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
		///    custom ports.
		///     If "type" is 'application' or 'applicationCategory', then "value" must be an object
		///    with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
		///    application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
		///    endpoint).
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		application = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		applicationCategory = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		host = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ipRange = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		localNet = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		port = 5,
	}
	
	public class UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesPerClientBandwidthLimits
	{
		
		/// <summary>
		/// The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandwidthLimits")]
		public UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsBandwidthLimits BandwidthLimits { get; set; }
		
		/// <summary>
		/// How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public string Settings { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsBandwidthLimits
	{
		
		/// <summary>
		/// The maximum download limit (integer, in Kbps).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitDown")]
		public System.Nullable<System.Int32> LimitDown { get; set; }
		
		/// <summary>
		/// The maximum upload limit (integer, in Kbps).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitUp")]
		public System.Nullable<System.Int32> LimitUp { get; set; }
	}
	
	public class GetNetworkApplianceTrafficShapingUplinkBandwidthReturn
	{
		
		/// <summary>
		/// A hash uplink keys and their configured settings for the Appliance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandwidthLimits")]
		public GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimits BandwidthLimits { get; set; }
	}
	
	public class GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimits
	{
		
		/// <summary>
		/// uplink cellular configured limits [optional]
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cellular")]
		public GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsCellular Cellular { get; set; }
		
		/// <summary>
		/// uplink wan1 configured limits [optional]
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wan1")]
		public GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsWan1 Wan1 { get; set; }
		
		/// <summary>
		/// uplink wan2 configured limits [optional]
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wan2")]
		public GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsWan2 Wan2 { get; set; }
	}
	
	public class GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsCellular
	{
		
		/// <summary>
		/// configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitDown")]
		public System.Nullable<System.Int32> LimitDown { get; set; }
		
		/// <summary>
		/// configured UP limit for the uplink (in Kbps).  Null indicated unlimited
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitUp")]
		public System.Nullable<System.Int32> LimitUp { get; set; }
	}
	
	public class GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsWan1
	{
		
		/// <summary>
		/// configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitDown")]
		public System.Nullable<System.Int32> LimitDown { get; set; }
		
		/// <summary>
		/// configured UP limit for the uplink (in Kbps).  Null indicated unlimited
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitUp")]
		public System.Nullable<System.Int32> LimitUp { get; set; }
	}
	
	public class GetNetworkApplianceTrafficShapingUplinkBandwidthReturnBandwidthLimitsWan2
	{
		
		/// <summary>
		/// configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitDown")]
		public System.Nullable<System.Int32> LimitDown { get; set; }
		
		/// <summary>
		/// configured UP limit for the uplink (in Kbps).  Null indicated unlimited
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitUp")]
		public System.Nullable<System.Int32> LimitUp { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBody
	{
		
		/// <summary>
		/// A mapping of uplinks to their bandwidth settings (be sure to check which uplinks are supported for your network)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandwidthLimits")]
		public UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimits BandwidthLimits { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimits
	{
		
		/// <summary>
		/// The bandwidth settings for the 'cellular' uplink
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cellular")]
		public UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsCellular Cellular { get; set; }
		
		/// <summary>
		/// The bandwidth settings for the 'wan1' uplink
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wan1")]
		public UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsWan1 Wan1 { get; set; }
		
		/// <summary>
		/// The bandwidth settings for the 'wan2' uplink
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wan2")]
		public UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsWan2 Wan2 { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsCellular
	{
		
		/// <summary>
		/// The maximum download limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitDown")]
		public System.Nullable<System.Int32> LimitDown { get; set; }
		
		/// <summary>
		/// The maximum upload limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitUp")]
		public System.Nullable<System.Int32> LimitUp { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsWan1
	{
		
		/// <summary>
		/// The maximum download limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitDown")]
		public System.Nullable<System.Int32> LimitDown { get; set; }
		
		/// <summary>
		/// The maximum upload limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitUp")]
		public System.Nullable<System.Int32> LimitUp { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkBandwidthPutBodyBandwidthLimitsWan2
	{
		
		/// <summary>
		/// The maximum download limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitDown")]
		public System.Nullable<System.Int32> LimitDown { get; set; }
		
		/// <summary>
		/// The maximum upload limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitUp")]
		public System.Nullable<System.Int32> LimitUp { get; set; }
	}
	
	public class GetNetworkApplianceTrafficShapingUplinkSelectionReturn
	{
		
		/// <summary>
		/// Whether active-active AutoVPN is enabled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="activeActiveAutoVpnEnabled")]
		public System.Nullable<System.Boolean> ActiveActiveAutoVpnEnabled { get; set; }
		
		/// <summary>
		/// The default uplink. Must be one of: 'wan1' or 'wan2'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultUplink")]
		public System.Nullable<GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink> DefaultUplink { get; set; }
		
		/// <summary>
		/// WAN failover and failback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failoverAndFailback")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailback FailoverAndFailback { get; set; }
		
		/// <summary>
		/// Whether load balancing is enabled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loadBalancingEnabled")]
		public System.Nullable<System.Boolean> LoadBalancingEnabled { get; set; }
		
		/// <summary>
		/// Uplink preference rules for VPN traffic
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vpnTrafficUplinkPreferences")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferences[] GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferences { get; set; }
		
		/// <summary>
		/// Uplink preference rules for WAN traffic
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wanTrafficUplinkPreferences")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferences[] GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferences { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wan1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wan2 = 1,
	}
	
	public class GetNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailback
	{
		
		/// <summary>
		/// Immediate WAN failover and failback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="immediate")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackImmediate Immediate { get; set; }
	}
	
	public class GetNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackImmediate
	{
		
		/// <summary>
		/// Whether immediate WAN failover and failback is enabled
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
	}
	
	public class GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferences
	{
		
		/// <summary>
		/// Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failOverCriterion")]
		public System.Nullable<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFailOverCriterion> FailOverCriterion { get; set; }
		
		/// <summary>
		/// Performance class setting for uplink preference rule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="performanceClass")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClass PerformanceClass { get; set; }
		
		/// <summary>
		/// Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="preferredUplink")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPreferredUplink PreferredUplink { get; set; }
		
		/// <summary>
		/// Traffic filters
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trafficFilters")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFilters[] GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFilters { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFailOverCriterion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		poorPerformance = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		uplinkDown = 1,
	}
	
	public class GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClass
	{
		
		/// <summary>
		/// Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="builtinPerformanceClassName")]
		public System.Nullable<GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassName> BuiltinPerformanceClassName { get; set; }
		
		/// <summary>
		/// ID of created custom performance class, must be present when performanceClass type is "custom"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customPerformanceClassId")]
		public string CustomPerformanceClassId { get; set; }
		
		/// <summary>
		/// Type of this performance class. Must be one of: 'builtin' or 'custom'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassName
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VoIP = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		builtin = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPreferredUplink
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		bestForVoIP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		defaultUplink = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		loadBalancing = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wan1 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wan2 = 4,
	}
	
	public class GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFilters
	{
		
		/// <summary>
		/// Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersType Type { get; set; }
		
		/// <summary>
		/// Value of traffic filter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValue Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		application = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		applicationCategory = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 2,
	}
	
	public class GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValue
	{
		
		/// <summary>
		/// Destination of 'custom' type traffic filter
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueDestination Destination { get; set; }
		
		/// <summary>
		/// ID of 'applicationCategory' or 'application' type traffic filter
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// Source of 'custom' type traffic filter
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueSource Source { get; set; }
	}
	
	public class GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueDestination
	{
		
		/// <summary>
		/// CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" or "fqdn" property
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// FQDN format address. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available in the "destination" object of the "vpnTrafficUplinkPreference" object. E.g.: "www.google.com"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fqdn")]
		public string Fqdn { get; set; }
		
		/// <summary>
		/// Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public System.Nullable<System.Int32> Host { get; set; }
		
		/// <summary>
		/// Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// E.g.: "any", "0" (also means "any"), "8080", "1-1024"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public string Port { get; set; }
		
		/// <summary>
		/// VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available under a template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueSource
	{
		
		/// <summary>
		/// CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public System.Nullable<System.Int32> Host { get; set; }
		
		/// <summary>
		/// Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// E.g.: "any", "0" (also means "any"), "8080", "1-1024"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public string Port { get; set; }
		
		/// <summary>
		/// VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferences
	{
		
		/// <summary>
		/// Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="preferredUplink")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink PreferredUplink { get; set; }
		
		/// <summary>
		/// Traffic filters
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trafficFilters")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFilters[] GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFilters { get; set; }
	}
	
	public class GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFilters
	{
		
		/// <summary>
		/// Traffic filter type. Must be "custom"
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersType Type { get; set; }
		
		/// <summary>
		/// Value of traffic filter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValue Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 0,
	}
	
	public class GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValue
	{
		
		/// <summary>
		/// Destination of 'custom' type traffic filter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueDestination Destination { get; set; }
		
		/// <summary>
		/// Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public System.Nullable<GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueProtocol> Protocol { get; set; }
		
		/// <summary>
		/// Source of 'custom' type traffic filter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueSource Source { get; set; }
	}
	
	public class GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueDestination
	{
		
		/// <summary>
		/// CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// E.g.: "any", "0" (also means "any"), "8080", "1-1024"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public string Port { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		any = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		icmp6 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tcp = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		udp = 3,
	}
	
	public class GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueSource
	{
		
		/// <summary>
		/// CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public System.Nullable<System.Int32> Host { get; set; }
		
		/// <summary>
		/// E.g.: "any", "0" (also means "any"), "8080", "1-1024"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public string Port { get; set; }
		
		/// <summary>
		/// VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBody
	{
		
		/// <summary>
		/// Toggle for enabling or disabling active-active AutoVPN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="activeActiveAutoVpnEnabled")]
		public System.Nullable<System.Boolean> ActiveActiveAutoVpnEnabled { get; set; }
		
		/// <summary>
		/// The default uplink. Must be one of: 'wan1' or 'wan2'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultUplink")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink DefaultUplink { get; set; }
		
		/// <summary>
		/// WAN failover and failback behavior
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failoverAndFailback")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyFailoverAndFailback FailoverAndFailback { get; set; }
		
		/// <summary>
		/// Toggle for enabling or disabling load balancing
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loadBalancingEnabled")]
		public System.Nullable<System.Boolean> LoadBalancingEnabled { get; set; }
		
		/// <summary>
		/// Array of uplink preference rules for VPN traffic
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vpnTrafficUplinkPreferences")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferences[] UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferences { get; set; }
		
		/// <summary>
		/// Array of uplink preference rules for WAN traffic
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wanTrafficUplinkPreferences")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferences[] UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferences { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyFailoverAndFailback
	{
		
		/// <summary>
		/// Immediate WAN transition terminates all flows (new and existing) on current WAN when it is deemed unreliable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="immediate")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyFailoverAndFailbackImmediate Immediate { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyFailoverAndFailbackImmediate
	{
		
		/// <summary>
		/// Toggle for enabling or disabling immediate WAN failover and failback
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferences
	{
		
		/// <summary>
		/// Fail over criterion for this uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failOverCriterion")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFailOverCriterion FailOverCriterion { get; set; }
		
		/// <summary>
		/// Performance class setting for this uplink preference rule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="performanceClass")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesPerformanceClass PerformanceClass { get; set; }
		
		/// <summary>
		/// Preferred uplink for this uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="preferredUplink")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPreferredUplink PreferredUplink { get; set; }
		
		/// <summary>
		/// Array of traffic filters for this uplink preference rule
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trafficFilters")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFilters[] UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFilters { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesPerformanceClass
	{
		
		/// <summary>
		/// Name of builtin performance class, must be present when performanceClass type is 'builtin', and value must be one of: 'VoIP'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="builtinPerformanceClassName")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassName BuiltinPerformanceClassName { get; set; }
		
		/// <summary>
		/// ID of created custom performance class, must be present when performanceClass type is 'custom'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customPerformanceClassId")]
		public string CustomPerformanceClassId { get; set; }
		
		/// <summary>
		/// Type of this performance class. Must be one of: 'builtin' or 'custom'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassType Type { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFilters
	{
		
		/// <summary>
		/// Type of this traffic filter. Must be one of: 'applicationCategory', 'application' or 'custom'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersType Type { get; set; }
		
		/// <summary>
		/// Value object of this traffic filter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValue Value { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValue
	{
		
		/// <summary>
		/// Destination of this custom type traffic filter
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValueDestination Destination { get; set; }
		
		/// <summary>
		/// ID of this applicationCategory or application type traffic filter. E.g.: "meraki:layer7/category/1", "meraki:layer7/application/4"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Protocol of this custom type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// Source of this custom type traffic filter
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValueSource Source { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValueDestination
	{
		
		/// <summary>
		/// CIDR format address, or "any". E.g.: "192.168.10.0/24",  "192.168.10.1" (same as "192.168.10.1/32"), "0.0.0.0/0" (same as "any")
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// FQDN format address. Currently only availabe in 'destination' of 'vpnTrafficUplinkPreference' object. E.g.: 'www.google.com'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fqdn")]
		public string Fqdn { get; set; }
		
		/// <summary>
		/// Host ID in the VLAN, should be used along with 'vlan', and not exceed the vlan subnet capacity. Currently only available under a template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public System.Nullable<System.Int32> Host { get; set; }
		
		/// <summary>
		/// Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// E.g.: "any", "0" (also means "any"), "8080", "1-1024"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public string Port { get; set; }
		
		/// <summary>
		/// VLAN ID of the configured VLAN in the Meraki network. Currently only available under a template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyVpnTrafficUplinkPreferencesTrafficFiltersValueSource
	{
		
		/// <summary>
		/// CIDR format address, or "any". E.g.: "192.168.10.0/24",  "192.168.10.1" (same as "192.168.10.1/32"), "0.0.0.0/0" (same as "any")
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// Host ID in the VLAN, should be used along with 'vlan', and not exceed the vlan subnet capacity. Currently only available under a template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public System.Nullable<System.Int32> Host { get; set; }
		
		/// <summary>
		/// Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// E.g.: "any", "0" (also means "any"), "8080", "1-1024"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public string Port { get; set; }
		
		/// <summary>
		/// VLAN ID of the configured VLAN in the Meraki network. Currently only available under a template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferences
	{
		
		/// <summary>
		/// Preferred uplink for this uplink preference rule. Must be one of: 'wan1' or 'wan2'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="preferredUplink")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink PreferredUplink { get; set; }
		
		/// <summary>
		/// Array of traffic filters for this uplink preference rule
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trafficFilters")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFilters[] UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFilters { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFilters
	{
		
		/// <summary>
		/// Type of this traffic filter. Must be one of: 'custom'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersType Type { get; set; }
		
		/// <summary>
		/// Value object of this traffic filter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValue Value { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValue
	{
		
		/// <summary>
		/// Destination of this custom type traffic filter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValueDestination Destination { get; set; }
		
		/// <summary>
		/// Protocol of this custom type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueProtocol Protocol { get; set; }
		
		/// <summary>
		/// Source of this custom type traffic filter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValueSource Source { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValueDestination
	{
		
		/// <summary>
		/// CIDR format address, or "any". E.g.: "192.168.10.0/24",  "192.168.10.1" (same as "192.168.10.1/32"), "0.0.0.0/0" (same as "any")
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// E.g.: "any", "0" (also means "any"), "8080", "1-1024"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public string Port { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionPutBodyWanTrafficUplinkPreferencesTrafficFiltersValueSource
	{
		
		/// <summary>
		/// CIDR format address, or "any". E.g.: "192.168.10.0/24",  "192.168.10.1" (same as "192.168.10.1/32"), "0.0.0.0/0" (same as "any")
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// Host ID in the VLAN, should be used along with 'vlan', and not exceed the vlan subnet capacity. Currently only available under a template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public System.Nullable<System.Int32> Host { get; set; }
		
		/// <summary>
		/// E.g.: "any", "0" (also means "any"), "8080", "1-1024"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public string Port { get; set; }
		
		/// <summary>
		/// VLAN ID of the configured VLAN in the Meraki network. Currently only available under a template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionReturn
	{
		
		/// <summary>
		/// Whether active-active AutoVPN is enabled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="activeActiveAutoVpnEnabled")]
		public System.Nullable<System.Boolean> ActiveActiveAutoVpnEnabled { get; set; }
		
		/// <summary>
		/// The default uplink. Must be one of: 'wan1' or 'wan2'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultUplink")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink DefaultUplink { get; set; }
		
		/// <summary>
		/// WAN failover and failback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failoverAndFailback")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailback FailoverAndFailback { get; set; }
		
		/// <summary>
		/// Whether load balancing is enabled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loadBalancingEnabled")]
		public System.Nullable<System.Boolean> LoadBalancingEnabled { get; set; }
		
		/// <summary>
		/// Uplink preference rules for VPN traffic
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vpnTrafficUplinkPreferences")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferences[] UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferences { get; set; }
		
		/// <summary>
		/// Uplink preference rules for WAN traffic
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wanTrafficUplinkPreferences")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferences[] UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferences { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailback
	{
		
		/// <summary>
		/// Immediate WAN failover and failback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="immediate")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackImmediate Immediate { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnFailoverAndFailbackImmediate
	{
		
		/// <summary>
		/// Whether immediate WAN failover and failback is enabled
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferences
	{
		
		/// <summary>
		/// Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failOverCriterion")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesFailOverCriterion FailOverCriterion { get; set; }
		
		/// <summary>
		/// Performance class setting for uplink preference rule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="performanceClass")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClass PerformanceClass { get; set; }
		
		/// <summary>
		/// Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="preferredUplink")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPreferredUplink PreferredUplink { get; set; }
		
		/// <summary>
		/// Traffic filters
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trafficFilters")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFilters[] UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFilters { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClass
	{
		
		/// <summary>
		/// Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="builtinPerformanceClassName")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassBuiltinPerformanceClassName BuiltinPerformanceClassName { get; set; }
		
		/// <summary>
		/// ID of created custom performance class, must be present when performanceClass type is "custom"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customPerformanceClassId")]
		public string CustomPerformanceClassId { get; set; }
		
		/// <summary>
		/// Type of this performance class. Must be one of: 'builtin' or 'custom'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesPerformanceClassType Type { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFilters
	{
		
		/// <summary>
		/// Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersType Type { get; set; }
		
		/// <summary>
		/// Value of traffic filter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValue Value { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValue
	{
		
		/// <summary>
		/// Destination of 'custom' type traffic filter
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueDestination Destination { get; set; }
		
		/// <summary>
		/// ID of 'applicationCategory' or 'application' type traffic filter
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// Source of 'custom' type traffic filter
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueSource Source { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueDestination
	{
		
		/// <summary>
		/// CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" or "fqdn" property
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// FQDN format address. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available in the "destination" object of the "vpnTrafficUplinkPreference" object. E.g.: "www.google.com"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fqdn")]
		public string Fqdn { get; set; }
		
		/// <summary>
		/// Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public System.Nullable<System.Int32> Host { get; set; }
		
		/// <summary>
		/// Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// E.g.: "any", "0" (also means "any"), "8080", "1-1024"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public string Port { get; set; }
		
		/// <summary>
		/// VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available under a template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnVpnTrafficUplinkPreferencesTrafficFiltersValueSource
	{
		
		/// <summary>
		/// CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public System.Nullable<System.Int32> Host { get; set; }
		
		/// <summary>
		/// Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// E.g.: "any", "0" (also means "any"), "8080", "1-1024"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public string Port { get; set; }
		
		/// <summary>
		/// VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferences
	{
		
		/// <summary>
		/// Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="preferredUplink")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnDefaultUplink PreferredUplink { get; set; }
		
		/// <summary>
		/// Traffic filters
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trafficFilters")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFilters[] UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFilters { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFilters
	{
		
		/// <summary>
		/// Traffic filter type. Must be "custom"
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersType Type { get; set; }
		
		/// <summary>
		/// Value of traffic filter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValue Value { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValue
	{
		
		/// <summary>
		/// Destination of 'custom' type traffic filter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueDestination Destination { get; set; }
		
		/// <summary>
		/// Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public GetNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueProtocol Protocol { get; set; }
		
		/// <summary>
		/// Source of 'custom' type traffic filter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueSource Source { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueDestination
	{
		
		/// <summary>
		/// CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// E.g.: "any", "0" (also means "any"), "8080", "1-1024"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public string Port { get; set; }
	}
	
	public class UpdateNetworkApplianceTrafficShapingUplinkSelectionReturnWanTrafficUplinkPreferencesTrafficFiltersValueSource
	{
		
		/// <summary>
		/// CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public System.Nullable<System.Int32> Host { get; set; }
		
		/// <summary>
		/// E.g.: "any", "0" (also means "any"), "8080", "1-1024"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public string Port { get; set; }
		
		/// <summary>
		/// VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class GetNetworkApplianceVlansReturn
	{
		
		/// <summary>
		/// The local IP of the appliance on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applianceIp")]
		public string ApplianceIp { get; set; }
		
		/// <summary>
		/// CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// DHCP boot option for boot filename
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpBootFilename")]
		public string DhcpBootFilename { get; set; }
		
		/// <summary>
		/// DHCP boot option to direct boot clients to the server to load the boot file from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpBootNextServer")]
		public string DhcpBootNextServer { get; set; }
		
		/// <summary>
		/// Use DHCP boot options specified in other properties
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpBootOptionsEnabled")]
		public System.Nullable<System.Boolean> DhcpBootOptionsEnabled { get; set; }
		
		/// <summary>
		/// The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpHandling")]
		public System.Nullable<GetNetworkApplianceVlansReturnDhcpHandling> DhcpHandling { get; set; }
		
		/// <summary>
		/// The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpLeaseTime")]
		public System.Nullable<GetNetworkApplianceVlansReturnDhcpLeaseTime> DhcpLeaseTime { get; set; }
		
		/// <summary>
		/// The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpOptions")]
		public GetNetworkApplianceVlansReturnDhcpOptions[] GetNetworkApplianceVlansReturnDhcpOptions { get; set; }
		
		/// <summary>
		/// The IPs of the DHCP servers that DHCP requests should be relayed to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpRelayServerIps")]
		public string[] DhcpRelayServerIps { get; set; }
		
		/// <summary>
		/// The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsNameservers")]
		public string DnsNameservers { get; set; }
		
		/// <summary>
		/// The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixedIpAssignments")]
		public string FixedIpAssignments { get; set; }
		
		/// <summary>
		/// The id of the desired group policy to apply to the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
		
		/// <summary>
		/// The VLAN ID of the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The interface ID of the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaceId")]
		public string InterfaceId { get; set; }
		
		/// <summary>
		/// IPv6 configuration on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public GetNetworkApplianceVlansReturnIpv6 Ipv6 { get; set; }
		
		/// <summary>
		/// Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mandatoryDhcp")]
		public GetNetworkApplianceVlansReturnMandatoryDhcp MandatoryDhcp { get; set; }
		
		/// <summary>
		/// Mask used for the subnet of all bound to the template networks. Applicable only for template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mask")]
		public System.Nullable<System.Int32> Mask { get; set; }
		
		/// <summary>
		/// The name of the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The DHCP reserved IP ranges on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservedIpRanges")]
		public GetNetworkApplianceVlansReturnReservedIpRanges[] GetNetworkApplianceVlansReturnReservedIpRanges { get; set; }
		
		/// <summary>
		/// The subnet of the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
		
		/// <summary>
		/// Type of subnetting of the VLAN. Applicable only for template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="templateVlanType")]
		public System.Nullable<GetNetworkApplianceVlansReturnTemplateVlanType> TemplateVlanType { get; set; }
		
		/// <summary>
		/// The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vpnNatSubnet")]
		public string VpnNatSubnet { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkApplianceVlansReturnDhcpHandling
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Do not respond to DHCP requests")]
		Do_not_respond_to_DHCP_requests = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Relay DHCP to another server")]
		Relay_DHCP_to_another_server = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Run a DHCP server")]
		Run_a_DHCP_server = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkApplianceVlansReturnDhcpLeaseTime
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 day")]
		_1_day = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 hour")]
		_1_hour = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 week")]
		_1_week = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="12 hours")]
		_12_hours = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="30 minutes")]
		_30_minutes = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4 hours")]
		_4_hours = 5,
	}
	
	public class GetNetworkApplianceVlansReturnDhcpOptions
	{
		
		/// <summary>
		/// The code for the DHCP option. This should be an integer between 2 and 254.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType Type { get; set; }
		
		/// <summary>
		/// The value for the DHCP option
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class GetNetworkApplianceVlansReturnIpv6
	{
		
		/// <summary>
		/// Enable IPv6 on VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Prefix assignments on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefixAssignments")]
		public GetNetworkApplianceVlansReturnIpv6PrefixAssignments[] GetNetworkApplianceVlansReturnIpv6PrefixAssignments { get; set; }
	}
	
	public class GetNetworkApplianceVlansReturnIpv6PrefixAssignments
	{
		
		/// <summary>
		/// Auto assign a /64 prefix from the origin to the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autonomous")]
		public System.Nullable<System.Boolean> Autonomous { get; set; }
		
		/// <summary>
		/// The origin of the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public GetNetworkApplianceVlansReturnIpv6PrefixAssignmentsOrigin Origin { get; set; }
		
		/// <summary>
		/// Manual configuration of the IPv6 Appliance IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticApplianceIp6")]
		public string StaticApplianceIp6 { get; set; }
		
		/// <summary>
		/// Manual configuration of a /64 prefix on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticPrefix")]
		public string StaticPrefix { get; set; }
	}
	
	public class GetNetworkApplianceVlansReturnIpv6PrefixAssignmentsOrigin
	{
		
		/// <summary>
		/// Interfaces associated with the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaces")]
		public string[] Interfaces { get; set; }
		
		/// <summary>
		/// Type of the origin
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType Type { get; set; }
	}
	
	public class GetNetworkApplianceVlansReturnMandatoryDhcp
	{
		
		/// <summary>
		/// Enable Mandatory DHCP on VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class GetNetworkApplianceVlansReturnReservedIpRanges
	{
		
		/// <summary>
		/// A text comment for the reserved range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// The last IP in the reserved range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end")]
		public string End { get; set; }
		
		/// <summary>
		/// The first IP in the reserved range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start")]
		public string Start { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkApplianceVlansReturnTemplateVlanType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		same = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unique = 1,
	}
	
	public class CreateNetworkApplianceVlanPostBody
	{
		
		/// <summary>
		/// The local IP of the appliance on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applianceIp")]
		public string ApplianceIp { get; set; }
		
		/// <summary>
		/// CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// The id of the desired group policy to apply to the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
		
		/// <summary>
		/// The VLAN ID of the new VLAN (must be between 1 and 4094)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// IPv6 configuration on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public CreateNetworkApplianceVlanPostBodyIpv6 Ipv6 { get; set; }
		
		/// <summary>
		/// Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mandatoryDhcp")]
		public CreateNetworkApplianceVlanPostBodyMandatoryDhcp MandatoryDhcp { get; set; }
		
		/// <summary>
		/// Mask used for the subnet of all bound to the template networks. Applicable only for template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mask")]
		public System.Nullable<System.Int32> Mask { get; set; }
		
		/// <summary>
		/// The name of the new VLAN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The subnet of the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
		
		/// <summary>
		/// Type of subnetting of the VLAN. Applicable only for template network.
		/// </summary>
		[System.ComponentModel.DefaultValue(GetNetworkApplianceVlansReturnTemplateVlanType.same)]
		[System.Runtime.Serialization.DataMember(Name="templateVlanType")]
		public GetNetworkApplianceVlansReturnTemplateVlanType TemplateVlanType { get; set; } = GetNetworkApplianceVlansReturnTemplateVlanType.same;
	}
	
	public class CreateNetworkApplianceVlanPostBodyIpv6
	{
		
		/// <summary>
		/// Enable IPv6 on VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Prefix assignments on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefixAssignments")]
		public CreateNetworkApplianceVlanPostBodyIpv6PrefixAssignments[] CreateNetworkApplianceVlanPostBodyIpv6PrefixAssignments { get; set; }
	}
	
	public class CreateNetworkApplianceVlanPostBodyIpv6PrefixAssignments
	{
		
		/// <summary>
		/// Auto assign a /64 prefix from the origin to the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autonomous")]
		public System.Nullable<System.Boolean> Autonomous { get; set; }
		
		/// <summary>
		/// The origin of the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public CreateNetworkApplianceVlanPostBodyIpv6PrefixAssignmentsOrigin Origin { get; set; }
		
		/// <summary>
		/// Manual configuration of the IPv6 Appliance IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticApplianceIp6")]
		public string StaticApplianceIp6 { get; set; }
		
		/// <summary>
		/// Manual configuration of a /64 prefix on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticPrefix")]
		public string StaticPrefix { get; set; }
	}
	
	public class CreateNetworkApplianceVlanPostBodyIpv6PrefixAssignmentsOrigin
	{
		
		/// <summary>
		/// Interfaces associated with the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaces")]
		public string[] Interfaces { get; set; }
		
		/// <summary>
		/// Type of the origin
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType Type { get; set; }
	}
	
	public class CreateNetworkApplianceVlanPostBodyMandatoryDhcp
	{
		
		/// <summary>
		/// Enable Mandatory DHCP on VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateNetworkApplianceVlansSettingsPutBody
	{
		
		/// <summary>
		/// Boolean indicating whether to enable (true) or disable (false) VLANs for the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlansEnabled")]
		public System.Nullable<System.Boolean> VlansEnabled { get; set; }
	}
	
	public class GetNetworkApplianceVlanReturn
	{
		
		/// <summary>
		/// The local IP of the appliance on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applianceIp")]
		public string ApplianceIp { get; set; }
		
		/// <summary>
		/// CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// DHCP boot option for boot filename
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpBootFilename")]
		public string DhcpBootFilename { get; set; }
		
		/// <summary>
		/// DHCP boot option to direct boot clients to the server to load the boot file from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpBootNextServer")]
		public string DhcpBootNextServer { get; set; }
		
		/// <summary>
		/// Use DHCP boot options specified in other properties
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpBootOptionsEnabled")]
		public System.Nullable<System.Boolean> DhcpBootOptionsEnabled { get; set; }
		
		/// <summary>
		/// The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpHandling")]
		public System.Nullable<GetNetworkApplianceVlanReturnDhcpHandling> DhcpHandling { get; set; }
		
		/// <summary>
		/// The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpLeaseTime")]
		public System.Nullable<GetNetworkApplianceVlanReturnDhcpLeaseTime> DhcpLeaseTime { get; set; }
		
		/// <summary>
		/// The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpOptions")]
		public GetNetworkApplianceVlanReturnDhcpOptions[] GetNetworkApplianceVlanReturnDhcpOptions { get; set; }
		
		/// <summary>
		/// The IPs of the DHCP servers that DHCP requests should be relayed to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpRelayServerIps")]
		public string[] DhcpRelayServerIps { get; set; }
		
		/// <summary>
		/// The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsNameservers")]
		public string DnsNameservers { get; set; }
		
		/// <summary>
		/// The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixedIpAssignments")]
		public string FixedIpAssignments { get; set; }
		
		/// <summary>
		/// The id of the desired group policy to apply to the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
		
		/// <summary>
		/// The VLAN ID of the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The interface ID of the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaceId")]
		public string InterfaceId { get; set; }
		
		/// <summary>
		/// IPv6 configuration on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public GetNetworkApplianceVlanReturnIpv6 Ipv6 { get; set; }
		
		/// <summary>
		/// Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mandatoryDhcp")]
		public GetNetworkApplianceVlanReturnMandatoryDhcp MandatoryDhcp { get; set; }
		
		/// <summary>
		/// Mask used for the subnet of all bound to the template networks. Applicable only for template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mask")]
		public System.Nullable<System.Int32> Mask { get; set; }
		
		/// <summary>
		/// The name of the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The DHCP reserved IP ranges on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservedIpRanges")]
		public GetNetworkApplianceVlanReturnReservedIpRanges[] GetNetworkApplianceVlanReturnReservedIpRanges { get; set; }
		
		/// <summary>
		/// The subnet of the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
		
		/// <summary>
		/// Type of subnetting of the VLAN. Applicable only for template network.
		/// </summary>
		[System.ComponentModel.DefaultValue(GetNetworkApplianceVlansReturnTemplateVlanType.same)]
		[System.Runtime.Serialization.DataMember(Name="templateVlanType")]
		public GetNetworkApplianceVlansReturnTemplateVlanType TemplateVlanType { get; set; } = GetNetworkApplianceVlansReturnTemplateVlanType.same;
		
		/// <summary>
		/// The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vpnNatSubnet")]
		public string VpnNatSubnet { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkApplianceVlanReturnDhcpHandling
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Do not respond to DHCP requests")]
		Do_not_respond_to_DHCP_requests = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Relay DHCP to another server")]
		Relay_DHCP_to_another_server = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Run a DHCP server")]
		Run_a_DHCP_server = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkApplianceVlanReturnDhcpLeaseTime
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 day")]
		_1_day = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 hour")]
		_1_hour = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 week")]
		_1_week = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="12 hours")]
		_12_hours = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="30 minutes")]
		_30_minutes = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4 hours")]
		_4_hours = 5,
	}
	
	public class GetNetworkApplianceVlanReturnDhcpOptions
	{
		
		/// <summary>
		/// The code for the DHCP option. This should be an integer between 2 and 254.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType Type { get; set; }
		
		/// <summary>
		/// The value for the DHCP option
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class GetNetworkApplianceVlanReturnIpv6
	{
		
		/// <summary>
		/// Enable IPv6 on VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Prefix assignments on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefixAssignments")]
		public GetNetworkApplianceVlanReturnIpv6PrefixAssignments[] GetNetworkApplianceVlanReturnIpv6PrefixAssignments { get; set; }
	}
	
	public class GetNetworkApplianceVlanReturnIpv6PrefixAssignments
	{
		
		/// <summary>
		/// Auto assign a /64 prefix from the origin to the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autonomous")]
		public System.Nullable<System.Boolean> Autonomous { get; set; }
		
		/// <summary>
		/// The origin of the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public GetNetworkApplianceVlanReturnIpv6PrefixAssignmentsOrigin Origin { get; set; }
		
		/// <summary>
		/// Manual configuration of the IPv6 Appliance IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticApplianceIp6")]
		public string StaticApplianceIp6 { get; set; }
		
		/// <summary>
		/// Manual configuration of a /64 prefix on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticPrefix")]
		public string StaticPrefix { get; set; }
	}
	
	public class GetNetworkApplianceVlanReturnIpv6PrefixAssignmentsOrigin
	{
		
		/// <summary>
		/// Interfaces associated with the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaces")]
		public string[] Interfaces { get; set; }
		
		/// <summary>
		/// Type of the origin
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType Type { get; set; }
	}
	
	public class GetNetworkApplianceVlanReturnMandatoryDhcp
	{
		
		/// <summary>
		/// Enable Mandatory DHCP on VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class GetNetworkApplianceVlanReturnReservedIpRanges
	{
		
		/// <summary>
		/// A text comment for the reserved range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// The last IP in the reserved range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end")]
		public string End { get; set; }
		
		/// <summary>
		/// The first IP in the reserved range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start")]
		public string Start { get; set; }
	}
	
	public class UpdateNetworkApplianceVlanPutBody
	{
		
		/// <summary>
		/// The local IP of the appliance on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applianceIp")]
		public string ApplianceIp { get; set; }
		
		/// <summary>
		/// CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// DHCP boot option for boot filename
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpBootFilename")]
		public string DhcpBootFilename { get; set; }
		
		/// <summary>
		/// DHCP boot option to direct boot clients to the server to load the boot file from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpBootNextServer")]
		public string DhcpBootNextServer { get; set; }
		
		/// <summary>
		/// Use DHCP boot options specified in other properties
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpBootOptionsEnabled")]
		public System.Nullable<System.Boolean> DhcpBootOptionsEnabled { get; set; }
		
		/// <summary>
		/// The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpHandling")]
		public System.Nullable<UpdateNetworkApplianceVlanPutBodyDhcpHandling> DhcpHandling { get; set; }
		
		/// <summary>
		/// The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpLeaseTime")]
		public System.Nullable<UpdateNetworkApplianceVlanPutBodyDhcpLeaseTime> DhcpLeaseTime { get; set; }
		
		/// <summary>
		/// The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpOptions")]
		public UpdateNetworkApplianceVlanPutBodyDhcpOptions[] UpdateNetworkApplianceVlanPutBodyDhcpOptions { get; set; }
		
		/// <summary>
		/// The IPs of the DHCP servers that DHCP requests should be relayed to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpRelayServerIps")]
		public string[] DhcpRelayServerIps { get; set; }
		
		/// <summary>
		/// The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsNameservers")]
		public string DnsNameservers { get; set; }
		
		/// <summary>
		/// The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixedIpAssignments")]
		public string FixedIpAssignments { get; set; }
		
		/// <summary>
		/// The id of the desired group policy to apply to the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
		
		/// <summary>
		/// IPv6 configuration on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public UpdateNetworkApplianceVlanPutBodyIpv6 Ipv6 { get; set; }
		
		/// <summary>
		/// Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mandatoryDhcp")]
		public UpdateNetworkApplianceVlanPutBodyMandatoryDhcp MandatoryDhcp { get; set; }
		
		/// <summary>
		/// Mask used for the subnet of all bound to the template networks. Applicable only for template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mask")]
		public System.Nullable<System.Int32> Mask { get; set; }
		
		/// <summary>
		/// The name of the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The DHCP reserved IP ranges on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservedIpRanges")]
		public UpdateNetworkApplianceVlanPutBodyReservedIpRanges[] UpdateNetworkApplianceVlanPutBodyReservedIpRanges { get; set; }
		
		/// <summary>
		/// The subnet of the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
		
		/// <summary>
		/// Type of subnetting of the VLAN. Applicable only for template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="templateVlanType")]
		public GetNetworkApplianceVlansReturnTemplateVlanType TemplateVlanType { get; set; }
		
		/// <summary>
		/// The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vpnNatSubnet")]
		public string VpnNatSubnet { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceVlanPutBodyDhcpHandling
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Do not respond to DHCP requests")]
		Do_not_respond_to_DHCP_requests = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Relay DHCP to another server")]
		Relay_DHCP_to_another_server = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Run a DHCP server")]
		Run_a_DHCP_server = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceVlanPutBodyDhcpLeaseTime
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 day")]
		_1_day = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 hour")]
		_1_hour = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 week")]
		_1_week = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="12 hours")]
		_12_hours = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="30 minutes")]
		_30_minutes = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4 hours")]
		_4_hours = 5,
	}
	
	public class UpdateNetworkApplianceVlanPutBodyDhcpOptions
	{
		
		/// <summary>
		/// The code for the DHCP option. This should be an integer between 2 and 254.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType Type { get; set; }
		
		/// <summary>
		/// The value for the DHCP option
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class UpdateNetworkApplianceVlanPutBodyIpv6
	{
		
		/// <summary>
		/// Enable IPv6 on VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Prefix assignments on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefixAssignments")]
		public UpdateNetworkApplianceVlanPutBodyIpv6PrefixAssignments[] UpdateNetworkApplianceVlanPutBodyIpv6PrefixAssignments { get; set; }
	}
	
	public class UpdateNetworkApplianceVlanPutBodyIpv6PrefixAssignments
	{
		
		/// <summary>
		/// Auto assign a /64 prefix from the origin to the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autonomous")]
		public System.Nullable<System.Boolean> Autonomous { get; set; }
		
		/// <summary>
		/// The origin of the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public UpdateNetworkApplianceVlanPutBodyIpv6PrefixAssignmentsOrigin Origin { get; set; }
		
		/// <summary>
		/// Manual configuration of the IPv6 Appliance IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticApplianceIp6")]
		public string StaticApplianceIp6 { get; set; }
		
		/// <summary>
		/// Manual configuration of a /64 prefix on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticPrefix")]
		public string StaticPrefix { get; set; }
	}
	
	public class UpdateNetworkApplianceVlanPutBodyIpv6PrefixAssignmentsOrigin
	{
		
		/// <summary>
		/// Interfaces associated with the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaces")]
		public string[] Interfaces { get; set; }
		
		/// <summary>
		/// Type of the origin
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType Type { get; set; }
	}
	
	public class UpdateNetworkApplianceVlanPutBodyMandatoryDhcp
	{
		
		/// <summary>
		/// Enable Mandatory DHCP on VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateNetworkApplianceVlanPutBodyReservedIpRanges
	{
		
		/// <summary>
		/// A text comment for the reserved range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// The last IP in the reserved range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="end")]
		public string End { get; set; }
		
		/// <summary>
		/// The first IP in the reserved range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start")]
		public string Start { get; set; }
	}
	
	public class UpdateNetworkApplianceVlanReturn
	{
		
		/// <summary>
		/// The local IP of the appliance on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applianceIp")]
		public string ApplianceIp { get; set; }
		
		/// <summary>
		/// CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// DHCP boot option for boot filename
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpBootFilename")]
		public string DhcpBootFilename { get; set; }
		
		/// <summary>
		/// DHCP boot option to direct boot clients to the server to load the boot file from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpBootNextServer")]
		public string DhcpBootNextServer { get; set; }
		
		/// <summary>
		/// Use DHCP boot options specified in other properties
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpBootOptionsEnabled")]
		public System.Nullable<System.Boolean> DhcpBootOptionsEnabled { get; set; }
		
		/// <summary>
		/// The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpHandling")]
		public System.Nullable<UpdateNetworkApplianceVlanReturnDhcpHandling> DhcpHandling { get; set; }
		
		/// <summary>
		/// The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpLeaseTime")]
		public System.Nullable<UpdateNetworkApplianceVlanReturnDhcpLeaseTime> DhcpLeaseTime { get; set; }
		
		/// <summary>
		/// The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpOptions")]
		public UpdateNetworkApplianceVlanReturnDhcpOptions[] UpdateNetworkApplianceVlanReturnDhcpOptions { get; set; }
		
		/// <summary>
		/// The IPs of the DHCP servers that DHCP requests should be relayed to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpRelayServerIps")]
		public string[] DhcpRelayServerIps { get; set; }
		
		/// <summary>
		/// The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsNameservers")]
		public string DnsNameservers { get; set; }
		
		/// <summary>
		/// The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixedIpAssignments")]
		public string FixedIpAssignments { get; set; }
		
		/// <summary>
		/// The id of the desired group policy to apply to the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
		
		/// <summary>
		/// The VLAN ID of the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The interface ID of the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaceId")]
		public string InterfaceId { get; set; }
		
		/// <summary>
		/// IPv6 configuration on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public UpdateNetworkApplianceVlanReturnIpv6 Ipv6 { get; set; }
		
		/// <summary>
		/// Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mandatoryDhcp")]
		public UpdateNetworkApplianceVlanReturnMandatoryDhcp MandatoryDhcp { get; set; }
		
		/// <summary>
		/// Mask used for the subnet of all bound to the template networks. Applicable only for template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mask")]
		public System.Nullable<System.Int32> Mask { get; set; }
		
		/// <summary>
		/// The name of the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The DHCP reserved IP ranges on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservedIpRanges")]
		public UpdateNetworkApplianceVlanReturnReservedIpRanges[] UpdateNetworkApplianceVlanReturnReservedIpRanges { get; set; }
		
		/// <summary>
		/// The subnet of the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
		
		/// <summary>
		/// Type of subnetting of the VLAN. Applicable only for template network.
		/// </summary>
		[System.ComponentModel.DefaultValue(GetNetworkApplianceVlansReturnTemplateVlanType.same)]
		[System.Runtime.Serialization.DataMember(Name="templateVlanType")]
		public GetNetworkApplianceVlansReturnTemplateVlanType TemplateVlanType { get; set; } = GetNetworkApplianceVlansReturnTemplateVlanType.same;
		
		/// <summary>
		/// The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vpnNatSubnet")]
		public string VpnNatSubnet { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceVlanReturnDhcpHandling
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Do not respond to DHCP requests")]
		Do_not_respond_to_DHCP_requests = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Relay DHCP to another server")]
		Relay_DHCP_to_another_server = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Run a DHCP server")]
		Run_a_DHCP_server = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceVlanReturnDhcpLeaseTime
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 day")]
		_1_day = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 hour")]
		_1_hour = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 week")]
		_1_week = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="12 hours")]
		_12_hours = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="30 minutes")]
		_30_minutes = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4 hours")]
		_4_hours = 5,
	}
	
	public class UpdateNetworkApplianceVlanReturnDhcpOptions
	{
		
		/// <summary>
		/// The code for the DHCP option. This should be an integer between 2 and 254.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType Type { get; set; }
		
		/// <summary>
		/// The value for the DHCP option
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class UpdateNetworkApplianceVlanReturnIpv6
	{
		
		/// <summary>
		/// Enable IPv6 on VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Prefix assignments on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefixAssignments")]
		public UpdateNetworkApplianceVlanReturnIpv6PrefixAssignments[] UpdateNetworkApplianceVlanReturnIpv6PrefixAssignments { get; set; }
	}
	
	public class UpdateNetworkApplianceVlanReturnIpv6PrefixAssignments
	{
		
		/// <summary>
		/// Auto assign a /64 prefix from the origin to the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autonomous")]
		public System.Nullable<System.Boolean> Autonomous { get; set; }
		
		/// <summary>
		/// The origin of the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public UpdateNetworkApplianceVlanReturnIpv6PrefixAssignmentsOrigin Origin { get; set; }
		
		/// <summary>
		/// Manual configuration of the IPv6 Appliance IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticApplianceIp6")]
		public string StaticApplianceIp6 { get; set; }
		
		/// <summary>
		/// Manual configuration of a /64 prefix on the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticPrefix")]
		public string StaticPrefix { get; set; }
	}
	
	public class UpdateNetworkApplianceVlanReturnIpv6PrefixAssignmentsOrigin
	{
		
		/// <summary>
		/// Interfaces associated with the prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaces")]
		public string[] Interfaces { get; set; }
		
		/// <summary>
		/// Type of the origin
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CreateNetworkAppliancePrefixesDelegatedStaticPostBodyOriginType Type { get; set; }
	}
	
	public class UpdateNetworkApplianceVlanReturnMandatoryDhcp
	{
		
		/// <summary>
		/// Enable Mandatory DHCP on VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateNetworkApplianceVlanReturnReservedIpRanges
	{
		
		/// <summary>
		/// A text comment for the reserved range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// The last IP in the reserved range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end")]
		public string End { get; set; }
		
		/// <summary>
		/// The first IP in the reserved range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start")]
		public string Start { get; set; }
	}
	
	public class UpdateNetworkApplianceVpnBgpPutBody
	{
		
		/// <summary>
		/// An Autonomous System Number (ASN) is required if you are to run BGP and peer with another BGP Speaker outside of the Auto VPN domain. This ASN will be applied to the entire Auto VPN domain. The entire 4-byte ASN range is supported. So, the ASN must be an integer between 1 and 4294967295. When absent, this field is not updated. If no value exists then it defaults to 64512.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="asNumber")]
		public System.Nullable<System.Int32> AsNumber { get; set; }
		
		/// <summary>
		/// Boolean value to enable or disable the BGP configuration. When BGP is enabled, the asNumber (ASN) will be autopopulated with the preconfigured ASN at other Hubs or a default value if there is no ASN configured.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// The IBGP holdtimer in seconds. The IBGP holdtimer must be an integer between 12 and 240. When absent, this field is not updated. If no value exists then it defaults to 240.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ibgpHoldTimer")]
		public System.Nullable<System.Int32> IbgpHoldTimer { get; set; }
		
		/// <summary>
		/// List of BGP neighbors. This list replaces the existing set of neighbors. When absent, this field is not updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="neighbors")]
		public UpdateNetworkApplianceVpnBgpPutBodyNeighbors[] UpdateNetworkApplianceVpnBgpPutBodyNeighbors { get; set; }
	}
	
	public class UpdateNetworkApplianceVpnBgpPutBodyNeighbors
	{
		
		/// <summary>
		/// When this feature is on, the Meraki device will advertise routes learned from other Autonomous Systems, thereby allowing traffic between Autonomous Systems to transit this AS. When absent, it defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowTransit")]
		public System.Nullable<System.Boolean> AllowTransit { get; set; }
		
		/// <summary>
		/// The EBGP hold timer in seconds for each neighbor. The EBGP hold timer must be an integer between 12 and 240.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ebgpHoldTimer")]
		public int EbgpHoldTimer { get; set; }
		
		/// <summary>
		/// Configure this if the neighbor is not adjacent. The EBGP multi-hop must be an integer between 1 and 255.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ebgpMultihop")]
		public int EbgpMultihop { get; set; }
		
		/// <summary>
		/// The IPv4 address of the neighbor
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// Information regarding IPv6 address of the neighbor, Required if `ip` is not present.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public UpdateNetworkApplianceVpnBgpPutBodyNeighborsIpv6 Ipv6 { get; set; }
		
		/// <summary>
		/// The receive limit is the maximum number of routes that can be received from any BGP peer. The receive limit must be an integer between 0 and 4294967295. When absent, it defaults to 0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="receiveLimit")]
		public System.Nullable<System.Int32> ReceiveLimit { get; set; }
		
		/// <summary>
		/// Remote ASN of the neighbor. The remote ASN must be an integer between 1 and 4294967295.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="remoteAsNumber")]
		public int RemoteAsNumber { get; set; }
	}
	
	public class UpdateNetworkApplianceVpnBgpPutBodyNeighborsIpv6
	{
		
		/// <summary>
		/// The IPv6 address of the neighbor.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
	}
	
	public class GetNetworkApplianceVpnSiteToSiteVpnReturn
	{
		
		/// <summary>
		/// The list of VPN hubs, in order of preference.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hubs")]
		public GetNetworkApplianceVpnSiteToSiteVpnReturnHubs[] GetNetworkApplianceVpnSiteToSiteVpnReturnHubs { get; set; }
		
		/// <summary>
		/// The site-to-site VPN mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public string Mode { get; set; }
		
		/// <summary>
		/// The list of subnets and their VPN presence.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnets")]
		public GetNetworkApplianceVpnSiteToSiteVpnReturnSubnets[] GetNetworkApplianceVpnSiteToSiteVpnReturnSubnets { get; set; }
	}
	
	public class GetNetworkApplianceVpnSiteToSiteVpnReturnHubs
	{
		
		/// <summary>
		/// The network ID of the hub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hubId")]
		public string HubId { get; set; }
		
		/// <summary>
		/// Indicates whether default route traffic should be sent to this hub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useDefaultRoute")]
		public System.Nullable<System.Boolean> UseDefaultRoute { get; set; }
	}
	
	public class GetNetworkApplianceVpnSiteToSiteVpnReturnSubnets
	{
		
		/// <summary>
		/// The CIDR notation subnet used within the VPN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localSubnet")]
		public string LocalSubnet { get; set; }
		
		/// <summary>
		/// Indicates the presence of the subnet in the VPN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useVpn")]
		public System.Nullable<System.Boolean> UseVpn { get; set; }
	}
	
	public class UpdateNetworkApplianceVpnSiteToSiteVpnPutBody
	{
		
		/// <summary>
		/// The list of VPN hubs, in order of preference. In spoke mode, at least 1 hub is required.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hubs")]
		public UpdateNetworkApplianceVpnSiteToSiteVpnPutBodyHubs[] UpdateNetworkApplianceVpnSiteToSiteVpnPutBodyHubs { get; set; }
		
		/// <summary>
		/// The site-to-site VPN mode. Can be one of 'none', 'spoke' or 'hub'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public UpdateNetworkApplianceVpnSiteToSiteVpnPutBodyMode Mode { get; set; }
		
		/// <summary>
		/// The list of subnets and their VPN presence.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnets")]
		public UpdateNetworkApplianceVpnSiteToSiteVpnPutBodySubnets[] UpdateNetworkApplianceVpnSiteToSiteVpnPutBodySubnets { get; set; }
	}
	
	public class UpdateNetworkApplianceVpnSiteToSiteVpnPutBodyHubs
	{
		
		/// <summary>
		/// The network ID of the hub.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hubId")]
		public string HubId { get; set; }
		
		/// <summary>
		/// Only valid in 'spoke' mode. Indicates whether default route traffic should be sent to this hub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useDefaultRoute")]
		public System.Nullable<System.Boolean> UseDefaultRoute { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkApplianceVpnSiteToSiteVpnPutBodyMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hub = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		spoke = 2,
	}
	
	public class UpdateNetworkApplianceVpnSiteToSiteVpnPutBodySubnets
	{
		
		/// <summary>
		/// The CIDR notation subnet used within the VPN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="localSubnet")]
		public string LocalSubnet { get; set; }
		
		/// <summary>
		/// Indicates the presence of the subnet in the VPN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useVpn")]
		public System.Nullable<System.Boolean> UseVpn { get; set; }
	}
	
	public class UpdateNetworkApplianceVpnSiteToSiteVpnReturn
	{
		
		/// <summary>
		/// The list of VPN hubs, in order of preference.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hubs")]
		public UpdateNetworkApplianceVpnSiteToSiteVpnReturnHubs[] UpdateNetworkApplianceVpnSiteToSiteVpnReturnHubs { get; set; }
		
		/// <summary>
		/// The site-to-site VPN mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public string Mode { get; set; }
		
		/// <summary>
		/// The list of subnets and their VPN presence.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnets")]
		public UpdateNetworkApplianceVpnSiteToSiteVpnReturnSubnets[] UpdateNetworkApplianceVpnSiteToSiteVpnReturnSubnets { get; set; }
	}
	
	public class UpdateNetworkApplianceVpnSiteToSiteVpnReturnHubs
	{
		
		/// <summary>
		/// The network ID of the hub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hubId")]
		public string HubId { get; set; }
		
		/// <summary>
		/// Indicates whether default route traffic should be sent to this hub.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useDefaultRoute")]
		public System.Nullable<System.Boolean> UseDefaultRoute { get; set; }
	}
	
	public class UpdateNetworkApplianceVpnSiteToSiteVpnReturnSubnets
	{
		
		/// <summary>
		/// The CIDR notation subnet used within the VPN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localSubnet")]
		public string LocalSubnet { get; set; }
		
		/// <summary>
		/// Indicates the presence of the subnet in the VPN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useVpn")]
		public System.Nullable<System.Boolean> UseVpn { get; set; }
	}
	
	public class UpdateNetworkApplianceWarmSparePutBody
	{
		
		/// <summary>
		/// Enable warm spare
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Serial number of the warm spare appliance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="spareSerial")]
		public string SpareSerial { get; set; }
		
		/// <summary>
		/// Uplink mode, either virtual or public
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uplinkMode")]
		public string UplinkMode { get; set; }
		
		/// <summary>
		/// The WAN 1 shared IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualIp1")]
		public string VirtualIp1 { get; set; }
		
		/// <summary>
		/// The WAN 2 shared IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualIp2")]
		public string VirtualIp2 { get; set; }
	}
	
	public class BindNetworkPostBody
	{
		
		/// <summary>
		/// Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model. Defaults to false if left unspecified. This option only affects switch networks and switch templates. Auto-bind is not valid unless the switch template has at least one profile and has at most one profile per switch model.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoBind")]
		public System.Nullable<System.Boolean> AutoBind { get; set; }
		
		/// <summary>
		/// The ID of the template to which the network should be bound.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configTemplateId")]
		public string ConfigTemplateId { get; set; }
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBody
	{
		
		/// <summary>
		/// Whether or not to record audio. Can be either true or false. Defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="audioRecordingEnabled")]
		public System.Nullable<System.Boolean> AudioRecordingEnabled { get; set; }
		
		/// <summary>
		/// Create redundant video backup using Cloud Archive. Can be either true or false. Defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloudArchiveEnabled")]
		public System.Nullable<System.Boolean> CloudArchiveEnabled { get; set; }
		
		/// <summary>
		/// The maximum number of days for which the data will be stored, or 'null' to keep data until storage space runs out. If the former, it can be one of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 30, 60, 90] days.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxRetentionDays")]
		public System.Nullable<System.Int32> MaxRetentionDays { get; set; }
		
		/// <summary>
		/// Deletes footage older than 3 days in which no motion was detected. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="motionBasedRetentionEnabled")]
		public System.Nullable<System.Boolean> MotionBasedRetentionEnabled { get; set; }
		
		/// <summary>
		/// The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="motionDetectorVersion")]
		public System.Nullable<System.Int32> MotionDetectorVersion { get; set; }
		
		/// <summary>
		/// The name of the new profile. Must be unique. This parameter is required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Disable features that require additional bandwidth such as Motion Recap. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restrictedBandwidthModeEnabled")]
		public System.Nullable<System.Boolean> RestrictedBandwidthModeEnabled { get; set; }
		
		/// <summary>
		/// Schedule for which this camera will record video, or 'null' to always record.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleId")]
		public string ScheduleId { get; set; }
		
		/// <summary>
		/// Video quality and resolution settings for all the camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="videoSettings")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings VideoSettings { get; set; }
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettings
	{
		
		/// <summary>
		/// Quality and resolution for MV12/MV22/MV72 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="MV12/MV22/MV72")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72 MV12SlashMV22SlashMV72 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV12WE camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12WE MV12WE { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV13 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13 MV13 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV21/MV71 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="MV21/MV71")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV21SlashMV71 MV21SlashMV71 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV22X/MV72X camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="MV22X/MV72X")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV22XSlashMV72X MV22XSlashMV72X { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV32 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32 MV32 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV33 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33 MV33 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV52 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52 MV52 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV63 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63 MV63 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV63X camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63X MV63X { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV93 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93 MV93 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV93X camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93X MV93X { get; set; }
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12SlashMV22SlashMV72Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 1,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12WE
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12WEResolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV12WEResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 1,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080' or '2688x1512'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV13Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 1,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV21SlashMV71
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV21SlashMV71Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV21SlashMV71Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV22XSlashMV72X
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720', '1920x1080' or '2688x1512'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV22XSlashMV72XResolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV22XSlashMV72XResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 2,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080' or '2058x2058'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV32Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2058x2058")]
		_2058x2058 = 1,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV33Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2112x2112")]
		_2112x2112 = 1,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720', '1920x1080', '2688x1512' or '3840x2160'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV52Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="3840x2160")]
		_3840x2160 = 3,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1920x1080' or '2688x1512'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 1,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63X
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63XResolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV63XResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="3840x2160")]
		_3840x2160 = 2,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2112x2112")]
		_2112x2112 = 1,
	}
	
	public class CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93X
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93XResolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraQualityRetentionProfilePostBodyVideoSettingsMV93XResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2112x2112")]
		_2112x2112 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2880x2880")]
		_2880x2880 = 2,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBody
	{
		
		/// <summary>
		/// Whether or not to record audio. Can be either true or false. Defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="audioRecordingEnabled")]
		public System.Nullable<System.Boolean> AudioRecordingEnabled { get; set; }
		
		/// <summary>
		/// Create redundant video backup using Cloud Archive. Can be either true or false. Defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloudArchiveEnabled")]
		public System.Nullable<System.Boolean> CloudArchiveEnabled { get; set; }
		
		/// <summary>
		/// The maximum number of days for which the data will be stored, or 'null' to keep data until storage space runs out. If the former, it can be one of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 30, 60, 90] days.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxRetentionDays")]
		public System.Nullable<System.Int32> MaxRetentionDays { get; set; }
		
		/// <summary>
		/// Deletes footage older than 3 days in which no motion was detected. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="motionBasedRetentionEnabled")]
		public System.Nullable<System.Boolean> MotionBasedRetentionEnabled { get; set; }
		
		/// <summary>
		/// The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="motionDetectorVersion")]
		public System.Nullable<System.Int32> MotionDetectorVersion { get; set; }
		
		/// <summary>
		/// The name of the new profile. Must be unique.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Disable features that require additional bandwidth such as Motion Recap. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restrictedBandwidthModeEnabled")]
		public System.Nullable<System.Boolean> RestrictedBandwidthModeEnabled { get; set; }
		
		/// <summary>
		/// Schedule for which this camera will record video, or 'null' to always record.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleId")]
		public string ScheduleId { get; set; }
		
		/// <summary>
		/// Video quality and resolution settings for all the camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="videoSettings")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings VideoSettings { get; set; }
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettings
	{
		
		/// <summary>
		/// Quality and resolution for MV12/MV22/MV72 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="MV12/MV22/MV72")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12SlashMV22SlashMV72 MV12SlashMV22SlashMV72 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV12WE camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12WE MV12WE { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV13 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV13 MV13 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV21/MV71 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="MV21/MV71")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV21SlashMV71 MV21SlashMV71 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV22X/MV72X camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="MV22X/MV72X")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV22XSlashMV72X MV22XSlashMV72X { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV32 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV32 MV32 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV33 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV33 MV33 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV52 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV52 MV52 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV63 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63 MV63 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV63X camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63X MV63X { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV93 camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93 MV93 { get; set; }
		
		/// <summary>
		/// Quality and resolution for MV93X camera models.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93X MV93X { get; set; }
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12SlashMV22SlashMV72
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12SlashMV22SlashMV72Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12SlashMV22SlashMV72Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 1,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12WE
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12WEResolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV12WEResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 1,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV13
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080' or '2688x1512'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV13Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV13Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 1,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV21SlashMV71
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV21SlashMV71Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV21SlashMV71Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV22XSlashMV72X
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720', '1920x1080' or '2688x1512'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV22XSlashMV72XResolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV22XSlashMV72XResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 2,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV32
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080' or '2058x2058'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV32Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV32Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2058x2058")]
		_2058x2058 = 1,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV33
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV33Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV33Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2112x2112")]
		_2112x2112 = 1,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV52
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1280x720', '1920x1080', '2688x1512' or '3840x2160'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV52Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV52Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1280x720")]
		_1280x720 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="3840x2160")]
		_3840x2160 = 3,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1920x1080' or '2688x1512'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 1,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63X
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63XResolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV63XResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1920x1080")]
		_1920x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2688x1512")]
		_2688x1512 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="3840x2160")]
		_3840x2160 = 2,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93Resolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93Resolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2112x2112")]
		_2112x2112 = 1,
	}
	
	public class UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93X
	{
		
		/// <summary>
		/// Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public UpdateDeviceCameraQualityAndRetentionPutBodyQuality Quality { get; set; }
		
		/// <summary>
		/// Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93XResolution Resolution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraQualityRetentionProfilePutBodyVideoSettingsMV93XResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1080x1080")]
		_1080x1080 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2112x2112")]
		_2112x2112 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2880x2880")]
		_2880x2880 = 2,
	}
	
	public class CreateNetworkCameraWirelessProfilePostBody
	{
		
		/// <summary>
		/// The identity of the wireless profile. Required for creating wireless profiles in 8021x-radius auth mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="identity")]
		public CreateNetworkCameraWirelessProfilePostBodyIdentity Identity { get; set; }
		
		/// <summary>
		/// The name of the camera wireless profile. This parameter is required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The details of the SSID config.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ssid")]
		public CreateNetworkCameraWirelessProfilePostBodySsid Ssid { get; set; }
	}
	
	public class CreateNetworkCameraWirelessProfilePostBodyIdentity
	{
		
		/// <summary>
		/// The password of the identity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// The username of the identity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	public class CreateNetworkCameraWirelessProfilePostBodySsid
	{
		
		/// <summary>
		/// The auth mode of the SSID. It can be set to ('psk', '8021x-radius').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authMode")]
		public System.Nullable<CreateNetworkCameraWirelessProfilePostBodySsidAuthMode> AuthMode { get; set; }
		
		/// <summary>
		/// The encryption mode of the SSID. It can be set to ('wpa', 'wpa-eap'). With 'wpa' mode, the authMode should be 'psk' and with 'wpa-eap' the authMode should be '8021x-radius'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptionMode")]
		public string EncryptionMode { get; set; }
		
		/// <summary>
		/// The name of the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The pre-shared key of the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="psk")]
		public string Psk { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkCameraWirelessProfilePostBodySsidAuthMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8021x-radius")]
		_8021xMinusradius = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		psk = 1,
	}
	
	public class UpdateNetworkCameraWirelessProfilePutBody
	{
		
		/// <summary>
		/// The identity of the wireless profile. Required for creating wireless profiles in 8021x-radius auth mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="identity")]
		public UpdateNetworkCameraWirelessProfilePutBodyIdentity Identity { get; set; }
		
		/// <summary>
		/// The name of the camera wireless profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The details of the SSID config.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssid")]
		public UpdateNetworkCameraWirelessProfilePutBodySsid Ssid { get; set; }
	}
	
	public class UpdateNetworkCameraWirelessProfilePutBodyIdentity
	{
		
		/// <summary>
		/// The password of the identity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// The username of the identity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	public class UpdateNetworkCameraWirelessProfilePutBodySsid
	{
		
		/// <summary>
		/// The auth mode of the SSID. It can be set to ('psk', '8021x-radius').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authMode")]
		public System.Nullable<UpdateNetworkCameraWirelessProfilePutBodySsidAuthMode> AuthMode { get; set; }
		
		/// <summary>
		/// The encryption mode of the SSID. It can be set to ('wpa', 'wpa-eap'). With 'wpa' mode, the authMode should be 'psk' and with 'wpa-eap' the authMode should be '8021x-radius'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptionMode")]
		public string EncryptionMode { get; set; }
		
		/// <summary>
		/// The name of the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The pre-shared key of the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="psk")]
		public string Psk { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCameraWirelessProfilePutBodySsidAuthMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8021x-radius")]
		_8021xMinusradius = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		psk = 1,
	}
	
	public class UpdateNetworkCellularGatewayConnectivityMonitoringDestinationsPutBody
	{
		
		/// <summary>
		/// The list of connectivity monitoring destinations
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinations")]
		public UpdateNetworkCellularGatewayConnectivityMonitoringDestinationsPutBodyDestinations[] UpdateNetworkCellularGatewayConnectivityMonitoringDestinationsPutBodyDestinations { get; set; }
	}
	
	public class UpdateNetworkCellularGatewayConnectivityMonitoringDestinationsPutBodyDestinations
	{
		
		/// <summary>
		/// Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="default")]
		public System.Nullable<System.Boolean> Default { get; set; }
		
		/// <summary>
		/// Description of the testing destination. Optional, defaults to an empty string
		/// </summary>
		[System.ComponentModel.DefaultValue("")]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; } = "";
		
		/// <summary>
		/// The IP address to test connectivity with
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class GetNetworkCellularGatewayDhcpReturn
	{
		
		/// <summary>
		/// DHCP Lease time for all MG in the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpLeaseTime")]
		public System.Nullable<GetNetworkCellularGatewayDhcpReturnDhcpLeaseTime> DhcpLeaseTime { get; set; }
		
		/// <summary>
		/// List of fixed IPs representing the the DNS Name servers when the mode is 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsCustomNameservers")]
		public string[] DnsCustomNameservers { get; set; }
		
		/// <summary>
		/// DNS name servers mode for all MG in the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsNameservers")]
		public System.Nullable<GetNetworkCellularGatewayDhcpReturnDnsNameservers> DnsNameservers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkCellularGatewayDhcpReturnDhcpLeaseTime
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 day")]
		_1_day = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 hour")]
		_1_hour = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 week")]
		_1_week = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="12 hours")]
		_12_hours = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="30 minutes")]
		_30_minutes = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4 hours")]
		_4_hours = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkCellularGatewayDhcpReturnDnsNameservers
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		google_dns = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		opendns = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		upstream_dns = 3,
	}
	
	public class UpdateNetworkCellularGatewayDhcpPutBody
	{
		
		/// <summary>
		/// DHCP Lease time for all MG of the network. Possible values are '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpLeaseTime")]
		public string DhcpLeaseTime { get; set; }
		
		/// <summary>
		/// list of fixed IPs representing the the DNS Name servers when the mode is 'custom'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsCustomNameservers")]
		public string[] DnsCustomNameservers { get; set; }
		
		/// <summary>
		/// DNS name servers mode for all MG of the network. Possible values are: 'upstream_dns', 'google_dns', 'opendns', 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsNameservers")]
		public string DnsNameservers { get; set; }
	}
	
	public class UpdateNetworkCellularGatewayDhcpReturn
	{
		
		/// <summary>
		/// DHCP Lease time for all MG in the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpLeaseTime")]
		public System.Nullable<UpdateNetworkCellularGatewayDhcpReturnDhcpLeaseTime> DhcpLeaseTime { get; set; }
		
		/// <summary>
		/// List of fixed IPs representing the the DNS Name servers when the mode is 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsCustomNameservers")]
		public string[] DnsCustomNameservers { get; set; }
		
		/// <summary>
		/// DNS name servers mode for all MG in the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsNameservers")]
		public GetNetworkCellularGatewayDhcpReturnDnsNameservers DnsNameservers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkCellularGatewayDhcpReturnDhcpLeaseTime
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 day")]
		_1_day = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 hour")]
		_1_hour = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 week")]
		_1_week = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="12 hours")]
		_12_hours = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="30 minutes")]
		_30_minutes = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4 hours")]
		_4_hours = 5,
	}
	
	public class UpdateNetworkCellularGatewaySubnetPoolPutBody
	{
		
		/// <summary>
		/// CIDR of the pool of subnets. Each MG in this network will automatically pick a subnet from this pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// Mask used for the subnet of all MGs in  this network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mask")]
		public System.Nullable<System.Int32> Mask { get; set; }
	}
	
	public class UpdateNetworkCellularGatewayUplinkPutBody
	{
		
		/// <summary>
		/// The bandwidth settings for the 'cellular' uplink
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandwidthLimits")]
		public UpdateNetworkCellularGatewayUplinkPutBodyBandwidthLimits BandwidthLimits { get; set; }
	}
	
	public class UpdateNetworkCellularGatewayUplinkPutBodyBandwidthLimits
	{
		
		/// <summary>
		/// The maximum download limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitDown")]
		public System.Nullable<System.Int32> LimitDown { get; set; }
		
		/// <summary>
		/// The maximum upload limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitUp")]
		public System.Nullable<System.Int32> LimitUp { get; set; }
	}
	
	public class GetNetworkClientsReturn
	{
		
		/// <summary>
		/// The adaptive policy group of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adaptivePolicyGroup")]
		public string AdaptivePolicyGroup { get; set; }
		
		/// <summary>
		/// Short description of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Prediction of the client's device type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceTypePrediction")]
		public string DeviceTypePrediction { get; set; }
		
		/// <summary>
		/// Timestamp client was first seen in the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firstSeen")]
		public System.Nullable<System.Int32> FirstSeen { get; set; }
		
		/// <summary>
		/// 802.1x group policy of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicy8021x")]
		public string GroupPolicy8021x { get; set; }
		
		/// <summary>
		/// The ID of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The IP address of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// The IPv6 address of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip6")]
		public string Ip6 { get; set; }
		
		/// <summary>
		/// Local IPv6 address of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip6Local")]
		public string Ip6Local { get; set; }
		
		/// <summary>
		/// Timestamp client was last seen in the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastSeen")]
		public System.Nullable<System.Int32> LastSeen { get; set; }
		
		/// <summary>
		/// The MAC address of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// Manufacturer of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="manufacturer")]
		public string Manufacturer { get; set; }
		
		/// <summary>
		/// Named VLAN of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namedVlan")]
		public string NamedVlan { get; set; }
		
		/// <summary>
		/// Notes on the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// The operating system of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="os")]
		public string Os { get; set; }
		
		/// <summary>
		/// Client's most recent connection type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recentDeviceConnection")]
		public System.Nullable<GetNetworkClientsReturnRecentDeviceConnection> RecentDeviceConnection { get; set; }
		
		/// <summary>
		/// The MAC address of the node that the device was last connected to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recentDeviceMac")]
		public string RecentDeviceMac { get; set; }
		
		/// <summary>
		/// The name of the node the device was last connected to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recentDeviceName")]
		public string RecentDeviceName { get; set; }
		
		/// <summary>
		/// The serial of the node the device was last connected to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recentDeviceSerial")]
		public string RecentDeviceSerial { get; set; }
		
		/// <summary>
		/// Status of SM for the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smInstalled")]
		public System.Nullable<System.Boolean> SmInstalled { get; set; }
		
		/// <summary>
		/// The name of the SSID that the client is connected to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssid")]
		public string Ssid { get; set; }
		
		/// <summary>
		/// The connection status of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<GetNetworkClientsReturnStatus> Status { get; set; }
		
		/// <summary>
		/// The switch port that the client is connected to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchport")]
		public string Switchport { get; set; }
		
		/// <summary>
		/// Usage, sent and received
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usage")]
		public GetNetworkClientsReturnUsage Usage { get; set; }
		
		/// <summary>
		/// The username of the user of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public string User { get; set; }
		
		/// <summary>
		/// The name of the VLAN that the client is connected to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public string Vlan { get; set; }
		
		/// <summary>
		/// Wireless capabilities of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wirelessCapabilities")]
		public string WirelessCapabilities { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkClientsReturnRecentDeviceConnection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Wired = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Wireless = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkClientsReturnStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Offline = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Online = 1,
	}
	
	public class GetNetworkClientsReturnUsage
	{
		
		/// <summary>
		/// Usage received by the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recv")]
		public System.Nullable<System.Single> Recv { get; set; }
		
		/// <summary>
		/// Usage sent by the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sent")]
		public System.Nullable<System.Single> Sent { get; set; }
	}
	
	public enum GetNetworkClientsApplicationUsageSsidNumber
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_4 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_5 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_6 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_7 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_8 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_9 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_10 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_11 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_12 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_13 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_14 = 14,
	}
	
	public class ProvisionNetworkClientsPostBody
	{
		
		/// <summary>
		/// The array of clients to provision
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clients")]
		public ProvisionNetworkClientsPostBodyClients[] ProvisionNetworkClientsPostBodyClients { get; set; }
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Group policy', 'Allowed', 'Blocked', 'Per connection' or 'Normal'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyDevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
		
		/// <summary>
		/// An object, describing what the policy-connection association is for the security appliance. (Only relevant if the security appliance is actually within the network)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policiesBySecurityAppliance")]
		public ProvisionNetworkClientsPostBodyPoliciesBySecurityAppliance PoliciesBySecurityAppliance { get; set; }
		
		/// <summary>
		/// An object, describing the policy-connection associations for each active SSID within the network. Keys should be the number of enabled SSIDs, mapping to an object describing the client's policy
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policiesBySsid")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid PoliciesBySsid { get; set; }
	}
	
	public class ProvisionNetworkClientsPostBodyClients
	{
		
		/// <summary>
		/// The MAC address of the client. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// The display name for the client. Optional. Limited to 255 bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyDevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Allowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Per connection")]
		Per_connection = 4,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySecurityAppliance
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Allowed', 'Blocked' or 'Normal'. Required.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public System.Nullable<ProvisionNetworkClientsPostBodyPoliciesBySecurityApplianceDevicePolicy> DevicePolicy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySecurityApplianceDevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Allowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 2,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid
	{
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="0")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_0 _0 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="1")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_1 _1 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="2")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_2 _2 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="3")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_3 _3 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="4")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_4 _4 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="5")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_5 _5 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="6")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_6 _6 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="7")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_7 _7 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="8")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_8 _8 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="9")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_9 _9 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="10")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_10 _10 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="11")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_11 _11 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="12")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_12 _12 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="13")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_13 _13 { get; set; }
		
		/// <summary>
		/// The number for the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="14")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_14 _14 { get; set; }
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_0
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_0DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_0DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Allowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_1
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_1DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_1DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Allowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_2
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_2DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_2DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Allowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_3
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_3DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_3DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Allowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_4
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_4DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_4DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Allowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_5
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_5DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_5DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Allowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_6
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_6DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_6DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Allowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_7
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_7DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_7DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Allowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_8
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_8DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_8DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Allowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_9
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_9DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_9DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Allowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_10
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_10DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_10DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Allowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_11
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_11DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_11DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Allowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_12
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_12DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_12DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Allowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_13
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_13DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_13DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Allowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 3,
	}
	
	public class ProvisionNetworkClientsPostBodyPoliciesBySsid_14
	{
		
		/// <summary>
		/// The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public ProvisionNetworkClientsPostBodyPoliciesBySsid_14DevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProvisionNetworkClientsPostBodyPoliciesBySsid_14DevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Allowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Normal = 3,
	}
	
	public enum GetNetworkClientsUsageHistoriesSsidNumber
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_4 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_5 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_6 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_7 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_8 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_9 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_10 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_11 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_12 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_13 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_14 = 14,
	}
	
	public class GetNetworkClientReturn
	{
		
		/// <summary>
		/// The Cisco discover protocol settings for the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cdp")]
		public string[] Cdp { get; set; }
		
		/// <summary>
		/// VPN connections associated with the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientVpnConnections")]
		public GetNetworkClientReturnClientVpnConnections[] GetNetworkClientReturnClientVpnConnections { get; set; }
		
		/// <summary>
		/// Short description of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Timestamp client was first seen in the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firstSeen")]
		public System.Nullable<System.Int32> FirstSeen { get; set; }
		
		/// <summary>
		/// The ID of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The IP address of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// The IPv6 address of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip6")]
		public string Ip6 { get; set; }
		
		/// <summary>
		/// Timestamp client was last seen in the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastSeen")]
		public System.Nullable<System.Int32> LastSeen { get; set; }
		
		/// <summary>
		/// The link layer discover protocol settings for the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lldp")]
		public string[] Lldp { get; set; }
		
		/// <summary>
		/// The MAC address of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// Manufacturer of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="manufacturer")]
		public string Manufacturer { get; set; }
		
		/// <summary>
		/// The operating system of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="os")]
		public string Os { get; set; }
		
		/// <summary>
		/// The MAC address of the node that the device was last connected to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recentDeviceMac")]
		public string RecentDeviceMac { get; set; }
		
		/// <summary>
		/// Status of SM for the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smInstalled")]
		public System.Nullable<System.Boolean> SmInstalled { get; set; }
		
		/// <summary>
		/// The name of the SSID that the client is connected to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssid")]
		public string Ssid { get; set; }
		
		/// <summary>
		/// The connection status of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public GetNetworkClientsReturnStatus Status { get; set; }
		
		/// <summary>
		/// The switch port that the client is connected to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchport")]
		public string Switchport { get; set; }
		
		/// <summary>
		/// The username of the user of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public string User { get; set; }
		
		/// <summary>
		/// The name of the VLAN that the client is connected to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public string Vlan { get; set; }
		
		/// <summary>
		/// Wireless capabilities of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wirelessCapabilities")]
		public string WirelessCapabilities { get; set; }
	}
	
	public class GetNetworkClientReturnClientVpnConnections
	{
		
		/// <summary>
		/// The time the client last connected to the VPN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectedAt")]
		public System.Nullable<System.Int32> ConnectedAt { get; set; }
		
		/// <summary>
		/// The time the client last disconnectd from the VPN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disconnectedAt")]
		public System.Nullable<System.Int32> DisconnectedAt { get; set; }
		
		/// <summary>
		/// The IP address of the VPN the client last connected to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remoteIp")]
		public string RemoteIp { get; set; }
	}
	
	public class UpdateNetworkClientPolicyPutBody
	{
		
		/// <summary>
		/// The policy to assign. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public string DevicePolicy { get; set; }
		
		/// <summary>
		/// [optional] If 'devicePolicy' is set to 'Group policy' this param is used to specify the group policy ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBody
	{
		
		/// <summary>
		/// The target SSIDs. Each SSID must be enabled and must have Click-through splash enabled. For each SSID where isAuthorized is true, the expiration time will automatically be set according to the SSID's splash frequency. Not all networks support configuring all SSIDs
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ssids")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids Ssids { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids
	{
		
		/// <summary>
		/// Splash authorization for SSID 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="0")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_0 _0 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="1")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_1 _1 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="2")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_2 _2 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 3
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="3")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_3 _3 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 4
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="4")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_4 _4 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 5
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="5")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_5 _5 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 6
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="6")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_6 _6 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 7
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="7")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_7 _7 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 8
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="8")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_8 _8 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 9
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="9")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_9 _9 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="10")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_10 _10 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 11
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="11")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_11 _11 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 12
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="12")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_12 _12 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 13
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="13")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_13 _13 { get; set; }
		
		/// <summary>
		/// Splash authorization for SSID 14
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="14")]
		public UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_14 _14 { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_0
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_1
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_2
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_3
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_4
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_5
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_6
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_7
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_8
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_9
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_10
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_11
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_12
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_13
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class UpdateNetworkClientSplashAuthorizationStatusPutBodySsids_14
	{
		
		/// <summary>
		/// New authorization status for the SSID (true, false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAuthorized")]
		public System.Nullable<System.Boolean> IsAuthorized { get; set; }
	}
	
	public class ClaimNetworkDevicesPostBody
	{
		
		/// <summary>
		/// A list of serials of devices to claim
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string[] Serials { get; set; }
	}
	
	public class VmxNetworkDevicesClaimPostBody
	{
		
		/// <summary>
		/// The size of the vMX you claim. It can be one of: small, medium, large, 100
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public VmxNetworkDevicesClaimPostBodySize Size { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum VmxNetworkDevicesClaimPostBodySize
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="100")]
		_100 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		large = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		medium = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		small = 3,
	}
	
	public class RemoveNetworkDevicesPostBody
	{
		
		/// <summary>
		/// The serial of a device
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public enum GetNetworkEventsProductType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		appliance = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		camera = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cellularGateway = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="switch")]
		_switch = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		systemsManager = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wireless = 5,
	}
	
	public class GetNetworkEventsReturn
	{
		
		/// <summary>
		/// An array of events that took place in the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="events")]
		public GetNetworkEventsReturnEvents[] GetNetworkEventsReturnEvents { get; set; }
		
		/// <summary>
		/// A message regarding the events sent. Usually 'null' unless there are no events
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// An UTC ISO8601 string of the latest occured at time of the listed events of the page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pageEndAt")]
		public string PageEndAt { get; set; }
		
		/// <summary>
		/// An UTC ISO8601 string of the earliest occured at time of the listed events of the page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pageStartAt")]
		public string PageStartAt { get; set; }
	}
	
	public class GetNetworkEventsReturnEvents
	{
		
		/// <summary>
		/// The category that the event type belongs to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		/// <summary>
		/// A description of the client. This is usually the client's device name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientDescription")]
		public string ClientDescription { get; set; }
		
		/// <summary>
		/// A string identifying the client. This could be a client's MAC or IP address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientId")]
		public string ClientId { get; set; }
		
		/// <summary>
		/// The client's MAC address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientMac")]
		public string ClientMac { get; set; }
		
		/// <summary>
		/// A description of the event the happened.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The name of the device. Only shown if the device is an access point.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceName")]
		public string DeviceName { get; set; }
		
		/// <summary>
		/// The serial number of the device. Only shown if the device is an access point.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceSerial")]
		public string DeviceSerial { get; set; }
		
		/// <summary>
		/// An object containing more data related to the event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventData")]
		public GetNetworkEventsReturnEventsEventData EventData { get; set; }
		
		/// <summary>
		/// The ID of the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// An UTC ISO8601 string of the time the event occurred at.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="occurredAt")]
		public string OccurredAt { get; set; }
		
		/// <summary>
		/// The SSID number of the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssidNumber")]
		public System.Nullable<System.Int32> SsidNumber { get; set; }
		
		/// <summary>
		/// The type of event being listed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class GetNetworkEventsReturnEventsEventData
	{
		
		/// <summary>
		/// The association ID of the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aid")]
		public string Aid { get; set; }
		
		/// <summary>
		/// The radio channel the client is connecting to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="channel")]
		public string Channel { get; set; }
		
		/// <summary>
		/// The client's IP address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="client_ip")]
		public string Client_ip { get; set; }
		
		/// <summary>
		/// The client's MAC address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="client_mac")]
		public string Client_mac { get; set; }
		
		/// <summary>
		/// The radio band number the client is trying to connect to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radio")]
		public string Radio { get; set; }
		
		/// <summary>
		/// The current received signal strength indication (RSSI) of the client connected to an AP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rssi")]
		public string Rssi { get; set; }
		
		/// <summary>
		/// The virtual access point (VAP) number the client is connecting to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vap")]
		public string Vap { get; set; }
	}
	
	public class GetNetworkEventsEventTypesReturn
	{
		
		/// <summary>
		/// Event category
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		/// <summary>
		/// Description of the event
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Event type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturn
	{
		
		/// <summary>
		/// The network devices to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="products")]
		public GetNetworkFirmwareUpgradesReturnProducts Products { get; set; }
		
		/// <summary>
		/// The timezone for the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timezone")]
		public string Timezone { get; set; }
		
		/// <summary>
		/// Upgrade window for devices in network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradeWindow")]
		public GetNetworkFirmwareUpgradesReturnUpgradeWindow UpgradeWindow { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProducts
	{
		
		/// <summary>
		/// The network device to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appliance")]
		public GetNetworkFirmwareUpgradesReturnProductsAppliance Appliance { get; set; }
		
		/// <summary>
		/// The network device to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="camera")]
		public GetNetworkFirmwareUpgradesReturnProductsCamera Camera { get; set; }
		
		/// <summary>
		/// The network device to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cellularGateway")]
		public GetNetworkFirmwareUpgradesReturnProductsCellularGateway CellularGateway { get; set; }
		
		/// <summary>
		/// The network device to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sensor")]
		public GetNetworkFirmwareUpgradesReturnProductsSensor Sensor { get; set; }
		
		/// <summary>
		/// The network device to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switch")]
		public GetNetworkFirmwareUpgradesReturnProductsSwitch Switch { get; set; }
		
		/// <summary>
		/// The network device to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wireless")]
		public GetNetworkFirmwareUpgradesReturnProductsWireless Wireless { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsAppliance
	{
		
		/// <summary>
		/// Firmware versions available for upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableVersions")]
		public GetNetworkFirmwareUpgradesReturnProductsApplianceAvailableVersions[] GetNetworkFirmwareUpgradesReturnProductsApplianceAvailableVersions { get; set; }
		
		/// <summary>
		/// Details of the current version on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsApplianceCurrentVersion CurrentVersion { get; set; }
		
		/// <summary>
		/// Details of the last firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpgrade")]
		public GetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgrade LastUpgrade { get; set; }
		
		/// <summary>
		/// Details of the next firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public GetNetworkFirmwareUpgradesReturnProductsApplianceNextUpgrade NextUpgrade { get; set; }
		
		/// <summary>
		/// Whether or not the network wants beta firmware
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="participateInNextBetaRelease")]
		public System.Nullable<System.Boolean> ParticipateInNextBetaRelease { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsApplianceAvailableVersions
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsApplianceCurrentVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgrade
	{
		
		/// <summary>
		/// Details of the version the device upgraded from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fromVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFromVersion FromVersion { get; set; }
		
		/// <summary>
		/// Timestamp of the last successful firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device upgraded to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeToVersion ToVersion { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFromVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsApplianceNextUpgrade
	{
		
		/// <summary>
		/// Timestamp of the next scheduled firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device will upgrade to if it exists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsCamera
	{
		
		/// <summary>
		/// Firmware versions available for upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableVersions")]
		public GetNetworkFirmwareUpgradesReturnProductsCameraAvailableVersions[] GetNetworkFirmwareUpgradesReturnProductsCameraAvailableVersions { get; set; }
		
		/// <summary>
		/// Details of the current version on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsCameraCurrentVersion CurrentVersion { get; set; }
		
		/// <summary>
		/// Details of the last firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpgrade")]
		public GetNetworkFirmwareUpgradesReturnProductsCameraLastUpgrade LastUpgrade { get; set; }
		
		/// <summary>
		/// Details of the next firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public GetNetworkFirmwareUpgradesReturnProductsCameraNextUpgrade NextUpgrade { get; set; }
		
		/// <summary>
		/// Whether or not the network wants beta firmware
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="participateInNextBetaRelease")]
		public System.Nullable<System.Boolean> ParticipateInNextBetaRelease { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsCameraAvailableVersions
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsCameraCurrentVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsCameraLastUpgrade
	{
		
		/// <summary>
		/// Details of the version the device upgraded from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fromVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFromVersion FromVersion { get; set; }
		
		/// <summary>
		/// Timestamp of the last successful firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device upgraded to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeToVersion ToVersion { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFromVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsCameraNextUpgrade
	{
		
		/// <summary>
		/// Timestamp of the next scheduled firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device will upgrade to if it exists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsCellularGateway
	{
		
		/// <summary>
		/// Firmware versions available for upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableVersions")]
		public GetNetworkFirmwareUpgradesReturnProductsCellularGatewayAvailableVersions[] GetNetworkFirmwareUpgradesReturnProductsCellularGatewayAvailableVersions { get; set; }
		
		/// <summary>
		/// Details of the current version on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsCellularGatewayCurrentVersion CurrentVersion { get; set; }
		
		/// <summary>
		/// Details of the last firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpgrade")]
		public GetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgrade LastUpgrade { get; set; }
		
		/// <summary>
		/// Details of the next firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public GetNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgrade NextUpgrade { get; set; }
		
		/// <summary>
		/// Whether or not the network wants beta firmware
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="participateInNextBetaRelease")]
		public System.Nullable<System.Boolean> ParticipateInNextBetaRelease { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsCellularGatewayAvailableVersions
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsCellularGatewayCurrentVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgrade
	{
		
		/// <summary>
		/// Details of the version the device upgraded from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fromVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFromVersion FromVersion { get; set; }
		
		/// <summary>
		/// Timestamp of the last successful firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device upgraded to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeToVersion ToVersion { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFromVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgrade
	{
		
		/// <summary>
		/// Timestamp of the next scheduled firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device will upgrade to if it exists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsSensor
	{
		
		/// <summary>
		/// Firmware versions available for upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableVersions")]
		public GetNetworkFirmwareUpgradesReturnProductsSensorAvailableVersions[] GetNetworkFirmwareUpgradesReturnProductsSensorAvailableVersions { get; set; }
		
		/// <summary>
		/// Details of the current version on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsSensorCurrentVersion CurrentVersion { get; set; }
		
		/// <summary>
		/// Details of the last firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpgrade")]
		public GetNetworkFirmwareUpgradesReturnProductsSensorLastUpgrade LastUpgrade { get; set; }
		
		/// <summary>
		/// Details of the next firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public GetNetworkFirmwareUpgradesReturnProductsSensorNextUpgrade NextUpgrade { get; set; }
		
		/// <summary>
		/// Whether or not the network wants beta firmware
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="participateInNextBetaRelease")]
		public System.Nullable<System.Boolean> ParticipateInNextBetaRelease { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsSensorAvailableVersions
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsSensorCurrentVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsSensorLastUpgrade
	{
		
		/// <summary>
		/// Details of the version the device upgraded from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fromVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFromVersion FromVersion { get; set; }
		
		/// <summary>
		/// Timestamp of the last successful firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device upgraded to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeToVersion ToVersion { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFromVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsSensorNextUpgrade
	{
		
		/// <summary>
		/// Timestamp of the next scheduled firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device will upgrade to if it exists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsSwitch
	{
		
		/// <summary>
		/// Firmware versions available for upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableVersions")]
		public GetNetworkFirmwareUpgradesReturnProductsSwitchAvailableVersions[] GetNetworkFirmwareUpgradesReturnProductsSwitchAvailableVersions { get; set; }
		
		/// <summary>
		/// Details of the current version on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsSwitchCurrentVersion CurrentVersion { get; set; }
		
		/// <summary>
		/// Details of the last firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpgrade")]
		public GetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgrade LastUpgrade { get; set; }
		
		/// <summary>
		/// Details of the next firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public GetNetworkFirmwareUpgradesReturnProductsSwitchNextUpgrade NextUpgrade { get; set; }
		
		/// <summary>
		/// Whether or not the network wants beta firmware
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="participateInNextBetaRelease")]
		public System.Nullable<System.Boolean> ParticipateInNextBetaRelease { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsSwitchAvailableVersions
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsSwitchCurrentVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgrade
	{
		
		/// <summary>
		/// Details of the version the device upgraded from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fromVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFromVersion FromVersion { get; set; }
		
		/// <summary>
		/// Timestamp of the last successful firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device upgraded to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeToVersion ToVersion { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFromVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsSwitchNextUpgrade
	{
		
		/// <summary>
		/// Timestamp of the next scheduled firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device will upgrade to if it exists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsWireless
	{
		
		/// <summary>
		/// Firmware versions available for upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableVersions")]
		public GetNetworkFirmwareUpgradesReturnProductsWirelessAvailableVersions[] GetNetworkFirmwareUpgradesReturnProductsWirelessAvailableVersions { get; set; }
		
		/// <summary>
		/// Details of the current version on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsWirelessCurrentVersion CurrentVersion { get; set; }
		
		/// <summary>
		/// Details of the last firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpgrade")]
		public GetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgrade LastUpgrade { get; set; }
		
		/// <summary>
		/// Details of the next firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public GetNetworkFirmwareUpgradesReturnProductsWirelessNextUpgrade NextUpgrade { get; set; }
		
		/// <summary>
		/// Whether or not the network wants beta firmware
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="participateInNextBetaRelease")]
		public System.Nullable<System.Boolean> ParticipateInNextBetaRelease { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsWirelessAvailableVersions
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsWirelessCurrentVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgrade
	{
		
		/// <summary>
		/// Details of the version the device upgraded from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fromVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFromVersion FromVersion { get; set; }
		
		/// <summary>
		/// Timestamp of the last successful firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device upgraded to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeToVersion ToVersion { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFromVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsWirelessNextUpgrade
	{
		
		/// <summary>
		/// Timestamp of the next scheduled firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device will upgrade to if it exists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public GetNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesReturnUpgradeWindow
	{
		
		/// <summary>
		/// Day of the week
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dayOfWeek")]
		public System.Nullable<GetNetworkFirmwareUpgradesReturnUpgradeWindowDayOfWeek> DayOfWeek { get; set; }
		
		/// <summary>
		/// Hour of the day
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hourOfDay")]
		public System.Nullable<GetNetworkFirmwareUpgradesReturnUpgradeWindowHourOfDay> HourOfDay { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkFirmwareUpgradesReturnUpgradeWindowDayOfWeek
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		fri = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		friday = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		mon = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		monday = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sat = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		saturday = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sun = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sunday = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		thu = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		thursday = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tue = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tuesday = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wed = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wednesday = 13,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkFirmwareUpgradesReturnUpgradeWindowHourOfDay
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="0:00")]
		_000 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="10:00")]
		_1000 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="11:00")]
		_1100 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="12:00")]
		_1200 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="13:00")]
		_1300 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="14:00")]
		_1400 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="15:00")]
		_1500 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="16:00")]
		_1600 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="17:00")]
		_1700 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="18:00")]
		_1800 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="19:00")]
		_1900 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1:00")]
		_100 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="20:00")]
		_2000 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="21:00")]
		_2100 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="22:00")]
		_2200 = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="23:00")]
		_2300 = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2:00")]
		_200 = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="3:00")]
		_300 = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4:00")]
		_400 = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5:00")]
		_500 = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6:00")]
		_600 = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="7:00")]
		_700 = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8:00")]
		_800 = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="9:00")]
		_900 = 23,
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBody
	{
		
		/// <summary>
		/// Contains information about the network to update
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="products")]
		public UpdateNetworkFirmwareUpgradesPutBodyProducts Products { get; set; }
		
		/// <summary>
		/// The timezone for the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timezone")]
		public string Timezone { get; set; }
		
		/// <summary>
		/// Upgrade window for devices in network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradeWindow")]
		public UpdateNetworkFirmwareUpgradesPutBodyUpgradeWindow UpgradeWindow { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyProducts
	{
		
		/// <summary>
		/// The network device to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appliance")]
		public UpdateNetworkFirmwareUpgradesPutBodyProductsAppliance Appliance { get; set; }
		
		/// <summary>
		/// The network device to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="camera")]
		public UpdateNetworkFirmwareUpgradesPutBodyProductsCamera Camera { get; set; }
		
		/// <summary>
		/// The network device to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cellularGateway")]
		public UpdateNetworkFirmwareUpgradesPutBodyProductsCellularGateway CellularGateway { get; set; }
		
		/// <summary>
		/// The network device to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sensor")]
		public UpdateNetworkFirmwareUpgradesPutBodyProductsSensor Sensor { get; set; }
		
		/// <summary>
		/// The network device to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switch")]
		public UpdateNetworkFirmwareUpgradesPutBodyProductsSwitch Switch { get; set; }
		
		/// <summary>
		/// The network device to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wireless")]
		public UpdateNetworkFirmwareUpgradesPutBodyProductsWireless Wireless { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyProductsAppliance
	{
		
		/// <summary>
		/// The pending firmware upgrade if it exists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public UpdateNetworkFirmwareUpgradesPutBodyProductsApplianceNextUpgrade NextUpgrade { get; set; }
		
		/// <summary>
		/// Whether or not the network wants beta firmware
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="participateInNextBetaRelease")]
		public System.Nullable<System.Boolean> ParticipateInNextBetaRelease { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyProductsApplianceNextUpgrade
	{
		
		/// <summary>
		/// The time of the last successful upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public string Time { get; set; }
		
		/// <summary>
		/// The version to be updated to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public UpdateNetworkFirmwareUpgradesPutBodyProductsApplianceNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyProductsApplianceNextUpgradeToVersion
	{
		
		/// <summary>
		/// The version ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyProductsCamera
	{
		
		/// <summary>
		/// The pending firmware upgrade if it exists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public UpdateNetworkFirmwareUpgradesPutBodyProductsCameraNextUpgrade NextUpgrade { get; set; }
		
		/// <summary>
		/// Whether or not the network wants beta firmware
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="participateInNextBetaRelease")]
		public System.Nullable<System.Boolean> ParticipateInNextBetaRelease { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyProductsCameraNextUpgrade
	{
		
		/// <summary>
		/// The time of the last successful upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public string Time { get; set; }
		
		/// <summary>
		/// The version to be updated to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public UpdateNetworkFirmwareUpgradesPutBodyProductsCameraNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyProductsCameraNextUpgradeToVersion
	{
		
		/// <summary>
		/// The version ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyProductsCellularGateway
	{
		
		/// <summary>
		/// The pending firmware upgrade if it exists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public UpdateNetworkFirmwareUpgradesPutBodyProductsCellularGatewayNextUpgrade NextUpgrade { get; set; }
		
		/// <summary>
		/// Whether or not the network wants beta firmware
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="participateInNextBetaRelease")]
		public System.Nullable<System.Boolean> ParticipateInNextBetaRelease { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyProductsCellularGatewayNextUpgrade
	{
		
		/// <summary>
		/// The time of the last successful upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public string Time { get; set; }
		
		/// <summary>
		/// The version to be updated to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public UpdateNetworkFirmwareUpgradesPutBodyProductsCellularGatewayNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyProductsCellularGatewayNextUpgradeToVersion
	{
		
		/// <summary>
		/// The version ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyProductsSensor
	{
		
		/// <summary>
		/// The pending firmware upgrade if it exists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public UpdateNetworkFirmwareUpgradesPutBodyProductsSensorNextUpgrade NextUpgrade { get; set; }
		
		/// <summary>
		/// Whether or not the network wants beta firmware
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="participateInNextBetaRelease")]
		public System.Nullable<System.Boolean> ParticipateInNextBetaRelease { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyProductsSensorNextUpgrade
	{
		
		/// <summary>
		/// The time of the last successful upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public string Time { get; set; }
		
		/// <summary>
		/// The version to be updated to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public UpdateNetworkFirmwareUpgradesPutBodyProductsSensorNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyProductsSensorNextUpgradeToVersion
	{
		
		/// <summary>
		/// The version ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyProductsSwitch
	{
		
		/// <summary>
		/// The pending firmware upgrade if it exists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public UpdateNetworkFirmwareUpgradesPutBodyProductsSwitchNextUpgrade NextUpgrade { get; set; }
		
		/// <summary>
		/// Whether or not the network wants beta firmware
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="participateInNextBetaRelease")]
		public System.Nullable<System.Boolean> ParticipateInNextBetaRelease { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyProductsSwitchNextUpgrade
	{
		
		/// <summary>
		/// The time of the last successful upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public string Time { get; set; }
		
		/// <summary>
		/// The version to be updated to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public UpdateNetworkFirmwareUpgradesPutBodyProductsSwitchNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyProductsSwitchNextUpgradeToVersion
	{
		
		/// <summary>
		/// The version ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyProductsWireless
	{
		
		/// <summary>
		/// The pending firmware upgrade if it exists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public UpdateNetworkFirmwareUpgradesPutBodyProductsWirelessNextUpgrade NextUpgrade { get; set; }
		
		/// <summary>
		/// Whether or not the network wants beta firmware
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="participateInNextBetaRelease")]
		public System.Nullable<System.Boolean> ParticipateInNextBetaRelease { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyProductsWirelessNextUpgrade
	{
		
		/// <summary>
		/// The time of the last successful upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public string Time { get; set; }
		
		/// <summary>
		/// The version to be updated to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public UpdateNetworkFirmwareUpgradesPutBodyProductsWirelessNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyProductsWirelessNextUpgradeToVersion
	{
		
		/// <summary>
		/// The version ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesPutBodyUpgradeWindow
	{
		
		/// <summary>
		/// Day of the week
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dayOfWeek")]
		public GetNetworkFirmwareUpgradesReturnUpgradeWindowDayOfWeek DayOfWeek { get; set; }
		
		/// <summary>
		/// Hour of the day
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hourOfDay")]
		public System.Nullable<UpdateNetworkFirmwareUpgradesPutBodyUpgradeWindowHourOfDay> HourOfDay { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkFirmwareUpgradesPutBodyUpgradeWindowHourOfDay
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="0:00")]
		_000 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="10:00")]
		_1000 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="11:00")]
		_1100 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="12:00")]
		_1200 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="13:00")]
		_1300 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="14:00")]
		_1400 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="15:00")]
		_1500 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="16:00")]
		_1600 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="17:00")]
		_1700 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="18:00")]
		_1800 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="19:00")]
		_1900 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1:00")]
		_100 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="20:00")]
		_2000 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="21:00")]
		_2100 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="22:00")]
		_2200 = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="23:00")]
		_2300 = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2:00")]
		_200 = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="3:00")]
		_300 = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4:00")]
		_400 = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5:00")]
		_500 = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6:00")]
		_600 = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="7:00")]
		_700 = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8:00")]
		_800 = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="9:00")]
		_900 = 23,
	}
	
	public class UpdateNetworkFirmwareUpgradesReturn
	{
		
		/// <summary>
		/// The network devices to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="products")]
		public UpdateNetworkFirmwareUpgradesReturnProducts Products { get; set; }
		
		/// <summary>
		/// The timezone for the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timezone")]
		public string Timezone { get; set; }
		
		/// <summary>
		/// Upgrade window for devices in network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradeWindow")]
		public UpdateNetworkFirmwareUpgradesReturnUpgradeWindow UpgradeWindow { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProducts
	{
		
		/// <summary>
		/// The network device to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appliance")]
		public UpdateNetworkFirmwareUpgradesReturnProductsAppliance Appliance { get; set; }
		
		/// <summary>
		/// The network device to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="camera")]
		public UpdateNetworkFirmwareUpgradesReturnProductsCamera Camera { get; set; }
		
		/// <summary>
		/// The network device to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cellularGateway")]
		public UpdateNetworkFirmwareUpgradesReturnProductsCellularGateway CellularGateway { get; set; }
		
		/// <summary>
		/// The network device to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sensor")]
		public UpdateNetworkFirmwareUpgradesReturnProductsSensor Sensor { get; set; }
		
		/// <summary>
		/// The network device to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switch")]
		public UpdateNetworkFirmwareUpgradesReturnProductsSwitch Switch { get; set; }
		
		/// <summary>
		/// The network device to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wireless")]
		public UpdateNetworkFirmwareUpgradesReturnProductsWireless Wireless { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsAppliance
	{
		
		/// <summary>
		/// Firmware versions available for upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableVersions")]
		public UpdateNetworkFirmwareUpgradesReturnProductsApplianceAvailableVersions[] UpdateNetworkFirmwareUpgradesReturnProductsApplianceAvailableVersions { get; set; }
		
		/// <summary>
		/// Details of the current version on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsApplianceCurrentVersion CurrentVersion { get; set; }
		
		/// <summary>
		/// Details of the last firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpgrade")]
		public UpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgrade LastUpgrade { get; set; }
		
		/// <summary>
		/// Details of the next firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public UpdateNetworkFirmwareUpgradesReturnProductsApplianceNextUpgrade NextUpgrade { get; set; }
		
		/// <summary>
		/// Whether or not the network wants beta firmware
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="participateInNextBetaRelease")]
		public System.Nullable<System.Boolean> ParticipateInNextBetaRelease { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsApplianceAvailableVersions
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsApplianceCurrentVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgrade
	{
		
		/// <summary>
		/// Details of the version the device upgraded from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fromVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFromVersion FromVersion { get; set; }
		
		/// <summary>
		/// Timestamp of the last successful firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device upgraded to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeToVersion ToVersion { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeFromVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsApplianceLastUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsApplianceNextUpgrade
	{
		
		/// <summary>
		/// Timestamp of the next scheduled firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device will upgrade to if it exists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsApplianceNextUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsCamera
	{
		
		/// <summary>
		/// Firmware versions available for upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableVersions")]
		public UpdateNetworkFirmwareUpgradesReturnProductsCameraAvailableVersions[] UpdateNetworkFirmwareUpgradesReturnProductsCameraAvailableVersions { get; set; }
		
		/// <summary>
		/// Details of the current version on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsCameraCurrentVersion CurrentVersion { get; set; }
		
		/// <summary>
		/// Details of the last firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpgrade")]
		public UpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgrade LastUpgrade { get; set; }
		
		/// <summary>
		/// Details of the next firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public UpdateNetworkFirmwareUpgradesReturnProductsCameraNextUpgrade NextUpgrade { get; set; }
		
		/// <summary>
		/// Whether or not the network wants beta firmware
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="participateInNextBetaRelease")]
		public System.Nullable<System.Boolean> ParticipateInNextBetaRelease { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsCameraAvailableVersions
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsCameraCurrentVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgrade
	{
		
		/// <summary>
		/// Details of the version the device upgraded from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fromVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFromVersion FromVersion { get; set; }
		
		/// <summary>
		/// Timestamp of the last successful firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device upgraded to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeToVersion ToVersion { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeFromVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsCameraLastUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsCameraNextUpgrade
	{
		
		/// <summary>
		/// Timestamp of the next scheduled firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device will upgrade to if it exists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsCameraNextUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsCellularGateway
	{
		
		/// <summary>
		/// Firmware versions available for upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableVersions")]
		public UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayAvailableVersions[] UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayAvailableVersions { get; set; }
		
		/// <summary>
		/// Details of the current version on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayCurrentVersion CurrentVersion { get; set; }
		
		/// <summary>
		/// Details of the last firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpgrade")]
		public UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgrade LastUpgrade { get; set; }
		
		/// <summary>
		/// Details of the next firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgrade NextUpgrade { get; set; }
		
		/// <summary>
		/// Whether or not the network wants beta firmware
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="participateInNextBetaRelease")]
		public System.Nullable<System.Boolean> ParticipateInNextBetaRelease { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayAvailableVersions
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayCurrentVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgrade
	{
		
		/// <summary>
		/// Details of the version the device upgraded from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fromVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFromVersion FromVersion { get; set; }
		
		/// <summary>
		/// Timestamp of the last successful firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device upgraded to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeToVersion ToVersion { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeFromVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayLastUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgrade
	{
		
		/// <summary>
		/// Timestamp of the next scheduled firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device will upgrade to if it exists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsCellularGatewayNextUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsSensor
	{
		
		/// <summary>
		/// Firmware versions available for upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableVersions")]
		public UpdateNetworkFirmwareUpgradesReturnProductsSensorAvailableVersions[] UpdateNetworkFirmwareUpgradesReturnProductsSensorAvailableVersions { get; set; }
		
		/// <summary>
		/// Details of the current version on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsSensorCurrentVersion CurrentVersion { get; set; }
		
		/// <summary>
		/// Details of the last firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpgrade")]
		public UpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgrade LastUpgrade { get; set; }
		
		/// <summary>
		/// Details of the next firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public UpdateNetworkFirmwareUpgradesReturnProductsSensorNextUpgrade NextUpgrade { get; set; }
		
		/// <summary>
		/// Whether or not the network wants beta firmware
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="participateInNextBetaRelease")]
		public System.Nullable<System.Boolean> ParticipateInNextBetaRelease { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsSensorAvailableVersions
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsSensorCurrentVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgrade
	{
		
		/// <summary>
		/// Details of the version the device upgraded from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fromVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFromVersion FromVersion { get; set; }
		
		/// <summary>
		/// Timestamp of the last successful firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device upgraded to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeToVersion ToVersion { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeFromVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsSensorLastUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsSensorNextUpgrade
	{
		
		/// <summary>
		/// Timestamp of the next scheduled firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device will upgrade to if it exists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsSensorNextUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsSwitch
	{
		
		/// <summary>
		/// Firmware versions available for upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableVersions")]
		public UpdateNetworkFirmwareUpgradesReturnProductsSwitchAvailableVersions[] UpdateNetworkFirmwareUpgradesReturnProductsSwitchAvailableVersions { get; set; }
		
		/// <summary>
		/// Details of the current version on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsSwitchCurrentVersion CurrentVersion { get; set; }
		
		/// <summary>
		/// Details of the last firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpgrade")]
		public UpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgrade LastUpgrade { get; set; }
		
		/// <summary>
		/// Details of the next firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public UpdateNetworkFirmwareUpgradesReturnProductsSwitchNextUpgrade NextUpgrade { get; set; }
		
		/// <summary>
		/// Whether or not the network wants beta firmware
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="participateInNextBetaRelease")]
		public System.Nullable<System.Boolean> ParticipateInNextBetaRelease { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsSwitchAvailableVersions
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsSwitchCurrentVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgrade
	{
		
		/// <summary>
		/// Details of the version the device upgraded from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fromVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFromVersion FromVersion { get; set; }
		
		/// <summary>
		/// Timestamp of the last successful firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device upgraded to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeToVersion ToVersion { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeFromVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsSwitchLastUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsSwitchNextUpgrade
	{
		
		/// <summary>
		/// Timestamp of the next scheduled firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device will upgrade to if it exists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsSwitchNextUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsWireless
	{
		
		/// <summary>
		/// Firmware versions available for upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableVersions")]
		public UpdateNetworkFirmwareUpgradesReturnProductsWirelessAvailableVersions[] UpdateNetworkFirmwareUpgradesReturnProductsWirelessAvailableVersions { get; set; }
		
		/// <summary>
		/// Details of the current version on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsWirelessCurrentVersion CurrentVersion { get; set; }
		
		/// <summary>
		/// Details of the last firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpgrade")]
		public UpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgrade LastUpgrade { get; set; }
		
		/// <summary>
		/// Details of the next firmware upgrade on the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public UpdateNetworkFirmwareUpgradesReturnProductsWirelessNextUpgrade NextUpgrade { get; set; }
		
		/// <summary>
		/// Whether or not the network wants beta firmware
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="participateInNextBetaRelease")]
		public System.Nullable<System.Boolean> ParticipateInNextBetaRelease { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsWirelessAvailableVersions
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsWirelessCurrentVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgrade
	{
		
		/// <summary>
		/// Details of the version the device upgraded from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fromVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFromVersion FromVersion { get; set; }
		
		/// <summary>
		/// Timestamp of the last successful firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device upgraded to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeToVersion ToVersion { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeFromVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsWirelessLastUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsWirelessNextUpgrade
	{
		
		/// <summary>
		/// Timestamp of the next scheduled firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Details of the version the device will upgrade to if it exists
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public UpdateNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnProductsWirelessNextUpgradeToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesReturnUpgradeWindow
	{
		
		/// <summary>
		/// Day of the week
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dayOfWeek")]
		public GetNetworkFirmwareUpgradesReturnUpgradeWindowDayOfWeek DayOfWeek { get; set; }
		
		/// <summary>
		/// Hour of the day
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hourOfDay")]
		public System.Nullable<UpdateNetworkFirmwareUpgradesReturnUpgradeWindowHourOfDay> HourOfDay { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkFirmwareUpgradesReturnUpgradeWindowHourOfDay
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="0:00")]
		_000 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="10:00")]
		_1000 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="11:00")]
		_1100 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="12:00")]
		_1200 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="13:00")]
		_1300 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="14:00")]
		_1400 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="15:00")]
		_1500 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="16:00")]
		_1600 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="17:00")]
		_1700 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="18:00")]
		_1800 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="19:00")]
		_1900 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1:00")]
		_100 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="20:00")]
		_2000 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="21:00")]
		_2100 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="22:00")]
		_2200 = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="23:00")]
		_2300 = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2:00")]
		_200 = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="3:00")]
		_300 = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4:00")]
		_400 = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5:00")]
		_500 = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6:00")]
		_600 = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="7:00")]
		_700 = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8:00")]
		_800 = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="9:00")]
		_900 = 23,
	}
	
	public class CreateNetworkFirmwareUpgradesRollbackPostBody
	{
		
		/// <summary>
		/// Product type to rollback (if the network is a combined network)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="product")]
		public System.Nullable<CreateNetworkFirmwareUpgradesRollbackPostBodyProduct> Product { get; set; }
		
		/// <summary>
		/// Reasons for the rollback
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="reasons")]
		public CreateNetworkFirmwareUpgradesRollbackPostBodyReasons[] CreateNetworkFirmwareUpgradesRollbackPostBodyReasons { get; set; }
		
		/// <summary>
		/// Scheduled time for the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Version to downgrade to (if the network has firmware flexibility)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public CreateNetworkFirmwareUpgradesRollbackPostBodyToVersion ToVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkFirmwareUpgradesRollbackPostBodyProduct
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		appliance = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		camera = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cellularGateway = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="switch")]
		_switch = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wireless = 4,
	}
	
	public class CreateNetworkFirmwareUpgradesRollbackPostBodyReasons
	{
		
		/// <summary>
		/// Reason for the rollback
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="category")]
		public CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory Category { get; set; }
		
		/// <summary>
		/// Additional comment about the rollback
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkFirmwareUpgradesRollbackPostBodyReasonsCategory
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="broke old features")]
		broke_old_features = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		other = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		performance = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stability = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		testing = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unifying networks versions")]
		unifying_networks_versions = 5,
	}
	
	public class CreateNetworkFirmwareUpgradesRollbackPostBodyToVersion
	{
		
		/// <summary>
		/// The version ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesRollbackReturn
	{
		
		/// <summary>
		/// Product type to rollback (if the network is a combined network)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="product")]
		public System.Nullable<CreateNetworkFirmwareUpgradesRollbackReturnProduct> Product { get; set; }
		
		/// <summary>
		/// Reasons for the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reasons")]
		public CreateNetworkFirmwareUpgradesRollbackReturnReasons[] CreateNetworkFirmwareUpgradesRollbackReturnReasons { get; set; }
		
		/// <summary>
		/// Status of the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<CreateNetworkFirmwareUpgradesRollbackReturnStatus> Status { get; set; }
		
		/// <summary>
		/// Scheduled time for the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// Version to downgrade to (if the network has firmware flexibility)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public CreateNetworkFirmwareUpgradesRollbackReturnToVersion ToVersion { get; set; }
		
		/// <summary>
		/// Batch ID of the firmware rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradeBatchId")]
		public string UpgradeBatchId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkFirmwareUpgradesRollbackReturnProduct
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		appliance = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		camera = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cellularGateway = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="switch")]
		_switch = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wireless = 4,
	}
	
	public class CreateNetworkFirmwareUpgradesRollbackReturnReasons
	{
		
		/// <summary>
		/// Reason for the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public System.Nullable<CreateNetworkFirmwareUpgradesRollbackReturnReasonsCategory> Category { get; set; }
		
		/// <summary>
		/// Additional comment about the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkFirmwareUpgradesRollbackReturnReasonsCategory
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="broke old features")]
		broke_old_features = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		other = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		performance = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stability = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		testing = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unifying networks versions")]
		unifying_networks_versions = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkFirmwareUpgradesRollbackReturnStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		canceled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		completed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		in_progress = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 3,
	}
	
	public class CreateNetworkFirmwareUpgradesRollbackReturnToVersion
	{
		
		/// <summary>
		/// Name of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// Firmware version identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesStagedEventsReturn
	{
		
		/// <summary>
		/// The network devices to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="products")]
		public GetNetworkFirmwareUpgradesStagedEventsReturnProducts Products { get; set; }
		
		/// <summary>
		/// Reasons for the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reasons")]
		public GetNetworkFirmwareUpgradesStagedEventsReturnReasons[] GetNetworkFirmwareUpgradesStagedEventsReturnReasons { get; set; }
		
		/// <summary>
		/// The ordered stages in the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stages")]
		public GetNetworkFirmwareUpgradesStagedEventsReturnStages[] GetNetworkFirmwareUpgradesStagedEventsReturnStages { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesStagedEventsReturnProducts
	{
		
		/// <summary>
		/// The Switch network to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switch")]
		public GetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitch Switch { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitch
	{
		
		/// <summary>
		/// Details of the next firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public GetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgrade NextUpgrade { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgrade
	{
		
		/// <summary>
		/// Details of the version the device will upgrade to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public GetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersion
	{
		
		/// <summary>
		/// Id of the Version being upgraded to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesStagedEventsReturnReasons
	{
		
		/// <summary>
		/// Reason for the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public System.Nullable<GetNetworkFirmwareUpgradesStagedEventsReturnReasonsCategory> Category { get; set; }
		
		/// <summary>
		/// Additional comment about the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkFirmwareUpgradesStagedEventsReturnReasonsCategory
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="broke old features")]
		broke_old_features = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		other = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		performance = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stability = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		testing = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unifying networks versions")]
		unifying_networks_versions = 5,
	}
	
	public class GetNetworkFirmwareUpgradesStagedEventsReturnStages
	{
		
		/// <summary>
		/// The staged upgrade group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public GetNetworkFirmwareUpgradesStagedEventsReturnStagesGroup Group { get; set; }
		
		/// <summary>
		/// The Staged Upgrade Milestones for the stage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="milestones")]
		public GetNetworkFirmwareUpgradesStagedEventsReturnStagesMilestones Milestones { get; set; }
		
		/// <summary>
		/// Current upgrade status of the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesStagedEventsReturnStagesGroup
	{
		
		/// <summary>
		/// Description of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Id of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesStagedEventsReturnStagesMilestones
	{
		
		/// <summary>
		/// Time that the group was canceled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canceledAt")]
		public System.Nullable<System.DateTimeOffset> CanceledAt { get; set; }
		
		/// <summary>
		/// Finish time for the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completedAt")]
		public System.Nullable<System.DateTimeOffset> CompletedAt { get; set; }
		
		/// <summary>
		/// Scheduled start time for the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduledFor")]
		public System.Nullable<System.DateTimeOffset> ScheduledFor { get; set; }
		
		/// <summary>
		/// Start time for the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startedAt")]
		public System.Nullable<System.DateTimeOffset> StartedAt { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesStagedEventPostBody
	{
		
		/// <summary>
		/// Contains firmware upgrade version information
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="products")]
		public CreateNetworkFirmwareUpgradesStagedEventPostBodyProducts Products { get; set; }
		
		/// <summary>
		/// All firmware upgrade stages in the network with their start time.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stages")]
		public CreateNetworkFirmwareUpgradesStagedEventPostBodyStages[] CreateNetworkFirmwareUpgradesStagedEventPostBodyStages { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesStagedEventPostBodyProducts
	{
		
		/// <summary>
		/// Version information for the switch network being upgraded
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switch")]
		public CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitch Switch { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitch
	{
		
		/// <summary>
		/// The next upgrade version for the switch network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitchNextUpgrade NextUpgrade { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitchNextUpgrade
	{
		
		/// <summary>
		/// The version to be updated to for switch devices
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitchNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesStagedEventPostBodyProductsSwitchNextUpgradeToVersion
	{
		
		/// <summary>
		/// The version ID
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesStagedEventPostBodyStages
	{
		
		/// <summary>
		/// The Staged Upgrade Group containing the name and ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public CreateNetworkFirmwareUpgradesStagedEventPostBodyStagesGroup Group { get; set; }
		
		/// <summary>
		/// The Staged Upgrade Milestones for the specific stage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="milestones")]
		public CreateNetworkFirmwareUpgradesStagedEventPostBodyStagesMilestones Milestones { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesStagedEventPostBodyStagesGroup
	{
		
		/// <summary>
		/// ID of the Staged Upgrade Group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesStagedEventPostBodyStagesMilestones
	{
		
		/// <summary>
		/// The start time of the staged upgrade stage. (In ISO-8601 format, in the time zone of the network.)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scheduledFor")]
		public string ScheduledFor { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesStagedEventReturn
	{
		
		/// <summary>
		/// The network devices to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="products")]
		public CreateNetworkFirmwareUpgradesStagedEventReturnProducts Products { get; set; }
		
		/// <summary>
		/// Reasons for the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reasons")]
		public CreateNetworkFirmwareUpgradesStagedEventReturnReasons[] CreateNetworkFirmwareUpgradesStagedEventReturnReasons { get; set; }
		
		/// <summary>
		/// The ordered stages in the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stages")]
		public CreateNetworkFirmwareUpgradesStagedEventReturnStages[] CreateNetworkFirmwareUpgradesStagedEventReturnStages { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesStagedEventReturnProducts
	{
		
		/// <summary>
		/// The Switch network to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switch")]
		public CreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitch Switch { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitch
	{
		
		/// <summary>
		/// Details of the next firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public CreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitchNextUpgrade NextUpgrade { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitchNextUpgrade
	{
		
		/// <summary>
		/// Details of the version the device will upgrade to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public CreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitchNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesStagedEventReturnProductsSwitchNextUpgradeToVersion
	{
		
		/// <summary>
		/// Id of the Version being upgraded to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesStagedEventReturnReasons
	{
		
		/// <summary>
		/// Reason for the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public System.Nullable<CreateNetworkFirmwareUpgradesStagedEventReturnReasonsCategory> Category { get; set; }
		
		/// <summary>
		/// Additional comment about the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkFirmwareUpgradesStagedEventReturnReasonsCategory
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="broke old features")]
		broke_old_features = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		other = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		performance = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stability = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		testing = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unifying networks versions")]
		unifying_networks_versions = 5,
	}
	
	public class CreateNetworkFirmwareUpgradesStagedEventReturnStages
	{
		
		/// <summary>
		/// The staged upgrade group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public CreateNetworkFirmwareUpgradesStagedEventReturnStagesGroup Group { get; set; }
		
		/// <summary>
		/// The Staged Upgrade Milestones for the stage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="milestones")]
		public CreateNetworkFirmwareUpgradesStagedEventReturnStagesMilestones Milestones { get; set; }
		
		/// <summary>
		/// Current upgrade status of the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesStagedEventReturnStagesGroup
	{
		
		/// <summary>
		/// Description of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Id of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class CreateNetworkFirmwareUpgradesStagedEventReturnStagesMilestones
	{
		
		/// <summary>
		/// Time that the group was canceled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canceledAt")]
		public System.Nullable<System.DateTimeOffset> CanceledAt { get; set; }
		
		/// <summary>
		/// Finish time for the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completedAt")]
		public System.Nullable<System.DateTimeOffset> CompletedAt { get; set; }
		
		/// <summary>
		/// Scheduled start time for the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduledFor")]
		public System.Nullable<System.DateTimeOffset> ScheduledFor { get; set; }
		
		/// <summary>
		/// Start time for the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startedAt")]
		public System.Nullable<System.DateTimeOffset> StartedAt { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesStagedEventsPutBody
	{
		
		/// <summary>
		/// All firmware upgrade stages in the network with their start time.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stages")]
		public UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStages[] UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStages { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStages
	{
		
		/// <summary>
		/// The Staged Upgrade Group containing the name and ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStagesGroup Group { get; set; }
		
		/// <summary>
		/// The Staged Upgrade Milestones for the specific stage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="milestones")]
		public UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStagesMilestones Milestones { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStagesGroup
	{
		
		/// <summary>
		/// ID of the Staged Upgrade Group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesStagedEventsPutBodyStagesMilestones
	{
		
		/// <summary>
		/// The start time of the staged upgrade stage. (In ISO-8601 format, in the time zone of the network.)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scheduledFor")]
		public string ScheduledFor { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesStagedEventsReturn
	{
		
		/// <summary>
		/// The network devices to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="products")]
		public UpdateNetworkFirmwareUpgradesStagedEventsReturnProducts Products { get; set; }
		
		/// <summary>
		/// Reasons for the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reasons")]
		public UpdateNetworkFirmwareUpgradesStagedEventsReturnReasons[] UpdateNetworkFirmwareUpgradesStagedEventsReturnReasons { get; set; }
		
		/// <summary>
		/// The ordered stages in the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stages")]
		public UpdateNetworkFirmwareUpgradesStagedEventsReturnStages[] UpdateNetworkFirmwareUpgradesStagedEventsReturnStages { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesStagedEventsReturnProducts
	{
		
		/// <summary>
		/// The Switch network to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switch")]
		public UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitch Switch { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitch
	{
		
		/// <summary>
		/// Details of the next firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgrade NextUpgrade { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgrade
	{
		
		/// <summary>
		/// Details of the version the device will upgrade to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersion
	{
		
		/// <summary>
		/// Id of the Version being upgraded to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesStagedEventsReturnReasons
	{
		
		/// <summary>
		/// Reason for the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public System.Nullable<UpdateNetworkFirmwareUpgradesStagedEventsReturnReasonsCategory> Category { get; set; }
		
		/// <summary>
		/// Additional comment about the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkFirmwareUpgradesStagedEventsReturnReasonsCategory
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="broke old features")]
		broke_old_features = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		other = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		performance = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stability = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		testing = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unifying networks versions")]
		unifying_networks_versions = 5,
	}
	
	public class UpdateNetworkFirmwareUpgradesStagedEventsReturnStages
	{
		
		/// <summary>
		/// The staged upgrade group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public UpdateNetworkFirmwareUpgradesStagedEventsReturnStagesGroup Group { get; set; }
		
		/// <summary>
		/// The Staged Upgrade Milestones for the stage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="milestones")]
		public UpdateNetworkFirmwareUpgradesStagedEventsReturnStagesMilestones Milestones { get; set; }
		
		/// <summary>
		/// Current upgrade status of the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesStagedEventsReturnStagesGroup
	{
		
		/// <summary>
		/// Description of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Id of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesStagedEventsReturnStagesMilestones
	{
		
		/// <summary>
		/// Time that the group was canceled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canceledAt")]
		public System.Nullable<System.DateTimeOffset> CanceledAt { get; set; }
		
		/// <summary>
		/// Finish time for the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completedAt")]
		public System.Nullable<System.DateTimeOffset> CompletedAt { get; set; }
		
		/// <summary>
		/// Scheduled start time for the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduledFor")]
		public System.Nullable<System.DateTimeOffset> ScheduledFor { get; set; }
		
		/// <summary>
		/// Start time for the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startedAt")]
		public System.Nullable<System.DateTimeOffset> StartedAt { get; set; }
	}
	
	public class DeferNetworkFirmwareUpgradesStagedEventsReturn
	{
		
		/// <summary>
		/// The network devices to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="products")]
		public DeferNetworkFirmwareUpgradesStagedEventsReturnProducts Products { get; set; }
		
		/// <summary>
		/// Reasons for the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reasons")]
		public DeferNetworkFirmwareUpgradesStagedEventsReturnReasons[] DeferNetworkFirmwareUpgradesStagedEventsReturnReasons { get; set; }
		
		/// <summary>
		/// The ordered stages in the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stages")]
		public DeferNetworkFirmwareUpgradesStagedEventsReturnStages[] DeferNetworkFirmwareUpgradesStagedEventsReturnStages { get; set; }
	}
	
	public class DeferNetworkFirmwareUpgradesStagedEventsReturnProducts
	{
		
		/// <summary>
		/// The Switch network to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switch")]
		public DeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitch Switch { get; set; }
	}
	
	public class DeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitch
	{
		
		/// <summary>
		/// Details of the next firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public DeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgrade NextUpgrade { get; set; }
	}
	
	public class DeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgrade
	{
		
		/// <summary>
		/// Details of the version the device will upgrade to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public DeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class DeferNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersion
	{
		
		/// <summary>
		/// Id of the Version being upgraded to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class DeferNetworkFirmwareUpgradesStagedEventsReturnReasons
	{
		
		/// <summary>
		/// Reason for the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public System.Nullable<DeferNetworkFirmwareUpgradesStagedEventsReturnReasonsCategory> Category { get; set; }
		
		/// <summary>
		/// Additional comment about the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DeferNetworkFirmwareUpgradesStagedEventsReturnReasonsCategory
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="broke old features")]
		broke_old_features = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		other = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		performance = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stability = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		testing = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unifying networks versions")]
		unifying_networks_versions = 5,
	}
	
	public class DeferNetworkFirmwareUpgradesStagedEventsReturnStages
	{
		
		/// <summary>
		/// The staged upgrade group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public DeferNetworkFirmwareUpgradesStagedEventsReturnStagesGroup Group { get; set; }
		
		/// <summary>
		/// The Staged Upgrade Milestones for the stage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="milestones")]
		public DeferNetworkFirmwareUpgradesStagedEventsReturnStagesMilestones Milestones { get; set; }
		
		/// <summary>
		/// Current upgrade status of the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	public class DeferNetworkFirmwareUpgradesStagedEventsReturnStagesGroup
	{
		
		/// <summary>
		/// Description of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Id of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class DeferNetworkFirmwareUpgradesStagedEventsReturnStagesMilestones
	{
		
		/// <summary>
		/// Time that the group was canceled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canceledAt")]
		public System.Nullable<System.DateTimeOffset> CanceledAt { get; set; }
		
		/// <summary>
		/// Finish time for the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completedAt")]
		public System.Nullable<System.DateTimeOffset> CompletedAt { get; set; }
		
		/// <summary>
		/// Scheduled start time for the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduledFor")]
		public System.Nullable<System.DateTimeOffset> ScheduledFor { get; set; }
		
		/// <summary>
		/// Start time for the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startedAt")]
		public System.Nullable<System.DateTimeOffset> StartedAt { get; set; }
	}
	
	public class RollbacksNetworkFirmwareUpgradesStagedEventsPostBody
	{
		
		/// <summary>
		/// The reason for rolling back the staged upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reasons")]
		public RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyReasons[] RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyReasons { get; set; }
		
		/// <summary>
		/// All completed or in-progress stages in the network with their new start times. All pending stages will be canceled
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stages")]
		public RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStages[] RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStages { get; set; }
	}
	
	public class RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyReasons
	{
		
		/// <summary>
		/// Reason for the rollback
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="category")]
		public RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyReasonsCategory Category { get; set; }
		
		/// <summary>
		/// Additional comment about the rollback
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyReasonsCategory
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="broke old features")]
		broke_old_features = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		other = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		performance = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stability = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		testing = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unifying networks versions")]
		unifying_networks_versions = 5,
	}
	
	public class RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStages
	{
		
		/// <summary>
		/// The Staged Upgrade Group containing the name and ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStagesGroup Group { get; set; }
		
		/// <summary>
		/// The Staged Upgrade Milestones for the specific stage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="milestones")]
		public RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStagesMilestones Milestones { get; set; }
	}
	
	public class RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStagesGroup
	{
		
		/// <summary>
		/// ID of the Staged Upgrade Group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class RollbacksNetworkFirmwareUpgradesStagedEventsPostBodyStagesMilestones
	{
		
		/// <summary>
		/// The start time of the staged upgrade stage. (In ISO-8601 format, in the time zone of the network.)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scheduledFor")]
		public string ScheduledFor { get; set; }
	}
	
	public class RollbacksNetworkFirmwareUpgradesStagedEventsReturn
	{
		
		/// <summary>
		/// The network devices to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="products")]
		public RollbacksNetworkFirmwareUpgradesStagedEventsReturnProducts Products { get; set; }
		
		/// <summary>
		/// Reasons for the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reasons")]
		public RollbacksNetworkFirmwareUpgradesStagedEventsReturnReasons[] RollbacksNetworkFirmwareUpgradesStagedEventsReturnReasons { get; set; }
		
		/// <summary>
		/// The ordered stages in the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stages")]
		public RollbacksNetworkFirmwareUpgradesStagedEventsReturnStages[] RollbacksNetworkFirmwareUpgradesStagedEventsReturnStages { get; set; }
	}
	
	public class RollbacksNetworkFirmwareUpgradesStagedEventsReturnProducts
	{
		
		/// <summary>
		/// The Switch network to be updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switch")]
		public RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitch Switch { get; set; }
	}
	
	public class RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitch
	{
		
		/// <summary>
		/// Details of the next firmware upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextUpgrade")]
		public RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgrade NextUpgrade { get; set; }
	}
	
	public class RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgrade
	{
		
		/// <summary>
		/// Details of the version the device will upgrade to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersion ToVersion { get; set; }
	}
	
	public class RollbacksNetworkFirmwareUpgradesStagedEventsReturnProductsSwitchNextUpgradeToVersion
	{
		
		/// <summary>
		/// Id of the Version being upgraded to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class RollbacksNetworkFirmwareUpgradesStagedEventsReturnReasons
	{
		
		/// <summary>
		/// Reason for the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public System.Nullable<RollbacksNetworkFirmwareUpgradesStagedEventsReturnReasonsCategory> Category { get; set; }
		
		/// <summary>
		/// Additional comment about the rollback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RollbacksNetworkFirmwareUpgradesStagedEventsReturnReasonsCategory
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="broke old features")]
		broke_old_features = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		other = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		performance = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stability = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		testing = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unifying networks versions")]
		unifying_networks_versions = 5,
	}
	
	public class RollbacksNetworkFirmwareUpgradesStagedEventsReturnStages
	{
		
		/// <summary>
		/// The staged upgrade group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public RollbacksNetworkFirmwareUpgradesStagedEventsReturnStagesGroup Group { get; set; }
		
		/// <summary>
		/// The Staged Upgrade Milestones for the stage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="milestones")]
		public RollbacksNetworkFirmwareUpgradesStagedEventsReturnStagesMilestones Milestones { get; set; }
		
		/// <summary>
		/// Current upgrade status of the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	public class RollbacksNetworkFirmwareUpgradesStagedEventsReturnStagesGroup
	{
		
		/// <summary>
		/// Description of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Id of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class RollbacksNetworkFirmwareUpgradesStagedEventsReturnStagesMilestones
	{
		
		/// <summary>
		/// Time that the group was canceled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canceledAt")]
		public System.Nullable<System.DateTimeOffset> CanceledAt { get; set; }
		
		/// <summary>
		/// Finish time for the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completedAt")]
		public System.Nullable<System.DateTimeOffset> CompletedAt { get; set; }
		
		/// <summary>
		/// Scheduled start time for the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduledFor")]
		public System.Nullable<System.DateTimeOffset> ScheduledFor { get; set; }
		
		/// <summary>
		/// Start time for the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startedAt")]
		public System.Nullable<System.DateTimeOffset> StartedAt { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesStagedGroupsReturn
	{
		
		/// <summary>
		/// The devices and Switch Stacks assigned to the Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignedDevices")]
		public GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevices AssignedDevices { get; set; }
		
		/// <summary>
		/// Description of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Id of staged upgrade group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupId")]
		public string GroupId { get; set; }
		
		/// <summary>
		/// Boolean indicating the default Group. Any device that does not have a group explicitly assigned will upgrade with this group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isDefault")]
		public System.Nullable<System.Boolean> IsDefault { get; set; }
		
		/// <summary>
		/// Name of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevices
	{
		
		/// <summary>
		/// Data Array of Devices containing the name and serial
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="devices")]
		public GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesDevices[] GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesDevices { get; set; }
		
		/// <summary>
		/// Data Array of Switch Stacks containing the name and id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchStacks")]
		public GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesSwitchStacks[] GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesSwitchStacks { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesDevices
	{
		
		/// <summary>
		/// Name of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Serial of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesStagedGroupsReturnAssignedDevicesSwitchStacks
	{
		
		/// <summary>
		/// ID of the Switch Stack
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the Switch Stack
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesStagedGroupReturn
	{
		
		/// <summary>
		/// The devices and Switch Stacks assigned to the Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignedDevices")]
		public GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevices AssignedDevices { get; set; }
		
		/// <summary>
		/// Description of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Id of staged upgrade group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupId")]
		public string GroupId { get; set; }
		
		/// <summary>
		/// Boolean indicating the default Group. Any device that does not have a group explicitly assigned will upgrade with this group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isDefault")]
		public System.Nullable<System.Boolean> IsDefault { get; set; }
		
		/// <summary>
		/// Name of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevices
	{
		
		/// <summary>
		/// Data Array of Devices containing the name and serial
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="devices")]
		public GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesDevices[] GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesDevices { get; set; }
		
		/// <summary>
		/// Data Array of Switch Stacks containing the name and id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchStacks")]
		public GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesSwitchStacks[] GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesSwitchStacks { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesDevices
	{
		
		/// <summary>
		/// Name of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Serial of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesStagedGroupReturnAssignedDevicesSwitchStacks
	{
		
		/// <summary>
		/// ID of the Switch Stack
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the Switch Stack
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesStagedStagesReturn
	{
		
		/// <summary>
		/// The Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public GetNetworkFirmwareUpgradesStagedStagesReturnGroup Group { get; set; }
	}
	
	public class GetNetworkFirmwareUpgradesStagedStagesReturnGroup
	{
		
		/// <summary>
		/// Description of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Id of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesStagedStagesPutBody
	{
		
		/// <summary>
		/// Array of Staged Upgrade Groups
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateNetworkFirmwareUpgradesStagedStagesPutBody_json[] UpdateNetworkFirmwareUpgradesStagedStagesPutBody_json { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesStagedStagesPutBody_json
	{
		
		/// <summary>
		/// The Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public UpdateNetworkFirmwareUpgradesStagedStagesPutBody_jsonGroup Group { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesStagedStagesPutBody_jsonGroup
	{
		
		/// <summary>
		/// ID of the Staged Upgrade Group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesStagedStagesReturn
	{
		
		/// <summary>
		/// The Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public UpdateNetworkFirmwareUpgradesStagedStagesReturnGroup Group { get; set; }
	}
	
	public class UpdateNetworkFirmwareUpgradesStagedStagesReturnGroup
	{
		
		/// <summary>
		/// Description of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Id of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the Staged Upgrade Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class CreateNetworkFloorPlanPostBody
	{
		
		/// <summary>
		/// The longitude and latitude of the bottom left corner of your floor plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bottomLeftCorner")]
		public CreateNetworkFloorPlanPostBodyBottomLeftCorner BottomLeftCorner { get; set; }
		
		/// <summary>
		/// The longitude and latitude of the bottom right corner of your floor plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bottomRightCorner")]
		public CreateNetworkFloorPlanPostBodyBottomRightCorner BottomRightCorner { get; set; }
		
		/// <summary>
		/// The longitude and latitude of the center of your floor plan. The 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="center")]
		public CreateNetworkFloorPlanPostBodyCenter Center { get; set; }
		
		/// <summary>
		/// The file contents (a base 64 encoded string) of your image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="imageContents")]
		public string ImageContents { get; set; }
		
		/// <summary>
		/// The name of your floor plan.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The longitude and latitude of the top left corner of your floor plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="topLeftCorner")]
		public CreateNetworkFloorPlanPostBodyTopLeftCorner TopLeftCorner { get; set; }
		
		/// <summary>
		/// The longitude and latitude of the top right corner of your floor plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="topRightCorner")]
		public CreateNetworkFloorPlanPostBodyTopRightCorner TopRightCorner { get; set; }
	}
	
	public class CreateNetworkFloorPlanPostBodyBottomLeftCorner
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class CreateNetworkFloorPlanPostBodyBottomRightCorner
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class CreateNetworkFloorPlanPostBodyCenter
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class CreateNetworkFloorPlanPostBodyTopLeftCorner
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class CreateNetworkFloorPlanPostBodyTopRightCorner
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class UpdateNetworkFloorPlanPutBody
	{
		
		/// <summary>
		/// The longitude and latitude of the bottom left corner of your floor plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bottomLeftCorner")]
		public UpdateNetworkFloorPlanPutBodyBottomLeftCorner BottomLeftCorner { get; set; }
		
		/// <summary>
		/// The longitude and latitude of the bottom right corner of your floor plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bottomRightCorner")]
		public UpdateNetworkFloorPlanPutBodyBottomRightCorner BottomRightCorner { get; set; }
		
		/// <summary>
		/// The longitude and latitude of the center of your floor plan. If you want to change the geolocation data of your floor plan, either the 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="center")]
		public UpdateNetworkFloorPlanPutBodyCenter Center { get; set; }
		
		/// <summary>
		/// The file contents (a base 64 encoded string) of your new image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in. If you upload a new image, and you do NOT specify any new geolocation fields ('center, 'topLeftCorner', etc), the floor plan will be recentered with no rotation in order to maintain the aspect ratio of your new image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageContents")]
		public string ImageContents { get; set; }
		
		/// <summary>
		/// The name of your floor plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The longitude and latitude of the top left corner of your floor plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="topLeftCorner")]
		public UpdateNetworkFloorPlanPutBodyTopLeftCorner TopLeftCorner { get; set; }
		
		/// <summary>
		/// The longitude and latitude of the top right corner of your floor plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="topRightCorner")]
		public UpdateNetworkFloorPlanPutBodyTopRightCorner TopRightCorner { get; set; }
	}
	
	public class UpdateNetworkFloorPlanPutBodyBottomLeftCorner
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class UpdateNetworkFloorPlanPutBodyBottomRightCorner
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class UpdateNetworkFloorPlanPutBodyCenter
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class UpdateNetworkFloorPlanPutBodyTopLeftCorner
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class UpdateNetworkFloorPlanPutBodyTopRightCorner
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
	}
	
	public class CreateNetworkGroupPolicyPostBody
	{
		
		/// <summary>
		///     The bandwidth settings for clients bound to your group policy.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandwidth")]
		public CreateNetworkGroupPolicyPostBodyBandwidth Bandwidth { get; set; }
		
		/// <summary>
		/// The Bonjour settings for your group policy. Only valid if your network has a wireless configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bonjourForwarding")]
		public CreateNetworkGroupPolicyPostBodyBonjourForwarding BonjourForwarding { get; set; }
		
		/// <summary>
		/// The content filtering settings for your group policy
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentFiltering")]
		public CreateNetworkGroupPolicyPostBodyContentFiltering ContentFiltering { get; set; }
		
		/// <summary>
		///     The firewall and traffic shaping rules and settings for your policy.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewallAndTrafficShaping")]
		public CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShaping FirewallAndTrafficShaping { get; set; }
		
		/// <summary>
		/// The name for your group policy. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		///     The schedule for the group policy. Schedules are applied to days of the week.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduling")]
		public CreateNetworkGroupPolicyPostBodyScheduling Scheduling { get; set; }
		
		/// <summary>
		/// Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashAuthSettings")]
		public System.Nullable<CreateNetworkGroupPolicyPostBodySplashAuthSettings> SplashAuthSettings { get; set; }
		
		/// <summary>
		/// The VLAN tagging settings for your group policy. Only available if your network has a wireless configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanTagging")]
		public CreateNetworkGroupPolicyPostBodyVlanTagging VlanTagging { get; set; }
	}
	
	public class CreateNetworkGroupPolicyPostBodyBandwidth
	{
		
		/// <summary>
		/// The bandwidth limits object, specifying upload and download speed for clients bound to the group policy. These are only enforced if 'settings' is set to 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandwidthLimits")]
		public CreateNetworkGroupPolicyPostBodyBandwidthBandwidthLimits BandwidthLimits { get; set; }
		
		/// <summary>
		/// How bandwidth limits are enforced. Can be 'network default', 'ignore' or 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public System.Nullable<CreateNetworkGroupPolicyPostBodyBandwidthSettings> Settings { get; set; }
	}
	
	public class CreateNetworkGroupPolicyPostBodyBandwidthBandwidthLimits
	{
		
		/// <summary>
		/// The maximum download limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitDown")]
		public System.Nullable<System.Int32> LimitDown { get; set; }
		
		/// <summary>
		/// The maximum upload limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitUp")]
		public System.Nullable<System.Int32> LimitUp { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkGroupPolicyPostBodyBandwidthSettings
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ignore = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="network default")]
		network_default = 2,
	}
	
	public class CreateNetworkGroupPolicyPostBodyBonjourForwarding
	{
		
		/// <summary>
		/// A list of the Bonjour forwarding rules for your group policy. If 'settings' is set to 'custom', at least one rule must be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public CreateNetworkGroupPolicyPostBodyBonjourForwardingRules[] CreateNetworkGroupPolicyPostBodyBonjourForwardingRules { get; set; }
		
		/// <summary>
		/// How Bonjour rules are applied. Can be 'network default', 'ignore' or 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public System.Nullable<CreateNetworkGroupPolicyPostBodyBonjourForwardingSettings> Settings { get; set; }
	}
	
	public class CreateNetworkGroupPolicyPostBodyBonjourForwardingRules
	{
		
		/// <summary>
		/// A description for your Bonjour forwarding rule. Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="services")]
		public string[] Services { get; set; }
		
		/// <summary>
		/// The ID of the service VLAN. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public string VlanId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkGroupPolicyPostBodyBonjourForwardingSettings
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ignore = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="network default")]
		network_default = 2,
	}
	
	public class CreateNetworkGroupPolicyPostBodyContentFiltering
	{
		
		/// <summary>
		/// Settings for allowed URL patterns
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedUrlPatterns")]
		public CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatterns AllowedUrlPatterns { get; set; }
		
		/// <summary>
		/// Settings for blocked URL categories
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockedUrlCategories")]
		public CreateNetworkGroupPolicyPostBodyContentFilteringBlockedUrlCategories BlockedUrlCategories { get; set; }
		
		/// <summary>
		/// Settings for blocked URL patterns
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockedUrlPatterns")]
		public CreateNetworkGroupPolicyPostBodyContentFilteringBlockedUrlPatterns BlockedUrlPatterns { get; set; }
	}
	
	public class CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatterns
	{
		
		/// <summary>
		/// A list of URL patterns that are allowed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patterns")]
		public string[] Patterns { get; set; }
		
		/// <summary>
		/// How URL patterns are applied. Can be 'network default', 'append' or 'override'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public System.Nullable<CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings> Settings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkGroupPolicyPostBodyContentFilteringAllowedUrlPatternsSettings
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		append = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="network default")]
		network_default = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="override")]
		_override = 2,
	}
	
	public class CreateNetworkGroupPolicyPostBodyContentFilteringBlockedUrlCategories
	{
		
		/// <summary>
		/// A list of URL categories to block
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="categories")]
		public string[] Categories { get; set; }
		
		/// <summary>
		/// How URL categories are applied. Can be 'network default', 'append' or 'override'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public System.Nullable<CreateNetworkGroupPolicyPostBodyContentFilteringBlockedUrlCategoriesSettings> Settings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkGroupPolicyPostBodyContentFilteringBlockedUrlCategoriesSettings
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		append = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="network default")]
		network_default = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="override")]
		_override = 2,
	}
	
	public class CreateNetworkGroupPolicyPostBodyContentFilteringBlockedUrlPatterns
	{
		
		/// <summary>
		/// A list of URL patterns that are blocked
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patterns")]
		public string[] Patterns { get; set; }
		
		/// <summary>
		/// How URL patterns are applied. Can be 'network default', 'append' or 'override'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public System.Nullable<CreateNetworkGroupPolicyPostBodyContentFilteringBlockedUrlPatternsSettings> Settings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkGroupPolicyPostBodyContentFilteringBlockedUrlPatternsSettings
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		append = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="network default")]
		network_default = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="override")]
		_override = 2,
	}
	
	public class CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShaping
	{
		
		/// <summary>
		/// An ordered array of the L3 firewall rules
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="l3FirewallRules")]
		public CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingL3FirewallRules[] CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingL3FirewallRules { get; set; }
		
		/// <summary>
		/// An ordered array of L7 firewall rules
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="l7FirewallRules")]
		public CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingL7FirewallRules[] CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingL7FirewallRules { get; set; }
		
		/// <summary>
		/// How firewall and traffic shaping rules are enforced. Can be 'network default', 'ignore' or 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public System.Nullable<CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingSettings> Settings { get; set; }
		
		/// <summary>
		///     An array of traffic shaping rules. Rules are applied in the order that
		///    they are specified in. An empty list (or null) means no rules. Note that
		///    you are allowed a maximum of 8 rules.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trafficShapingRules")]
		public CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRules[] CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRules { get; set; }
	}
	
	public class CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingL3FirewallRules
	{
		
		/// <summary>
		/// Description of the rule (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Destination IP address (in IP or CIDR notation), a fully-qualified domain name (FQDN, if your network supports it) or 'any'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destCidr")]
		public string DestCidr { get; set; }
		
		/// <summary>
		/// Destination port (integer in the range 1-65535), a port range (e.g. 8080-9090), or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destPort")]
		public string DestPort { get; set; }
		
		/// <summary>
		/// 'allow' or 'deny' traffic specified by this rule
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public string Policy { get; set; }
		
		/// <summary>
		/// The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public string Protocol { get; set; }
	}
	
	public class CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingL7FirewallRules
	{
		
		/// <summary>
		/// The policy applied to matching traffic. Must be 'deny'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesPolicy Policy { get; set; }
		
		/// <summary>
		/// Type of the L7 Rule. Must be 'application', 'applicationCategory', 'host', 'port' or 'ipRange'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesType Type { get; set; }
		
		/// <summary>
		/// The 'value' of what you want to block. If 'type' is 'host', 'port' or 'ipRange', 'value' must be a string matching either a hostname (e.g. somewhere.com), a port (e.g. 8080), or an IP range (e.g. 192.1.0.0/16). If 'type' is 'application' or 'applicationCategory', then 'value' must be an object with an ID for the application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingSettings
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ignore = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="network default")]
		network_default = 2,
	}
	
	public class CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRules
	{
		
		/// <summary>
		///     A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="definitions")]
		public CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitions[] CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitions { get; set; }
		
		/// <summary>
		///     The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
		///    For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dscpTagValue")]
		public System.Nullable<System.Int32> DscpTagValue { get; set; }
		
		/// <summary>
		///     The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
		///    null means 'Do not set PCP tag'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pcpTagValue")]
		public System.Nullable<System.Int32> PcpTagValue { get; set; }
		
		/// <summary>
		///     An object describing the bandwidth settings for your rule.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perClientBandwidthLimits")]
		public CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimits PerClientBandwidthLimits { get; set; }
		
		/// <summary>
		///     A string, indicating the priority level for packets bound to your rule.
		///    Can be 'low', 'normal' or 'high'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public string Priority { get; set; }
	}
	
	public class CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitions
	{
		
		/// <summary>
		/// The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsType Type { get; set; }
		
		/// <summary>
		///     If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
		///    a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
		///    "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
		///    custom ports.
		///     If "type" is 'application' or 'applicationCategory', then "value" must be an object
		///    with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
		///    application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
		///    endpoint).
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimits
	{
		
		/// <summary>
		/// The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandwidthLimits")]
		public CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsBandwidthLimits BandwidthLimits { get; set; }
		
		/// <summary>
		/// How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public string Settings { get; set; }
	}
	
	public class CreateNetworkGroupPolicyPostBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsBandwidthLimits
	{
		
		/// <summary>
		/// The maximum download limit (integer, in Kbps).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitDown")]
		public System.Nullable<System.Int32> LimitDown { get; set; }
		
		/// <summary>
		/// The maximum upload limit (integer, in Kbps).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitUp")]
		public System.Nullable<System.Int32> LimitUp { get; set; }
	}
	
	public class CreateNetworkGroupPolicyPostBodyScheduling
	{
		
		/// <summary>
		/// Whether scheduling is enabled (true) or disabled (false). Defaults to false. If true, the schedule objects for each day of the week (monday - sunday) are parsed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The schedule object for Friday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="friday")]
		public CreateNetworkGroupPolicyPostBodySchedulingFriday Friday { get; set; }
		
		/// <summary>
		/// The schedule object for Monday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monday")]
		public CreateNetworkGroupPolicyPostBodySchedulingMonday Monday { get; set; }
		
		/// <summary>
		/// The schedule object for Saturday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="saturday")]
		public CreateNetworkGroupPolicyPostBodySchedulingSaturday Saturday { get; set; }
		
		/// <summary>
		/// The schedule object for Sunday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sunday")]
		public CreateNetworkGroupPolicyPostBodySchedulingSunday Sunday { get; set; }
		
		/// <summary>
		/// The schedule object for Thursday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thursday")]
		public CreateNetworkGroupPolicyPostBodySchedulingThursday Thursday { get; set; }
		
		/// <summary>
		/// The schedule object for Tuesday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tuesday")]
		public CreateNetworkGroupPolicyPostBodySchedulingTuesday Tuesday { get; set; }
		
		/// <summary>
		/// The schedule object for Wednesday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wednesday")]
		public CreateNetworkGroupPolicyPostBodySchedulingWednesday Wednesday { get; set; }
	}
	
	public class CreateNetworkGroupPolicyPostBodySchedulingFriday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateNetworkGroupPolicyPostBodySchedulingMonday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateNetworkGroupPolicyPostBodySchedulingSaturday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateNetworkGroupPolicyPostBodySchedulingSunday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateNetworkGroupPolicyPostBodySchedulingThursday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateNetworkGroupPolicyPostBodySchedulingTuesday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateNetworkGroupPolicyPostBodySchedulingWednesday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkGroupPolicyPostBodySplashAuthSettings
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		bypass = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="network default")]
		network_default = 1,
	}
	
	public class CreateNetworkGroupPolicyPostBodyVlanTagging
	{
		
		/// <summary>
		/// How VLAN tagging is applied. Can be 'network default', 'ignore' or 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public System.Nullable<CreateNetworkGroupPolicyPostBodyVlanTaggingSettings> Settings { get; set; }
		
		/// <summary>
		/// The ID of the vlan you want to tag. This only applies if 'settings' is set to 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public string VlanId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkGroupPolicyPostBodyVlanTaggingSettings
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ignore = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="network default")]
		network_default = 2,
	}
	
	public class UpdateNetworkGroupPolicyPutBody
	{
		
		/// <summary>
		///     The bandwidth settings for clients bound to your group policy.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandwidth")]
		public UpdateNetworkGroupPolicyPutBodyBandwidth Bandwidth { get; set; }
		
		/// <summary>
		/// The Bonjour settings for your group policy. Only valid if your network has a wireless configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bonjourForwarding")]
		public UpdateNetworkGroupPolicyPutBodyBonjourForwarding BonjourForwarding { get; set; }
		
		/// <summary>
		/// The content filtering settings for your group policy
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentFiltering")]
		public UpdateNetworkGroupPolicyPutBodyContentFiltering ContentFiltering { get; set; }
		
		/// <summary>
		///     The firewall and traffic shaping rules and settings for your policy.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewallAndTrafficShaping")]
		public UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShaping FirewallAndTrafficShaping { get; set; }
		
		/// <summary>
		/// The name for your group policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		///     The schedule for the group policy. Schedules are applied to days of the week.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduling")]
		public UpdateNetworkGroupPolicyPutBodyScheduling Scheduling { get; set; }
		
		/// <summary>
		/// Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashAuthSettings")]
		public System.Nullable<UpdateNetworkGroupPolicyPutBodySplashAuthSettings> SplashAuthSettings { get; set; }
		
		/// <summary>
		/// The VLAN tagging settings for your group policy. Only available if your network has a wireless configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanTagging")]
		public UpdateNetworkGroupPolicyPutBodyVlanTagging VlanTagging { get; set; }
	}
	
	public class UpdateNetworkGroupPolicyPutBodyBandwidth
	{
		
		/// <summary>
		/// The bandwidth limits object, specifying upload and download speed for clients bound to the group policy. These are only enforced if 'settings' is set to 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandwidthLimits")]
		public UpdateNetworkGroupPolicyPutBodyBandwidthBandwidthLimits BandwidthLimits { get; set; }
		
		/// <summary>
		/// How bandwidth limits are enforced. Can be 'network default', 'ignore' or 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public System.Nullable<UpdateNetworkGroupPolicyPutBodyBandwidthSettings> Settings { get; set; }
	}
	
	public class UpdateNetworkGroupPolicyPutBodyBandwidthBandwidthLimits
	{
		
		/// <summary>
		/// The maximum download limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitDown")]
		public System.Nullable<System.Int32> LimitDown { get; set; }
		
		/// <summary>
		/// The maximum upload limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitUp")]
		public System.Nullable<System.Int32> LimitUp { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkGroupPolicyPutBodyBandwidthSettings
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ignore = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="network default")]
		network_default = 2,
	}
	
	public class UpdateNetworkGroupPolicyPutBodyBonjourForwarding
	{
		
		/// <summary>
		/// A list of the Bonjour forwarding rules for your group policy. If 'settings' is set to 'custom', at least one rule must be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkGroupPolicyPutBodyBonjourForwardingRules[] UpdateNetworkGroupPolicyPutBodyBonjourForwardingRules { get; set; }
		
		/// <summary>
		/// How Bonjour rules are applied. Can be 'network default', 'ignore' or 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public System.Nullable<UpdateNetworkGroupPolicyPutBodyBonjourForwardingSettings> Settings { get; set; }
	}
	
	public class UpdateNetworkGroupPolicyPutBodyBonjourForwardingRules
	{
		
		/// <summary>
		/// A description for your Bonjour forwarding rule. Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="services")]
		public string[] Services { get; set; }
		
		/// <summary>
		/// The ID of the service VLAN. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public string VlanId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkGroupPolicyPutBodyBonjourForwardingSettings
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ignore = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="network default")]
		network_default = 2,
	}
	
	public class UpdateNetworkGroupPolicyPutBodyContentFiltering
	{
		
		/// <summary>
		/// Settings for allowed URL patterns
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedUrlPatterns")]
		public UpdateNetworkGroupPolicyPutBodyContentFilteringAllowedUrlPatterns AllowedUrlPatterns { get; set; }
		
		/// <summary>
		/// Settings for blocked URL categories
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockedUrlCategories")]
		public UpdateNetworkGroupPolicyPutBodyContentFilteringBlockedUrlCategories BlockedUrlCategories { get; set; }
		
		/// <summary>
		/// Settings for blocked URL patterns
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockedUrlPatterns")]
		public UpdateNetworkGroupPolicyPutBodyContentFilteringBlockedUrlPatterns BlockedUrlPatterns { get; set; }
	}
	
	public class UpdateNetworkGroupPolicyPutBodyContentFilteringAllowedUrlPatterns
	{
		
		/// <summary>
		/// A list of URL patterns that are allowed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patterns")]
		public string[] Patterns { get; set; }
		
		/// <summary>
		/// How URL patterns are applied. Can be 'network default', 'append' or 'override'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public System.Nullable<UpdateNetworkGroupPolicyPutBodyContentFilteringAllowedUrlPatternsSettings> Settings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkGroupPolicyPutBodyContentFilteringAllowedUrlPatternsSettings
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		append = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="network default")]
		network_default = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="override")]
		_override = 2,
	}
	
	public class UpdateNetworkGroupPolicyPutBodyContentFilteringBlockedUrlCategories
	{
		
		/// <summary>
		/// A list of URL categories to block
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="categories")]
		public string[] Categories { get; set; }
		
		/// <summary>
		/// How URL categories are applied. Can be 'network default', 'append' or 'override'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public System.Nullable<UpdateNetworkGroupPolicyPutBodyContentFilteringBlockedUrlCategoriesSettings> Settings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkGroupPolicyPutBodyContentFilteringBlockedUrlCategoriesSettings
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		append = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="network default")]
		network_default = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="override")]
		_override = 2,
	}
	
	public class UpdateNetworkGroupPolicyPutBodyContentFilteringBlockedUrlPatterns
	{
		
		/// <summary>
		/// A list of URL patterns that are blocked
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patterns")]
		public string[] Patterns { get; set; }
		
		/// <summary>
		/// How URL patterns are applied. Can be 'network default', 'append' or 'override'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public System.Nullable<UpdateNetworkGroupPolicyPutBodyContentFilteringBlockedUrlPatternsSettings> Settings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkGroupPolicyPutBodyContentFilteringBlockedUrlPatternsSettings
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		append = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="network default")]
		network_default = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="override")]
		_override = 2,
	}
	
	public class UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShaping
	{
		
		/// <summary>
		/// An ordered array of the L3 firewall rules
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="l3FirewallRules")]
		public UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingL3FirewallRules[] UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingL3FirewallRules { get; set; }
		
		/// <summary>
		/// An ordered array of L7 firewall rules
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="l7FirewallRules")]
		public UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingL7FirewallRules[] UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingL7FirewallRules { get; set; }
		
		/// <summary>
		/// How firewall and traffic shaping rules are enforced. Can be 'network default', 'ignore' or 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public System.Nullable<UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingSettings> Settings { get; set; }
		
		/// <summary>
		///     An array of traffic shaping rules. Rules are applied in the order that
		///    they are specified in. An empty list (or null) means no rules. Note that
		///    you are allowed a maximum of 8 rules.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trafficShapingRules")]
		public UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRules[] UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRules { get; set; }
	}
	
	public class UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingL3FirewallRules
	{
		
		/// <summary>
		/// Description of the rule (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Destination IP address (in IP or CIDR notation), a fully-qualified domain name (FQDN, if your network supports it) or 'any'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destCidr")]
		public string DestCidr { get; set; }
		
		/// <summary>
		/// Destination port (integer in the range 1-65535), a port range (e.g. 8080-9090), or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destPort")]
		public string DestPort { get; set; }
		
		/// <summary>
		/// 'allow' or 'deny' traffic specified by this rule
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public string Policy { get; set; }
		
		/// <summary>
		/// The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public string Protocol { get; set; }
	}
	
	public class UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingL7FirewallRules
	{
		
		/// <summary>
		/// The policy applied to matching traffic. Must be 'deny'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesPolicy Policy { get; set; }
		
		/// <summary>
		/// Type of the L7 Rule. Must be 'application', 'applicationCategory', 'host', 'port' or 'ipRange'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesType Type { get; set; }
		
		/// <summary>
		/// The 'value' of what you want to block. If 'type' is 'host', 'port' or 'ipRange', 'value' must be a string matching either a hostname (e.g. somewhere.com), a port (e.g. 8080), or an IP range (e.g. 192.1.0.0/16). If 'type' is 'application' or 'applicationCategory', then 'value' must be an object with an ID for the application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingSettings
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ignore = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="network default")]
		network_default = 2,
	}
	
	public class UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRules
	{
		
		/// <summary>
		///     A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="definitions")]
		public UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitions[] UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitions { get; set; }
		
		/// <summary>
		///     The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
		///    For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dscpTagValue")]
		public System.Nullable<System.Int32> DscpTagValue { get; set; }
		
		/// <summary>
		///     The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
		///    null means 'Do not set PCP tag'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pcpTagValue")]
		public System.Nullable<System.Int32> PcpTagValue { get; set; }
		
		/// <summary>
		///     An object describing the bandwidth settings for your rule.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perClientBandwidthLimits")]
		public UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimits PerClientBandwidthLimits { get; set; }
		
		/// <summary>
		///     A string, indicating the priority level for packets bound to your rule.
		///    Can be 'low', 'normal' or 'high'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public string Priority { get; set; }
	}
	
	public class UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitions
	{
		
		/// <summary>
		/// The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsType Type { get; set; }
		
		/// <summary>
		///     If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
		///    a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
		///    "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
		///    custom ports.
		///     If "type" is 'application' or 'applicationCategory', then "value" must be an object
		///    with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
		///    application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
		///    endpoint).
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimits
	{
		
		/// <summary>
		/// The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandwidthLimits")]
		public UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsBandwidthLimits BandwidthLimits { get; set; }
		
		/// <summary>
		/// How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public string Settings { get; set; }
	}
	
	public class UpdateNetworkGroupPolicyPutBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsBandwidthLimits
	{
		
		/// <summary>
		/// The maximum download limit (integer, in Kbps).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitDown")]
		public System.Nullable<System.Int32> LimitDown { get; set; }
		
		/// <summary>
		/// The maximum upload limit (integer, in Kbps).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitUp")]
		public System.Nullable<System.Int32> LimitUp { get; set; }
	}
	
	public class UpdateNetworkGroupPolicyPutBodyScheduling
	{
		
		/// <summary>
		/// Whether scheduling is enabled (true) or disabled (false). Defaults to false. If true, the schedule objects for each day of the week (monday - sunday) are parsed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The schedule object for Friday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="friday")]
		public UpdateNetworkGroupPolicyPutBodySchedulingFriday Friday { get; set; }
		
		/// <summary>
		/// The schedule object for Monday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monday")]
		public UpdateNetworkGroupPolicyPutBodySchedulingMonday Monday { get; set; }
		
		/// <summary>
		/// The schedule object for Saturday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="saturday")]
		public UpdateNetworkGroupPolicyPutBodySchedulingSaturday Saturday { get; set; }
		
		/// <summary>
		/// The schedule object for Sunday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sunday")]
		public UpdateNetworkGroupPolicyPutBodySchedulingSunday Sunday { get; set; }
		
		/// <summary>
		/// The schedule object for Thursday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thursday")]
		public UpdateNetworkGroupPolicyPutBodySchedulingThursday Thursday { get; set; }
		
		/// <summary>
		/// The schedule object for Tuesday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tuesday")]
		public UpdateNetworkGroupPolicyPutBodySchedulingTuesday Tuesday { get; set; }
		
		/// <summary>
		/// The schedule object for Wednesday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wednesday")]
		public UpdateNetworkGroupPolicyPutBodySchedulingWednesday Wednesday { get; set; }
	}
	
	public class UpdateNetworkGroupPolicyPutBodySchedulingFriday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkGroupPolicyPutBodySchedulingMonday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkGroupPolicyPutBodySchedulingSaturday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkGroupPolicyPutBodySchedulingSunday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkGroupPolicyPutBodySchedulingThursday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkGroupPolicyPutBodySchedulingTuesday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkGroupPolicyPutBodySchedulingWednesday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkGroupPolicyPutBodySplashAuthSettings
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		bypass = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="network default")]
		network_default = 1,
	}
	
	public class UpdateNetworkGroupPolicyPutBodyVlanTagging
	{
		
		/// <summary>
		/// How VLAN tagging is applied. Can be 'network default', 'ignore' or 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public System.Nullable<UpdateNetworkGroupPolicyPutBodyVlanTaggingSettings> Settings { get; set; }
		
		/// <summary>
		/// The ID of the vlan you want to tag. This only applies if 'settings' is set to 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public string VlanId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkGroupPolicyPutBodyVlanTaggingSettings
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ignore = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="network default")]
		network_default = 2,
	}
	
	public class GetNetworkHealthAlertsReturn
	{
		
		/// <summary>
		/// Category of the alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		/// <summary>
		/// Alert identifier. Value can be empty
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The scope of the alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scope")]
		public GetNetworkHealthAlertsReturnScope Scope { get; set; }
		
		/// <summary>
		/// Severity of the alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="severity")]
		public System.Nullable<GetNetworkHealthAlertsReturnSeverity> Severity { get; set; }
		
		/// <summary>
		/// Alert type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class GetNetworkHealthAlertsReturnScope
	{
		
		/// <summary>
		/// Applications related to the alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applications")]
		public GetNetworkHealthAlertsReturnScopeApplications[] GetNetworkHealthAlertsReturnScopeApplications { get; set; }
		
		/// <summary>
		/// Devices related to the alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="devices")]
		public GetNetworkHealthAlertsReturnScopeDevices[] GetNetworkHealthAlertsReturnScopeDevices { get; set; }
		
		/// <summary>
		/// Peers related to the alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peers")]
		public GetNetworkHealthAlertsReturnScopePeers[] GetNetworkHealthAlertsReturnScopePeers { get; set; }
	}
	
	public class GetNetworkHealthAlertsReturnScopeApplications
	{
		
		/// <summary>
		/// Name of the application
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// URL to the application
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetNetworkHealthAlertsReturnScopeDevices
	{
		
		/// <summary>
		/// Clients related to the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clients")]
		public GetNetworkHealthAlertsReturnScopeDevicesClients[] GetNetworkHealthAlertsReturnScopeDevicesClients { get; set; }
		
		/// <summary>
		/// Lldp information
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lldp")]
		public GetNetworkHealthAlertsReturnScopeDevicesLldp Lldp { get; set; }
		
		/// <summary>
		/// The mac address of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// Name of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Product type of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productType")]
		public string ProductType { get; set; }
		
		/// <summary>
		/// Serial number of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// URL to the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetNetworkHealthAlertsReturnScopeDevicesClients
	{
		
		/// <summary>
		/// Mac address of the client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
	}
	
	public class GetNetworkHealthAlertsReturnScopeDevicesLldp
	{
		
		/// <summary>
		/// Port Id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portId")]
		public string PortId { get; set; }
	}
	
	public class GetNetworkHealthAlertsReturnScopePeers
	{
		
		/// <summary>
		/// Network of the peer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public GetNetworkHealthAlertsReturnScopePeersNetwork Network { get; set; }
		
		/// <summary>
		/// URL to the peer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetNetworkHealthAlertsReturnScopePeersNetwork
	{
		
		/// <summary>
		/// Id of the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkHealthAlertsReturnSeverity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		error = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		info = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		warning = 2,
	}
	
	public class GetNetworkInsightApplicationHealthByTimeReturn
	{
		
		/// <summary>
		/// The end time of the query range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTs")]
		public System.Nullable<System.DateTimeOffset> EndTs { get; set; }
		
		/// <summary>
		/// LAN goodput (Number of useful information bits delivered over a LAN per unit of time)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lanGoodput")]
		public System.Nullable<System.Int32> LanGoodput { get; set; }
		
		/// <summary>
		/// LAN latency in milliseconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lanLatencyMs")]
		public System.Nullable<System.Single> LanLatencyMs { get; set; }
		
		/// <summary>
		/// LAN loss percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lanLossPercent")]
		public System.Nullable<System.Single> LanLossPercent { get; set; }
		
		/// <summary>
		/// Number of clients
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numClients")]
		public System.Nullable<System.Int32> NumClients { get; set; }
		
		/// <summary>
		/// Received kilobytes-per-second
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recv")]
		public System.Nullable<System.Int32> Recv { get; set; }
		
		/// <summary>
		/// Duration of the response, in milliseconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseDuration")]
		public System.Nullable<System.Int32> ResponseDuration { get; set; }
		
		/// <summary>
		/// Sent kilobytes-per-second
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sent")]
		public System.Nullable<System.Int32> Sent { get; set; }
		
		/// <summary>
		/// The start time of the query range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTs")]
		public System.Nullable<System.DateTimeOffset> StartTs { get; set; }
		
		/// <summary>
		/// WAN goodput (Number of useful information bits delivered over a WAN per unit of time)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wanGoodput")]
		public System.Nullable<System.Int32> WanGoodput { get; set; }
		
		/// <summary>
		/// WAN latency in milliseconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wanLatencyMs")]
		public System.Nullable<System.Single> WanLatencyMs { get; set; }
		
		/// <summary>
		/// WAN loss percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wanLossPercent")]
		public System.Nullable<System.Single> WanLossPercent { get; set; }
	}
	
	public class GetNetworkMerakiAuthUsersReturn
	{
		
		/// <summary>
		/// Authorization type for user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accountType")]
		public string AccountType { get; set; }
		
		/// <summary>
		/// User authorization info
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizations")]
		public GetNetworkMerakiAuthUsersReturnAuthorizations[] GetNetworkMerakiAuthUsersReturnAuthorizations { get; set; }
		
		/// <summary>
		/// Creation time of the user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.Nullable<System.DateTimeOffset> CreatedAt { get; set; }
		
		/// <summary>
		/// Email address of the user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Meraki auth user id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Whether or not the user is a Dashboard administrator
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAdmin")]
		public System.Nullable<System.Boolean> IsAdmin { get; set; }
		
		/// <summary>
		/// Name of the user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetNetworkMerakiAuthUsersReturnAuthorizations
	{
		
		/// <summary>
		/// User is authorized by the account email address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizedByEmail")]
		public string AuthorizedByEmail { get; set; }
		
		/// <summary>
		/// User is authorized by the account name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizedByName")]
		public string AuthorizedByName { get; set; }
		
		/// <summary>
		/// Authorized zone of the user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizedZone")]
		public string AuthorizedZone { get; set; }
		
		/// <summary>
		/// Authorization expiration time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiresAt")]
		public System.Nullable<System.DateTimeOffset> ExpiresAt { get; set; }
		
		/// <summary>
		/// SSID number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssidNumber")]
		public System.Nullable<System.Int32> SsidNumber { get; set; }
	}
	
	public class CreateNetworkMerakiAuthUserPostBody
	{
		
		/// <summary>
		/// Authorization type for user. Can be 'Guest' or '802.1X' for wireless networks, or 'Client VPN' for wired networks. Defaults to '802.1X'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accountType")]
		public System.Nullable<CreateNetworkMerakiAuthUserPostBodyAccountType> AccountType { get; set; }
		
		/// <summary>
		/// Authorization zones and expiration dates for the user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authorizations")]
		public CreateNetworkMerakiAuthUserPostBodyAuthorizations[] CreateNetworkMerakiAuthUserPostBodyAuthorizations { get; set; }
		
		/// <summary>
		/// Email address of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Whether or not Meraki should email the password to user. Default is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emailPasswordToUser")]
		public System.Nullable<System.Boolean> EmailPasswordToUser { get; set; }
		
		/// <summary>
		/// Whether or not the user is a Dashboard administrator.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAdmin")]
		public System.Nullable<System.Boolean> IsAdmin { get; set; }
		
		/// <summary>
		/// Name of the user. Only required If the user is not a Dashboard administrator.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The password for this user account. Only required If the user is not a Dashboard administrator.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkMerakiAuthUserPostBodyAccountType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="802.1X")]
		_802_1X = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Client VPN")]
		Client_VPN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Guest = 2,
	}
	
	public class CreateNetworkMerakiAuthUserPostBodyAuthorizations
	{
		
		/// <summary>
		/// Date for authorization to expire. Set to 'Never' for the authorization to not expire, which is the default.
		/// </summary>
		[System.ComponentModel.DefaultValue("Never")]
		[System.Runtime.Serialization.DataMember(Name="expiresAt")]
		public string ExpiresAt { get; set; } = "Never";
		
		/// <summary>
		/// Required for wireless networks. The SSID for which the user is being authorized, which must be configured for the user's given accountType.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssidNumber")]
		public System.Nullable<System.Int32> SsidNumber { get; set; }
	}
	
	public class GetNetworkMerakiAuthUserReturn
	{
		
		/// <summary>
		/// Authorization type for user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accountType")]
		public string AccountType { get; set; }
		
		/// <summary>
		/// User authorization info
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizations")]
		public GetNetworkMerakiAuthUserReturnAuthorizations[] GetNetworkMerakiAuthUserReturnAuthorizations { get; set; }
		
		/// <summary>
		/// Creation time of the user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.Nullable<System.DateTimeOffset> CreatedAt { get; set; }
		
		/// <summary>
		/// Email address of the user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Meraki auth user id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Whether or not the user is a Dashboard administrator
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAdmin")]
		public System.Nullable<System.Boolean> IsAdmin { get; set; }
		
		/// <summary>
		/// Name of the user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetNetworkMerakiAuthUserReturnAuthorizations
	{
		
		/// <summary>
		/// User is authorized by the account email address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizedByEmail")]
		public string AuthorizedByEmail { get; set; }
		
		/// <summary>
		/// User is authorized by the account name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizedByName")]
		public string AuthorizedByName { get; set; }
		
		/// <summary>
		/// Authorized zone of the user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizedZone")]
		public string AuthorizedZone { get; set; }
		
		/// <summary>
		/// Authorization expiration time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiresAt")]
		public System.Nullable<System.DateTimeOffset> ExpiresAt { get; set; }
		
		/// <summary>
		/// SSID number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssidNumber")]
		public System.Nullable<System.Int32> SsidNumber { get; set; }
	}
	
	public class UpdateNetworkMerakiAuthUserPutBody
	{
		
		/// <summary>
		/// Authorization zones and expiration dates for the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizations")]
		public UpdateNetworkMerakiAuthUserPutBodyAuthorizations[] UpdateNetworkMerakiAuthUserPutBodyAuthorizations { get; set; }
		
		/// <summary>
		/// Whether or not Meraki should email the password to user. Default is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emailPasswordToUser")]
		public System.Nullable<System.Boolean> EmailPasswordToUser { get; set; }
		
		/// <summary>
		/// Name of the user. Only allowed If the user is not Dashboard administrator.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The password for this user account. Only allowed If the user is not Dashboard administrator.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
	}
	
	public class UpdateNetworkMerakiAuthUserPutBodyAuthorizations
	{
		
		/// <summary>
		/// Date for authorization to expire. Default is for authorization to not expire.
		/// </summary>
		[System.ComponentModel.DefaultValue("Never")]
		[System.Runtime.Serialization.DataMember(Name="expiresAt")]
		public string ExpiresAt { get; set; } = "Never";
		
		/// <summary>
		/// SSID for which the user is being authorized
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ssidNumber")]
		public int SsidNumber { get; set; }
	}
	
	public class UpdateNetworkMerakiAuthUserReturn
	{
		
		/// <summary>
		/// Authorization type for user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accountType")]
		public string AccountType { get; set; }
		
		/// <summary>
		/// User authorization info
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizations")]
		public UpdateNetworkMerakiAuthUserReturnAuthorizations[] UpdateNetworkMerakiAuthUserReturnAuthorizations { get; set; }
		
		/// <summary>
		/// Creation time of the user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.Nullable<System.DateTimeOffset> CreatedAt { get; set; }
		
		/// <summary>
		/// Email address of the user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Meraki auth user id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Whether or not the user is a Dashboard administrator
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAdmin")]
		public System.Nullable<System.Boolean> IsAdmin { get; set; }
		
		/// <summary>
		/// Name of the user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateNetworkMerakiAuthUserReturnAuthorizations
	{
		
		/// <summary>
		/// User is authorized by the account email address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizedByEmail")]
		public string AuthorizedByEmail { get; set; }
		
		/// <summary>
		/// User is authorized by the account name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizedByName")]
		public string AuthorizedByName { get; set; }
		
		/// <summary>
		/// Authorized zone of the user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizedZone")]
		public string AuthorizedZone { get; set; }
		
		/// <summary>
		/// Authorization expiration time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiresAt")]
		public System.Nullable<System.DateTimeOffset> ExpiresAt { get; set; }
		
		/// <summary>
		/// SSID number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssidNumber")]
		public System.Nullable<System.Int32> SsidNumber { get; set; }
	}
	
	public class CreateNetworkMqttBrokerPostBody
	{
		
		/// <summary>
		/// Authentication settings of the MQTT broker
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public string Authentication { get; set; }
		
		/// <summary>
		/// Host name/IP address where the MQTT broker runs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// Name of the MQTT broker.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Host port though which the MQTT broker can be reached.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
		
		/// <summary>
		/// Security settings of the MQTT broker.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="security")]
		public CreateNetworkMqttBrokerPostBodySecurity Security { get; set; }
	}
	
	public class CreateNetworkMqttBrokerPostBodySecurity
	{
		
		/// <summary>
		/// Security protocol of the MQTT broker.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public string Mode { get; set; }
		
		/// <summary>
		/// TLS settings of the MQTT broker.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="security")]
		public CreateNetworkMqttBrokerPostBodySecuritySecurity Security { get; set; }
	}
	
	public class CreateNetworkMqttBrokerPostBodySecuritySecurity
	{
		
		/// <summary>
		/// CA Certificate of the MQTT broker.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caCertificate")]
		public string CaCertificate { get; set; }
		
		/// <summary>
		/// Whether the TLS hostname verification is enabled for the MQTT broker.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="verifyHostnames")]
		public System.Nullable<System.Boolean> VerifyHostnames { get; set; }
	}
	
	public class UpdateNetworkMqttBrokerPutBody
	{
		
		/// <summary>
		/// Authentication settings of the MQTT broker
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public string Authentication { get; set; }
		
		/// <summary>
		/// Host name/IP address where the MQTT broker runs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// Name of the MQTT broker.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Host port though which the MQTT broker can be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Security settings of the MQTT broker.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="security")]
		public UpdateNetworkMqttBrokerPutBodySecurity Security { get; set; }
	}
	
	public class UpdateNetworkMqttBrokerPutBodySecurity
	{
		
		/// <summary>
		/// Security protocol of the MQTT broker.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public string Mode { get; set; }
		
		/// <summary>
		/// TLS settings of the MQTT broker.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="security")]
		public UpdateNetworkMqttBrokerPutBodySecuritySecurity Security { get; set; }
	}
	
	public class UpdateNetworkMqttBrokerPutBodySecuritySecurity
	{
		
		/// <summary>
		/// CA Certificate of the MQTT broker.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caCertificate")]
		public string CaCertificate { get; set; }
		
		/// <summary>
		/// Whether the TLS hostname verification is enabled for the MQTT broker.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="verifyHostnames")]
		public System.Nullable<System.Boolean> VerifyHostnames { get; set; }
	}
	
	public class UpdateNetworkNetflowPutBody
	{
		
		/// <summary>
		/// The IPv4 address of the NetFlow collector.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="collectorIp")]
		public string CollectorIp { get; set; }
		
		/// <summary>
		/// The port that the NetFlow collector will be listening on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="collectorPort")]
		public System.Nullable<System.Int32> CollectorPort { get; set; }
		
		/// <summary>
		/// The port that the Encrypted Traffic Analytics collector will be listening on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etaDstPort")]
		public System.Nullable<System.Int32> EtaDstPort { get; set; }
		
		/// <summary>
		/// Boolean indicating whether Encrypted Traffic Analytics is enabled (true) or disabled (false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etaEnabled")]
		public System.Nullable<System.Boolean> EtaEnabled { get; set; }
		
		/// <summary>
		/// Boolean indicating whether NetFlow traffic reporting is enabled (true) or disabled (false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reportingEnabled")]
		public System.Nullable<System.Boolean> ReportingEnabled { get; set; }
	}
	
	public class CreateNetworkPiiRequestPostBody
	{
		
		/// <summary>
		/// The datasets related to the provided key that should be deleted. Only applies to "delete" requests. The value "all" will be expanded to all datasets applicable to this type. The datasets by applicable to each type are: mac (usage, events, traffic), email (users, loginAttempts), username (users, loginAttempts), bluetoothMac (client, connectivity), smDeviceId (device), smUserId (user)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="datasets")]
		public string[] Datasets { get; set; }
		
		/// <summary>
		/// The email of a network user account. Only applies to "delete" requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// The MAC of a network client device. Applies to both "restrict processing" and "delete" requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// The sm_device_id of a Systems Manager device. The only way to "restrict processing" or "delete" a Systems Manager device. Must include "device" in the dataset for a "delete" request to destroy the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smDeviceId")]
		public string SmDeviceId { get; set; }
		
		/// <summary>
		/// The sm_user_id of a Systems Manager user. The only way to "restrict processing" or "delete" a Systems Manager user. Must include "user" in the dataset for a "delete" request to destroy the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smUserId")]
		public string SmUserId { get; set; }
		
		/// <summary>
		/// One of "delete" or "restrict processing"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<CreateNetworkPiiRequestPostBodyType> Type { get; set; }
		
		/// <summary>
		/// The username of a network log in. Only applies to "delete" requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkPiiRequestPostBodyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		delete = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="restrict processing")]
		restrict_processing = 1,
	}
	
	public class GetNetworkPoliciesByClientReturn
	{
		
		/// <summary>
		/// Assigned policies
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assigned")]
		public GetNetworkPoliciesByClientReturnAssigned[] GetNetworkPoliciesByClientReturnAssigned { get; set; }
		
		/// <summary>
		/// ID of client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientId")]
		public string ClientId { get; set; }
		
		/// <summary>
		/// Name of client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetNetworkPoliciesByClientReturnAssigned
	{
		
		/// <summary>
		/// id of policy
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
		
		/// <summary>
		/// name of policy
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// ssid
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssid")]
		public GetNetworkPoliciesByClientReturnAssignedSsid[] GetNetworkPoliciesByClientReturnAssignedSsid { get; set; }
		
		/// <summary>
		/// type of policy
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class GetNetworkPoliciesByClientReturnAssignedSsid
	{
		
		/// <summary>
		/// number of ssid
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssidNumber")]
		public System.Nullable<System.Int32> SsidNumber { get; set; }
	}
	
	public class GetNetworkSensorAlertsCurrentOverviewByMetricReturn
	{
		
		/// <summary>
		/// Counts of currently alerting sensors, aggregated by alerting metric
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="counts")]
		public GetNetworkSensorAlertsCurrentOverviewByMetricReturnCounts Counts { get; set; }
		
		/// <summary>
		/// List of metrics that are supported for alerts, based on available sensor devices in the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="supportedMetrics")]
		public string[] SupportedMetrics { get; set; }
	}
	
	public class GetNetworkSensorAlertsCurrentOverviewByMetricReturnCounts
	{
		
		/// <summary>
		/// Number of sensors that are currently alerting due to an open door
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="door")]
		public System.Nullable<System.Int32> Door { get; set; }
		
		/// <summary>
		/// Number of sensors that are currently alerting due to humidity readings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="humidity")]
		public System.Nullable<System.Int32> Humidity { get; set; }
		
		/// <summary>
		/// Number of sensors that are currently alerting due to indoor air quality readings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="indoorAirQuality")]
		public System.Nullable<System.Int32> IndoorAirQuality { get; set; }
		
		/// <summary>
		/// Object containing the number of sensors that are currently alerting due to noise readings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noise")]
		public GetNetworkSensorAlertsCurrentOverviewByMetricReturnCountsNoise Noise { get; set; }
		
		/// <summary>
		/// Number of sensors that are currently alerting due to PM2.5 readings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pm25")]
		public System.Nullable<System.Int32> Pm25 { get; set; }
		
		/// <summary>
		/// Number of sensors that are currently alerting due to temperature readings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="temperature")]
		public System.Nullable<System.Int32> Temperature { get; set; }
		
		/// <summary>
		/// Number of sensors that are currently alerting due to TVOC readings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tvoc")]
		public System.Nullable<System.Int32> Tvoc { get; set; }
		
		/// <summary>
		/// Number of sensors that are currently alerting due to the presence of water
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="water")]
		public System.Nullable<System.Int32> Water { get; set; }
	}
	
	public class GetNetworkSensorAlertsCurrentOverviewByMetricReturnCountsNoise
	{
		
		/// <summary>
		/// Number of sensors that are currently alerting due to ambient noise readings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ambient")]
		public System.Nullable<System.Int32> Ambient { get; set; }
	}
	
	public class GetNetworkSensorAlertsOverviewByMetricReturn
	{
		
		/// <summary>
		/// Counts of sensor alerts over the timespan, by reading metric
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="counts")]
		public GetNetworkSensorAlertsOverviewByMetricReturnCounts Counts { get; set; }
		
		/// <summary>
		/// End of the timespan over which sensor alerts are counted
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTs")]
		public System.Nullable<System.DateTimeOffset> EndTs { get; set; }
		
		/// <summary>
		/// Start of the timespan over which sensor alerts are counted
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTs")]
		public System.Nullable<System.DateTimeOffset> StartTs { get; set; }
	}
	
	public class GetNetworkSensorAlertsOverviewByMetricReturnCounts
	{
		
		/// <summary>
		/// Number of sensor alerts that occurred due to an open door
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="door")]
		public System.Nullable<System.Int32> Door { get; set; }
		
		/// <summary>
		/// Number of sensor alerts that occurred due to humidity readings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="humidity")]
		public System.Nullable<System.Int32> Humidity { get; set; }
		
		/// <summary>
		/// Number of sensor alerts that occurred due to indoor air quality readings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="indoorAirQuality")]
		public System.Nullable<System.Int32> IndoorAirQuality { get; set; }
		
		/// <summary>
		/// Object containing the number of sensor alerts that occurred due to noise readings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noise")]
		public GetNetworkSensorAlertsOverviewByMetricReturnCountsNoise Noise { get; set; }
		
		/// <summary>
		/// Number of sensor alerts that occurred due to PM2.5 readings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pm25")]
		public System.Nullable<System.Int32> Pm25 { get; set; }
		
		/// <summary>
		/// Number of sensor alerts that occurred due to temperature readings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="temperature")]
		public System.Nullable<System.Int32> Temperature { get; set; }
		
		/// <summary>
		/// Number of sensor alerts that occurred due to TVOC readings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tvoc")]
		public System.Nullable<System.Int32> Tvoc { get; set; }
		
		/// <summary>
		/// Number of sensor alerts that occurred due to the presence of water
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="water")]
		public System.Nullable<System.Int32> Water { get; set; }
	}
	
	public class GetNetworkSensorAlertsOverviewByMetricReturnCountsNoise
	{
		
		/// <summary>
		/// Number of sensor alerts that occurred due to ambient noise readings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ambient")]
		public System.Nullable<System.Int32> Ambient { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfilesReturn
	{
		
		/// <summary>
		/// List of conditions that will cause the profile to send an alert.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="conditions")]
		public GetNetworkSensorAlertsProfilesReturnConditions[] GetNetworkSensorAlertsProfilesReturnConditions { get; set; }
		
		/// <summary>
		/// Name of the sensor alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// ID of the sensor alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profileId")]
		public string ProfileId { get; set; }
		
		/// <summary>
		/// List of recipients that will recieve the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recipients")]
		public GetNetworkSensorAlertsProfilesReturnRecipients Recipients { get; set; }
		
		/// <summary>
		/// The sensor schedule to use with the alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public GetNetworkSensorAlertsProfilesReturnSchedule Schedule { get; set; }
		
		/// <summary>
		/// List of device serials assigned to this sensor alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string[] Serials { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfilesReturnConditions
	{
		
		/// <summary>
		/// If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature and humidity thresholds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public System.Nullable<GetNetworkSensorAlertsProfilesReturnConditionsDirection> Direction { get; set; }
		
		/// <summary>
		/// Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, and 1 hour. Default is 0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<GetNetworkSensorAlertsProfilesReturnConditionsDuration> Duration { get; set; }
		
		/// <summary>
		/// The type of sensor metric that will be monitored for changes. Available metrics are door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metric")]
		public string Metric { get; set; }
		
		/// <summary>
		/// Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="threshold")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThreshold Threshold { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkSensorAlertsProfilesReturnConditionsDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		above = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		below = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkSensorAlertsProfilesReturnConditionsDuration
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_60 = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_120 = 120,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_180 = 180,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_240 = 240,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_300 = 300,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_600 = 600,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_900 = 900,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1800 = 1800,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3600 = 3600,
	}
	
	public class GetNetworkSensorAlertsProfilesReturnConditionsThreshold
	{
		
		/// <summary>
		/// Door open threshold. 'open' must be provided and set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="door")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdDoor Door { get; set; }
		
		/// <summary>
		/// Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="humidity")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidity Humidity { get; set; }
		
		/// <summary>
		/// Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="indoorAirQuality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdIndoorAirQuality IndoorAirQuality { get; set; }
		
		/// <summary>
		/// Noise threshold. 'ambient' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noise")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdNoise Noise { get; set; }
		
		/// <summary>
		/// PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pm25")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdPm25 Pm25 { get; set; }
		
		/// <summary>
		/// Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="temperature")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdTemperature Temperature { get; set; }
		
		/// <summary>
		/// TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tvoc")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdTvoc Tvoc { get; set; }
		
		/// <summary>
		/// Water detection threshold. 'present' must be provided and set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="water")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdWater Water { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfilesReturnConditionsThresholdDoor
	{
		
		/// <summary>
		/// Alerting threshold for a door open event. Must be set to true.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open")]
		public bool Open { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidity
	{
		
		/// <summary>
		/// Alerting threshold as a qualitative humidity level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public System.Nullable<GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality> Quality { get; set; }
		
		/// <summary>
		/// Alerting threshold in %RH.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relativePercentage")]
		public System.Nullable<System.Int32> RelativePercentage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		fair = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		good = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		inadequate = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		poor = 3,
	}
	
	public class GetNetworkSensorAlertsProfilesReturnConditionsThresholdIndoorAirQuality
	{
		
		/// <summary>
		/// Alerting threshold as a qualitative indoor air quality level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
		
		/// <summary>
		/// Alerting threshold as indoor air quality score.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="score")]
		public System.Nullable<System.Int32> Score { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfilesReturnConditionsThresholdNoise
	{
		
		/// <summary>
		/// Ambient noise threshold. One of 'level' or 'quality' must be provided.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ambient")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdNoiseAmbient Ambient { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfilesReturnConditionsThresholdNoiseAmbient
	{
		
		/// <summary>
		/// Alerting threshold as adjusted decibels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="level")]
		public System.Nullable<System.Int32> Level { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative ambient noise level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfilesReturnConditionsThresholdPm25
	{
		
		/// <summary>
		/// Alerting threshold as PM2.5 parts per million.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentration")]
		public System.Nullable<System.Int32> Concentration { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative PM2.5 level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfilesReturnConditionsThresholdTemperature
	{
		
		/// <summary>
		/// Alerting threshold in degrees Celsius.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="celsius")]
		public System.Nullable<System.Single> Celsius { get; set; }
		
		/// <summary>
		/// Alerting threshold in degrees Fahrenheit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fahrenheit")]
		public System.Nullable<System.Single> Fahrenheit { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative temperature level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfilesReturnConditionsThresholdTvoc
	{
		
		/// <summary>
		/// Alerting threshold as TVOC micrograms per cubic meter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentration")]
		public System.Nullable<System.Int32> Concentration { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative TVOC level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfilesReturnConditionsThresholdWater
	{
		
		/// <summary>
		/// Alerting threshold for a water detection event. Must be set to true.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="present")]
		public bool Present { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfilesReturnRecipients
	{
		
		/// <summary>
		/// A list of emails that will receive information about the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emails")]
		public string[] Emails { get; set; }
		
		/// <summary>
		/// A list of webhook endpoint IDs that will receive information about the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpServerIds")]
		public string[] HttpServerIds { get; set; }
		
		/// <summary>
		/// A list of SMS numbers that will receive information about the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smsNumbers")]
		public string[] SmsNumbers { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfilesReturnSchedule
	{
		
		/// <summary>
		/// ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the sensor schedule to use with the alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfilePostBody
	{
		
		/// <summary>
		/// List of conditions that will cause the profile to send an alert.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="conditions")]
		public CreateNetworkSensorAlertsProfilePostBodyConditions[] CreateNetworkSensorAlertsProfilePostBodyConditions { get; set; }
		
		/// <summary>
		/// Name of the sensor alert profile.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// List of recipients that will recieve the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recipients")]
		public CreateNetworkSensorAlertsProfilePostBodyRecipients Recipients { get; set; }
		
		/// <summary>
		/// The sensor schedule to use with the alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public CreateNetworkSensorAlertsProfilePostBodySchedule Schedule { get; set; }
		
		/// <summary>
		/// List of device serials assigned to this sensor alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string[] Serials { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfilePostBodyConditions
	{
		
		/// <summary>
		/// If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature and humidity thresholds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public GetNetworkSensorAlertsProfilesReturnConditionsDirection Direction { get; set; }
		
		/// <summary>
		/// Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, and 1 hour. Default is 0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<CreateNetworkSensorAlertsProfilePostBodyConditionsDuration> Duration { get; set; }
		
		/// <summary>
		/// The type of sensor metric that will be monitored for changes. Available metrics are door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metric")]
		public string Metric { get; set; }
		
		/// <summary>
		/// Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="threshold")]
		public CreateNetworkSensorAlertsProfilePostBodyConditionsThreshold Threshold { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkSensorAlertsProfilePostBodyConditionsDuration
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_60 = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_120 = 120,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_180 = 180,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_240 = 240,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_300 = 300,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_600 = 600,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_900 = 900,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1800 = 1800,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3600 = 3600,
	}
	
	public class CreateNetworkSensorAlertsProfilePostBodyConditionsThreshold
	{
		
		/// <summary>
		/// Door open threshold. 'open' must be provided and set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="door")]
		public CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdDoor Door { get; set; }
		
		/// <summary>
		/// Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="humidity")]
		public CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdHumidity Humidity { get; set; }
		
		/// <summary>
		/// Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="indoorAirQuality")]
		public CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdIndoorAirQuality IndoorAirQuality { get; set; }
		
		/// <summary>
		/// Noise threshold. 'ambient' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noise")]
		public CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdNoise Noise { get; set; }
		
		/// <summary>
		/// PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pm25")]
		public CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdPm25 Pm25 { get; set; }
		
		/// <summary>
		/// Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="temperature")]
		public CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdTemperature Temperature { get; set; }
		
		/// <summary>
		/// TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tvoc")]
		public CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdTvoc Tvoc { get; set; }
		
		/// <summary>
		/// Water detection threshold. 'present' must be provided and set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="water")]
		public CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdWater Water { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdDoor
	{
		
		/// <summary>
		/// Alerting threshold for a door open event. Must be set to true.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open")]
		public bool Open { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdHumidity
	{
		
		/// <summary>
		/// Alerting threshold as a qualitative humidity level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
		
		/// <summary>
		/// Alerting threshold in %RH.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relativePercentage")]
		public System.Nullable<System.Int32> RelativePercentage { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdIndoorAirQuality
	{
		
		/// <summary>
		/// Alerting threshold as a qualitative indoor air quality level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
		
		/// <summary>
		/// Alerting threshold as indoor air quality score.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="score")]
		public System.Nullable<System.Int32> Score { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdNoise
	{
		
		/// <summary>
		/// Ambient noise threshold. One of 'level' or 'quality' must be provided.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ambient")]
		public CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdNoiseAmbient Ambient { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdNoiseAmbient
	{
		
		/// <summary>
		/// Alerting threshold as adjusted decibels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="level")]
		public System.Nullable<System.Int32> Level { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative ambient noise level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdPm25
	{
		
		/// <summary>
		/// Alerting threshold as PM2.5 parts per million.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentration")]
		public System.Nullable<System.Int32> Concentration { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative PM2.5 level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdTemperature
	{
		
		/// <summary>
		/// Alerting threshold in degrees Celsius.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="celsius")]
		public System.Nullable<System.Single> Celsius { get; set; }
		
		/// <summary>
		/// Alerting threshold in degrees Fahrenheit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fahrenheit")]
		public System.Nullable<System.Single> Fahrenheit { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative temperature level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdTvoc
	{
		
		/// <summary>
		/// Alerting threshold as TVOC micrograms per cubic meter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentration")]
		public System.Nullable<System.Int32> Concentration { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative TVOC level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfilePostBodyConditionsThresholdWater
	{
		
		/// <summary>
		/// Alerting threshold for a water detection event. Must be set to true.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="present")]
		public bool Present { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfilePostBodyRecipients
	{
		
		/// <summary>
		/// A list of emails that will receive information about the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emails")]
		public string[] Emails { get; set; }
		
		/// <summary>
		/// A list of webhook endpoint IDs that will receive information about the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpServerIds")]
		public string[] HttpServerIds { get; set; }
		
		/// <summary>
		/// A list of SMS numbers that will receive information about the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smsNumbers")]
		public string[] SmsNumbers { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfilePostBodySchedule
	{
		
		/// <summary>
		/// ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfileReturn
	{
		
		/// <summary>
		/// List of conditions that will cause the profile to send an alert.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="conditions")]
		public CreateNetworkSensorAlertsProfileReturnConditions[] CreateNetworkSensorAlertsProfileReturnConditions { get; set; }
		
		/// <summary>
		/// Name of the sensor alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// ID of the sensor alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profileId")]
		public string ProfileId { get; set; }
		
		/// <summary>
		/// List of recipients that will recieve the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recipients")]
		public CreateNetworkSensorAlertsProfileReturnRecipients Recipients { get; set; }
		
		/// <summary>
		/// The sensor schedule to use with the alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public CreateNetworkSensorAlertsProfileReturnSchedule Schedule { get; set; }
		
		/// <summary>
		/// List of device serials assigned to this sensor alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string[] Serials { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfileReturnConditions
	{
		
		/// <summary>
		/// If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature and humidity thresholds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public GetNetworkSensorAlertsProfilesReturnConditionsDirection Direction { get; set; }
		
		/// <summary>
		/// Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, and 1 hour. Default is 0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<CreateNetworkSensorAlertsProfileReturnConditionsDuration> Duration { get; set; }
		
		/// <summary>
		/// The type of sensor metric that will be monitored for changes. Available metrics are door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metric")]
		public string Metric { get; set; }
		
		/// <summary>
		/// Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="threshold")]
		public CreateNetworkSensorAlertsProfileReturnConditionsThreshold Threshold { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkSensorAlertsProfileReturnConditionsDuration
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_60 = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_120 = 120,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_180 = 180,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_240 = 240,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_300 = 300,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_600 = 600,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_900 = 900,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1800 = 1800,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3600 = 3600,
	}
	
	public class CreateNetworkSensorAlertsProfileReturnConditionsThreshold
	{
		
		/// <summary>
		/// Door open threshold. 'open' must be provided and set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="door")]
		public CreateNetworkSensorAlertsProfileReturnConditionsThresholdDoor Door { get; set; }
		
		/// <summary>
		/// Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="humidity")]
		public CreateNetworkSensorAlertsProfileReturnConditionsThresholdHumidity Humidity { get; set; }
		
		/// <summary>
		/// Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="indoorAirQuality")]
		public CreateNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQuality IndoorAirQuality { get; set; }
		
		/// <summary>
		/// Noise threshold. 'ambient' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noise")]
		public CreateNetworkSensorAlertsProfileReturnConditionsThresholdNoise Noise { get; set; }
		
		/// <summary>
		/// PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pm25")]
		public CreateNetworkSensorAlertsProfileReturnConditionsThresholdPm25 Pm25 { get; set; }
		
		/// <summary>
		/// Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="temperature")]
		public CreateNetworkSensorAlertsProfileReturnConditionsThresholdTemperature Temperature { get; set; }
		
		/// <summary>
		/// TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tvoc")]
		public CreateNetworkSensorAlertsProfileReturnConditionsThresholdTvoc Tvoc { get; set; }
		
		/// <summary>
		/// Water detection threshold. 'present' must be provided and set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="water")]
		public CreateNetworkSensorAlertsProfileReturnConditionsThresholdWater Water { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfileReturnConditionsThresholdDoor
	{
		
		/// <summary>
		/// Alerting threshold for a door open event. Must be set to true.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open")]
		public bool Open { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfileReturnConditionsThresholdHumidity
	{
		
		/// <summary>
		/// Alerting threshold as a qualitative humidity level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
		
		/// <summary>
		/// Alerting threshold in %RH.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relativePercentage")]
		public System.Nullable<System.Int32> RelativePercentage { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQuality
	{
		
		/// <summary>
		/// Alerting threshold as a qualitative indoor air quality level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
		
		/// <summary>
		/// Alerting threshold as indoor air quality score.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="score")]
		public System.Nullable<System.Int32> Score { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfileReturnConditionsThresholdNoise
	{
		
		/// <summary>
		/// Ambient noise threshold. One of 'level' or 'quality' must be provided.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ambient")]
		public CreateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbient Ambient { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbient
	{
		
		/// <summary>
		/// Alerting threshold as adjusted decibels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="level")]
		public System.Nullable<System.Int32> Level { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative ambient noise level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfileReturnConditionsThresholdPm25
	{
		
		/// <summary>
		/// Alerting threshold as PM2.5 parts per million.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentration")]
		public System.Nullable<System.Int32> Concentration { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative PM2.5 level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfileReturnConditionsThresholdTemperature
	{
		
		/// <summary>
		/// Alerting threshold in degrees Celsius.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="celsius")]
		public System.Nullable<System.Single> Celsius { get; set; }
		
		/// <summary>
		/// Alerting threshold in degrees Fahrenheit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fahrenheit")]
		public System.Nullable<System.Single> Fahrenheit { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative temperature level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfileReturnConditionsThresholdTvoc
	{
		
		/// <summary>
		/// Alerting threshold as TVOC micrograms per cubic meter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentration")]
		public System.Nullable<System.Int32> Concentration { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative TVOC level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfileReturnConditionsThresholdWater
	{
		
		/// <summary>
		/// Alerting threshold for a water detection event. Must be set to true.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="present")]
		public bool Present { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfileReturnRecipients
	{
		
		/// <summary>
		/// A list of emails that will receive information about the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emails")]
		public string[] Emails { get; set; }
		
		/// <summary>
		/// A list of webhook endpoint IDs that will receive information about the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpServerIds")]
		public string[] HttpServerIds { get; set; }
		
		/// <summary>
		/// A list of SMS numbers that will receive information about the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smsNumbers")]
		public string[] SmsNumbers { get; set; }
	}
	
	public class CreateNetworkSensorAlertsProfileReturnSchedule
	{
		
		/// <summary>
		/// ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the sensor schedule to use with the alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfileReturn
	{
		
		/// <summary>
		/// List of conditions that will cause the profile to send an alert.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="conditions")]
		public GetNetworkSensorAlertsProfileReturnConditions[] GetNetworkSensorAlertsProfileReturnConditions { get; set; }
		
		/// <summary>
		/// Name of the sensor alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// ID of the sensor alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profileId")]
		public string ProfileId { get; set; }
		
		/// <summary>
		/// List of recipients that will recieve the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recipients")]
		public GetNetworkSensorAlertsProfileReturnRecipients Recipients { get; set; }
		
		/// <summary>
		/// The sensor schedule to use with the alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public GetNetworkSensorAlertsProfileReturnSchedule Schedule { get; set; }
		
		/// <summary>
		/// List of device serials assigned to this sensor alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string[] Serials { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfileReturnConditions
	{
		
		/// <summary>
		/// If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature and humidity thresholds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public GetNetworkSensorAlertsProfilesReturnConditionsDirection Direction { get; set; }
		
		/// <summary>
		/// Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, and 1 hour. Default is 0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<GetNetworkSensorAlertsProfileReturnConditionsDuration> Duration { get; set; }
		
		/// <summary>
		/// The type of sensor metric that will be monitored for changes. Available metrics are door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metric")]
		public string Metric { get; set; }
		
		/// <summary>
		/// Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="threshold")]
		public GetNetworkSensorAlertsProfileReturnConditionsThreshold Threshold { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkSensorAlertsProfileReturnConditionsDuration
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_60 = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_120 = 120,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_180 = 180,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_240 = 240,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_300 = 300,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_600 = 600,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_900 = 900,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1800 = 1800,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3600 = 3600,
	}
	
	public class GetNetworkSensorAlertsProfileReturnConditionsThreshold
	{
		
		/// <summary>
		/// Door open threshold. 'open' must be provided and set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="door")]
		public GetNetworkSensorAlertsProfileReturnConditionsThresholdDoor Door { get; set; }
		
		/// <summary>
		/// Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="humidity")]
		public GetNetworkSensorAlertsProfileReturnConditionsThresholdHumidity Humidity { get; set; }
		
		/// <summary>
		/// Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="indoorAirQuality")]
		public GetNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQuality IndoorAirQuality { get; set; }
		
		/// <summary>
		/// Noise threshold. 'ambient' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noise")]
		public GetNetworkSensorAlertsProfileReturnConditionsThresholdNoise Noise { get; set; }
		
		/// <summary>
		/// PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pm25")]
		public GetNetworkSensorAlertsProfileReturnConditionsThresholdPm25 Pm25 { get; set; }
		
		/// <summary>
		/// Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="temperature")]
		public GetNetworkSensorAlertsProfileReturnConditionsThresholdTemperature Temperature { get; set; }
		
		/// <summary>
		/// TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tvoc")]
		public GetNetworkSensorAlertsProfileReturnConditionsThresholdTvoc Tvoc { get; set; }
		
		/// <summary>
		/// Water detection threshold. 'present' must be provided and set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="water")]
		public GetNetworkSensorAlertsProfileReturnConditionsThresholdWater Water { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfileReturnConditionsThresholdDoor
	{
		
		/// <summary>
		/// Alerting threshold for a door open event. Must be set to true.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open")]
		public bool Open { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfileReturnConditionsThresholdHumidity
	{
		
		/// <summary>
		/// Alerting threshold as a qualitative humidity level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
		
		/// <summary>
		/// Alerting threshold in %RH.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relativePercentage")]
		public System.Nullable<System.Int32> RelativePercentage { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQuality
	{
		
		/// <summary>
		/// Alerting threshold as a qualitative indoor air quality level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
		
		/// <summary>
		/// Alerting threshold as indoor air quality score.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="score")]
		public System.Nullable<System.Int32> Score { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfileReturnConditionsThresholdNoise
	{
		
		/// <summary>
		/// Ambient noise threshold. One of 'level' or 'quality' must be provided.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ambient")]
		public GetNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbient Ambient { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbient
	{
		
		/// <summary>
		/// Alerting threshold as adjusted decibels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="level")]
		public System.Nullable<System.Int32> Level { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative ambient noise level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfileReturnConditionsThresholdPm25
	{
		
		/// <summary>
		/// Alerting threshold as PM2.5 parts per million.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentration")]
		public System.Nullable<System.Int32> Concentration { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative PM2.5 level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfileReturnConditionsThresholdTemperature
	{
		
		/// <summary>
		/// Alerting threshold in degrees Celsius.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="celsius")]
		public System.Nullable<System.Single> Celsius { get; set; }
		
		/// <summary>
		/// Alerting threshold in degrees Fahrenheit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fahrenheit")]
		public System.Nullable<System.Single> Fahrenheit { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative temperature level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfileReturnConditionsThresholdTvoc
	{
		
		/// <summary>
		/// Alerting threshold as TVOC micrograms per cubic meter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentration")]
		public System.Nullable<System.Int32> Concentration { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative TVOC level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfileReturnConditionsThresholdWater
	{
		
		/// <summary>
		/// Alerting threshold for a water detection event. Must be set to true.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="present")]
		public bool Present { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfileReturnRecipients
	{
		
		/// <summary>
		/// A list of emails that will receive information about the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emails")]
		public string[] Emails { get; set; }
		
		/// <summary>
		/// A list of webhook endpoint IDs that will receive information about the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpServerIds")]
		public string[] HttpServerIds { get; set; }
		
		/// <summary>
		/// A list of SMS numbers that will receive information about the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smsNumbers")]
		public string[] SmsNumbers { get; set; }
	}
	
	public class GetNetworkSensorAlertsProfileReturnSchedule
	{
		
		/// <summary>
		/// ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the sensor schedule to use with the alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfilePutBody
	{
		
		/// <summary>
		/// List of conditions that will cause the profile to send an alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="conditions")]
		public UpdateNetworkSensorAlertsProfilePutBodyConditions[] UpdateNetworkSensorAlertsProfilePutBodyConditions { get; set; }
		
		/// <summary>
		/// Name of the sensor alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// List of recipients that will recieve the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recipients")]
		public UpdateNetworkSensorAlertsProfilePutBodyRecipients Recipients { get; set; }
		
		/// <summary>
		/// The sensor schedule to use with the alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public UpdateNetworkSensorAlertsProfilePutBodySchedule Schedule { get; set; }
		
		/// <summary>
		/// List of device serials assigned to this sensor alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string[] Serials { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfilePutBodyConditions
	{
		
		/// <summary>
		/// If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature and humidity thresholds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public GetNetworkSensorAlertsProfilesReturnConditionsDirection Direction { get; set; }
		
		/// <summary>
		/// Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, and 1 hour. Default is 0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<UpdateNetworkSensorAlertsProfilePutBodyConditionsDuration> Duration { get; set; }
		
		/// <summary>
		/// The type of sensor metric that will be monitored for changes. Available metrics are door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metric")]
		public string Metric { get; set; }
		
		/// <summary>
		/// Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="threshold")]
		public UpdateNetworkSensorAlertsProfilePutBodyConditionsThreshold Threshold { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSensorAlertsProfilePutBodyConditionsDuration
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_60 = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_120 = 120,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_180 = 180,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_240 = 240,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_300 = 300,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_600 = 600,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_900 = 900,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1800 = 1800,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3600 = 3600,
	}
	
	public class UpdateNetworkSensorAlertsProfilePutBodyConditionsThreshold
	{
		
		/// <summary>
		/// Door open threshold. 'open' must be provided and set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="door")]
		public UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdDoor Door { get; set; }
		
		/// <summary>
		/// Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="humidity")]
		public UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdHumidity Humidity { get; set; }
		
		/// <summary>
		/// Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="indoorAirQuality")]
		public UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdIndoorAirQuality IndoorAirQuality { get; set; }
		
		/// <summary>
		/// Noise threshold. 'ambient' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noise")]
		public UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdNoise Noise { get; set; }
		
		/// <summary>
		/// PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pm25")]
		public UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdPm25 Pm25 { get; set; }
		
		/// <summary>
		/// Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="temperature")]
		public UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdTemperature Temperature { get; set; }
		
		/// <summary>
		/// TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tvoc")]
		public UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdTvoc Tvoc { get; set; }
		
		/// <summary>
		/// Water detection threshold. 'present' must be provided and set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="water")]
		public UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdWater Water { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdDoor
	{
		
		/// <summary>
		/// Alerting threshold for a door open event. Must be set to true.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open")]
		public bool Open { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdHumidity
	{
		
		/// <summary>
		/// Alerting threshold as a qualitative humidity level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
		
		/// <summary>
		/// Alerting threshold in %RH.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relativePercentage")]
		public System.Nullable<System.Int32> RelativePercentage { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdIndoorAirQuality
	{
		
		/// <summary>
		/// Alerting threshold as a qualitative indoor air quality level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
		
		/// <summary>
		/// Alerting threshold as indoor air quality score.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="score")]
		public System.Nullable<System.Int32> Score { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdNoise
	{
		
		/// <summary>
		/// Ambient noise threshold. One of 'level' or 'quality' must be provided.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ambient")]
		public UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdNoiseAmbient Ambient { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdNoiseAmbient
	{
		
		/// <summary>
		/// Alerting threshold as adjusted decibels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="level")]
		public System.Nullable<System.Int32> Level { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative ambient noise level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdPm25
	{
		
		/// <summary>
		/// Alerting threshold as PM2.5 parts per million.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentration")]
		public System.Nullable<System.Int32> Concentration { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative PM2.5 level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdTemperature
	{
		
		/// <summary>
		/// Alerting threshold in degrees Celsius.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="celsius")]
		public System.Nullable<System.Single> Celsius { get; set; }
		
		/// <summary>
		/// Alerting threshold in degrees Fahrenheit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fahrenheit")]
		public System.Nullable<System.Single> Fahrenheit { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative temperature level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdTvoc
	{
		
		/// <summary>
		/// Alerting threshold as TVOC micrograms per cubic meter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentration")]
		public System.Nullable<System.Int32> Concentration { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative TVOC level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfilePutBodyConditionsThresholdWater
	{
		
		/// <summary>
		/// Alerting threshold for a water detection event. Must be set to true.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="present")]
		public bool Present { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfilePutBodyRecipients
	{
		
		/// <summary>
		/// A list of emails that will receive information about the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emails")]
		public string[] Emails { get; set; }
		
		/// <summary>
		/// A list of webhook endpoint IDs that will receive information about the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpServerIds")]
		public string[] HttpServerIds { get; set; }
		
		/// <summary>
		/// A list of SMS numbers that will receive information about the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smsNumbers")]
		public string[] SmsNumbers { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfilePutBodySchedule
	{
		
		/// <summary>
		/// ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfileReturn
	{
		
		/// <summary>
		/// List of conditions that will cause the profile to send an alert.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="conditions")]
		public UpdateNetworkSensorAlertsProfileReturnConditions[] UpdateNetworkSensorAlertsProfileReturnConditions { get; set; }
		
		/// <summary>
		/// Name of the sensor alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// ID of the sensor alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profileId")]
		public string ProfileId { get; set; }
		
		/// <summary>
		/// List of recipients that will recieve the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recipients")]
		public UpdateNetworkSensorAlertsProfileReturnRecipients Recipients { get; set; }
		
		/// <summary>
		/// The sensor schedule to use with the alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public UpdateNetworkSensorAlertsProfileReturnSchedule Schedule { get; set; }
		
		/// <summary>
		/// List of device serials assigned to this sensor alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string[] Serials { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfileReturnConditions
	{
		
		/// <summary>
		/// If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature and humidity thresholds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public GetNetworkSensorAlertsProfilesReturnConditionsDirection Direction { get; set; }
		
		/// <summary>
		/// Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, and 1 hour. Default is 0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<UpdateNetworkSensorAlertsProfileReturnConditionsDuration> Duration { get; set; }
		
		/// <summary>
		/// The type of sensor metric that will be monitored for changes. Available metrics are door, humidity, indoorAirQuality, noise, pm25, temperature, tvoc, and water.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metric")]
		public string Metric { get; set; }
		
		/// <summary>
		/// Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="threshold")]
		public UpdateNetworkSensorAlertsProfileReturnConditionsThreshold Threshold { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSensorAlertsProfileReturnConditionsDuration
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_60 = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_120 = 120,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_180 = 180,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_240 = 240,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_300 = 300,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_600 = 600,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_900 = 900,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1800 = 1800,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3600 = 3600,
	}
	
	public class UpdateNetworkSensorAlertsProfileReturnConditionsThreshold
	{
		
		/// <summary>
		/// Door open threshold. 'open' must be provided and set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="door")]
		public UpdateNetworkSensorAlertsProfileReturnConditionsThresholdDoor Door { get; set; }
		
		/// <summary>
		/// Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="humidity")]
		public UpdateNetworkSensorAlertsProfileReturnConditionsThresholdHumidity Humidity { get; set; }
		
		/// <summary>
		/// Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="indoorAirQuality")]
		public UpdateNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQuality IndoorAirQuality { get; set; }
		
		/// <summary>
		/// Noise threshold. 'ambient' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noise")]
		public UpdateNetworkSensorAlertsProfileReturnConditionsThresholdNoise Noise { get; set; }
		
		/// <summary>
		/// PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pm25")]
		public UpdateNetworkSensorAlertsProfileReturnConditionsThresholdPm25 Pm25 { get; set; }
		
		/// <summary>
		/// Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="temperature")]
		public UpdateNetworkSensorAlertsProfileReturnConditionsThresholdTemperature Temperature { get; set; }
		
		/// <summary>
		/// TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tvoc")]
		public UpdateNetworkSensorAlertsProfileReturnConditionsThresholdTvoc Tvoc { get; set; }
		
		/// <summary>
		/// Water detection threshold. 'present' must be provided and set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="water")]
		public UpdateNetworkSensorAlertsProfileReturnConditionsThresholdWater Water { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfileReturnConditionsThresholdDoor
	{
		
		/// <summary>
		/// Alerting threshold for a door open event. Must be set to true.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="open")]
		public bool Open { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfileReturnConditionsThresholdHumidity
	{
		
		/// <summary>
		/// Alerting threshold as a qualitative humidity level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
		
		/// <summary>
		/// Alerting threshold in %RH.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relativePercentage")]
		public System.Nullable<System.Int32> RelativePercentage { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfileReturnConditionsThresholdIndoorAirQuality
	{
		
		/// <summary>
		/// Alerting threshold as a qualitative indoor air quality level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
		
		/// <summary>
		/// Alerting threshold as indoor air quality score.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="score")]
		public System.Nullable<System.Int32> Score { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfileReturnConditionsThresholdNoise
	{
		
		/// <summary>
		/// Ambient noise threshold. One of 'level' or 'quality' must be provided.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ambient")]
		public UpdateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbient Ambient { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfileReturnConditionsThresholdNoiseAmbient
	{
		
		/// <summary>
		/// Alerting threshold as adjusted decibels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="level")]
		public System.Nullable<System.Int32> Level { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative ambient noise level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfileReturnConditionsThresholdPm25
	{
		
		/// <summary>
		/// Alerting threshold as PM2.5 parts per million.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentration")]
		public System.Nullable<System.Int32> Concentration { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative PM2.5 level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfileReturnConditionsThresholdTemperature
	{
		
		/// <summary>
		/// Alerting threshold in degrees Celsius.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="celsius")]
		public System.Nullable<System.Single> Celsius { get; set; }
		
		/// <summary>
		/// Alerting threshold in degrees Fahrenheit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fahrenheit")]
		public System.Nullable<System.Single> Fahrenheit { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative temperature level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfileReturnConditionsThresholdTvoc
	{
		
		/// <summary>
		/// Alerting threshold as TVOC micrograms per cubic meter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentration")]
		public System.Nullable<System.Int32> Concentration { get; set; }
		
		/// <summary>
		/// Alerting threshold as a qualitative TVOC level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quality")]
		public GetNetworkSensorAlertsProfilesReturnConditionsThresholdHumidityQuality Quality { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfileReturnConditionsThresholdWater
	{
		
		/// <summary>
		/// Alerting threshold for a water detection event. Must be set to true.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="present")]
		public bool Present { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfileReturnRecipients
	{
		
		/// <summary>
		/// A list of emails that will receive information about the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emails")]
		public string[] Emails { get; set; }
		
		/// <summary>
		/// A list of webhook endpoint IDs that will receive information about the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpServerIds")]
		public string[] HttpServerIds { get; set; }
		
		/// <summary>
		/// A list of SMS numbers that will receive information about the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smsNumbers")]
		public string[] SmsNumbers { get; set; }
	}
	
	public class UpdateNetworkSensorAlertsProfileReturnSchedule
	{
		
		/// <summary>
		/// ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the sensor schedule to use with the alert profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetNetworkSensorRelationshipsReturn
	{
		
		/// <summary>
		/// A sensor or gateway device in the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="device")]
		public GetNetworkSensorRelationshipsReturnDevice Device { get; set; }
		
		/// <summary>
		/// An object describing the relationships defined between the device and other devices
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relationships")]
		public GetNetworkSensorRelationshipsReturnRelationships Relationships { get; set; }
	}
	
	public class GetNetworkSensorRelationshipsReturnDevice
	{
		
		/// <summary>
		/// The name of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The product type of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productType")]
		public GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesProductType ProductType { get; set; }
		
		/// <summary>
		/// The serial of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class GetNetworkSensorRelationshipsReturnRelationships
	{
		
		/// <summary>
		/// A role defined between an MT sensor and an MV camera that adds the camera's livestream to the sensor's details page. Snapshots from the camera will also appear in alert notifications that the sensor triggers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="livestream")]
		public GetNetworkSensorRelationshipsReturnRelationshipsLivestream Livestream { get; set; }
	}
	
	public class GetNetworkSensorRelationshipsReturnRelationshipsLivestream
	{
		
		/// <summary>
		/// An array of the related devices for the role
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relatedDevices")]
		public GetNetworkSensorRelationshipsReturnRelationshipsLivestreamRelatedDevices[] GetNetworkSensorRelationshipsReturnRelationshipsLivestreamRelatedDevices { get; set; }
	}
	
	public class GetNetworkSensorRelationshipsReturnRelationshipsLivestreamRelatedDevices
	{
		
		/// <summary>
		/// The product type of the related device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productType")]
		public GetDeviceSensorRelationshipsReturnLivestreamRelatedDevicesProductType ProductType { get; set; }
		
		/// <summary>
		/// The serial of the related device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class GetNetworkSettingsReturn
	{
		
		/// <summary>
		/// Privacy settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientPrivacy")]
		public GetNetworkSettingsReturnClientPrivacy ClientPrivacy { get; set; }
		
		/// <summary>
		/// A hash of FIPS options applied to the Network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fips")]
		public GetNetworkSettingsReturnFips Fips { get; set; }
		
		/// <summary>
		/// A hash of Local Status page(s)' authentication options applied to the Network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localStatusPage")]
		public GetNetworkSettingsReturnLocalStatusPage LocalStatusPage { get; set; }
		
		/// <summary>
		/// Enables / disables the local device status pages (<a target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a target='_blank' href='http://switch.meraki.com/'>switch.meraki.com, </a><a target='_blank' href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional (defaults to false)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localStatusPageEnabled")]
		public System.Nullable<System.Boolean> LocalStatusPageEnabled { get; set; }
		
		/// <summary>
		/// A hash of Named VLANs options applied to the Network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namedVlans")]
		public GetNetworkSettingsReturnNamedVlans NamedVlans { get; set; }
		
		/// <summary>
		/// Enables / disables access to the device status page (<a target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set if localStatusPageEnabled is set to true
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remoteStatusPageEnabled")]
		public System.Nullable<System.Boolean> RemoteStatusPageEnabled { get; set; }
		
		/// <summary>
		/// A hash of SecureConnect options applied to the Network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="securePort")]
		public GetNetworkSettingsReturnSecurePort SecurePort { get; set; }
	}
	
	public class GetNetworkSettingsReturnClientPrivacy
	{
		
		/// <summary>
		/// The date to expire the data before
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expireDataBefore")]
		public System.Nullable<System.DateTimeOffset> ExpireDataBefore { get; set; }
		
		/// <summary>
		/// The number of days, weeks, or months in Epoch time to expire the data before
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expireDataOlderThan")]
		public System.Nullable<System.Int32> ExpireDataOlderThan { get; set; }
	}
	
	public class GetNetworkSettingsReturnFips
	{
		
		/// <summary>
		/// Enables / disables FIPS on the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class GetNetworkSettingsReturnLocalStatusPage
	{
		
		/// <summary>
		/// A hash of Local Status page(s)' authentication options applied to the Network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public GetNetworkSettingsReturnLocalStatusPageAuthentication Authentication { get; set; }
	}
	
	public class GetNetworkSettingsReturnLocalStatusPageAuthentication
	{
		
		/// <summary>
		/// Enables / disables the authentication on Local Status page(s).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The username used for Local Status Page(s).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	public class GetNetworkSettingsReturnNamedVlans
	{
		
		/// <summary>
		/// Enables / disables Named VLANs on the Network.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
	}
	
	public class GetNetworkSettingsReturnSecurePort
	{
		
		/// <summary>
		/// Enables / disables SecureConnect on the network. Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateNetworkSettingsPutBody
	{
		
		/// <summary>
		/// A hash of Local Status page(s)' authentication options applied to the Network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localStatusPage")]
		public UpdateNetworkSettingsPutBodyLocalStatusPage LocalStatusPage { get; set; }
		
		/// <summary>
		/// Enables / disables the local device status pages (<a target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a target='_blank' href='http://switch.meraki.com/'>switch.meraki.com, </a><a target='_blank' href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional (defaults to false)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localStatusPageEnabled")]
		public System.Nullable<System.Boolean> LocalStatusPageEnabled { get; set; }
		
		/// <summary>
		/// Enables / disables access to the device status page (<a target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set if localStatusPageEnabled is set to true
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remoteStatusPageEnabled")]
		public System.Nullable<System.Boolean> RemoteStatusPageEnabled { get; set; }
		
		/// <summary>
		/// A hash of SecureConnect options applied to the Network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="securePort")]
		public UpdateNetworkSettingsPutBodySecurePort SecurePort { get; set; }
	}
	
	public class UpdateNetworkSettingsPutBodyLocalStatusPage
	{
		
		/// <summary>
		/// A hash of Local Status page(s)' authentication options applied to the Network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public UpdateNetworkSettingsPutBodyLocalStatusPageAuthentication Authentication { get; set; }
	}
	
	public class UpdateNetworkSettingsPutBodyLocalStatusPageAuthentication
	{
		
		/// <summary>
		/// Enables / disables the authentication on Local Status page(s).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The password used for Local Status Page(s). Set this to null to clear the password.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
	}
	
	public class UpdateNetworkSettingsPutBodySecurePort
	{
		
		/// <summary>
		/// Enables / disables SecureConnect on the network. Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateNetworkSettingsReturn
	{
		
		/// <summary>
		/// Privacy settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientPrivacy")]
		public UpdateNetworkSettingsReturnClientPrivacy ClientPrivacy { get; set; }
		
		/// <summary>
		/// A hash of FIPS options applied to the Network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fips")]
		public UpdateNetworkSettingsReturnFips Fips { get; set; }
		
		/// <summary>
		/// A hash of Local Status page(s)' authentication options applied to the Network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localStatusPage")]
		public UpdateNetworkSettingsReturnLocalStatusPage LocalStatusPage { get; set; }
		
		/// <summary>
		/// Enables / disables the local device status pages (<a target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a target='_blank' href='http://switch.meraki.com/'>switch.meraki.com, </a><a target='_blank' href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional (defaults to false)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localStatusPageEnabled")]
		public System.Nullable<System.Boolean> LocalStatusPageEnabled { get; set; }
		
		/// <summary>
		/// A hash of Named VLANs options applied to the Network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namedVlans")]
		public UpdateNetworkSettingsReturnNamedVlans NamedVlans { get; set; }
		
		/// <summary>
		/// Enables / disables access to the device status page (<a target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set if localStatusPageEnabled is set to true
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remoteStatusPageEnabled")]
		public System.Nullable<System.Boolean> RemoteStatusPageEnabled { get; set; }
		
		/// <summary>
		/// A hash of SecureConnect options applied to the Network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="securePort")]
		public UpdateNetworkSettingsReturnSecurePort SecurePort { get; set; }
	}
	
	public class UpdateNetworkSettingsReturnClientPrivacy
	{
		
		/// <summary>
		/// The date to expire the data before
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expireDataBefore")]
		public System.Nullable<System.DateTimeOffset> ExpireDataBefore { get; set; }
		
		/// <summary>
		/// The number of days, weeks, or months in Epoch time to expire the data before
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expireDataOlderThan")]
		public System.Nullable<System.Int32> ExpireDataOlderThan { get; set; }
	}
	
	public class UpdateNetworkSettingsReturnFips
	{
		
		/// <summary>
		/// Enables / disables FIPS on the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateNetworkSettingsReturnLocalStatusPage
	{
		
		/// <summary>
		/// A hash of Local Status page(s)' authentication options applied to the Network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public UpdateNetworkSettingsReturnLocalStatusPageAuthentication Authentication { get; set; }
	}
	
	public class UpdateNetworkSettingsReturnLocalStatusPageAuthentication
	{
		
		/// <summary>
		/// Enables / disables the authentication on Local Status page(s).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The username used for Local Status Page(s).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	public class UpdateNetworkSettingsReturnNamedVlans
	{
		
		/// <summary>
		/// Enables / disables Named VLANs on the Network.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
	}
	
	public class UpdateNetworkSettingsReturnSecurePort
	{
		
		/// <summary>
		/// Enables / disables SecureConnect on the network. Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class CreateNetworkSmBypassActivationLockAttemptPostBody
	{
		
		/// <summary>
		/// The ids of the devices to attempt activation lock bypass.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
	}
	
	public class GetNetworkSmDevicesReturn
	{
		
		/// <summary>
		/// The Meraki Id of the device record.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The IP address of the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// The name of the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Notes associated with the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// The name of the device OS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osName")]
		public string OsName { get; set; }
		
		/// <summary>
		/// The device serial.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// The device serial number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serialNumber")]
		public string SerialNumber { get; set; }
		
		/// <summary>
		/// The name of the SSID the device was last connected to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssid")]
		public string Ssid { get; set; }
		
		/// <summary>
		/// The device model.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="systemModel")]
		public string SystemModel { get; set; }
		
		/// <summary>
		/// An array of tags associated with the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// The UUID of the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uuid")]
		public string Uuid { get; set; }
		
		/// <summary>
		/// The MAC of the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiMac")]
		public string WifiMac { get; set; }
	}
	
	public class CheckinNetworkSmDevicesPostBody
	{
		
		/// <summary>
		/// The ids of the devices to be checked-in.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
		
		/// <summary>
		/// The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be checked-in.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scope")]
		public string[] Scope { get; set; }
		
		/// <summary>
		/// The serials of the devices to be checked-in.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string[] Serials { get; set; }
		
		/// <summary>
		/// The wifiMacs of the devices to be checked-in.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiMacs")]
		public string[] WifiMacs { get; set; }
	}
	
	public class CheckinNetworkSmDevicesReturn
	{
		
		/// <summary>
		/// The Meraki Ids of the set of devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
	}
	
	public class UpdateNetworkSmDevicesFieldsPutBody
	{
		
		/// <summary>
		/// The new fields of the device. Each field of this object is optional.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deviceFields")]
		public UpdateNetworkSmDevicesFieldsPutBodyDeviceFields DeviceFields { get; set; }
		
		/// <summary>
		/// The id of the device to be modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The serial of the device to be modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// The wifiMac of the device to be modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiMac")]
		public string WifiMac { get; set; }
	}
	
	public class UpdateNetworkSmDevicesFieldsPutBodyDeviceFields
	{
		
		/// <summary>
		/// New name for the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// New notes for the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
	}
	
	public class UpdateNetworkSmDevicesFieldsReturn
	{
		
		/// <summary>
		/// The Meraki Id of the device record.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Notes associated with the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// The device serial.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// The MAC of the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiMac")]
		public string WifiMac { get; set; }
	}
	
	public class LockNetworkSmDevicesPostBody
	{
		
		/// <summary>
		/// The ids of the devices to be locked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
		
		/// <summary>
		/// The pin number for locking macOS devices (a six digit number). Required only for macOS devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pin")]
		public System.Nullable<System.Int32> Pin { get; set; }
		
		/// <summary>
		/// The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be wiped.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scope")]
		public string[] Scope { get; set; }
		
		/// <summary>
		/// The serials of the devices to be locked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string[] Serials { get; set; }
		
		/// <summary>
		/// The wifiMacs of the devices to be locked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiMacs")]
		public string[] WifiMacs { get; set; }
	}
	
	public class LockNetworkSmDevicesReturn
	{
		
		/// <summary>
		/// The Meraki Ids of the set of devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
	}
	
	public class ModifyNetworkSmDevicesTagsPostBody
	{
		
		/// <summary>
		/// The ids of the devices to be modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
		
		/// <summary>
		/// The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scope")]
		public string[] Scope { get; set; }
		
		/// <summary>
		/// The serials of the devices to be modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string[] Serials { get; set; }
		
		/// <summary>
		/// The tags to be added, deleted, or updated.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// One of add, delete, or update. Only devices that have been modified will be returned.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updateAction")]
		public string UpdateAction { get; set; }
		
		/// <summary>
		/// The wifiMacs of the devices to be modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiMacs")]
		public string[] WifiMacs { get; set; }
	}
	
	public class ModifyNetworkSmDevicesTagsReturn
	{
		
		/// <summary>
		/// The Meraki Id of the device record.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The device serial.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// An array of tags associated with the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// The MAC of the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiMac")]
		public string WifiMac { get; set; }
	}
	
	public class MoveNetworkSmDevicesPostBody
	{
		
		/// <summary>
		/// The ids of the devices to be moved.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
		
		/// <summary>
		/// The new network to which the devices will be moved.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="newNetwork")]
		public string NewNetwork { get; set; }
		
		/// <summary>
		/// The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be moved.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scope")]
		public string[] Scope { get; set; }
		
		/// <summary>
		/// The serials of the devices to be moved.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string[] Serials { get; set; }
		
		/// <summary>
		/// The wifiMacs of the devices to be moved.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiMacs")]
		public string[] WifiMacs { get; set; }
	}
	
	public class MoveNetworkSmDevicesReturn
	{
		
		/// <summary>
		/// The Meraki Ids of the set of devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
		
		/// <summary>
		/// The network to which the devices was moved.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newNetwork")]
		public string NewNetwork { get; set; }
	}
	
	public class WipeNetworkSmDevicesPostBody
	{
		
		/// <summary>
		/// The id of the device to be wiped.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The pin number (a six digit value) for wiping a macOS device. Required only for macOS devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pin")]
		public System.Nullable<System.Int32> Pin { get; set; }
		
		/// <summary>
		/// The serial of the device to be wiped.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// The wifiMac of the device to be wiped.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiMac")]
		public string WifiMac { get; set; }
	}
	
	public class WipeNetworkSmDevicesReturn
	{
		
		/// <summary>
		/// The Meraki Id of the devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class GetNetworkSmDeviceCellularUsageHistoryReturn
	{
		
		/// <summary>
		/// The amount of cellular data received by the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="received")]
		public System.Nullable<System.Single> Received { get; set; }
		
		/// <summary>
		/// The amount of cellular sent received by the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sent")]
		public System.Nullable<System.Single> Sent { get; set; }
		
		/// <summary>
		/// When the cellular usage data was collected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ts")]
		public string Ts { get; set; }
	}
	
	public class GetNetworkSmDeviceCertsReturn
	{
		
		/// <summary>
		/// The PEM of the certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certPem")]
		public string CertPem { get; set; }
		
		/// <summary>
		/// The Meraki managed device Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceId")]
		public string DeviceId { get; set; }
		
		/// <summary>
		/// The Meraki Id of the certificate record.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The certificate issuer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issuer")]
		public string Issuer { get; set; }
		
		/// <summary>
		/// The name of the certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The date after which the certificate is no longer valid.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notValidAfter")]
		public string NotValidAfter { get; set; }
		
		/// <summary>
		/// The date before which the certificate is not valid.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notValidBefore")]
		public string NotValidBefore { get; set; }
		
		/// <summary>
		/// The subject of the certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subject")]
		public string Subject { get; set; }
	}
	
	public class GetNetworkSmDeviceConnectivityReturn
	{
		
		/// <summary>
		/// When the device was first seen as connected to the internet in each connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firstSeenAt")]
		public string FirstSeenAt { get; set; }
		
		/// <summary>
		/// When the device was last seen as connected to the internet in each connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastSeenAt")]
		public string LastSeenAt { get; set; }
	}
	
	public class GetNetworkSmDeviceDesktopLogsReturn
	{
		
		/// <summary>
		/// The IP address of the DCHP Server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpServer")]
		public string DhcpServer { get; set; }
		
		/// <summary>
		/// The DNS Server during the connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsServer")]
		public string DnsServer { get; set; }
		
		/// <summary>
		/// The gateway IP the device was connected to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The IP of the device during connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// The time the data was measured at.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="measuredAt")]
		public string MeasuredAt { get; set; }
		
		/// <summary>
		/// The network device for the device used for connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkDevice")]
		public string NetworkDevice { get; set; }
		
		/// <summary>
		/// The network driver for the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkDriver")]
		public string NetworkDriver { get; set; }
		
		/// <summary>
		/// The network max transmission unit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkMTU")]
		public string NetworkMTU { get; set; }
		
		/// <summary>
		/// The public IP address of the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicIP")]
		public string PublicIP { get; set; }
		
		/// <summary>
		/// The subnet of the device connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
		
		/// <summary>
		/// The time the connection was logged.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ts")]
		public string Ts { get; set; }
		
		/// <summary>
		/// The user during connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public string User { get; set; }
		
		/// <summary>
		/// The type of authentication used by the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiAuth")]
		public string WifiAuth { get; set; }
		
		/// <summary>
		/// The MAC of the access point the device is connected to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiBssid")]
		public string WifiBssid { get; set; }
		
		/// <summary>
		/// Channel through which the connection is routing.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiChannel")]
		public string WifiChannel { get; set; }
		
		/// <summary>
		/// The wireless signal power level received by the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiNoise")]
		public string WifiNoise { get; set; }
		
		/// <summary>
		/// The Received Signal Strength Indicator for the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiRssi")]
		public string WifiRssi { get; set; }
		
		/// <summary>
		/// The name of the network the device is connected to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiSsid")]
		public string WifiSsid { get; set; }
	}
	
	public class GetNetworkSmDeviceDeviceCommandLogsReturn
	{
		
		/// <summary>
		/// The type of command sent to the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="action")]
		public string Action { get; set; }
		
		/// <summary>
		/// The Meraki dashboard user who initiated the command.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dashboardUser")]
		public string DashboardUser { get; set; }
		
		/// <summary>
		/// A JSON string object containing command details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string Details { get; set; }
		
		/// <summary>
		/// The name of the device to which the command is sent.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The time the command was sent to the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ts")]
		public string Ts { get; set; }
	}
	
	public class GetNetworkSmDeviceDeviceProfilesReturn
	{
		
		/// <summary>
		/// The Meraki managed device Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceId")]
		public string DeviceId { get; set; }
		
		/// <summary>
		/// The numerical Meraki Id of the profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A boolean indicating if the profile is encrypted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isEncrypted")]
		public System.Nullable<System.Boolean> IsEncrypted { get; set; }
		
		/// <summary>
		/// Whether or not the profile is managed by Meraki.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isManaged")]
		public System.Nullable<System.Boolean> IsManaged { get; set; }
		
		/// <summary>
		/// The name of the profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A string containing a JSON object with the profile data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profileData")]
		public string ProfileData { get; set; }
		
		/// <summary>
		/// The identifier of the profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profileIdentifier")]
		public string ProfileIdentifier { get; set; }
		
		/// <summary>
		/// The verison of the profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	public class GetNetworkSmDeviceNetworkAdaptersReturn
	{
		
		/// <summary>
		/// The IP address of the DCHP Server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpServer")]
		public string DhcpServer { get; set; }
		
		/// <summary>
		/// The IP address of the DNS Server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsServer")]
		public string DnsServer { get; set; }
		
		/// <summary>
		/// The IP address of the Gateway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The Meraki Id of the network adapter record.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The IP address of the network adapter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// The MAC associated with the network adapter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// The name of the newtwork adapter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The subnet for the network adapter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
	}
	
	public class GetNetworkSmDevicePerformanceHistoryReturn
	{
		
		/// <summary>
		/// The percentage of CPU used as a decimal format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuPercentUsed")]
		public System.Nullable<System.Single> CpuPercentUsed { get; set; }
		
		/// <summary>
		/// An object containing disk usage details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskUsage")]
		public GetNetworkSmDevicePerformanceHistoryReturnDiskUsage DiskUsage { get; set; }
		
		/// <summary>
		/// The active RAM on the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memActive")]
		public System.Nullable<System.Int32> MemActive { get; set; }
		
		/// <summary>
		/// Memory that is not yet in use by the system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memFree")]
		public System.Nullable<System.Int32> MemFree { get; set; }
		
		/// <summary>
		/// The inactive RAM on the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memInactive")]
		public System.Nullable<System.Int32> MemInactive { get; set; }
		
		/// <summary>
		/// Memory used for core OS functions on the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memWired")]
		public System.Nullable<System.Int32> MemWired { get; set; }
		
		/// <summary>
		/// Network bandwith received.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkReceived")]
		public System.Nullable<System.Int32> NetworkReceived { get; set; }
		
		/// <summary>
		/// Network bandwith transmitted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkSent")]
		public System.Nullable<System.Int32> NetworkSent { get; set; }
		
		/// <summary>
		/// The amount of space being used on the startup disk to swap unused files to and from RAM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="swapUsed")]
		public System.Nullable<System.Int32> SwapUsed { get; set; }
		
		/// <summary>
		/// The time at which the performance was measured.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ts")]
		public string Ts { get; set; }
	}
	
	public class GetNetworkSmDevicePerformanceHistoryReturnDiskUsage
	{
		
		/// <summary>
		/// An object containing current disk usage details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="c")]
		public GetNetworkSmDevicePerformanceHistoryReturnDiskUsageC C { get; set; }
	}
	
	public class GetNetworkSmDevicePerformanceHistoryReturnDiskUsageC
	{
		
		/// <summary>
		/// The available disk space.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="space")]
		public System.Nullable<System.Int32> Space { get; set; }
		
		/// <summary>
		/// The used disk space.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="used")]
		public System.Nullable<System.Int32> Used { get; set; }
	}
	
	public class GetNetworkSmDeviceSecurityCentersReturn
	{
		
		/// <summary>
		/// The name of the Antivirus.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="antiVirusName")]
		public string AntiVirusName { get; set; }
		
		/// <summary>
		/// The name of the Firewall.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fireWallName")]
		public string FireWallName { get; set; }
		
		/// <summary>
		/// Boolean indicating if the device has Antivirus.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasAntiVirus")]
		public System.Nullable<System.Boolean> HasAntiVirus { get; set; }
		
		/// <summary>
		/// Boolean indicating if the device has a Firewall installed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasFireWallInstalled")]
		public System.Nullable<System.Boolean> HasFireWallInstalled { get; set; }
		
		/// <summary>
		/// The Meraki identifier for the security center record.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Boolean indicating if the device has auto login disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAutoLoginDisabled")]
		public System.Nullable<System.Boolean> IsAutoLoginDisabled { get; set; }
		
		/// <summary>
		/// Boolean indicating if the device has disk encryption.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isDiskEncrypted")]
		public System.Nullable<System.Boolean> IsDiskEncrypted { get; set; }
		
		/// <summary>
		/// Boolean indicating if the device has a Firewall enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isFireWallEnabled")]
		public System.Nullable<System.Boolean> IsFireWallEnabled { get; set; }
		
		/// <summary>
		/// Boolean indicating if the device is rooted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isRooted")]
		public System.Nullable<System.Boolean> IsRooted { get; set; }
		
		/// <summary>
		/// A comma seperated list of procs running on the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runningProcs")]
		public string RunningProcs { get; set; }
	}
	
	public class GetNetworkSmDeviceSoftwaresReturn
	{
		
		/// <summary>
		/// The Meraki managed application Id for this record on a particular device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appId")]
		public string AppId { get; set; }
		
		/// <summary>
		/// The size of the software bundle.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bundleSize")]
		public System.Nullable<System.Int32> BundleSize { get; set; }
		
		/// <summary>
		/// When the Meraki record for the software was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public string CreatedAt { get; set; }
		
		/// <summary>
		/// The Meraki managed device Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceId")]
		public string DeviceId { get; set; }
		
		/// <summary>
		/// The size of the data stored in the application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dynamicSize")]
		public System.Nullable<System.Int32> DynamicSize { get; set; }
		
		/// <summary>
		/// The Meraki software Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Software bundle identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="identifier")]
		public string Identifier { get; set; }
		
		/// <summary>
		/// When the Software was installed on the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="installedAt")]
		public string InstalledAt { get; set; }
		
		/// <summary>
		/// A boolean indicating whether or not an iOS redemption code was used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iosRedemptionCode")]
		public System.Nullable<System.Boolean> IosRedemptionCode { get; set; }
		
		/// <summary>
		/// A boolean indicating whether or not the software is managed by Meraki.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isManaged")]
		public System.Nullable<System.Boolean> IsManaged { get; set; }
		
		/// <summary>
		/// The itunes numerical identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="itunesId")]
		public string ItunesId { get; set; }
		
		/// <summary>
		/// The license key associated with this software installation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseKey")]
		public string LicenseKey { get; set; }
		
		/// <summary>
		/// The name of the software.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The path on the device where the software record is located.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// The redemption code used for this software.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redemptionCode")]
		public System.Nullable<System.Int32> RedemptionCode { get; set; }
		
		/// <summary>
		/// Short version notation for the software.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortVersion")]
		public string ShortVersion { get; set; }
		
		/// <summary>
		/// The management status of the software.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A boolean indicating this software record should be installed on the associated device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toInstall")]
		public System.Nullable<System.Boolean> ToInstall { get; set; }
		
		/// <summary>
		/// A boolean indicating this software record should be uninstalled on the associated device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toUninstall")]
		public System.Nullable<System.Boolean> ToUninstall { get; set; }
		
		/// <summary>
		/// When the record was uninstalled from the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uninstalledAt")]
		public string UninstalledAt { get; set; }
		
		/// <summary>
		/// When the record was last updated by Meraki.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public string UpdatedAt { get; set; }
		
		/// <summary>
		/// The vendor of the software.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vendor")]
		public string Vendor { get; set; }
		
		/// <summary>
		/// Full version notation for the software.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	public class GetNetworkSmDeviceWlanListsReturn
	{
		
		/// <summary>
		/// When the Meraki record for the wlanList was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public string CreatedAt { get; set; }
		
		/// <summary>
		/// The Meraki managed Id of the wlanList record.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// An XML string containing the WLAN List for the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xml")]
		public string Xml { get; set; }
	}
	
	public class GetNetworkSmProfilesReturn
	{
		
		/// <summary>
		/// Description of a profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of a profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of a profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Scope of a profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scope")]
		public string Scope { get; set; }
		
		/// <summary>
		/// Tags of a profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
	}
	
	public class GetNetworkSmTrustedAccessConfigsReturn
	{
		
		/// <summary>
		/// time that access ends
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessEndAt")]
		public System.Nullable<System.DateTimeOffset> AccessEndAt { get; set; }
		
		/// <summary>
		/// time that access starts
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessStartAt")]
		public System.Nullable<System.DateTimeOffset> AccessStartAt { get; set; }
		
		/// <summary>
		/// device ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// device name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// scope
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scope")]
		public string Scope { get; set; }
		
		/// <summary>
		/// SSID name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssidName")]
		public string SsidName { get; set; }
		
		/// <summary>
		/// device tags
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// type of access period, either a static range or a dynamic period
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeboundType")]
		public System.Nullable<GetNetworkSmTrustedAccessConfigsReturnTimeboundType> TimeboundType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkSmTrustedAccessConfigsReturnTimeboundType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dynamic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="static")]
		_static = 1,
	}
	
	public class GetNetworkSmUserAccessDevicesReturn
	{
		
		/// <summary>
		/// user email
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// device ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// mac address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// device name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// system type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="systemType")]
		public string SystemType { get; set; }
		
		/// <summary>
		/// device tags
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// Array of trusted access configs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trustedAccessConnections")]
		public GetNetworkSmUserAccessDevicesReturnTrustedAccessConnections[] GetNetworkSmUserAccessDevicesReturnTrustedAccessConnections { get; set; }
		
		/// <summary>
		/// username
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	public class GetNetworkSmUserAccessDevicesReturnTrustedAccessConnections
	{
		
		/// <summary>
		/// time that config was downloaded
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="downloadedAt")]
		public string DownloadedAt { get; set; }
		
		/// <summary>
		/// time of last connection
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastConnectedAt")]
		public System.Nullable<System.DateTimeOffset> LastConnectedAt { get; set; }
		
		/// <summary>
		/// time that SCEP completed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scepCompletedAt")]
		public System.Nullable<System.DateTimeOffset> ScepCompletedAt { get; set; }
		
		/// <summary>
		/// config id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trustedAccessConfigId")]
		public string TrustedAccessConfigId { get; set; }
	}
	
	public class GetNetworkSmUsersReturn
	{
		
		/// <summary>
		/// Active Directory Groups the user belongs to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adGroups")]
		public string[] AdGroups { get; set; }
		
		/// <summary>
		/// Apple School Manager Groups the user belongs to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="asmGroups")]
		public string[] AsmGroups { get; set; }
		
		/// <summary>
		/// Azure Active Directory Groups the user belongs to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="azureAdGroups")]
		public string[] AzureAdGroups { get; set; }
		
		/// <summary>
		/// The user display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// User email.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// User full name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fullName")]
		public string FullName { get; set; }
		
		/// <summary>
		/// A boolean indicating if the user has an associated identity certificate..
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasIdentityCertificate")]
		public System.Nullable<System.Boolean> HasIdentityCertificate { get; set; }
		
		/// <summary>
		/// A boolean denoting if the user has a password associated with the record.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasPassword")]
		public System.Nullable<System.Boolean> HasPassword { get; set; }
		
		/// <summary>
		/// The Meraki managed Id of the user record.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Whether the user was created using an external integration, or via the Meraki Dashboard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isExternal")]
		public System.Nullable<System.Boolean> IsExternal { get; set; }
		
		/// <summary>
		/// SAML Groups the user belongs to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="samlGroups")]
		public string[] SamlGroups { get; set; }
		
		/// <summary>
		/// The set of tags the user is scoped to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string Tags { get; set; }
		
		/// <summary>
		/// The url where the users thumbnail is hosted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userThumbnail")]
		public string UserThumbnail { get; set; }
		
		/// <summary>
		/// The users username.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	public class GetNetworkSmUserDeviceProfilesReturn
	{
		
		/// <summary>
		/// The Meraki managed device Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceId")]
		public string DeviceId { get; set; }
		
		/// <summary>
		/// The numerical Meraki Id of the profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A boolean indicating if the profile is encrypted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isEncrypted")]
		public System.Nullable<System.Boolean> IsEncrypted { get; set; }
		
		/// <summary>
		/// Whether or not the profile is managed by Meraki.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isManaged")]
		public System.Nullable<System.Boolean> IsManaged { get; set; }
		
		/// <summary>
		/// The name of the profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A string containing a JSON object with the profile data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profileData")]
		public string ProfileData { get; set; }
		
		/// <summary>
		/// The identifier of the profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profileIdentifier")]
		public string ProfileIdentifier { get; set; }
		
		/// <summary>
		/// The verison of the profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	public class GetNetworkSmUserSoftwaresReturn
	{
		
		/// <summary>
		/// The Meraki managed application Id for this record on a particular device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appId")]
		public string AppId { get; set; }
		
		/// <summary>
		/// The size of the software bundle.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bundleSize")]
		public System.Nullable<System.Int32> BundleSize { get; set; }
		
		/// <summary>
		/// When the Meraki record for the software was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public string CreatedAt { get; set; }
		
		/// <summary>
		/// The Meraki managed device Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceId")]
		public string DeviceId { get; set; }
		
		/// <summary>
		/// The size of the data stored in the application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dynamicSize")]
		public System.Nullable<System.Int32> DynamicSize { get; set; }
		
		/// <summary>
		/// The Meraki software Id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Software bundle identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="identifier")]
		public string Identifier { get; set; }
		
		/// <summary>
		/// When the Software was installed on the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="installedAt")]
		public string InstalledAt { get; set; }
		
		/// <summary>
		/// A boolean indicating whether or not an iOS redemption code was used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iosRedemptionCode")]
		public System.Nullable<System.Boolean> IosRedemptionCode { get; set; }
		
		/// <summary>
		/// A boolean indicating whether or not the software is managed by Meraki.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isManaged")]
		public System.Nullable<System.Boolean> IsManaged { get; set; }
		
		/// <summary>
		/// The itunes numerical identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="itunesId")]
		public string ItunesId { get; set; }
		
		/// <summary>
		/// The license key associated with this software installation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseKey")]
		public string LicenseKey { get; set; }
		
		/// <summary>
		/// The name of the software.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The path on the device where the software record is located.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// The redemption code used for this software.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redemptionCode")]
		public System.Nullable<System.Int32> RedemptionCode { get; set; }
		
		/// <summary>
		/// Short version notation for the software.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortVersion")]
		public string ShortVersion { get; set; }
		
		/// <summary>
		/// The management status of the software.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// A boolean indicating this software record should be installed on the associated device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toInstall")]
		public System.Nullable<System.Boolean> ToInstall { get; set; }
		
		/// <summary>
		/// A boolean indicating this software record should be uninstalled on the associated device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toUninstall")]
		public System.Nullable<System.Boolean> ToUninstall { get; set; }
		
		/// <summary>
		/// When the record was uninstalled from the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uninstalledAt")]
		public string UninstalledAt { get; set; }
		
		/// <summary>
		/// When the record was last updated by Meraki.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public string UpdatedAt { get; set; }
		
		/// <summary>
		/// The vendor of the software.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vendor")]
		public string Vendor { get; set; }
		
		/// <summary>
		/// Full version notation for the software.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	public class UpdateNetworkSnmpPutBody
	{
		
		/// <summary>
		/// The type of SNMP access. Can be one of 'none' (disabled), 'community' (V1/V2c), or 'users' (V3).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="access")]
		public System.Nullable<UpdateNetworkSnmpPutBodyAccess> Access { get; set; }
		
		/// <summary>
		/// The SNMP community string. Only relevant if 'access' is set to 'community'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="communityString")]
		public string CommunityString { get; set; }
		
		/// <summary>
		/// The list of SNMP users. Only relevant if 'access' is set to 'users'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="users")]
		public UpdateNetworkSnmpPutBodyUsers[] UpdateNetworkSnmpPutBodyUsers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSnmpPutBodyAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		community = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		users = 2,
	}
	
	public class UpdateNetworkSnmpPutBodyUsers
	{
		
		/// <summary>
		/// The passphrase for the SNMP user. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="passphrase")]
		public string Passphrase { get; set; }
		
		/// <summary>
		/// The username for the SNMP user. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	public enum GetNetworkSplashLoginAttemptsSsidNumber
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_4 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_5 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_6 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_7 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_8 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_9 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_10 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_11 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_12 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_13 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_14 = 14,
	}
	
	public class SplitNetworkReturn
	{
		
		/// <summary>
		/// Networks after the split
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resultingNetworks")]
		public SplitNetworkReturnResultingNetworks[] SplitNetworkReturnResultingNetworks { get; set; }
	}
	
	public class SplitNetworkReturnResultingNetworks
	{
		
		/// <summary>
		/// Enrollment string for the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enrollmentString")]
		public string EnrollmentString { get; set; }
		
		/// <summary>
		/// Network ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// If the network is bound to a config template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isBoundToConfigTemplate")]
		public System.Nullable<System.Boolean> IsBoundToConfigTemplate { get; set; }
		
		/// <summary>
		/// Network name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Notes for the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// Organization ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organizationId")]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// List of the product types that the network supports
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productTypes")]
		public string[] ProductTypes { get; set; }
		
		/// <summary>
		/// Network tags
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// Timezone of the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeZone")]
		public string TimeZone { get; set; }
		
		/// <summary>
		/// URL to the network Dashboard UI
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetNetworkSwitchAccessControlListsReturn
	{
		
		/// <summary>
		/// An ordered array of the access control list rules
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public GetNetworkSwitchAccessControlListsReturnRules[] GetNetworkSwitchAccessControlListsReturnRules { get; set; }
	}
	
	public class GetNetworkSwitchAccessControlListsReturnRules
	{
		
		/// <summary>
		/// Description of the rule (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Destination IP address (in IP or CIDR notation)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstCidr")]
		public string DstCidr { get; set; }
		
		/// <summary>
		/// Destination port
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstPort")]
		public string DstPort { get; set; }
		
		/// <summary>
		/// IP address version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipVersion")]
		public System.Nullable<GetNetworkSwitchAccessControlListsReturnRulesIpVersion> IpVersion { get; set; }
		
		/// <summary>
		/// 'allow' or 'deny' traffic specified by this rule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy Policy { get; set; }
		
		/// <summary>
		/// The type of protocol
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public System.Nullable<GetNetworkSwitchAccessControlListsReturnRulesProtocol> Protocol { get; set; }
		
		/// <summary>
		/// Source IP address (in IP or CIDR notation)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcCidr")]
		public string SrcCidr { get; set; }
		
		/// <summary>
		/// Source port
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPort")]
		public string SrcPort { get; set; }
		
		/// <summary>
		/// ncoming traffic VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public string Vlan { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkSwitchAccessControlListsReturnRulesIpVersion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		any = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ipv4 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ipv6 = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkSwitchAccessControlListsReturnRulesProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		any = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tcp = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		udp = 2,
	}
	
	public class UpdateNetworkSwitchAccessControlListsPutBody
	{
		
		/// <summary>
		/// An ordered array of the access control list rules (not including the default rule). An empty array will clear the rules.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkSwitchAccessControlListsPutBodyRules[] UpdateNetworkSwitchAccessControlListsPutBodyRules { get; set; }
	}
	
	public class UpdateNetworkSwitchAccessControlListsPutBodyRules
	{
		
		/// <summary>
		/// Description of the rule (optional).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Destination IP address (in IP or CIDR notation) or 'any'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dstCidr")]
		public string DstCidr { get; set; }
		
		/// <summary>
		/// Destination port. Must be in the range of 1-65535 or 'any'. Default is 'any'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstPort")]
		public string DstPort { get; set; }
		
		/// <summary>
		/// IP address version (must be 'any', 'ipv4' or 'ipv6'). Applicable only if network supports IPv6. Default value is 'ipv4'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipVersion")]
		public GetNetworkSwitchAccessControlListsReturnRulesIpVersion IpVersion { get; set; }
		
		/// <summary>
		/// 'allow' or 'deny' traffic specified by this rule.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy Policy { get; set; }
		
		/// <summary>
		/// The type of protocol (must be 'tcp', 'udp', or 'any').
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public GetNetworkSwitchAccessControlListsReturnRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// Source IP address (in IP or CIDR notation) or 'any'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="srcCidr")]
		public string SrcCidr { get; set; }
		
		/// <summary>
		/// Source port. Must be in the range  of 1-65535 or 'any'. Default is 'any'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPort")]
		public string SrcPort { get; set; }
		
		/// <summary>
		/// Incoming traffic VLAN. Must be in the range of 1-4095 or 'any'. Default is 'any'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public string Vlan { get; set; }
	}
	
	public class UpdateNetworkSwitchAccessControlListsReturn
	{
		
		/// <summary>
		/// An ordered array of the access control list rules
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkSwitchAccessControlListsReturnRules[] UpdateNetworkSwitchAccessControlListsReturnRules { get; set; }
	}
	
	public class UpdateNetworkSwitchAccessControlListsReturnRules
	{
		
		/// <summary>
		/// Description of the rule (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Destination IP address (in IP or CIDR notation)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstCidr")]
		public string DstCidr { get; set; }
		
		/// <summary>
		/// Destination port
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstPort")]
		public string DstPort { get; set; }
		
		/// <summary>
		/// IP address version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipVersion")]
		public GetNetworkSwitchAccessControlListsReturnRulesIpVersion IpVersion { get; set; }
		
		/// <summary>
		/// 'allow' or 'deny' traffic specified by this rule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy Policy { get; set; }
		
		/// <summary>
		/// The type of protocol
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public GetNetworkSwitchAccessControlListsReturnRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// Source IP address (in IP or CIDR notation)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcCidr")]
		public string SrcCidr { get; set; }
		
		/// <summary>
		/// Source port
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPort")]
		public string SrcPort { get; set; }
		
		/// <summary>
		/// ncoming traffic VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public string Vlan { get; set; }
	}
	
	public class GetNetworkSwitchAccessPoliciesReturn
	{
		
		/// <summary>
		/// Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyType")]
		public System.Nullable<GetNetworkSwitchAccessPoliciesReturnAccessPolicyType> AccessPolicyType { get; set; }
		
		/// <summary>
		/// 802.1x Settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dot1x")]
		public GetNetworkSwitchAccessPoliciesReturnDot1x Dot1x { get; set; }
		
		/// <summary>
		/// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestPortBouncing")]
		public System.Nullable<System.Boolean> GuestPortBouncing { get; set; }
		
		/// <summary>
		/// ID for the guest VLAN allow unauthorized devices access to limited network resources
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestVlanId")]
		public System.Nullable<System.Int32> GuestVlanId { get; set; }
		
		/// <summary>
		/// Choose the Host Mode for the access policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostMode")]
		public System.Nullable<GetNetworkSwitchAccessPoliciesReturnHostMode> HostMode { get; set; }
		
		/// <summary>
		/// Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="increaseAccessSpeed")]
		public System.Nullable<System.Boolean> IncreaseAccessSpeed { get; set; }
		
		/// <summary>
		/// Name of the access policy
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Object for RADIUS Settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radius")]
		public GetNetworkSwitchAccessPoliciesReturnRadius Radius { get; set; }
		
		/// <summary>
		/// Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusAccountingEnabled")]
		public System.Nullable<System.Boolean> RadiusAccountingEnabled { get; set; }
		
		/// <summary>
		/// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusAccountingServers")]
		public GetNetworkSwitchAccessPoliciesReturnRadiusAccountingServers[] GetNetworkSwitchAccessPoliciesReturnRadiusAccountingServers { get; set; }
		
		/// <summary>
		/// Change of authentication for RADIUS re-authentication and disconnection
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusCoaSupportEnabled")]
		public System.Nullable<System.Boolean> RadiusCoaSupportEnabled { get; set; }
		
		/// <summary>
		/// Acceptable values are `""` for None, or `"11"` for Group Policies ACL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusGroupAttribute")]
		public string RadiusGroupAttribute { get; set; }
		
		/// <summary>
		/// List of RADIUS servers to require connecting devices to authenticate against before granting network access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusServers")]
		public GetNetworkSwitchAccessPoliciesReturnRadiusServers[] GetNetworkSwitchAccessPoliciesReturnRadiusServers { get; set; }
		
		/// <summary>
		/// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusTestingEnabled")]
		public System.Nullable<System.Boolean> RadiusTestingEnabled { get; set; }
		
		/// <summary>
		/// Enable to restrict access for clients to a response_objectific set of IP addresses or hostnames prior to authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlRedirectWalledGardenEnabled")]
		public System.Nullable<System.Boolean> UrlRedirectWalledGardenEnabled { get; set; }
		
		/// <summary>
		/// IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlRedirectWalledGardenRanges")]
		public string[] UrlRedirectWalledGardenRanges { get; set; }
		
		/// <summary>
		/// CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlanClients")]
		public System.Nullable<System.Boolean> VoiceVlanClients { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkSwitchAccessPoliciesReturnAccessPolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="802.1x")]
		_802_1x = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Hybrid authentication")]
		Hybrid_authentication = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAC authentication bypass")]
		MAC_authentication_bypass = 2,
	}
	
	public class GetNetworkSwitchAccessPoliciesReturnDot1x
	{
		
		/// <summary>
		/// Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="controlDirection")]
		public System.Nullable<GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection> ControlDirection { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		both = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		inbound = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkSwitchAccessPoliciesReturnHostMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Multi-Auth")]
		MultiMinusAuth = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Multi-Domain")]
		MultiMinusDomain = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Multi-Host")]
		MultiMinusHost = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Single-Host")]
		SingleMinusHost = 3,
	}
	
	public class GetNetworkSwitchAccessPoliciesReturnRadius
	{
		
		/// <summary>
		/// Critical auth settings for when authentication is rejected by the RADIUS server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="criticalAuth")]
		public GetNetworkSwitchAccessPoliciesReturnRadiusCriticalAuth CriticalAuth { get; set; }
		
		/// <summary>
		/// VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failedAuthVlanId")]
		public System.Nullable<System.Int32> FailedAuthVlanId { get; set; }
		
		/// <summary>
		/// Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reAuthenticationInterval")]
		public System.Nullable<System.Int32> ReAuthenticationInterval { get; set; }
	}
	
	public class GetNetworkSwitchAccessPoliciesReturnRadiusCriticalAuth
	{
		
		/// <summary>
		/// VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataVlanId")]
		public System.Nullable<System.Int32> DataVlanId { get; set; }
		
		/// <summary>
		/// Enable to suspend port bounce when RADIUS servers are unreachable
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="suspendPortBounce")]
		public System.Nullable<System.Boolean> SuspendPortBounce { get; set; }
		
		/// <summary>
		/// VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlanId")]
		public System.Nullable<System.Int32> VoiceVlanId { get; set; }
	}
	
	public class GetNetworkSwitchAccessPoliciesReturnRadiusAccountingServers
	{
		
		/// <summary>
		/// Public IP address of the RADIUS accounting server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// UDP port that the RADIUS Accounting server listens on for access requests
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
	}
	
	public class GetNetworkSwitchAccessPoliciesReturnRadiusServers
	{
		
		/// <summary>
		/// Public IP address of the RADIUS server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// UDP port that the RADIUS server listens on for access requests
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
	}
	
	public class CreateNetworkSwitchAccessPolicyPostBody
	{
		
		/// <summary>
		/// Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyType")]
		public System.Nullable<CreateNetworkSwitchAccessPolicyPostBodyAccessPolicyType> AccessPolicyType { get; set; }
		
		/// <summary>
		/// 802.1x Settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dot1x")]
		public CreateNetworkSwitchAccessPolicyPostBodyDot1x Dot1x { get; set; }
		
		/// <summary>
		/// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestPortBouncing")]
		public System.Nullable<System.Boolean> GuestPortBouncing { get; set; }
		
		/// <summary>
		/// ID for the guest VLAN allow unauthorized devices access to limited network resources
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestVlanId")]
		public System.Nullable<System.Int32> GuestVlanId { get; set; }
		
		/// <summary>
		/// Choose the Host Mode for the access policy.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostMode")]
		public CreateNetworkSwitchAccessPolicyPostBodyHostMode HostMode { get; set; }
		
		/// <summary>
		/// Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="increaseAccessSpeed")]
		public System.Nullable<System.Boolean> IncreaseAccessSpeed { get; set; }
		
		/// <summary>
		/// Name of the access policy
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Object for RADIUS Settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radius")]
		public CreateNetworkSwitchAccessPolicyPostBodyRadius Radius { get; set; }
		
		/// <summary>
		/// Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="radiusAccountingEnabled")]
		public bool RadiusAccountingEnabled { get; set; }
		
		/// <summary>
		/// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusAccountingServers")]
		public CreateNetworkSwitchAccessPolicyPostBodyRadiusAccountingServers[] CreateNetworkSwitchAccessPolicyPostBodyRadiusAccountingServers { get; set; }
		
		/// <summary>
		/// Change of authentication for RADIUS re-authentication and disconnection
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="radiusCoaSupportEnabled")]
		public bool RadiusCoaSupportEnabled { get; set; }
		
		/// <summary>
		/// Acceptable values are `""` for None, or `"11"` for Group Policies ACL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusGroupAttribute")]
		public string RadiusGroupAttribute { get; set; }
		
		/// <summary>
		/// List of RADIUS servers to require connecting devices to authenticate against before granting network access
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="radiusServers")]
		public CreateNetworkSwitchAccessPolicyPostBodyRadiusServers[] CreateNetworkSwitchAccessPolicyPostBodyRadiusServers { get; set; }
		
		/// <summary>
		/// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="radiusTestingEnabled")]
		public bool RadiusTestingEnabled { get; set; }
		
		/// <summary>
		/// Enable to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="urlRedirectWalledGardenEnabled")]
		public bool UrlRedirectWalledGardenEnabled { get; set; }
		
		/// <summary>
		/// IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlRedirectWalledGardenRanges")]
		public string[] UrlRedirectWalledGardenRanges { get; set; }
		
		/// <summary>
		/// CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlanClients")]
		public System.Nullable<System.Boolean> VoiceVlanClients { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkSwitchAccessPolicyPostBodyAccessPolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="802.1x")]
		_802_1x = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Hybrid authentication")]
		Hybrid_authentication = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAC authentication bypass")]
		MAC_authentication_bypass = 2,
	}
	
	public class CreateNetworkSwitchAccessPolicyPostBodyDot1x
	{
		
		/// <summary>
		/// Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="controlDirection")]
		public GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection ControlDirection { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkSwitchAccessPolicyPostBodyHostMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Multi-Auth")]
		MultiMinusAuth = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Multi-Domain")]
		MultiMinusDomain = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Multi-Host")]
		MultiMinusHost = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Single-Host")]
		SingleMinusHost = 3,
	}
	
	public class CreateNetworkSwitchAccessPolicyPostBodyRadius
	{
		
		/// <summary>
		/// Critical auth settings for when authentication is rejected by the RADIUS server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="criticalAuth")]
		public CreateNetworkSwitchAccessPolicyPostBodyRadiusCriticalAuth CriticalAuth { get; set; }
		
		/// <summary>
		/// VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failedAuthVlanId")]
		public System.Nullable<System.Int32> FailedAuthVlanId { get; set; }
		
		/// <summary>
		/// Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reAuthenticationInterval")]
		public System.Nullable<System.Int32> ReAuthenticationInterval { get; set; }
	}
	
	public class CreateNetworkSwitchAccessPolicyPostBodyRadiusCriticalAuth
	{
		
		/// <summary>
		/// VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataVlanId")]
		public System.Nullable<System.Int32> DataVlanId { get; set; }
		
		/// <summary>
		/// Enable to suspend port bounce when RADIUS servers are unreachable
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="suspendPortBounce")]
		public System.Nullable<System.Boolean> SuspendPortBounce { get; set; }
		
		/// <summary>
		/// VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlanId")]
		public System.Nullable<System.Int32> VoiceVlanId { get; set; }
	}
	
	public class CreateNetworkSwitchAccessPolicyPostBodyRadiusAccountingServers
	{
		
		/// <summary>
		/// Public IP address of the RADIUS accounting server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// UDP port that the RADIUS Accounting server listens on for access requests
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
		
		/// <summary>
		/// RADIUS client shared secret
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
	}
	
	public class CreateNetworkSwitchAccessPolicyPostBodyRadiusServers
	{
		
		/// <summary>
		/// Public IP address of the RADIUS server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// UDP port that the RADIUS server listens on for access requests
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
		
		/// <summary>
		/// RADIUS client shared secret
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
	}
	
	public class GetNetworkSwitchAccessPolicyReturn
	{
		
		/// <summary>
		/// Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyType")]
		public System.Nullable<GetNetworkSwitchAccessPolicyReturnAccessPolicyType> AccessPolicyType { get; set; }
		
		/// <summary>
		/// 802.1x Settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dot1x")]
		public GetNetworkSwitchAccessPolicyReturnDot1x Dot1x { get; set; }
		
		/// <summary>
		/// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestPortBouncing")]
		public System.Nullable<System.Boolean> GuestPortBouncing { get; set; }
		
		/// <summary>
		/// ID for the guest VLAN allow unauthorized devices access to limited network resources
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestVlanId")]
		public System.Nullable<System.Int32> GuestVlanId { get; set; }
		
		/// <summary>
		/// Choose the Host Mode for the access policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostMode")]
		public System.Nullable<GetNetworkSwitchAccessPolicyReturnHostMode> HostMode { get; set; }
		
		/// <summary>
		/// Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="increaseAccessSpeed")]
		public System.Nullable<System.Boolean> IncreaseAccessSpeed { get; set; }
		
		/// <summary>
		/// Name of the access policy
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Object for RADIUS Settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radius")]
		public GetNetworkSwitchAccessPolicyReturnRadius Radius { get; set; }
		
		/// <summary>
		/// Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusAccountingEnabled")]
		public System.Nullable<System.Boolean> RadiusAccountingEnabled { get; set; }
		
		/// <summary>
		/// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusAccountingServers")]
		public GetNetworkSwitchAccessPolicyReturnRadiusAccountingServers[] GetNetworkSwitchAccessPolicyReturnRadiusAccountingServers { get; set; }
		
		/// <summary>
		/// Change of authentication for RADIUS re-authentication and disconnection
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusCoaSupportEnabled")]
		public System.Nullable<System.Boolean> RadiusCoaSupportEnabled { get; set; }
		
		/// <summary>
		/// Acceptable values are `""` for None, or `"11"` for Group Policies ACL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusGroupAttribute")]
		public string RadiusGroupAttribute { get; set; }
		
		/// <summary>
		/// List of RADIUS servers to require connecting devices to authenticate against before granting network access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusServers")]
		public GetNetworkSwitchAccessPolicyReturnRadiusServers[] GetNetworkSwitchAccessPolicyReturnRadiusServers { get; set; }
		
		/// <summary>
		/// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusTestingEnabled")]
		public System.Nullable<System.Boolean> RadiusTestingEnabled { get; set; }
		
		/// <summary>
		/// Enable to restrict access for clients to a response_objectific set of IP addresses or hostnames prior to authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlRedirectWalledGardenEnabled")]
		public System.Nullable<System.Boolean> UrlRedirectWalledGardenEnabled { get; set; }
		
		/// <summary>
		/// IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlRedirectWalledGardenRanges")]
		public string[] UrlRedirectWalledGardenRanges { get; set; }
		
		/// <summary>
		/// CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlanClients")]
		public System.Nullable<System.Boolean> VoiceVlanClients { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkSwitchAccessPolicyReturnAccessPolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="802.1x")]
		_802_1x = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Hybrid authentication")]
		Hybrid_authentication = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAC authentication bypass")]
		MAC_authentication_bypass = 2,
	}
	
	public class GetNetworkSwitchAccessPolicyReturnDot1x
	{
		
		/// <summary>
		/// Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="controlDirection")]
		public GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection ControlDirection { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkSwitchAccessPolicyReturnHostMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Multi-Auth")]
		MultiMinusAuth = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Multi-Domain")]
		MultiMinusDomain = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Multi-Host")]
		MultiMinusHost = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Single-Host")]
		SingleMinusHost = 3,
	}
	
	public class GetNetworkSwitchAccessPolicyReturnRadius
	{
		
		/// <summary>
		/// Critical auth settings for when authentication is rejected by the RADIUS server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="criticalAuth")]
		public GetNetworkSwitchAccessPolicyReturnRadiusCriticalAuth CriticalAuth { get; set; }
		
		/// <summary>
		/// VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failedAuthVlanId")]
		public System.Nullable<System.Int32> FailedAuthVlanId { get; set; }
		
		/// <summary>
		/// Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reAuthenticationInterval")]
		public System.Nullable<System.Int32> ReAuthenticationInterval { get; set; }
	}
	
	public class GetNetworkSwitchAccessPolicyReturnRadiusCriticalAuth
	{
		
		/// <summary>
		/// VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataVlanId")]
		public System.Nullable<System.Int32> DataVlanId { get; set; }
		
		/// <summary>
		/// Enable to suspend port bounce when RADIUS servers are unreachable
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="suspendPortBounce")]
		public System.Nullable<System.Boolean> SuspendPortBounce { get; set; }
		
		/// <summary>
		/// VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlanId")]
		public System.Nullable<System.Int32> VoiceVlanId { get; set; }
	}
	
	public class GetNetworkSwitchAccessPolicyReturnRadiusAccountingServers
	{
		
		/// <summary>
		/// Public IP address of the RADIUS accounting server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// UDP port that the RADIUS Accounting server listens on for access requests
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
	}
	
	public class GetNetworkSwitchAccessPolicyReturnRadiusServers
	{
		
		/// <summary>
		/// Public IP address of the RADIUS server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// UDP port that the RADIUS server listens on for access requests
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
	}
	
	public class UpdateNetworkSwitchAccessPolicyPutBody
	{
		
		/// <summary>
		/// Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyType")]
		public System.Nullable<UpdateNetworkSwitchAccessPolicyPutBodyAccessPolicyType> AccessPolicyType { get; set; }
		
		/// <summary>
		/// 802.1x Settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dot1x")]
		public UpdateNetworkSwitchAccessPolicyPutBodyDot1x Dot1x { get; set; }
		
		/// <summary>
		/// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestPortBouncing")]
		public System.Nullable<System.Boolean> GuestPortBouncing { get; set; }
		
		/// <summary>
		/// ID for the guest VLAN allow unauthorized devices access to limited network resources
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestVlanId")]
		public System.Nullable<System.Int32> GuestVlanId { get; set; }
		
		/// <summary>
		/// Choose the Host Mode for the access policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostMode")]
		public System.Nullable<UpdateNetworkSwitchAccessPolicyPutBodyHostMode> HostMode { get; set; }
		
		/// <summary>
		/// Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="increaseAccessSpeed")]
		public System.Nullable<System.Boolean> IncreaseAccessSpeed { get; set; }
		
		/// <summary>
		/// Name of the access policy
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Object for RADIUS Settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radius")]
		public UpdateNetworkSwitchAccessPolicyPutBodyRadius Radius { get; set; }
		
		/// <summary>
		/// Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusAccountingEnabled")]
		public System.Nullable<System.Boolean> RadiusAccountingEnabled { get; set; }
		
		/// <summary>
		/// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusAccountingServers")]
		public UpdateNetworkSwitchAccessPolicyPutBodyRadiusAccountingServers[] UpdateNetworkSwitchAccessPolicyPutBodyRadiusAccountingServers { get; set; }
		
		/// <summary>
		/// Change of authentication for RADIUS re-authentication and disconnection
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusCoaSupportEnabled")]
		public System.Nullable<System.Boolean> RadiusCoaSupportEnabled { get; set; }
		
		/// <summary>
		/// Acceptable values are `""` for None, or `"11"` for Group Policies ACL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusGroupAttribute")]
		public string RadiusGroupAttribute { get; set; }
		
		/// <summary>
		/// List of RADIUS servers to require connecting devices to authenticate against before granting network access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusServers")]
		public UpdateNetworkSwitchAccessPolicyPutBodyRadiusServers[] UpdateNetworkSwitchAccessPolicyPutBodyRadiusServers { get; set; }
		
		/// <summary>
		/// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusTestingEnabled")]
		public System.Nullable<System.Boolean> RadiusTestingEnabled { get; set; }
		
		/// <summary>
		/// Enable to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlRedirectWalledGardenEnabled")]
		public System.Nullable<System.Boolean> UrlRedirectWalledGardenEnabled { get; set; }
		
		/// <summary>
		/// IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlRedirectWalledGardenRanges")]
		public string[] UrlRedirectWalledGardenRanges { get; set; }
		
		/// <summary>
		/// CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlanClients")]
		public System.Nullable<System.Boolean> VoiceVlanClients { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSwitchAccessPolicyPutBodyAccessPolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="802.1x")]
		_802_1x = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Hybrid authentication")]
		Hybrid_authentication = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAC authentication bypass")]
		MAC_authentication_bypass = 2,
	}
	
	public class UpdateNetworkSwitchAccessPolicyPutBodyDot1x
	{
		
		/// <summary>
		/// Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="controlDirection")]
		public GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection ControlDirection { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSwitchAccessPolicyPutBodyHostMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Multi-Auth")]
		MultiMinusAuth = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Multi-Domain")]
		MultiMinusDomain = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Multi-Host")]
		MultiMinusHost = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Single-Host")]
		SingleMinusHost = 3,
	}
	
	public class UpdateNetworkSwitchAccessPolicyPutBodyRadius
	{
		
		/// <summary>
		/// Critical auth settings for when authentication is rejected by the RADIUS server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="criticalAuth")]
		public UpdateNetworkSwitchAccessPolicyPutBodyRadiusCriticalAuth CriticalAuth { get; set; }
		
		/// <summary>
		/// VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failedAuthVlanId")]
		public System.Nullable<System.Int32> FailedAuthVlanId { get; set; }
		
		/// <summary>
		/// Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reAuthenticationInterval")]
		public System.Nullable<System.Int32> ReAuthenticationInterval { get; set; }
	}
	
	public class UpdateNetworkSwitchAccessPolicyPutBodyRadiusCriticalAuth
	{
		
		/// <summary>
		/// VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataVlanId")]
		public System.Nullable<System.Int32> DataVlanId { get; set; }
		
		/// <summary>
		/// Enable to suspend port bounce when RADIUS servers are unreachable
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="suspendPortBounce")]
		public System.Nullable<System.Boolean> SuspendPortBounce { get; set; }
		
		/// <summary>
		/// VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlanId")]
		public System.Nullable<System.Int32> VoiceVlanId { get; set; }
	}
	
	public class UpdateNetworkSwitchAccessPolicyPutBodyRadiusAccountingServers
	{
		
		/// <summary>
		/// Public IP address of the RADIUS accounting server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// UDP port that the RADIUS Accounting server listens on for access requests
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
		
		/// <summary>
		/// RADIUS client shared secret
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
	}
	
	public class UpdateNetworkSwitchAccessPolicyPutBodyRadiusServers
	{
		
		/// <summary>
		/// Public IP address of the RADIUS server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// UDP port that the RADIUS server listens on for access requests
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
		
		/// <summary>
		/// RADIUS client shared secret
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
	}
	
	public class UpdateNetworkSwitchAccessPolicyReturn
	{
		
		/// <summary>
		/// Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyType")]
		public System.Nullable<UpdateNetworkSwitchAccessPolicyReturnAccessPolicyType> AccessPolicyType { get; set; }
		
		/// <summary>
		/// 802.1x Settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dot1x")]
		public UpdateNetworkSwitchAccessPolicyReturnDot1x Dot1x { get; set; }
		
		/// <summary>
		/// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestPortBouncing")]
		public System.Nullable<System.Boolean> GuestPortBouncing { get; set; }
		
		/// <summary>
		/// ID for the guest VLAN allow unauthorized devices access to limited network resources
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestVlanId")]
		public System.Nullable<System.Int32> GuestVlanId { get; set; }
		
		/// <summary>
		/// Choose the Host Mode for the access policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostMode")]
		public System.Nullable<UpdateNetworkSwitchAccessPolicyReturnHostMode> HostMode { get; set; }
		
		/// <summary>
		/// Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="increaseAccessSpeed")]
		public System.Nullable<System.Boolean> IncreaseAccessSpeed { get; set; }
		
		/// <summary>
		/// Name of the access policy
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Object for RADIUS Settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radius")]
		public UpdateNetworkSwitchAccessPolicyReturnRadius Radius { get; set; }
		
		/// <summary>
		/// Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusAccountingEnabled")]
		public System.Nullable<System.Boolean> RadiusAccountingEnabled { get; set; }
		
		/// <summary>
		/// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusAccountingServers")]
		public UpdateNetworkSwitchAccessPolicyReturnRadiusAccountingServers[] UpdateNetworkSwitchAccessPolicyReturnRadiusAccountingServers { get; set; }
		
		/// <summary>
		/// Change of authentication for RADIUS re-authentication and disconnection
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusCoaSupportEnabled")]
		public System.Nullable<System.Boolean> RadiusCoaSupportEnabled { get; set; }
		
		/// <summary>
		/// Acceptable values are `""` for None, or `"11"` for Group Policies ACL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusGroupAttribute")]
		public string RadiusGroupAttribute { get; set; }
		
		/// <summary>
		/// List of RADIUS servers to require connecting devices to authenticate against before granting network access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusServers")]
		public UpdateNetworkSwitchAccessPolicyReturnRadiusServers[] UpdateNetworkSwitchAccessPolicyReturnRadiusServers { get; set; }
		
		/// <summary>
		/// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusTestingEnabled")]
		public System.Nullable<System.Boolean> RadiusTestingEnabled { get; set; }
		
		/// <summary>
		/// Enable to restrict access for clients to a response_objectific set of IP addresses or hostnames prior to authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlRedirectWalledGardenEnabled")]
		public System.Nullable<System.Boolean> UrlRedirectWalledGardenEnabled { get; set; }
		
		/// <summary>
		/// IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlRedirectWalledGardenRanges")]
		public string[] UrlRedirectWalledGardenRanges { get; set; }
		
		/// <summary>
		/// CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlanClients")]
		public System.Nullable<System.Boolean> VoiceVlanClients { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSwitchAccessPolicyReturnAccessPolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="802.1x")]
		_802_1x = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Hybrid authentication")]
		Hybrid_authentication = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAC authentication bypass")]
		MAC_authentication_bypass = 2,
	}
	
	public class UpdateNetworkSwitchAccessPolicyReturnDot1x
	{
		
		/// <summary>
		/// Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="controlDirection")]
		public GetNetworkSwitchAccessPoliciesReturnDot1xControlDirection ControlDirection { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSwitchAccessPolicyReturnHostMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Multi-Auth")]
		MultiMinusAuth = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Multi-Domain")]
		MultiMinusDomain = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Multi-Host")]
		MultiMinusHost = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Single-Host")]
		SingleMinusHost = 3,
	}
	
	public class UpdateNetworkSwitchAccessPolicyReturnRadius
	{
		
		/// <summary>
		/// Critical auth settings for when authentication is rejected by the RADIUS server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="criticalAuth")]
		public UpdateNetworkSwitchAccessPolicyReturnRadiusCriticalAuth CriticalAuth { get; set; }
		
		/// <summary>
		/// VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failedAuthVlanId")]
		public System.Nullable<System.Int32> FailedAuthVlanId { get; set; }
		
		/// <summary>
		/// Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reAuthenticationInterval")]
		public System.Nullable<System.Int32> ReAuthenticationInterval { get; set; }
	}
	
	public class UpdateNetworkSwitchAccessPolicyReturnRadiusCriticalAuth
	{
		
		/// <summary>
		/// VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataVlanId")]
		public System.Nullable<System.Int32> DataVlanId { get; set; }
		
		/// <summary>
		/// Enable to suspend port bounce when RADIUS servers are unreachable
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="suspendPortBounce")]
		public System.Nullable<System.Boolean> SuspendPortBounce { get; set; }
		
		/// <summary>
		/// VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlanId")]
		public System.Nullable<System.Int32> VoiceVlanId { get; set; }
	}
	
	public class UpdateNetworkSwitchAccessPolicyReturnRadiusAccountingServers
	{
		
		/// <summary>
		/// Public IP address of the RADIUS accounting server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// UDP port that the RADIUS Accounting server listens on for access requests
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
	}
	
	public class UpdateNetworkSwitchAccessPolicyReturnRadiusServers
	{
		
		/// <summary>
		/// Public IP address of the RADIUS server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// UDP port that the RADIUS server listens on for access requests
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
	}
	
	public class UpdateNetworkSwitchAlternateManagementInterfacePutBody
	{
		
		/// <summary>
		/// Boolean value to enable or disable AMI configuration. If enabled, VLAN and protocols must be set
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Can be one or more of the following values: 'radius', 'snmp' or 'syslog'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocols")]
		public string[] Protocols { get; set; }
		
		/// <summary>
		/// Array of switch serial number and IP assignment. If parameter is present, it cannot have empty body. Note: switches parameter is not applicable for template networks, in other words, do not put 'switches' in the body when updating template networks. Also, an empty 'switches' array will remove all previous assignments
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switches")]
		public UpdateNetworkSwitchAlternateManagementInterfacePutBodySwitches[] UpdateNetworkSwitchAlternateManagementInterfacePutBodySwitches { get; set; }
		
		/// <summary>
		/// Alternate management VLAN, must be between 1 and 4094
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public System.Nullable<System.Int32> VlanId { get; set; }
	}
	
	public class UpdateNetworkSwitchAlternateManagementInterfacePutBodySwitches
	{
		
		/// <summary>
		/// Switch alternative management IP. To remove a prior IP setting, provide an empty string
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="alternateManagementIp")]
		public string AlternateManagementIp { get; set; }
		
		/// <summary>
		/// Switch gateway must be in IP format. Only and must be specified for Polaris switches
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// Switch serial number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// Switch subnet mask must be in IP format. Only and must be specified for Polaris switches
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetMask")]
		public string SubnetMask { get; set; }
	}
	
	public class GetNetworkSwitchDhcpV4ServersSeenReturn
	{
		
		/// <summary>
		/// Client id of the server if available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientId")]
		public string ClientId { get; set; }
		
		/// <summary>
		/// Attributes of the server when it's a device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="device")]
		public GetNetworkSwitchDhcpV4ServersSeenReturnDevice Device { get; set; }
		
		/// <summary>
		/// IPv4 attributes of the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public GetNetworkSwitchDhcpV4ServersSeenReturnIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// Whether the server is allowed or blocked. Always true for configured servers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAllowed")]
		public System.Nullable<System.Boolean> IsAllowed { get; set; }
		
		/// <summary>
		/// Whether the server is configured.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isConfigured")]
		public System.Nullable<System.Boolean> IsConfigured { get; set; }
		
		/// <summary>
		/// Attributes of the server's last ack.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastAck")]
		public GetNetworkSwitchDhcpV4ServersSeenReturnLastAck LastAck { get; set; }
		
		/// <summary>
		/// Last packet the server received.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastPacket")]
		public GetNetworkSwitchDhcpV4ServersSeenReturnLastPacket LastPacket { get; set; }
		
		/// <summary>
		/// Last time the server was seen.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastSeenAt")]
		public System.Nullable<System.DateTimeOffset> LastSeenAt { get; set; }
		
		/// <summary>
		/// Mac address of the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// Devices that saw the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seenBy")]
		public GetNetworkSwitchDhcpV4ServersSeenReturnSeenBy[] GetNetworkSwitchDhcpV4ServersSeenReturnSeenBy { get; set; }
		
		/// <summary>
		/// server type. Can be a 'device', 'stack', or 'discovered' (i.e client).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<GetNetworkSwitchDhcpV4ServersSeenReturnType> Type { get; set; }
		
		/// <summary>
		/// Vlan id of the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class GetNetworkSwitchDhcpV4ServersSeenReturnDevice
	{
		
		/// <summary>
		/// Interface attributes of the server. Only for configured servers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interface")]
		public GetNetworkSwitchDhcpV4ServersSeenReturnDeviceInterface Interface { get; set; }
		
		/// <summary>
		/// Device name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Device serial.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// Url link to device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetNetworkSwitchDhcpV4ServersSeenReturnDeviceInterface
	{
		
		/// <summary>
		/// Interface name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Url link to interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetNetworkSwitchDhcpV4ServersSeenReturnIpv4
	{
		
		/// <summary>
		/// IPv4 address of the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// IPv4 gateway address of the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// Subnet of the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
	}
	
	public class GetNetworkSwitchDhcpV4ServersSeenReturnLastAck
	{
		
		/// <summary>
		/// IPv4 attributes of the last ack.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public GetNetworkSwitchDhcpV4ServersSeenReturnLastAckIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// Last time the server was acked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ts")]
		public System.Nullable<System.DateTimeOffset> Ts { get; set; }
	}
	
	public class GetNetworkSwitchDhcpV4ServersSeenReturnLastAckIpv4
	{
		
		/// <summary>
		/// IPv4 address of the last ack.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
	}
	
	public class GetNetworkSwitchDhcpV4ServersSeenReturnLastPacket
	{
		
		/// <summary>
		/// Destination of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketDestination Destination { get; set; }
		
		/// <summary>
		/// Additional ethernet attributes of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ethernet")]
		public GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketEthernet Ethernet { get; set; }
		
		/// <summary>
		/// DHCP-specific fields of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fields")]
		public GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketFields Fields { get; set; }
		
		/// <summary>
		/// Additional IP attributes of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIp Ip { get; set; }
		
		/// <summary>
		/// Source of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketSource Source { get; set; }
		
		/// <summary>
		/// Packet type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// UDP attributes of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="udp")]
		public GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketUdp Udp { get; set; }
	}
	
	public class GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketDestination
	{
		
		/// <summary>
		/// Destination ipv4 attributes of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketDestinationIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// Destination mac address of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// Destination port of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
	}
	
	public class GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketDestinationIpv4
	{
		
		/// <summary>
		/// Destination ipv4 address of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
	}
	
	public class GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketEthernet
	{
		
		/// <summary>
		/// Ethernet type of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketFields
	{
		
		/// <summary>
		/// Client hardware address of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="chaddr")]
		public string Chaddr { get; set; }
		
		/// <summary>
		/// Client IP address of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ciaddr")]
		public string Ciaddr { get; set; }
		
		/// <summary>
		/// Packet flags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="flags")]
		public string Flags { get; set; }
		
		/// <summary>
		/// Gateway IP address of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="giaddr")]
		public string Giaddr { get; set; }
		
		/// <summary>
		/// Hardware length of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hlen")]
		public System.Nullable<System.Int32> Hlen { get; set; }
		
		/// <summary>
		/// Number of hops the packet took.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hops")]
		public System.Nullable<System.Int32> Hops { get; set; }
		
		/// <summary>
		/// Hardware type code of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="htype")]
		public System.Nullable<System.Int32> Htype { get; set; }
		
		/// <summary>
		/// Magic cookie of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="magicCookie")]
		public string MagicCookie { get; set; }
		
		/// <summary>
		/// Operation code of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="op")]
		public System.Nullable<System.Int32> Op { get; set; }
		
		/// <summary>
		/// Additional DHCP options of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="options")]
		public GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketFieldsOptions[] GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketFieldsOptions { get; set; }
		
		/// <summary>
		/// Number of seconds since receiving the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secs")]
		public System.Nullable<System.Int32> Secs { get; set; }
		
		/// <summary>
		/// Server IP address of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="siaddr")]
		public string Siaddr { get; set; }
		
		/// <summary>
		/// Server identifier address of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sname")]
		public string Sname { get; set; }
		
		/// <summary>
		/// Transaction id of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xid")]
		public string Xid { get; set; }
		
		/// <summary>
		/// Assigned IP address of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="yiaddr")]
		public string Yiaddr { get; set; }
	}
	
	public class GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketFieldsOptions
	{
		
		/// <summary>
		/// Option name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Option value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIp
	{
		
		/// <summary>
		/// DSCP attributes of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dscp")]
		public GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIpDscp Dscp { get; set; }
		
		/// <summary>
		/// IP header length of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headerLength")]
		public System.Nullable<System.Int32> HeaderLength { get; set; }
		
		/// <summary>
		/// IP ID of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// IP length of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="length")]
		public System.Nullable<System.Int32> Length { get; set; }
		
		/// <summary>
		/// IP protocol number of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public System.Nullable<System.Int32> Protocol { get; set; }
		
		/// <summary>
		/// Time to live of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public System.Nullable<System.Int32> Ttl { get; set; }
		
		/// <summary>
		/// IP version of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public System.Nullable<GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIpVersion> Version { get; set; }
	}
	
	public class GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIpDscp
	{
		
		/// <summary>
		/// ECN number of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ecn")]
		public System.Nullable<System.Int32> Ecn { get; set; }
		
		/// <summary>
		/// DSCP tag number of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public System.Nullable<System.Int32> Tag { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketIpVersion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_4 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_6 = 6,
	}
	
	public class GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketSource
	{
		
		/// <summary>
		/// Source ipv4 attributes of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketSourceIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// Source mac address of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// Source port of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
	}
	
	public class GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketSourceIpv4
	{
		
		/// <summary>
		/// Source ipv4 address of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
	}
	
	public class GetNetworkSwitchDhcpV4ServersSeenReturnLastPacketUdp
	{
		
		/// <summary>
		/// UDP checksum of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="checksum")]
		public string Checksum { get; set; }
		
		/// <summary>
		/// UDP length of the packet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="length")]
		public System.Nullable<System.Int32> Length { get; set; }
	}
	
	public class GetNetworkSwitchDhcpV4ServersSeenReturnSeenBy
	{
		
		/// <summary>
		/// Device name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Device serial.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// Url link to device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkSwitchDhcpV4ServersSeenReturnType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		device = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		discovered = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stack = 2,
	}
	
	public class UpdateNetworkSwitchDhcpServerPolicyPutBody
	{
		
		/// <summary>
		/// Alert settings for DHCP servers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alerts")]
		public UpdateNetworkSwitchDhcpServerPolicyPutBodyAlerts Alerts { get; set; }
		
		/// <summary>
		/// List the MAC addresses of DHCP servers to permit on the network when defaultPolicy is set to block. An empty array will clear the entries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedServers")]
		public string[] AllowedServers { get; set; }
		
		/// <summary>
		/// Dynamic ARP Inspection settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="arpInspection")]
		public UpdateNetworkSwitchDhcpServerPolicyPutBodyArpInspection ArpInspection { get; set; }
		
		/// <summary>
		/// List the MAC addresses of DHCP servers to block on the network when defaultPolicy is set to allow. An empty array will clear the entries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockedServers")]
		public string[] BlockedServers { get; set; }
		
		/// <summary>
		/// 'allow' or 'block' new DHCP servers. Default value is 'allow'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultPolicy")]
		public System.Nullable<UpdateNetworkSwitchDhcpServerPolicyPutBodyDefaultPolicy> DefaultPolicy { get; set; }
	}
	
	public class UpdateNetworkSwitchDhcpServerPolicyPutBodyAlerts
	{
		
		/// <summary>
		/// Email alert settings for DHCP servers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public UpdateNetworkSwitchDhcpServerPolicyPutBodyAlertsEmail Email { get; set; }
	}
	
	public class UpdateNetworkSwitchDhcpServerPolicyPutBodyAlertsEmail
	{
		
		/// <summary>
		/// When enabled, send an email if a new DHCP server is seen. Default value is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateNetworkSwitchDhcpServerPolicyPutBodyArpInspection
	{
		
		/// <summary>
		/// Enable or disable Dynamic ARP Inspection on the network. Default value is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSwitchDhcpServerPolicyPutBodyDefaultPolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		allow = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		block = 1,
	}
	
	public class GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersReturn
	{
		
		/// <summary>
		/// IPv4 attributes of the trusted server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersReturnIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// Mac address of the trusted server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// ID of the trusted server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trustedServerId")]
		public string TrustedServerId { get; set; }
		
		/// <summary>
		/// Vlan ID of the trusted server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class GetNetworkSwitchDhcpServerPolicyArpInspectionTrustedServersReturnIpv4
	{
		
		/// <summary>
		/// IPv4 address of the trusted server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
	}
	
	public class CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPostBody
	{
		
		/// <summary>
		/// The IPv4 attributes of the trusted server being added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPostBodyIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// The mac address of the trusted server being added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// The VLAN of the trusted server being added. It must be between 1 and 4094
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public int Vlan { get; set; }
	}
	
	public class CreateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPostBodyIpv4
	{
		
		/// <summary>
		/// The IPv4 address of the trusted server being added
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
	}
	
	public class UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPutBody
	{
		
		/// <summary>
		/// The updated IPv4 attributes of the trusted server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPutBodyIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// The updated mac address of the trusted server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// The updated VLAN of the trusted server. It must be between 1 and 4094
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerPutBodyIpv4
	{
		
		/// <summary>
		/// The updated IPv4 address of the trusted server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
	}
	
	public class UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerReturn
	{
		
		/// <summary>
		/// IPv4 attributes of the trusted server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerReturnIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// Mac address of the trusted server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// ID of the trusted server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trustedServerId")]
		public string TrustedServerId { get; set; }
		
		/// <summary>
		/// Vlan ID of the trusted server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class UpdateNetworkSwitchDhcpServerPolicyArpInspectionTrustedServerReturnIpv4
	{
		
		/// <summary>
		/// IPv4 address of the trusted server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
	}
	
	public class GetNetworkSwitchDhcpServerPolicyArpInspectionWarningsByDeviceReturn
	{
		
		/// <summary>
		/// Whether this switch has a trusted DAI port. Always false if supportsInspection is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasTrustedPort")]
		public System.Nullable<System.Boolean> HasTrustedPort { get; set; }
		
		/// <summary>
		/// Switch name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Switch serial.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// Whether this switch supports Dynamic ARP Inspection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="supportsInspection")]
		public System.Nullable<System.Boolean> SupportsInspection { get; set; }
		
		/// <summary>
		/// Url link to switch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class UpdateNetworkSwitchDscpToCosMappingsPutBody
	{
		
		/// <summary>
		/// An array of DSCP to CoS mappings. An empty array will reset the mappings to default.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mappings")]
		public UpdateNetworkSwitchDscpToCosMappingsPutBodyMappings[] UpdateNetworkSwitchDscpToCosMappingsPutBodyMappings { get; set; }
	}
	
	public class UpdateNetworkSwitchDscpToCosMappingsPutBodyMappings
	{
		
		/// <summary>
		/// The actual layer-2 CoS queue the DSCP value is mapped to. These are not bits set on outgoing frames. Value can be in the range of 0 to 5 inclusive.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cos")]
		public int Cos { get; set; }
		
		/// <summary>
		/// The Differentiated Services Code Point (DSCP) tag in the IP header that will be mapped to a particular Class-of-Service (CoS) queue. Value can be in the range of 0 to 63 inclusive.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dscp")]
		public int Dscp { get; set; }
		
		/// <summary>
		/// Label for the mapping (optional).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class CreateNetworkSwitchLinkAggregationPostBody
	{
		
		/// <summary>
		/// Array of switch or stack ports for creating aggregation group. Minimum 2 and maximum 8 ports are supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchPorts")]
		public CreateNetworkSwitchLinkAggregationPostBodySwitchPorts[] CreateNetworkSwitchLinkAggregationPostBodySwitchPorts { get; set; }
		
		/// <summary>
		/// Array of switch profile ports for creating aggregation group. Minimum 2 and maximum 8 ports are supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchProfilePorts")]
		public CreateNetworkSwitchLinkAggregationPostBodySwitchProfilePorts[] CreateNetworkSwitchLinkAggregationPostBodySwitchProfilePorts { get; set; }
	}
	
	public class CreateNetworkSwitchLinkAggregationPostBodySwitchPorts
	{
		
		/// <summary>
		/// Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portId")]
		public string PortId { get; set; }
		
		/// <summary>
		/// Serial number of the switch.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class CreateNetworkSwitchLinkAggregationPostBodySwitchProfilePorts
	{
		
		/// <summary>
		/// Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portId")]
		public string PortId { get; set; }
		
		/// <summary>
		/// Profile identifier.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="profile")]
		public string Profile { get; set; }
	}
	
	public class UpdateNetworkSwitchLinkAggregationPutBody
	{
		
		/// <summary>
		/// Array of switch or stack ports for updating aggregation group. Minimum 2 and maximum 8 ports are supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchPorts")]
		public UpdateNetworkSwitchLinkAggregationPutBodySwitchPorts[] UpdateNetworkSwitchLinkAggregationPutBodySwitchPorts { get; set; }
		
		/// <summary>
		/// Array of switch profile ports for updating aggregation group. Minimum 2 and maximum 8 ports are supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchProfilePorts")]
		public UpdateNetworkSwitchLinkAggregationPutBodySwitchProfilePorts[] UpdateNetworkSwitchLinkAggregationPutBodySwitchProfilePorts { get; set; }
	}
	
	public class UpdateNetworkSwitchLinkAggregationPutBodySwitchPorts
	{
		
		/// <summary>
		/// Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portId")]
		public string PortId { get; set; }
		
		/// <summary>
		/// Serial number of the switch.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class UpdateNetworkSwitchLinkAggregationPutBodySwitchProfilePorts
	{
		
		/// <summary>
		/// Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portId")]
		public string PortId { get; set; }
		
		/// <summary>
		/// Profile identifier.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="profile")]
		public string Profile { get; set; }
	}
	
	public class GetNetworkSwitchMtuReturn
	{
		
		/// <summary>
		/// MTU size for the entire network. Default value is 9578.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultMtuSize")]
		public System.Nullable<System.Int32> DefaultMtuSize { get; set; }
		
		/// <summary>
		/// Override MTU size for individual switches or switch profiles.
		///      An empty array will clear overrides.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="overrides")]
		public GetNetworkSwitchMtuReturnOverrides[] GetNetworkSwitchMtuReturnOverrides { get; set; }
	}
	
	public class GetNetworkSwitchMtuReturnOverrides
	{
		
		/// <summary>
		/// MTU size for the switches or switch profiles.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mtuSize")]
		public int MtuSize { get; set; }
		
		/// <summary>
		/// List of switch profile IDs. Applicable only for template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchProfiles")]
		public string[] SwitchProfiles { get; set; }
		
		/// <summary>
		/// List of switch serials. Applicable only for switch network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switches")]
		public string[] Switches { get; set; }
	}
	
	public class UpdateNetworkSwitchMtuPutBody
	{
		
		/// <summary>
		/// MTU size for the entire network. Default value is 9578.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultMtuSize")]
		public System.Nullable<System.Int32> DefaultMtuSize { get; set; }
		
		/// <summary>
		/// Override MTU size for individual switches or switch profiles. An empty array will clear overrides.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="overrides")]
		public UpdateNetworkSwitchMtuPutBodyOverrides[] UpdateNetworkSwitchMtuPutBodyOverrides { get; set; }
	}
	
	public class UpdateNetworkSwitchMtuPutBodyOverrides
	{
		
		/// <summary>
		/// MTU size for the switches or switch profiles.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mtuSize")]
		public int MtuSize { get; set; }
		
		/// <summary>
		/// List of switch profile IDs. Applicable only for template network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchProfiles")]
		public string[] SwitchProfiles { get; set; }
		
		/// <summary>
		/// List of switch serials. Applicable only for switch network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switches")]
		public string[] Switches { get; set; }
	}
	
	public class CreateNetworkSwitchPortSchedulePostBody
	{
		
		/// <summary>
		/// The name for your port schedule. Required
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		///     The schedule for switch port scheduling. Schedules are applied to days of the week.
		///    When it's empty, default schedule with all days of a week are configured.
		///    Any unspecified day in the schedule is added as a default schedule configuration of the day.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portSchedule")]
		public CreateNetworkSwitchPortSchedulePostBodyPortSchedule PortSchedule { get; set; }
	}
	
	public class CreateNetworkSwitchPortSchedulePostBodyPortSchedule
	{
		
		/// <summary>
		/// The schedule object for Friday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="friday")]
		public CreateNetworkSwitchPortSchedulePostBodyPortScheduleFriday Friday { get; set; }
		
		/// <summary>
		/// The schedule object for Monday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monday")]
		public CreateNetworkSwitchPortSchedulePostBodyPortScheduleMonday Monday { get; set; }
		
		/// <summary>
		/// The schedule object for Saturday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="saturday")]
		public CreateNetworkSwitchPortSchedulePostBodyPortScheduleSaturday Saturday { get; set; }
		
		/// <summary>
		/// The schedule object for Sunday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sunday")]
		public CreateNetworkSwitchPortSchedulePostBodyPortScheduleSunday Sunday { get; set; }
		
		/// <summary>
		/// The schedule object for Thursday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thursday")]
		public CreateNetworkSwitchPortSchedulePostBodyPortScheduleThursday Thursday { get; set; }
		
		/// <summary>
		/// The schedule object for Tuesday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tuesday")]
		public CreateNetworkSwitchPortSchedulePostBodyPortScheduleTuesday Tuesday { get; set; }
		
		/// <summary>
		/// The schedule object for Wednesday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wednesday")]
		public CreateNetworkSwitchPortSchedulePostBodyPortScheduleWednesday Wednesday { get; set; }
	}
	
	public class CreateNetworkSwitchPortSchedulePostBodyPortScheduleFriday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateNetworkSwitchPortSchedulePostBodyPortScheduleMonday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateNetworkSwitchPortSchedulePostBodyPortScheduleSaturday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateNetworkSwitchPortSchedulePostBodyPortScheduleSunday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateNetworkSwitchPortSchedulePostBodyPortScheduleThursday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateNetworkSwitchPortSchedulePostBodyPortScheduleTuesday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateNetworkSwitchPortSchedulePostBodyPortScheduleWednesday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkSwitchPortSchedulePutBody
	{
		
		/// <summary>
		/// The name for your port schedule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		///     The schedule for switch port scheduling. Schedules are applied to days of the week.
		///    When it's empty, default schedule with all days of a week are configured.
		///    Any unspecified day in the schedule is added as a default schedule configuration of the day.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portSchedule")]
		public UpdateNetworkSwitchPortSchedulePutBodyPortSchedule PortSchedule { get; set; }
	}
	
	public class UpdateNetworkSwitchPortSchedulePutBodyPortSchedule
	{
		
		/// <summary>
		/// The schedule object for Friday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="friday")]
		public UpdateNetworkSwitchPortSchedulePutBodyPortScheduleFriday Friday { get; set; }
		
		/// <summary>
		/// The schedule object for Monday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monday")]
		public UpdateNetworkSwitchPortSchedulePutBodyPortScheduleMonday Monday { get; set; }
		
		/// <summary>
		/// The schedule object for Saturday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="saturday")]
		public UpdateNetworkSwitchPortSchedulePutBodyPortScheduleSaturday Saturday { get; set; }
		
		/// <summary>
		/// The schedule object for Sunday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sunday")]
		public UpdateNetworkSwitchPortSchedulePutBodyPortScheduleSunday Sunday { get; set; }
		
		/// <summary>
		/// The schedule object for Thursday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thursday")]
		public UpdateNetworkSwitchPortSchedulePutBodyPortScheduleThursday Thursday { get; set; }
		
		/// <summary>
		/// The schedule object for Tuesday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tuesday")]
		public UpdateNetworkSwitchPortSchedulePutBodyPortScheduleTuesday Tuesday { get; set; }
		
		/// <summary>
		/// The schedule object for Wednesday.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wednesday")]
		public UpdateNetworkSwitchPortSchedulePutBodyPortScheduleWednesday Wednesday { get; set; }
	}
	
	public class UpdateNetworkSwitchPortSchedulePutBodyPortScheduleFriday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkSwitchPortSchedulePutBodyPortScheduleMonday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkSwitchPortSchedulePutBodyPortScheduleSaturday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkSwitchPortSchedulePutBodyPortScheduleSunday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkSwitchPortSchedulePutBodyPortScheduleThursday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkSwitchPortSchedulePutBodyPortScheduleTuesday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class UpdateNetworkSwitchPortSchedulePutBodyPortScheduleWednesday
	{
		
		/// <summary>
		/// Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateNetworkSwitchQosRulePostBody
	{
		
		/// <summary>
		/// DSCP tag. Set this to -1 to trust incoming DSCP. Default value is 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dscp")]
		public System.Nullable<System.Int32> Dscp { get; set; }
		
		/// <summary>
		/// The destination port of the incoming packet. Applicable only if protocol is TCP or UDP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstPort")]
		public System.Nullable<System.Int32> DstPort { get; set; }
		
		/// <summary>
		/// The destination port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstPortRange")]
		public string DstPortRange { get; set; }
		
		/// <summary>
		/// The protocol of the incoming packet. Can be one of "ANY", "TCP" or "UDP". Default value is "ANY"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public System.Nullable<CreateNetworkSwitchQosRulePostBodyProtocol> Protocol { get; set; }
		
		/// <summary>
		/// The source port of the incoming packet. Applicable only if protocol is TCP or UDP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPort")]
		public System.Nullable<System.Int32> SrcPort { get; set; }
		
		/// <summary>
		/// The source port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPortRange")]
		public string SrcPortRange { get; set; }
		
		/// <summary>
		/// The VLAN of the incoming packet. A null value will match any VLAN.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public int Vlan { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkSwitchQosRulePostBodyProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TCP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UDP = 2,
	}
	
	public class UpdateNetworkSwitchQosRulesOrderPutBody
	{
		
		/// <summary>
		/// A list of quality of service rule IDs arranged in order in which they should be processed by the switch.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleIds")]
		public string[] RuleIds { get; set; }
	}
	
	public class UpdateNetworkSwitchQosRulePutBody
	{
		
		/// <summary>
		/// DSCP tag that should be assigned to incoming packet. Set this to -1 to trust incoming DSCP. Default value is 0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dscp")]
		public System.Nullable<System.Int32> Dscp { get; set; }
		
		/// <summary>
		/// The destination port of the incoming packet. Applicable only if protocol is TCP or UDP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstPort")]
		public System.Nullable<System.Int32> DstPort { get; set; }
		
		/// <summary>
		/// The destination port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstPortRange")]
		public string DstPortRange { get; set; }
		
		/// <summary>
		/// The protocol of the incoming packet. Can be one of "ANY", "TCP" or "UDP". Default value is "ANY".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public CreateNetworkSwitchQosRulePostBodyProtocol Protocol { get; set; }
		
		/// <summary>
		/// The source port of the incoming packet. Applicable only if protocol is TCP or UDP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPort")]
		public System.Nullable<System.Int32> SrcPort { get; set; }
		
		/// <summary>
		/// The source port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPortRange")]
		public string SrcPortRange { get; set; }
		
		/// <summary>
		/// The VLAN of the incoming packet. A null value will match any VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class UpdateNetworkSwitchRoutingMulticastPutBody
	{
		
		/// <summary>
		/// Default multicast setting for entire network. IGMP snooping and Flood unknown multicast traffic settings are enabled by default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultSettings")]
		public UpdateNetworkSwitchRoutingMulticastPutBodyDefaultSettings DefaultSettings { get; set; }
		
		/// <summary>
		/// Array of paired switches/stacks/profiles and corresponding multicast settings. An empty array will clear the multicast settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="overrides")]
		public UpdateNetworkSwitchRoutingMulticastPutBodyOverrides[] UpdateNetworkSwitchRoutingMulticastPutBodyOverrides { get; set; }
	}
	
	public class UpdateNetworkSwitchRoutingMulticastPutBodyDefaultSettings
	{
		
		/// <summary>
		/// Flood unknown multicast traffic setting for entire network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="floodUnknownMulticastTrafficEnabled")]
		public System.Nullable<System.Boolean> FloodUnknownMulticastTrafficEnabled { get; set; }
		
		/// <summary>
		/// IGMP snooping setting for entire network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="igmpSnoopingEnabled")]
		public System.Nullable<System.Boolean> IgmpSnoopingEnabled { get; set; }
	}
	
	public class UpdateNetworkSwitchRoutingMulticastPutBodyOverrides
	{
		
		/// <summary>
		/// Flood unknown multicast traffic setting for switches, switch stacks or switch profiles
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="floodUnknownMulticastTrafficEnabled")]
		public bool FloodUnknownMulticastTrafficEnabled { get; set; }
		
		/// <summary>
		/// IGMP snooping setting for switches, switch stacks or switch profiles
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="igmpSnoopingEnabled")]
		public bool IgmpSnoopingEnabled { get; set; }
		
		/// <summary>
		/// List of switch stack ids for non-template network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stacks")]
		public string[] Stacks { get; set; }
		
		/// <summary>
		/// List of switch profiles ids for template network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchProfiles")]
		public string[] SwitchProfiles { get; set; }
		
		/// <summary>
		/// List of switch serials for non-template network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switches")]
		public string[] Switches { get; set; }
	}
	
	public class CreateNetworkSwitchRoutingMulticastRendezvousPointPostBody
	{
		
		/// <summary>
		/// The IP address of the interface where the RP needs to be created.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="interfaceIp")]
		public string InterfaceIp { get; set; }
		
		/// <summary>
		/// 'Any', or the IP address of a multicast group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="multicastGroup")]
		public string MulticastGroup { get; set; }
	}
	
	public class UpdateNetworkSwitchRoutingMulticastRendezvousPointPutBody
	{
		
		/// <summary>
		/// The IP address of the interface to use
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="interfaceIp")]
		public string InterfaceIp { get; set; }
		
		/// <summary>
		/// 'Any', or the IP address of a multicast group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="multicastGroup")]
		public string MulticastGroup { get; set; }
	}
	
	public class UpdateNetworkSwitchRoutingOspfPutBody
	{
		
		/// <summary>
		/// OSPF areas
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="areas")]
		public UpdateNetworkSwitchRoutingOspfPutBodyAreas[] UpdateNetworkSwitchRoutingOspfPutBodyAreas { get; set; }
		
		/// <summary>
		/// Time interval to determine when the peer will be declared inactive/dead. Value must be between 1 and 65535
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deadTimerInSeconds")]
		public System.Nullable<System.Int32> DeadTimerInSeconds { get; set; }
		
		/// <summary>
		/// Boolean value to enable or disable OSPF routing. OSPF routing is disabled by default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Time interval in seconds at which hello packet will be sent to OSPF neighbors to maintain connectivity. Value must be between 1 and 255. Default is 10 seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helloTimerInSeconds")]
		public System.Nullable<System.Int32> HelloTimerInSeconds { get; set; }
		
		/// <summary>
		/// Boolean value to enable or disable MD5 authentication. MD5 authentication is disabled by default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="md5AuthenticationEnabled")]
		public System.Nullable<System.Boolean> Md5AuthenticationEnabled { get; set; }
		
		/// <summary>
		/// MD5 authentication credentials. This param is only relevant if md5AuthenticationEnabled is true
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="md5AuthenticationKey")]
		public UpdateNetworkSwitchRoutingOspfPutBodyMd5AuthenticationKey Md5AuthenticationKey { get; set; }
		
		/// <summary>
		/// OSPF v3 configuration
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="v3")]
		public UpdateNetworkSwitchRoutingOspfPutBodyV3 V3 { get; set; }
	}
	
	public class UpdateNetworkSwitchRoutingOspfPutBodyAreas
	{
		
		/// <summary>
		/// OSPF area ID
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="areaId")]
		public string AreaId { get; set; }
		
		/// <summary>
		/// Name of the OSPF area
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="areaName")]
		public string AreaName { get; set; }
		
		/// <summary>
		/// Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="areaType")]
		public UpdateNetworkSwitchRoutingOspfPutBodyAreasAreaType AreaType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSwitchRoutingOspfPutBodyAreasAreaType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		normal = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		nssa = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stub = 2,
	}
	
	public class UpdateNetworkSwitchRoutingOspfPutBodyMd5AuthenticationKey
	{
		
		/// <summary>
		/// MD5 authentication key index. Key index must be between 1 to 255
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// MD5 authentication passphrase
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="passphrase")]
		public string Passphrase { get; set; }
	}
	
	public class UpdateNetworkSwitchRoutingOspfPutBodyV3
	{
		
		/// <summary>
		/// OSPF v3 areas
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="areas")]
		public UpdateNetworkSwitchRoutingOspfPutBodyV3Areas[] UpdateNetworkSwitchRoutingOspfPutBodyV3Areas { get; set; }
		
		/// <summary>
		/// Time interval to determine when the peer will be declared inactive/dead. Value must be between 1 and 65535
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deadTimerInSeconds")]
		public System.Nullable<System.Int32> DeadTimerInSeconds { get; set; }
		
		/// <summary>
		/// Boolean value to enable or disable V3 OSPF routing. OSPF V3 routing is disabled by default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Time interval in seconds at which hello packet will be sent to OSPF neighbors to maintain connectivity. Value must be between 1 and 255. Default is 10 seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helloTimerInSeconds")]
		public System.Nullable<System.Int32> HelloTimerInSeconds { get; set; }
	}
	
	public class UpdateNetworkSwitchRoutingOspfPutBodyV3Areas
	{
		
		/// <summary>
		/// OSPF area ID
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="areaId")]
		public string AreaId { get; set; }
		
		/// <summary>
		/// Name of the OSPF area
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="areaName")]
		public string AreaName { get; set; }
		
		/// <summary>
		/// Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="areaType")]
		public UpdateNetworkSwitchRoutingOspfPutBodyAreasAreaType AreaType { get; set; }
	}
	
	public class GetNetworkSwitchSettingsReturn
	{
		
		/// <summary>
		/// Exceptions on a per switch basis to "useCombinedPower"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="powerExceptions")]
		public GetNetworkSwitchSettingsReturnPowerExceptions[] GetNetworkSwitchSettingsReturnPowerExceptions { get; set; }
		
		/// <summary>
		/// The use Combined Power as the default behavior of secondary power supplies on supported devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useCombinedPower")]
		public System.Nullable<System.Boolean> UseCombinedPower { get; set; }
		
		/// <summary>
		/// Management VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class GetNetworkSwitchSettingsReturnPowerExceptions
	{
		
		/// <summary>
		/// Per switch exception (combined, redundant, useNetworkSetting)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="powerType")]
		public System.Nullable<GetNetworkSwitchSettingsReturnPowerExceptionsPowerType> PowerType { get; set; }
		
		/// <summary>
		/// Serial number of the switch
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkSwitchSettingsReturnPowerExceptionsPowerType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		combined = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		redundant = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		useNetworkSetting = 2,
	}
	
	public class UpdateNetworkSwitchSettingsPutBody
	{
		
		/// <summary>
		/// Exceptions on a per switch basis to "useCombinedPower"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="powerExceptions")]
		public UpdateNetworkSwitchSettingsPutBodyPowerExceptions[] UpdateNetworkSwitchSettingsPutBodyPowerExceptions { get; set; }
		
		/// <summary>
		/// The use Combined Power as the default behavior of secondary power supplies on supported devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useCombinedPower")]
		public System.Nullable<System.Boolean> UseCombinedPower { get; set; }
		
		/// <summary>
		/// Management VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class UpdateNetworkSwitchSettingsPutBodyPowerExceptions
	{
		
		/// <summary>
		/// Per switch exception (combined, redundant, useNetworkSetting)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="powerType")]
		public GetNetworkSwitchSettingsReturnPowerExceptionsPowerType PowerType { get; set; }
		
		/// <summary>
		/// Serial number of the switch
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class UpdateNetworkSwitchSettingsReturn
	{
		
		/// <summary>
		/// Exceptions on a per switch basis to "useCombinedPower"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="powerExceptions")]
		public UpdateNetworkSwitchSettingsReturnPowerExceptions[] UpdateNetworkSwitchSettingsReturnPowerExceptions { get; set; }
		
		/// <summary>
		/// The use Combined Power as the default behavior of secondary power supplies on supported devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useCombinedPower")]
		public System.Nullable<System.Boolean> UseCombinedPower { get; set; }
		
		/// <summary>
		/// Management VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public class UpdateNetworkSwitchSettingsReturnPowerExceptions
	{
		
		/// <summary>
		/// Per switch exception (combined, redundant, useNetworkSetting)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="powerType")]
		public GetNetworkSwitchSettingsReturnPowerExceptionsPowerType PowerType { get; set; }
		
		/// <summary>
		/// Serial number of the switch
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class CreateNetworkSwitchStackPostBody
	{
		
		/// <summary>
		/// The name of the new stack
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// An array of switch serials to be added into the new stack
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string[] Serials { get; set; }
	}
	
	public class GetNetworkSwitchStackReturn
	{
		
		/// <summary>
		/// Switch stacks id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Switch stacks name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Serials of the switches in the switch stack
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string[] Serials { get; set; }
	}
	
	public class AddNetworkSwitchStackPostBody
	{
		
		/// <summary>
		/// The serial of the switch to be added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class RemoveNetworkSwitchStackPostBody
	{
		
		/// <summary>
		/// The serial of the switch to be removed
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class CreateNetworkSwitchStackRoutingInterfacePostBody
	{
		
		/// <summary>
		/// The next hop for any traffic that isn't going to a directly connected subnet or over a static route. This IP address must exist in a subnet with a routed interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultGateway")]
		public string DefaultGateway { get; set; }
		
		/// <summary>
		/// The IP address this switch stack will use for layer 3 routing on this VLAN or subnet. This cannot be the same as the switch's management IP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaceIp")]
		public string InterfaceIp { get; set; }
		
		/// <summary>
		/// The IPv6 settings of the interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public CreateNetworkSwitchStackRoutingInterfacePostBodyIpv6 Ipv6 { get; set; }
		
		/// <summary>
		/// Enable multicast support if, multicast routing between VLANs is required. Options are, 'disabled', 'enabled' or 'IGMP snooping querier'. Default is 'disabled'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multicastRouting")]
		public System.Nullable<CreateNetworkSwitchStackRoutingInterfacePostBodyMulticastRouting> MulticastRouting { get; set; }
		
		/// <summary>
		/// A friendly name or description for the interface or VLAN.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The OSPF routing settings of the interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ospfSettings")]
		public CreateNetworkSwitchStackRoutingInterfacePostBodyOspfSettings OspfSettings { get; set; }
		
		/// <summary>
		/// The network that this routed interface is on, in CIDR notation (ex. 10.1.1.0/24).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
		
		/// <summary>
		/// The VLAN this routed interface is on. VLAN must be between 1 and 4094.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public int VlanId { get; set; }
	}
	
	public class CreateNetworkSwitchStackRoutingInterfacePostBodyIpv6
	{
		
		/// <summary>
		/// The IPv6 address of the interface. Required if assignmentMode is 'static'. Must not be included if assignmentMode is 'eui-64'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The IPv6 assignment mode for the interface. Can be either 'eui-64' or 'static'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignmentMode")]
		public string AssignmentMode { get; set; }
		
		/// <summary>
		/// The IPv6 default gateway of the interface. Required if prefix is defined and this is the first interface with IPv6 configured for the stack.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The IPv6 prefix of the interface. Required if IPv6 object is included.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkSwitchStackRoutingInterfacePostBodyMulticastRouting
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IGMP snooping querier")]
		IGMP_snooping_querier = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 2,
	}
	
	public class CreateNetworkSwitchStackRoutingInterfacePostBodyOspfSettings
	{
		
		/// <summary>
		/// The OSPF area to which this interface should belong. Can be either 'disabled' or the identifier of an existing OSPF area. Defaults to 'disabled'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="area")]
		public string Area { get; set; }
		
		/// <summary>
		/// The path cost for this interface. Defaults to 1, but can be increased up to 65535 to give lower priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cost")]
		public System.Nullable<System.Int32> Cost { get; set; }
		
		/// <summary>
		/// When enabled, OSPF will not run on the interface, but the subnet will still be advertised.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPassiveEnabled")]
		public System.Nullable<System.Boolean> IsPassiveEnabled { get; set; }
	}
	
	public class UpdateNetworkSwitchStackRoutingInterfacePutBody
	{
		
		/// <summary>
		/// The next hop for any traffic that isn't going to a directly connected subnet or over a static route. This IP address must exist in a subnet with a routed interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultGateway")]
		public string DefaultGateway { get; set; }
		
		/// <summary>
		/// The IP address this switch stack will use for layer 3 routing on this VLAN or subnet. This cannot be the same as the switch's management IP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaceIp")]
		public string InterfaceIp { get; set; }
		
		/// <summary>
		/// The IPv6 settings of the interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public UpdateNetworkSwitchStackRoutingInterfacePutBodyIpv6 Ipv6 { get; set; }
		
		/// <summary>
		/// Enable multicast support if, multicast routing between VLANs is required. Options are, 'disabled', 'enabled' or 'IGMP snooping querier'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multicastRouting")]
		public System.Nullable<UpdateNetworkSwitchStackRoutingInterfacePutBodyMulticastRouting> MulticastRouting { get; set; }
		
		/// <summary>
		/// A friendly name or description for the interface or VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The OSPF routing settings of the interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ospfSettings")]
		public UpdateNetworkSwitchStackRoutingInterfacePutBodyOspfSettings OspfSettings { get; set; }
		
		/// <summary>
		/// The network that this routed interface is on, in CIDR notation (ex. 10.1.1.0/24).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
		
		/// <summary>
		/// The VLAN this routed interface is on. VLAN must be between 1 and 4094.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public System.Nullable<System.Int32> VlanId { get; set; }
	}
	
	public class UpdateNetworkSwitchStackRoutingInterfacePutBodyIpv6
	{
		
		/// <summary>
		/// The IPv6 address of the interface. Required if assignmentMode is included and set as 'static'. Must not be included if assignmentMode is 'eui-64'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The IPv6 assignment mode for the interface. Can be either 'eui-64' or 'static'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignmentMode")]
		public string AssignmentMode { get; set; }
		
		/// <summary>
		/// The IPv6 default gateway of the interface. Required if prefix is defined and this is the first interface with IPv6 configured for the stack.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The IPv6 prefix of the interface. Required if IPv6 object is included and interface does not already have ipv6.prefix configured
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSwitchStackRoutingInterfacePutBodyMulticastRouting
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IGMP snooping querier")]
		IGMP_snooping_querier = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 2,
	}
	
	public class UpdateNetworkSwitchStackRoutingInterfacePutBodyOspfSettings
	{
		
		/// <summary>
		/// The OSPF area to which this interface should belong. Can be either 'disabled' or the identifier of an existing OSPF area.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="area")]
		public string Area { get; set; }
		
		/// <summary>
		/// The path cost for this interface. Defaults to 1, but can be increased up to 65535 to give lower priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cost")]
		public System.Nullable<System.Int32> Cost { get; set; }
		
		/// <summary>
		/// When enabled, OSPF will not run on the interface, but the subnet will still be advertised.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPassiveEnabled")]
		public System.Nullable<System.Boolean> IsPassiveEnabled { get; set; }
	}
	
	public class UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBody
	{
		
		/// <summary>
		/// The PXE boot server file name for the DHCP server running on the switch stack interface
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bootFileName")]
		public string BootFileName { get; set; }
		
		/// <summary>
		/// The PXE boot server IP for the DHCP server running on the switch stack interface
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bootNextServer")]
		public string BootNextServer { get; set; }
		
		/// <summary>
		/// Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch stack interface
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bootOptionsEnabled")]
		public System.Nullable<System.Boolean> BootOptionsEnabled { get; set; }
		
		/// <summary>
		/// The DHCP lease time config for the dhcp server running on switch stack interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpLeaseTime")]
		public System.Nullable<UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyDhcpLeaseTime> DhcpLeaseTime { get; set; }
		
		/// <summary>
		/// The DHCP mode options for the switch stack interface ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpMode")]
		public UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpMode DhcpMode { get; set; }
		
		/// <summary>
		/// Array of DHCP options consisting of code, type and value for the DHCP server running on the switch stack interface
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpOptions")]
		public UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyDhcpOptions[] UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyDhcpOptions { get; set; }
		
		/// <summary>
		/// The DHCP relay server IPs to which DHCP packets would get relayed for the switch stack interface
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcpRelayServerIps")]
		public string[] DhcpRelayServerIps { get; set; }
		
		/// <summary>
		/// The DHCP name server IPs when DHCP name server option is 'custom'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsCustomNameservers")]
		public string[] DnsCustomNameservers { get; set; }
		
		/// <summary>
		/// The DHCP name server option for the dhcp server running on the switch stack interface ('googlePublicDns', 'openDns' or 'custom')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsNameserversOption")]
		public UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDnsNameserversOption DnsNameserversOption { get; set; }
		
		/// <summary>
		/// Array of DHCP fixed IP assignments for the DHCP server running on the switch stack interface
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixedIpAssignments")]
		public UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyFixedIpAssignments[] UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyFixedIpAssignments { get; set; }
		
		/// <summary>
		/// Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservedIpRanges")]
		public UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyReservedIpRanges[] UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyReservedIpRanges { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyDhcpLeaseTime
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 day")]
		_1_day = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 hour")]
		_1_hour = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 week")]
		_1_week = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="12 hours")]
		_12_hours = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="30 minutes")]
		_30_minutes = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4 hours")]
		_4_hours = 5,
	}
	
	public class UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyDhcpOptions
	{
		
		/// <summary>
		/// The code for DHCP option which should be from 2 to 254
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public UpdateDeviceSwitchRoutingInterfaceDhcpPutBodyDhcpOptionsType Type { get; set; }
		
		/// <summary>
		/// The value of the DHCP option
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyFixedIpAssignments
	{
		
		/// <summary>
		/// The IP address of the client which has fixed IP address assigned to it
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// The MAC address of the client which has fixed IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// The name of the client which has fixed IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateNetworkSwitchStackRoutingInterfaceDhcpPutBodyReservedIpRanges
	{
		
		/// <summary>
		/// The comment for the reserved IP range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// The ending IP address of the reserved IP range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="end")]
		public string End { get; set; }
		
		/// <summary>
		/// The starting IP address of the reserved IP range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start")]
		public string Start { get; set; }
	}
	
	public class GetNetworkSwitchStormControlReturn
	{
		
		/// <summary>
		/// Broadcast threshold.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="broadcastThreshold")]
		public System.Nullable<System.Int32> BroadcastThreshold { get; set; }
		
		/// <summary>
		/// Multicast threshold.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multicastThreshold")]
		public System.Nullable<System.Int32> MulticastThreshold { get; set; }
		
		/// <summary>
		/// Unknown Unicast threshold.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unknownUnicastThreshold")]
		public System.Nullable<System.Int32> UnknownUnicastThreshold { get; set; }
	}
	
	public class UpdateNetworkSwitchStormControlPutBody
	{
		
		/// <summary>
		/// Percentage (1 to 99) of total available port bandwidth for broadcast traffic type. Default value 100 percent rate is to clear the configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="broadcastThreshold")]
		public System.Nullable<System.Int32> BroadcastThreshold { get; set; }
		
		/// <summary>
		/// Percentage (1 to 99) of total available port bandwidth for multicast traffic type. Default value 100 percent rate is to clear the configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multicastThreshold")]
		public System.Nullable<System.Int32> MulticastThreshold { get; set; }
		
		/// <summary>
		/// Percentage (1 to 99) of total available port bandwidth for unknown unicast (dlf-destination lookup failure) traffic type. Default value 100 percent rate is to clear the configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unknownUnicastThreshold")]
		public System.Nullable<System.Int32> UnknownUnicastThreshold { get; set; }
	}
	
	public class UpdateNetworkSwitchStpPutBody
	{
		
		/// <summary>
		/// The spanning tree protocol status in network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rstpEnabled")]
		public System.Nullable<System.Boolean> RstpEnabled { get; set; }
		
		/// <summary>
		/// STP bridge priority for switches/stacks or switch profiles. An empty array will clear the STP bridge priority settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stpBridgePriority")]
		public UpdateNetworkSwitchStpPutBodyStpBridgePriority[] UpdateNetworkSwitchStpPutBodyStpBridgePriority { get; set; }
	}
	
	public class UpdateNetworkSwitchStpPutBodyStpBridgePriority
	{
		
		/// <summary>
		/// List of stack IDs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stacks")]
		public string[] Stacks { get; set; }
		
		/// <summary>
		/// STP priority for switch, stacks, or switch profiles
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stpPriority")]
		public int StpPriority { get; set; }
		
		/// <summary>
		/// List of switch profile IDs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchProfiles")]
		public string[] SwitchProfiles { get; set; }
		
		/// <summary>
		/// List of switch serial numbers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switches")]
		public string[] Switches { get; set; }
	}
	
	public class GetNetworkSyslogServersReturn
	{
		
		/// <summary>
		/// List of the syslog servers for this network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="servers")]
		public GetNetworkSyslogServersReturnServers[] GetNetworkSyslogServersReturnServers { get; set; }
	}
	
	public class GetNetworkSyslogServersReturnServers
	{
		
		/// <summary>
		/// The IP address of the syslog server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// The port of the syslog server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// A list of roles for the syslog server. Options (case-insensitive): 'Wireless event log', 'Appliance event log', 'Switch event log', 'Air Marshal events', 'Flows', 'URLs', 'IDS alerts', 'Security events'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="roles")]
		public string[] Roles { get; set; }
	}
	
	public class UpdateNetworkSyslogServersPutBody
	{
		
		/// <summary>
		/// A list of the syslog servers for this network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="servers")]
		public UpdateNetworkSyslogServersPutBodyServers[] UpdateNetworkSyslogServersPutBodyServers { get; set; }
	}
	
	public class UpdateNetworkSyslogServersPutBodyServers
	{
		
		/// <summary>
		/// The IP address of the syslog server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// The port of the syslog server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
		
		/// <summary>
		/// A list of roles for the syslog server. Options (case-insensitive): 'Wireless event log', 'Appliance event log', 'Switch event log', 'Air Marshal events', 'Flows', 'URLs', 'IDS alerts', 'Security events'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="roles")]
		public string[] Roles { get; set; }
	}
	
	public class UpdateNetworkSyslogServersReturn
	{
		
		/// <summary>
		/// List of the syslog servers for this network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="servers")]
		public UpdateNetworkSyslogServersReturnServers[] UpdateNetworkSyslogServersReturnServers { get; set; }
	}
	
	public class UpdateNetworkSyslogServersReturnServers
	{
		
		/// <summary>
		/// The IP address of the syslog server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// The port of the syslog server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// A list of roles for the syslog server. Options (case-insensitive): 'Wireless event log', 'Appliance event log', 'Switch event log', 'Air Marshal events', 'Flows', 'URLs', 'IDS alerts', 'Security events'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="roles")]
		public string[] Roles { get; set; }
	}
	
	public enum GetNetworkTrafficDeviceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		appliance = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		combined = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="switch")]
		_switch = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wireless = 3,
	}
	
	public class UpdateNetworkTrafficAnalysisPutBody
	{
		
		/// <summary>
		/// The list of items that make up the custom pie chart for traffic reporting.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customPieChartItems")]
		public UpdateNetworkTrafficAnalysisPutBodyCustomPieChartItems[] UpdateNetworkTrafficAnalysisPutBodyCustomPieChartItems { get; set; }
		
		/// <summary>
		///     The traffic analysis mode for the network. Can be one of 'disabled' (do not collect traffic types),
		///    'basic' (collect generic traffic categories), or 'detailed' (collect destination hostnames).
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public System.Nullable<UpdateNetworkTrafficAnalysisPutBodyMode> Mode { get; set; }
	}
	
	public class UpdateNetworkTrafficAnalysisPutBodyCustomPieChartItems
	{
		
		/// <summary>
		/// The name of the custom pie chart item.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		///     The signature type for the custom pie chart item. Can be one of 'host', 'port' or 'ipRange'.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public UpdateNetworkTrafficAnalysisPutBodyCustomPieChartItemsType Type { get; set; }
		
		/// <summary>
		///     The value of the custom pie chart item. Valid syntax depends on the signature type of the chart item
		///    (see sample request/response for more details).
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkTrafficAnalysisPutBodyCustomPieChartItemsType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		host = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ipRange = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		port = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkTrafficAnalysisPutBodyMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		basic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		detailed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 2,
	}
	
	public class UnbindNetworkPostBody
	{
		
		/// <summary>
		/// Optional boolean to retain all the current configs given by the template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retainConfigs")]
		public System.Nullable<System.Boolean> RetainConfigs { get; set; }
	}
	
	public class UnbindNetworkReturn
	{
		
		/// <summary>
		/// Enrollment string for the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enrollmentString")]
		public string EnrollmentString { get; set; }
		
		/// <summary>
		/// Network ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// If the network is bound to a config template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isBoundToConfigTemplate")]
		public System.Nullable<System.Boolean> IsBoundToConfigTemplate { get; set; }
		
		/// <summary>
		/// Network name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Notes for the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// Organization ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organizationId")]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// List of the product types that the network supports
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productTypes")]
		public string[] ProductTypes { get; set; }
		
		/// <summary>
		/// Network tags
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// Timezone of the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeZone")]
		public string TimeZone { get; set; }
		
		/// <summary>
		/// URL to the network Dashboard UI
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetNetworkWebhooksHttpServersReturn
	{
		
		/// <summary>
		/// A Base64 encoded ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A name for easy reference to the HTTP server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A Meraki network ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// The payload template to use when posting data to the HTTP server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payloadTemplate")]
		public GetNetworkWebhooksHttpServersReturnPayloadTemplate PayloadTemplate { get; set; }
		
		/// <summary>
		/// The URL of the HTTP server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetNetworkWebhooksHttpServersReturnPayloadTemplate
	{
		
		/// <summary>
		/// The name of the payload template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of the payload template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payloadTemplateId")]
		public string PayloadTemplateId { get; set; }
	}
	
	public class CreateNetworkWebhooksHttpServerPostBody
	{
		
		/// <summary>
		/// A name for easy reference to the HTTP server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The payload template to use when posting data to the HTTP server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payloadTemplate")]
		public CreateNetworkWebhooksHttpServerPostBodyPayloadTemplate PayloadTemplate { get; set; }
		
		/// <summary>
		/// A shared secret that will be included in POSTs sent to the HTTP server. This secret can be used to verify that the request was sent by Meraki.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sharedSecret")]
		public string SharedSecret { get; set; }
		
		/// <summary>
		/// The URL of the HTTP server. Once set, cannot be updated.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class CreateNetworkWebhooksHttpServerPostBodyPayloadTemplate
	{
		
		/// <summary>
		/// The name of the payload template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of the payload template. Defaults to 'wpt_00001' for the Meraki template. For Meraki-included templates: for the Webex (included) template use 'wpt_00002'; for the Slack (included) template use 'wpt_00003'; for the Microsoft Teams (included) template use 'wpt_00004'; for the ServiceNow (included) template use 'wpt_00006'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payloadTemplateId")]
		public string PayloadTemplateId { get; set; }
	}
	
	public class GetNetworkWebhooksHttpServerReturn
	{
		
		/// <summary>
		/// A Base64 encoded ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A name for easy reference to the HTTP server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A Meraki network ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// The payload template to use when posting data to the HTTP server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payloadTemplate")]
		public GetNetworkWebhooksHttpServerReturnPayloadTemplate PayloadTemplate { get; set; }
		
		/// <summary>
		/// The URL of the HTTP server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetNetworkWebhooksHttpServerReturnPayloadTemplate
	{
		
		/// <summary>
		/// The name of the payload template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of the payload template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payloadTemplateId")]
		public string PayloadTemplateId { get; set; }
	}
	
	public class UpdateNetworkWebhooksHttpServerPutBody
	{
		
		/// <summary>
		/// A name for easy reference to the HTTP server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The payload template to use when posting data to the HTTP server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payloadTemplate")]
		public UpdateNetworkWebhooksHttpServerPutBodyPayloadTemplate PayloadTemplate { get; set; }
		
		/// <summary>
		/// A shared secret that will be included in POSTs sent to the HTTP server. This secret can be used to verify that the request was sent by Meraki.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sharedSecret")]
		public string SharedSecret { get; set; }
	}
	
	public class UpdateNetworkWebhooksHttpServerPutBodyPayloadTemplate
	{
		
		/// <summary>
		/// The ID of the payload template. Defaults to 'wpt_00001' for the Meraki template. For Meraki-included templates: for the Webex (included) template use 'wpt_00002'; for the Slack (included) template use 'wpt_00003'; for the Microsoft Teams (included) template use 'wpt_00004'; for the ServiceNow (included) template use 'wpt_00006'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payloadTemplateId")]
		public string PayloadTemplateId { get; set; }
	}
	
	public class UpdateNetworkWebhooksHttpServerReturn
	{
		
		/// <summary>
		/// A Base64 encoded ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A name for easy reference to the HTTP server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A Meraki network ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// The payload template to use when posting data to the HTTP server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payloadTemplate")]
		public UpdateNetworkWebhooksHttpServerReturnPayloadTemplate PayloadTemplate { get; set; }
		
		/// <summary>
		/// The URL of the HTTP server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class UpdateNetworkWebhooksHttpServerReturnPayloadTemplate
	{
		
		/// <summary>
		/// The name of the payload template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of the payload template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payloadTemplateId")]
		public string PayloadTemplateId { get; set; }
	}
	
	public class GetNetworkWebhooksPayloadTemplatesReturn
	{
		
		/// <summary>
		/// The body of the payload template, in liquid template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// The payload template headers, will be rendered as a key-value pair in the webhook.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public GetNetworkWebhooksPayloadTemplatesReturnHeaders[] GetNetworkWebhooksPayloadTemplatesReturnHeaders { get; set; }
		
		/// <summary>
		/// The name of the payload template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Webhook payload template Id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payloadTemplateId")]
		public string PayloadTemplateId { get; set; }
		
		/// <summary>
		/// The type of the payload template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class GetNetworkWebhooksPayloadTemplatesReturnHeaders
	{
		
		/// <summary>
		/// The name of the header attribute
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value returned in the header attribute, in liquid template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="template")]
		public string Template { get; set; }
	}
	
	public class CreateNetworkWebhooksPayloadTemplatePostBody
	{
		
		/// <summary>
		/// The liquid template used for the body of the webhook message. Either `body` or `bodyFile` must be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// A file containing liquid template used for the body of the webhook message. Either `body` or `bodyFile` must be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bodyFile")]
		public string BodyFile { get; set; }
		
		/// <summary>
		/// The liquid template used with the webhook headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public CreateNetworkWebhooksPayloadTemplatePostBodyHeaders[] CreateNetworkWebhooksPayloadTemplatePostBodyHeaders { get; set; }
		
		/// <summary>
		/// A file containing the liquid template used with the webhook headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headersFile")]
		public string HeadersFile { get; set; }
		
		/// <summary>
		/// The name of the new template
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class CreateNetworkWebhooksPayloadTemplatePostBodyHeaders
	{
		
		/// <summary>
		/// The name of the header template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The liquid template for the headers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="template")]
		public string Template { get; set; }
	}
	
	public class GetNetworkWebhooksPayloadTemplateReturn
	{
		
		/// <summary>
		/// The body of the payload template, in liquid template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// The payload template headers, will be rendered as a key-value pair in the webhook.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public GetNetworkWebhooksPayloadTemplateReturnHeaders[] GetNetworkWebhooksPayloadTemplateReturnHeaders { get; set; }
		
		/// <summary>
		/// The name of the payload template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Webhook payload template Id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payloadTemplateId")]
		public string PayloadTemplateId { get; set; }
		
		/// <summary>
		/// The type of the payload template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class GetNetworkWebhooksPayloadTemplateReturnHeaders
	{
		
		/// <summary>
		/// The name of the header attribute
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value returned in the header attribute, in liquid template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="template")]
		public string Template { get; set; }
	}
	
	public class UpdateNetworkWebhooksPayloadTemplatePutBody
	{
		
		/// <summary>
		/// The liquid template used for the body of the webhook message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// A file containing liquid template used for the body of the webhook message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bodyFile")]
		public string BodyFile { get; set; }
		
		/// <summary>
		/// The liquid template used with the webhook headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public UpdateNetworkWebhooksPayloadTemplatePutBodyHeaders[] UpdateNetworkWebhooksPayloadTemplatePutBodyHeaders { get; set; }
		
		/// <summary>
		/// A file containing the liquid template used with the webhook headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headersFile")]
		public string HeadersFile { get; set; }
		
		/// <summary>
		/// The name of the template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateNetworkWebhooksPayloadTemplatePutBodyHeaders
	{
		
		/// <summary>
		/// The name of the header template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The liquid template for the headers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="template")]
		public string Template { get; set; }
	}
	
	public class UpdateNetworkWebhooksPayloadTemplateReturn
	{
		
		/// <summary>
		/// The body of the payload template, in liquid template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// The payload template headers, will be rendered as a key-value pair in the webhook.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public UpdateNetworkWebhooksPayloadTemplateReturnHeaders[] UpdateNetworkWebhooksPayloadTemplateReturnHeaders { get; set; }
		
		/// <summary>
		/// The name of the payload template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Webhook payload template Id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payloadTemplateId")]
		public string PayloadTemplateId { get; set; }
		
		/// <summary>
		/// The type of the payload template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class UpdateNetworkWebhooksPayloadTemplateReturnHeaders
	{
		
		/// <summary>
		/// The name of the header attribute
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value returned in the header attribute, in liquid template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="template")]
		public string Template { get; set; }
	}
	
	public class CreateNetworkWebhooksWebhookTestPostBody
	{
		
		/// <summary>
		/// The type of alert which the test webhook will send. Optional. Defaults to power_supply_down.
		/// </summary>
		[System.ComponentModel.DefaultValue("power_supply_down")]
		[System.Runtime.Serialization.DataMember(Name="alertTypeId")]
		public string AlertTypeId { get; set; } = "power_supply_down";
		
		/// <summary>
		/// The ID of the payload template of the test webhook. Defaults to the HTTP server's template ID if one exists for the given URL, or Generic template ID otherwise
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payloadTemplateId")]
		public string PayloadTemplateId { get; set; }
		
		/// <summary>
		/// The name of the payload template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payloadTemplateName")]
		public string PayloadTemplateName { get; set; }
		
		/// <summary>
		/// The shared secret the test webhook will send. Optional. Defaults to an empty string.
		/// </summary>
		[System.ComponentModel.DefaultValue("")]
		[System.Runtime.Serialization.DataMember(Name="sharedSecret")]
		public string SharedSecret { get; set; } = "";
		
		/// <summary>
		/// The URL where the test webhook will be sent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetNetworkWebhooksWebhookTestReturn
	{
		
		/// <summary>
		/// Webhook delivery identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Current status of the webhook delivery
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<GetNetworkWebhooksWebhookTestReturnStatus> Status { get; set; }
		
		/// <summary>
		/// URL where the webhook was delivered
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkWebhooksWebhookTestReturnStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		abandoned = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		delivered = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enqueued = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		processing = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		retrying = 4,
	}
	
	public class UpdateNetworkWirelessAlternateManagementInterfacePutBody
	{
		
		/// <summary>
		/// Array of access point serial number and IP assignment. Note: accessPoints IP assignment is not applicable for template networks, in other words, do not put 'accessPoints' in the body when updating template networks. Also, an empty 'accessPoints' array will remove all previous static IP assignments
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPoints")]
		public UpdateNetworkWirelessAlternateManagementInterfacePutBodyAccessPoints[] UpdateNetworkWirelessAlternateManagementInterfacePutBodyAccessPoints { get; set; }
		
		/// <summary>
		/// Boolean value to enable or disable alternate management interface
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Can be one or more of the following values: 'radius', 'snmp', 'syslog' or 'ldap'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocols")]
		public string[] Protocols { get; set; }
		
		/// <summary>
		/// Alternate management interface VLAN, must be between 1 and 4094
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public System.Nullable<System.Int32> VlanId { get; set; }
	}
	
	public class UpdateNetworkWirelessAlternateManagementInterfacePutBodyAccessPoints
	{
		
		/// <summary>
		/// Wireless alternate management interface device IP. Provide an empty string to remove alternate management IP assignment
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="alternateManagementIp")]
		public string AlternateManagementIp { get; set; }
		
		/// <summary>
		/// Primary DNS must be in IP format
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dns1")]
		public string Dns1 { get; set; }
		
		/// <summary>
		/// Optional secondary DNS must be in IP format
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dns2")]
		public string Dns2 { get; set; }
		
		/// <summary>
		/// Gateway must be in IP format
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// Serial number of access point to be configured with alternate management IP
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// Subnet mask must be in IP format
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetMask")]
		public string SubnetMask { get; set; }
	}
	
	public class UpdateNetworkWirelessBillingPutBody
	{
		
		/// <summary>
		/// The currency code of this node group's billing plans
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currency")]
		public string Currency { get; set; }
		
		/// <summary>
		/// Array of billing plans in the node group. (Can configure a maximum of 5)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="plans")]
		public UpdateNetworkWirelessBillingPutBodyPlans[] UpdateNetworkWirelessBillingPutBodyPlans { get; set; }
	}
	
	public class UpdateNetworkWirelessBillingPutBodyPlans
	{
		
		/// <summary>
		/// The uplink bandwidth settings for the pricing plan.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bandwidthLimits")]
		public UpdateNetworkWirelessBillingPutBodyPlansBandwidthLimits BandwidthLimits { get; set; }
		
		/// <summary>
		/// The id of the pricing plan to update.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The price of the billing plan.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price")]
		public float Price { get; set; }
		
		/// <summary>
		/// The time limit of the pricing plan in minutes. Can be '1 hour', '1 day', '1 week', or '30 days'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeLimit")]
		public UpdateNetworkWirelessBillingPutBodyPlansTimeLimit TimeLimit { get; set; }
	}
	
	public class UpdateNetworkWirelessBillingPutBodyPlansBandwidthLimits
	{
		
		/// <summary>
		/// The maximum download limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitDown")]
		public System.Nullable<System.Int32> LimitDown { get; set; }
		
		/// <summary>
		/// The maximum upload limit (integer, in Kbps). null indicates no limit
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitUp")]
		public System.Nullable<System.Int32> LimitUp { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessBillingPutBodyPlansTimeLimit
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 day")]
		_1_day = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 hour")]
		_1_hour = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1 week")]
		_1_week = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="30 days")]
		_30_days = 3,
	}
	
	public class GetNetworkWirelessBluetoothSettingsReturn
	{
		
		/// <summary>
		/// Whether APs will advertise beacons.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advertisingEnabled")]
		public System.Nullable<System.Boolean> AdvertisingEnabled { get; set; }
		
		/// <summary>
		/// Whether ESL is enabled on this network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eslEnabled")]
		public System.Nullable<System.Boolean> EslEnabled { get; set; }
		
		/// <summary>
		/// The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="major")]
		public System.Nullable<System.Int32> Major { get; set; }
		
		/// <summary>
		/// The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="majorMinorAssignmentMode")]
		public string MajorMinorAssignmentMode { get; set; }
		
		/// <summary>
		/// The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minor")]
		public System.Nullable<System.Int32> Minor { get; set; }
		
		/// <summary>
		/// Whether APs will scan for Bluetooth enabled clients.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scanningEnabled")]
		public System.Nullable<System.Boolean> ScanningEnabled { get; set; }
		
		/// <summary>
		/// The UUID to be used in the beacon identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uuid")]
		public string Uuid { get; set; }
	}
	
	public class UpdateNetworkWirelessBluetoothSettingsPutBody
	{
		
		/// <summary>
		/// Whether APs will advertise beacons.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advertisingEnabled")]
		public System.Nullable<System.Boolean> AdvertisingEnabled { get; set; }
		
		/// <summary>
		/// The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="major")]
		public System.Nullable<System.Int32> Major { get; set; }
		
		/// <summary>
		/// The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="majorMinorAssignmentMode")]
		public System.Nullable<UpdateNetworkWirelessBluetoothSettingsPutBodyMajorMinorAssignmentMode> MajorMinorAssignmentMode { get; set; }
		
		/// <summary>
		/// The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minor")]
		public System.Nullable<System.Int32> Minor { get; set; }
		
		/// <summary>
		/// Whether APs will scan for Bluetooth enabled clients.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scanningEnabled")]
		public System.Nullable<System.Boolean> ScanningEnabled { get; set; }
		
		/// <summary>
		/// The UUID to be used in the beacon identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uuid")]
		public string Uuid { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessBluetoothSettingsPutBodyMajorMinorAssignmentMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Non-unique")]
		NonMinusunique = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unique = 1,
	}
	
	public class UpdateNetworkWirelessBluetoothSettingsReturn
	{
		
		/// <summary>
		/// Whether APs will advertise beacons.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advertisingEnabled")]
		public System.Nullable<System.Boolean> AdvertisingEnabled { get; set; }
		
		/// <summary>
		/// Whether ESL is enabled on this network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eslEnabled")]
		public System.Nullable<System.Boolean> EslEnabled { get; set; }
		
		/// <summary>
		/// The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="major")]
		public System.Nullable<System.Int32> Major { get; set; }
		
		/// <summary>
		/// The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="majorMinorAssignmentMode")]
		public string MajorMinorAssignmentMode { get; set; }
		
		/// <summary>
		/// The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minor")]
		public System.Nullable<System.Int32> Minor { get; set; }
		
		/// <summary>
		/// Whether APs will scan for Bluetooth enabled clients.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scanningEnabled")]
		public System.Nullable<System.Boolean> ScanningEnabled { get; set; }
		
		/// <summary>
		/// The UUID to be used in the beacon identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uuid")]
		public string Uuid { get; set; }
	}
	
	public enum GetNetworkWirelessChannelUtilizationHistoryBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
	}
	
	public class GetNetworkWirelessChannelUtilizationHistoryReturn
	{
		
		/// <summary>
		/// The end time of the query range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTs")]
		public System.Nullable<System.DateTimeOffset> EndTs { get; set; }
		
		/// <summary>
		/// The start time of the query range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTs")]
		public System.Nullable<System.DateTimeOffset> StartTs { get; set; }
		
		/// <summary>
		/// Average wifi utilization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="utilization80211")]
		public System.Nullable<System.Single> Utilization80211 { get; set; }
		
		/// <summary>
		/// Average signal interference
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="utilizationNon80211")]
		public System.Nullable<System.Single> UtilizationNon80211 { get; set; }
		
		/// <summary>
		/// Total channel utilization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="utilizationTotal")]
		public System.Nullable<System.Single> UtilizationTotal { get; set; }
	}
	
	public enum GetNetworkWirelessClientCountHistoryBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
	}
	
	public class GetNetworkWirelessClientCountHistoryReturn
	{
		
		/// <summary>
		/// Number of connected clients
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientCount")]
		public System.Nullable<System.Int32> ClientCount { get; set; }
		
		/// <summary>
		/// The end time of the query range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTs")]
		public System.Nullable<System.DateTimeOffset> EndTs { get; set; }
		
		/// <summary>
		/// The start time of the query range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTs")]
		public System.Nullable<System.DateTimeOffset> StartTs { get; set; }
	}
	
	public enum GetNetworkWirelessClientsConnectionStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
	}
	
	public enum GetNetworkWirelessClientsLatencyStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
	}
	
	public enum GetNetworkWirelessClientConnectionStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
	}
	
	public enum GetNetworkWirelessClientConnectivityEventsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
	}
	
	public enum GetNetworkWirelessClientConnectivityEventsSsidNumber
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_4 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_5 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_6 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_7 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_8 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_9 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_10 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_11 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_12 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_13 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_14 = 14,
	}
	
	public enum GetNetworkWirelessClientLatencyStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
	}
	
	public enum GetNetworkWirelessConnectionStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
	}
	
	public class GetNetworkWirelessConnectionStatsReturn
	{
		
		/// <summary>
		/// The number of failed association attempts
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assoc")]
		public System.Nullable<System.Int32> Assoc { get; set; }
		
		/// <summary>
		/// The number of failed authentication attempts
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="auth")]
		public System.Nullable<System.Int32> Auth { get; set; }
		
		/// <summary>
		/// The number of failed DHCP attempts
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcp")]
		public System.Nullable<System.Int32> Dhcp { get; set; }
		
		/// <summary>
		/// The number of failed DNS attempts
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dns")]
		public System.Nullable<System.Int32> Dns { get; set; }
		
		/// <summary>
		/// The number of successful connection attempts
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="success")]
		public System.Nullable<System.Int32> Success { get; set; }
	}
	
	public enum GetNetworkWirelessDataRateHistoryBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
	}
	
	public class GetNetworkWirelessDataRateHistoryReturn
	{
		
		/// <summary>
		/// Average data rate in kilobytes-per-second
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="averageKbps")]
		public System.Nullable<System.Int32> AverageKbps { get; set; }
		
		/// <summary>
		/// Download rate in kilobytes-per-second
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="downloadKbps")]
		public System.Nullable<System.Int32> DownloadKbps { get; set; }
		
		/// <summary>
		/// The end time of the query range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTs")]
		public System.Nullable<System.DateTimeOffset> EndTs { get; set; }
		
		/// <summary>
		/// The start time of the query range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTs")]
		public System.Nullable<System.DateTimeOffset> StartTs { get; set; }
		
		/// <summary>
		/// Upload rate in kilobytes-per-second
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uploadKbps")]
		public System.Nullable<System.Int32> UploadKbps { get; set; }
	}
	
	public enum GetNetworkWirelessDevicesConnectionStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
	}
	
	public class GetNetworkWirelessDevicesConnectionStatsReturn
	{
		
		/// <summary>
		/// The connection stats of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionStats")]
		public GetNetworkWirelessDevicesConnectionStatsReturnConnectionStats ConnectionStats { get; set; }
		
		/// <summary>
		/// The serial number for the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class GetNetworkWirelessDevicesConnectionStatsReturnConnectionStats
	{
		
		/// <summary>
		/// The number of failed association attempts
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assoc")]
		public System.Nullable<System.Int32> Assoc { get; set; }
		
		/// <summary>
		/// The number of failed authentication attempts
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="auth")]
		public System.Nullable<System.Int32> Auth { get; set; }
		
		/// <summary>
		/// The number of failed DHCP attempts
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dhcp")]
		public System.Nullable<System.Int32> Dhcp { get; set; }
		
		/// <summary>
		/// The number of failed DNS attempts
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dns")]
		public System.Nullable<System.Int32> Dns { get; set; }
		
		/// <summary>
		/// The number of successful connection attempts
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="success")]
		public System.Nullable<System.Int32> Success { get; set; }
	}
	
	public enum GetNetworkWirelessDevicesLatencyStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
	}
	
	public enum GetNetworkWirelessFailedConnectionsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
	}
	
	public class GetNetworkWirelessFailedConnectionsReturn
	{
		
		/// <summary>
		/// Client Mac
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientMac")]
		public string ClientMac { get; set; }
		
		/// <summary>
		/// The failed onboarding step. One of: assoc, auth, dhcp, dns.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failureStep")]
		public string FailureStep { get; set; }
		
		/// <summary>
		/// Serial Number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// SSID Number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssidNumber")]
		public System.Nullable<System.Int32> SsidNumber { get; set; }
		
		/// <summary>
		/// The timestamp when the client mac failed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ts")]
		public System.Nullable<System.DateTimeOffset> Ts { get; set; }
		
		/// <summary>
		/// The failure type in the onboarding step
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// LAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
	}
	
	public enum GetNetworkWirelessLatencyHistoryBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
	}
	
	public enum GetNetworkWirelessLatencyHistoryAccessCategory
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		backgroundTraffic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		bestEffortTraffic = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		videoTraffic = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		voiceTraffic = 3,
	}
	
	public class GetNetworkWirelessLatencyHistoryReturn
	{
		
		/// <summary>
		/// Average latency in milliseconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="avgLatencyMs")]
		public System.Nullable<System.Int32> AvgLatencyMs { get; set; }
		
		/// <summary>
		/// The end time of the query range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTs")]
		public System.Nullable<System.DateTimeOffset> EndTs { get; set; }
		
		/// <summary>
		/// The start time of the query range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTs")]
		public System.Nullable<System.DateTimeOffset> StartTs { get; set; }
	}
	
	public enum GetNetworkWirelessLatencyStatsBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
	}
	
	public class CreateNetworkWirelessRfProfilePostBody
	{
		
		/// <summary>
		/// Settings that will be enabled if selectionType is set to 'ap'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apBandSettings")]
		public CreateNetworkWirelessRfProfilePostBodyApBandSettings ApBandSettings { get; set; }
		
		/// <summary>
		/// Band selection can be set to either 'ssid' or 'ap'. This param is required on creation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bandSelectionType")]
		public CreateNetworkWirelessRfProfilePostBodyBandSelectionType BandSelectionType { get; set; }
		
		/// <summary>
		/// Steers client to best available access point. Can be either true or false. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientBalancingEnabled")]
		public System.Nullable<System.Boolean> ClientBalancingEnabled { get; set; }
		
		/// <summary>
		/// Settings related to 5Ghz band
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fiveGhzSettings")]
		public CreateNetworkWirelessRfProfilePostBodyFiveGhzSettings FiveGhzSettings { get; set; }
		
		/// <summary>
		/// Minimum bitrate can be set to either 'band' or 'ssid'. Defaults to band.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrateType")]
		public System.Nullable<CreateNetworkWirelessRfProfilePostBodyMinBitrateType> MinBitrateType { get; set; }
		
		/// <summary>
		/// The name of the new profile. Must be unique. This param is required on creation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Per-SSID radio settings by number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perSsidSettings")]
		public CreateNetworkWirelessRfProfilePostBodyPerSsidSettings PerSsidSettings { get; set; }
		
		/// <summary>
		/// Settings related to radio transmission.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transmission")]
		public CreateNetworkWirelessRfProfilePostBodyTransmission Transmission { get; set; }
		
		/// <summary>
		/// Settings related to 2.4Ghz band
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="twoFourGhzSettings")]
		public CreateNetworkWirelessRfProfilePostBodyTwoFourGhzSettings TwoFourGhzSettings { get; set; }
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyApBandSettings
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'. Defaults to dual.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band. Can be either true or false. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyApBandSettingsBandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyBandSelectionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ap = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ssid = 1,
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyFiveGhzSettings
	{
		
		/// <summary>
		/// Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. Defaults to auto.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="channelWidth")]
		public string ChannelWidth { get; set; }
		
		/// <summary>
		/// Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 30.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPower")]
		public System.Nullable<System.Int32> MaxPower { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 8.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minPower")]
		public System.Nullable<System.Int32> MinPower { get; set; }
		
		/// <summary>
		/// The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rxsop")]
		public System.Nullable<System.Int32> Rxsop { get; set; }
		
		/// <summary>
		/// Sets valid auto channels for 5Ghz band. Can be one of '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161' or '165'.Defaults to [36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 149, 153, 157, 161, 165].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validAutoChannels")]
		public int[] ValidAutoChannels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyMinBitrateType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		band = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ssid = 1,
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyPerSsidSettings
	{
		
		/// <summary>
		/// Settings for SSID 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="0")]
		public CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_0 _0 { get; set; }
		
		/// <summary>
		/// Settings for SSID 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="1")]
		public CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_1 _1 { get; set; }
		
		/// <summary>
		/// Settings for SSID 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="2")]
		public CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_2 _2 { get; set; }
		
		/// <summary>
		/// Settings for SSID 3
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="3")]
		public CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_3 _3 { get; set; }
		
		/// <summary>
		/// Settings for SSID 4
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="4")]
		public CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_4 _4 { get; set; }
		
		/// <summary>
		/// Settings for SSID 5
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="5")]
		public CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_5 _5 { get; set; }
		
		/// <summary>
		/// Settings for SSID 6
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="6")]
		public CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_6 _6 { get; set; }
		
		/// <summary>
		/// Settings for SSID 7
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="7")]
		public CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_7 _7 { get; set; }
		
		/// <summary>
		/// Settings for SSID 8
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="8")]
		public CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_8 _8 { get; set; }
		
		/// <summary>
		/// Settings for SSID 9
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="9")]
		public CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_9 _9 { get; set; }
		
		/// <summary>
		/// Settings for SSID 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="10")]
		public CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_10 _10 { get; set; }
		
		/// <summary>
		/// Settings for SSID 11
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="11")]
		public CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_11 _11 { get; set; }
		
		/// <summary>
		/// Settings for SSID 12
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="12")]
		public CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_12 _12 { get; set; }
		
		/// <summary>
		/// Settings for SSID 13
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="13")]
		public CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_13 _13 { get; set; }
		
		/// <summary>
		/// Settings for SSID 14
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="14")]
		public CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_14 _14 { get; set; }
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_0
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_0BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_0BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_1
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_1BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_1BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_2
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_2BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_2BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_3
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_3BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_3BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_4
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_4BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_4BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_5
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_5BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_5BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_6
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_6BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_6BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_7
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_7BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_7BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_8
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_8BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_8BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_9
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_9BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_9BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_10
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_10BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_10BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_11
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_11BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_11BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_12
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_12BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_12BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_13
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_13BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_13BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_14
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_14BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateNetworkWirelessRfProfilePostBodyPerSsidSettings_14BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyTransmission
	{
		
		/// <summary>
		/// Toggle for radio transmission. When false, radios will not transmit at all.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class CreateNetworkWirelessRfProfilePostBodyTwoFourGhzSettings
	{
		
		/// <summary>
		/// Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="axEnabled")]
		public System.Nullable<System.Boolean> AxEnabled { get; set; }
		
		/// <summary>
		/// Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 30.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPower")]
		public System.Nullable<System.Int32> MaxPower { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. Defaults to 11.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
		
		/// <summary>
		/// Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 5.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minPower")]
		public System.Nullable<System.Int32> MinPower { get; set; }
		
		/// <summary>
		/// The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rxsop")]
		public System.Nullable<System.Int32> Rxsop { get; set; }
		
		/// <summary>
		/// Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validAutoChannels")]
		public int[] ValidAutoChannels { get; set; }
	}
	
	public class UpdateNetworkWirelessRfProfilePutBody
	{
		
		/// <summary>
		/// Settings that will be enabled if selectionType is set to 'ap'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apBandSettings")]
		public UpdateNetworkWirelessRfProfilePutBodyApBandSettings ApBandSettings { get; set; }
		
		/// <summary>
		/// Band selection can be set to either 'ssid' or 'ap'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSelectionType")]
		public CreateNetworkWirelessRfProfilePostBodyBandSelectionType BandSelectionType { get; set; }
		
		/// <summary>
		/// Steers client to best available access point. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientBalancingEnabled")]
		public System.Nullable<System.Boolean> ClientBalancingEnabled { get; set; }
		
		/// <summary>
		/// Settings related to 5Ghz band
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fiveGhzSettings")]
		public UpdateNetworkWirelessRfProfilePutBodyFiveGhzSettings FiveGhzSettings { get; set; }
		
		/// <summary>
		/// Minimum bitrate can be set to either 'band' or 'ssid'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrateType")]
		public CreateNetworkWirelessRfProfilePostBodyMinBitrateType MinBitrateType { get; set; }
		
		/// <summary>
		/// The name of the new profile. Must be unique.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Per-SSID radio settings by number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perSsidSettings")]
		public UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings PerSsidSettings { get; set; }
		
		/// <summary>
		/// Settings related to radio transmission.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transmission")]
		public UpdateNetworkWirelessRfProfilePutBodyTransmission Transmission { get; set; }
		
		/// <summary>
		/// Settings related to 2.4Ghz band
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="twoFourGhzSettings")]
		public UpdateNetworkWirelessRfProfilePutBodyTwoFourGhzSettings TwoFourGhzSettings { get; set; }
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyApBandSettings
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfilePutBodyApBandSettingsBandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfilePutBodyApBandSettingsBandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyFiveGhzSettings
	{
		
		/// <summary>
		/// Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="channelWidth")]
		public string ChannelWidth { get; set; }
		
		/// <summary>
		/// Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPower")]
		public System.Nullable<System.Int32> MaxPower { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minPower")]
		public System.Nullable<System.Int32> MinPower { get; set; }
		
		/// <summary>
		/// The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rxsop")]
		public System.Nullable<System.Int32> Rxsop { get; set; }
		
		/// <summary>
		/// Sets valid auto channels for 5Ghz band. Can be one of '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161' or '165'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validAutoChannels")]
		public int[] ValidAutoChannels { get; set; }
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings
	{
		
		/// <summary>
		/// Settings for SSID 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="0")]
		public UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_0 _0 { get; set; }
		
		/// <summary>
		/// Settings for SSID 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="1")]
		public UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_1 _1 { get; set; }
		
		/// <summary>
		/// Settings for SSID 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="2")]
		public UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_2 _2 { get; set; }
		
		/// <summary>
		/// Settings for SSID 3
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="3")]
		public UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_3 _3 { get; set; }
		
		/// <summary>
		/// Settings for SSID 4
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="4")]
		public UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_4 _4 { get; set; }
		
		/// <summary>
		/// Settings for SSID 5
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="5")]
		public UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_5 _5 { get; set; }
		
		/// <summary>
		/// Settings for SSID 6
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="6")]
		public UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_6 _6 { get; set; }
		
		/// <summary>
		/// Settings for SSID 7
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="7")]
		public UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_7 _7 { get; set; }
		
		/// <summary>
		/// Settings for SSID 8
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="8")]
		public UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_8 _8 { get; set; }
		
		/// <summary>
		/// Settings for SSID 9
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="9")]
		public UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_9 _9 { get; set; }
		
		/// <summary>
		/// Settings for SSID 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="10")]
		public UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_10 _10 { get; set; }
		
		/// <summary>
		/// Settings for SSID 11
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="11")]
		public UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_11 _11 { get; set; }
		
		/// <summary>
		/// Settings for SSID 12
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="12")]
		public UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_12 _12 { get; set; }
		
		/// <summary>
		/// Settings for SSID 13
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="13")]
		public UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_13 _13 { get; set; }
		
		/// <summary>
		/// Settings for SSID 14
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="14")]
		public UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_14 _14 { get; set; }
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_0
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_0BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_0BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_1
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_1BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_1BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_2
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_2BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_2BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_3
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_3BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_3BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_4
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_4BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_4BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_5
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_5BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_5BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_6
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_6BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_6BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_7
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_7BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_7BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_8
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_8BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_8BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_9
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_9BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_9BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_10
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_10BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_10BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_11
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_11BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_11BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_12
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_12BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_12BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_13
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_13BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_13BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_14
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_14BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfilePutBodyPerSsidSettings_14BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyTransmission
	{
		
		/// <summary>
		/// Toggle for radio transmission. When false, radios will not transmit at all.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateNetworkWirelessRfProfilePutBodyTwoFourGhzSettings
	{
		
		/// <summary>
		/// Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="axEnabled")]
		public System.Nullable<System.Boolean> AxEnabled { get; set; }
		
		/// <summary>
		/// Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPower")]
		public System.Nullable<System.Int32> MaxPower { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
		
		/// <summary>
		/// Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minPower")]
		public System.Nullable<System.Int32> MinPower { get; set; }
		
		/// <summary>
		/// The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rxsop")]
		public System.Nullable<System.Int32> Rxsop { get; set; }
		
		/// <summary>
		/// Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validAutoChannels")]
		public int[] ValidAutoChannels { get; set; }
	}
	
	public class UpdateNetworkWirelessRfProfileReturn
	{
		
		/// <summary>
		/// Settings that will be enabled if selectionType is set to 'ap'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apBandSettings")]
		public UpdateNetworkWirelessRfProfileReturnApBandSettings ApBandSettings { get; set; }
		
		/// <summary>
		/// Band selection can be set to either 'ssid' or 'ap'. This param is required on creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSelectionType")]
		public string BandSelectionType { get; set; }
		
		/// <summary>
		/// Steers client to best available access point. Can be either true or false. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientBalancingEnabled")]
		public System.Nullable<System.Boolean> ClientBalancingEnabled { get; set; }
		
		/// <summary>
		/// Settings related to 5Ghz band
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fiveGhzSettings")]
		public UpdateNetworkWirelessRfProfileReturnFiveGhzSettings FiveGhzSettings { get; set; }
		
		/// <summary>
		/// The name of the new profile. Must be unique.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Minimum bitrate can be set to either 'band' or 'ssid'. Defaults to band.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrateType")]
		public string MinBitrateType { get; set; }
		
		/// <summary>
		/// The name of the new profile. Must be unique. This param is required on creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The network ID of the RF Profile
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// Per-SSID radio settings by number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perSsidSettings")]
		public UpdateNetworkWirelessRfProfileReturnPerSsidSettings PerSsidSettings { get; set; }
		
		/// <summary>
		/// Settings related to radio transmission.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transmission")]
		public UpdateNetworkWirelessRfProfileReturnTransmission Transmission { get; set; }
		
		/// <summary>
		/// Settings related to 2.4Ghz band
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="twoFourGhzSettings")]
		public UpdateNetworkWirelessRfProfileReturnTwoFourGhzSettings TwoFourGhzSettings { get; set; }
	}
	
	public class UpdateNetworkWirelessRfProfileReturnApBandSettings
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'. Defaults to dual.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public string BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band. Can be either true or false. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
	}
	
	public class UpdateNetworkWirelessRfProfileReturnFiveGhzSettings
	{
		
		/// <summary>
		/// Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. Defaults to auto.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="channelWidth")]
		public string ChannelWidth { get; set; }
		
		/// <summary>
		/// Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 30.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPower")]
		public System.Nullable<System.Int32> MaxPower { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 8.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minPower")]
		public System.Nullable<System.Int32> MinPower { get; set; }
		
		/// <summary>
		/// The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rxsop")]
		public System.Nullable<System.Int32> Rxsop { get; set; }
		
		/// <summary>
		/// Sets valid auto channels for 5Ghz band. Can be one of '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161' or '165'.Defaults to [36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 149, 153, 157, 161, 165].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validAutoChannels")]
		public int[] ValidAutoChannels { get; set; }
	}
	
	public class UpdateNetworkWirelessRfProfileReturnPerSsidSettings
	{
		
		/// <summary>
		/// Settings for SSID 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="0")]
		public UpdateNetworkWirelessRfProfileReturnPerSsidSettings_0 _0 { get; set; }
		
		/// <summary>
		/// Settings for SSID 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="1")]
		public UpdateNetworkWirelessRfProfileReturnPerSsidSettings_1 _1 { get; set; }
		
		/// <summary>
		/// Settings for SSID 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="2")]
		public UpdateNetworkWirelessRfProfileReturnPerSsidSettings_2 _2 { get; set; }
		
		/// <summary>
		/// Settings for SSID 3
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="3")]
		public UpdateNetworkWirelessRfProfileReturnPerSsidSettings_3 _3 { get; set; }
		
		/// <summary>
		/// Settings for SSID 4
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="4")]
		public UpdateNetworkWirelessRfProfileReturnPerSsidSettings_4 _4 { get; set; }
		
		/// <summary>
		/// Settings for SSID 5
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="5")]
		public UpdateNetworkWirelessRfProfileReturnPerSsidSettings_5 _5 { get; set; }
		
		/// <summary>
		/// Settings for SSID 6
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="6")]
		public UpdateNetworkWirelessRfProfileReturnPerSsidSettings_6 _6 { get; set; }
		
		/// <summary>
		/// Settings for SSID 7
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="7")]
		public UpdateNetworkWirelessRfProfileReturnPerSsidSettings_7 _7 { get; set; }
		
		/// <summary>
		/// Settings for SSID 8
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="8")]
		public UpdateNetworkWirelessRfProfileReturnPerSsidSettings_8 _8 { get; set; }
		
		/// <summary>
		/// Settings for SSID 9
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="9")]
		public UpdateNetworkWirelessRfProfileReturnPerSsidSettings_9 _9 { get; set; }
		
		/// <summary>
		/// Settings for SSID 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="10")]
		public UpdateNetworkWirelessRfProfileReturnPerSsidSettings_10 _10 { get; set; }
		
		/// <summary>
		/// Settings for SSID 11
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="11")]
		public UpdateNetworkWirelessRfProfileReturnPerSsidSettings_11 _11 { get; set; }
		
		/// <summary>
		/// Settings for SSID 12
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="12")]
		public UpdateNetworkWirelessRfProfileReturnPerSsidSettings_12 _12 { get; set; }
		
		/// <summary>
		/// Settings for SSID 13
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="13")]
		public UpdateNetworkWirelessRfProfileReturnPerSsidSettings_13 _13 { get; set; }
		
		/// <summary>
		/// Settings for SSID 14
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="14")]
		public UpdateNetworkWirelessRfProfileReturnPerSsidSettings_14 _14 { get; set; }
	}
	
	public class UpdateNetworkWirelessRfProfileReturnPerSsidSettings_0
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_0BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Name of SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfileReturnPerSsidSettings_0BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfileReturnPerSsidSettings_1
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_1BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Name of SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfileReturnPerSsidSettings_1BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfileReturnPerSsidSettings_2
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_2BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Name of SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfileReturnPerSsidSettings_2BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfileReturnPerSsidSettings_3
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_3BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Name of SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfileReturnPerSsidSettings_3BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfileReturnPerSsidSettings_4
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_4BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Name of SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfileReturnPerSsidSettings_4BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfileReturnPerSsidSettings_5
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_5BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Name of SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfileReturnPerSsidSettings_5BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfileReturnPerSsidSettings_6
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_6BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Name of SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfileReturnPerSsidSettings_6BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfileReturnPerSsidSettings_7
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_7BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Name of SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfileReturnPerSsidSettings_7BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfileReturnPerSsidSettings_8
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_8BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Name of SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfileReturnPerSsidSettings_8BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfileReturnPerSsidSettings_9
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_9BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Name of SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfileReturnPerSsidSettings_9BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfileReturnPerSsidSettings_10
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_10BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Name of SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfileReturnPerSsidSettings_10BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfileReturnPerSsidSettings_11
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_11BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Name of SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfileReturnPerSsidSettings_11BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfileReturnPerSsidSettings_12
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_12BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Name of SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfileReturnPerSsidSettings_12BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfileReturnPerSsidSettings_13
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_13BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Name of SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfileReturnPerSsidSettings_13BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfileReturnPerSsidSettings_14
	{
		
		/// <summary>
		/// Choice between 'dual', '2.4ghz' or '5ghz'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandOperationMode")]
		public System.Nullable<UpdateNetworkWirelessRfProfileReturnPerSsidSettings_14BandOperationMode> BandOperationMode { get; set; }
		
		/// <summary>
		/// Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSteeringEnabled")]
		public System.Nullable<System.Boolean> BandSteeringEnabled { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Int32> MinBitrate { get; set; }
		
		/// <summary>
		/// Name of SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessRfProfileReturnPerSsidSettings_14BandOperationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4ghz")]
		_2_4ghz = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5ghz")]
		_5ghz = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dual = 2,
	}
	
	public class UpdateNetworkWirelessRfProfileReturnTransmission
	{
		
		/// <summary>
		/// Toggle for radio transmission. When false, radios will not transmit at all.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateNetworkWirelessRfProfileReturnTwoFourGhzSettings
	{
		
		/// <summary>
		/// Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="axEnabled")]
		public System.Nullable<System.Boolean> AxEnabled { get; set; }
		
		/// <summary>
		/// Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 30.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPower")]
		public System.Nullable<System.Int32> MaxPower { get; set; }
		
		/// <summary>
		/// Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. Defaults to 11.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
		
		/// <summary>
		/// Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 5.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minPower")]
		public System.Nullable<System.Int32> MinPower { get; set; }
		
		/// <summary>
		/// The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rxsop")]
		public System.Nullable<System.Int32> Rxsop { get; set; }
		
		/// <summary>
		/// Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validAutoChannels")]
		public int[] ValidAutoChannels { get; set; }
	}
	
	public class GetNetworkWirelessSettingsReturn
	{
		
		/// <summary>
		/// Toggle for enabling or disabling IPv6 bridging in a network (Note: if enabled, SSIDs must also be configured to use bridge mode)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6BridgeEnabled")]
		public System.Nullable<System.Boolean> Ipv6BridgeEnabled { get; set; }
		
		/// <summary>
		/// Toggle for enabling or disabling LED lights on all APs in the network (making them run dark)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ledLightsOn")]
		public System.Nullable<System.Boolean> LedLightsOn { get; set; }
		
		/// <summary>
		/// Toggle for enabling or disabling location analytics for your network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationAnalyticsEnabled")]
		public System.Nullable<System.Boolean> LocationAnalyticsEnabled { get; set; }
		
		/// <summary>
		/// Toggle for enabling or disabling meshing in a network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="meshingEnabled")]
		public System.Nullable<System.Boolean> MeshingEnabled { get; set; }
		
		/// <summary>
		/// Named VLAN settings for wireless networks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namedVlans")]
		public GetNetworkWirelessSettingsReturnNamedVlans NamedVlans { get; set; }
		
		/// <summary>
		/// The upgrade strategy to apply to the network. Must be one of 'minimizeUpgradeTime' or 'minimizeClientDowntime'. Requires firmware version MR 26.8 or higher'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradeStrategy")]
		public System.Nullable<GetNetworkWirelessSettingsReturnUpgradeStrategy> UpgradeStrategy { get; set; }
	}
	
	public class GetNetworkWirelessSettingsReturnNamedVlans
	{
		
		/// <summary>
		/// Named VLAN Pool DHCP Monitoring settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="poolDhcpMonitoring")]
		public GetNetworkWirelessSettingsReturnNamedVlansPoolDhcpMonitoring PoolDhcpMonitoring { get; set; }
	}
	
	public class GetNetworkWirelessSettingsReturnNamedVlansPoolDhcpMonitoring
	{
		
		/// <summary>
		/// The duration in minutes that devices will refrain from using dirty VLANs before adding them back to the pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<System.Int32> Duration { get; set; }
		
		/// <summary>
		/// Whether or not devices using named VLAN pools should remove dirty VLANs from the pool, thereby preventing clients from being assigned to VLANs where they would be unable to obtain an IP address via DHCP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkWirelessSettingsReturnUpgradeStrategy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		minimizeClientDowntime = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		minimizeUpgradeTime = 1,
	}
	
	public class UpdateNetworkWirelessSettingsPutBody
	{
		
		/// <summary>
		/// Toggle for enabling or disabling IPv6 bridging in a network (Note: if enabled, SSIDs must also be configured to use bridge mode)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6BridgeEnabled")]
		public System.Nullable<System.Boolean> Ipv6BridgeEnabled { get; set; }
		
		/// <summary>
		/// Toggle for enabling or disabling LED lights on all APs in the network (making them run dark)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ledLightsOn")]
		public System.Nullable<System.Boolean> LedLightsOn { get; set; }
		
		/// <summary>
		/// Toggle for enabling or disabling location analytics for your network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationAnalyticsEnabled")]
		public System.Nullable<System.Boolean> LocationAnalyticsEnabled { get; set; }
		
		/// <summary>
		/// Toggle for enabling or disabling meshing in a network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="meshingEnabled")]
		public System.Nullable<System.Boolean> MeshingEnabled { get; set; }
		
		/// <summary>
		/// The upgrade strategy to apply to the network. Must be one of 'minimizeUpgradeTime' or 'minimizeClientDowntime'. Requires firmware version MR 26.8 or higher'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradeStrategy")]
		public GetNetworkWirelessSettingsReturnUpgradeStrategy UpgradeStrategy { get; set; }
	}
	
	public class UpdateNetworkWirelessSettingsReturn
	{
		
		/// <summary>
		/// Toggle for enabling or disabling IPv6 bridging in a network (Note: if enabled, SSIDs must also be configured to use bridge mode)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6BridgeEnabled")]
		public System.Nullable<System.Boolean> Ipv6BridgeEnabled { get; set; }
		
		/// <summary>
		/// Toggle for enabling or disabling LED lights on all APs in the network (making them run dark)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ledLightsOn")]
		public System.Nullable<System.Boolean> LedLightsOn { get; set; }
		
		/// <summary>
		/// Toggle for enabling or disabling location analytics for your network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationAnalyticsEnabled")]
		public System.Nullable<System.Boolean> LocationAnalyticsEnabled { get; set; }
		
		/// <summary>
		/// Toggle for enabling or disabling meshing in a network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="meshingEnabled")]
		public System.Nullable<System.Boolean> MeshingEnabled { get; set; }
		
		/// <summary>
		/// Named VLAN settings for wireless networks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namedVlans")]
		public UpdateNetworkWirelessSettingsReturnNamedVlans NamedVlans { get; set; }
		
		/// <summary>
		/// The upgrade strategy to apply to the network. Must be one of 'minimizeUpgradeTime' or 'minimizeClientDowntime'. Requires firmware version MR 26.8 or higher'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradeStrategy")]
		public GetNetworkWirelessSettingsReturnUpgradeStrategy UpgradeStrategy { get; set; }
	}
	
	public class UpdateNetworkWirelessSettingsReturnNamedVlans
	{
		
		/// <summary>
		/// Named VLAN Pool DHCP Monitoring settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="poolDhcpMonitoring")]
		public UpdateNetworkWirelessSettingsReturnNamedVlansPoolDhcpMonitoring PoolDhcpMonitoring { get; set; }
	}
	
	public class UpdateNetworkWirelessSettingsReturnNamedVlansPoolDhcpMonitoring
	{
		
		/// <summary>
		/// The duration in minutes that devices will refrain from using dirty VLANs before adding them back to the pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<System.Int32> Duration { get; set; }
		
		/// <summary>
		/// Whether or not devices using named VLAN pools should remove dirty VLANs from the pool, thereby preventing clients from being assigned to VLANs where they would be unable to obtain an IP address via DHCP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public enum GetNetworkWirelessSignalQualityHistoryBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
	}
	
	public class GetNetworkWirelessSignalQualityHistoryReturn
	{
		
		/// <summary>
		/// The end time of the query range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTs")]
		public System.Nullable<System.DateTimeOffset> EndTs { get; set; }
		
		/// <summary>
		/// Received signal strength indicator
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rssi")]
		public System.Nullable<System.Int32> Rssi { get; set; }
		
		/// <summary>
		/// Signal to noise ratio
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snr")]
		public System.Nullable<System.Int32> Snr { get; set; }
		
		/// <summary>
		/// The start time of the query range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTs")]
		public System.Nullable<System.DateTimeOffset> StartTs { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidPutBody
	{
		
		/// <summary>
		/// The current setting for Active Directory. Only valid if splashPage is 'Password-protected with Active Directory'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="activeDirectory")]
		public UpdateNetworkWirelessSsidPutBodyActiveDirectory ActiveDirectory { get; set; }
		
		/// <summary>
		/// Boolean indicating whether or not adult content will be blocked
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adultContentFilteringEnabled")]
		public System.Nullable<System.Boolean> AdultContentFilteringEnabled { get; set; }
		
		/// <summary>
		/// The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apTagsAndVlanIds")]
		public UpdateNetworkWirelessSsidPutBodyApTagsAndVlanIds[] UpdateNetworkWirelessSsidPutBodyApTagsAndVlanIds { get; set; }
		
		/// <summary>
		/// The association control method for the SSID ('open', 'open-enhanced', 'psk', 'open-with-radius', 'open-with-nac', '8021x-meraki', '8021x-nac', '8021x-radius', '8021x-google', '8021x-localradius', 'ipsk-with-radius' or 'ipsk-without-radius')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authMode")]
		public System.Nullable<UpdateNetworkWirelessSsidPutBodyAuthMode> AuthMode { get; set; }
		
		/// <summary>
		/// Accepts a list of tags for this SSID. If availableOnAllAps is false, then the SSID will only be broadcast by APs with tags matching any of the tags in this list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availabilityTags")]
		public string[] AvailabilityTags { get; set; }
		
		/// <summary>
		/// Boolean indicating whether all APs should broadcast the SSID or if it should be restricted to APs matching any availability tags. Can only be false if the SSID has availability tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableOnAllAps")]
		public System.Nullable<System.Boolean> AvailableOnAllAps { get; set; }
		
		/// <summary>
		/// The client-serving radio frequencies of this SSID in the default indoor RF profile. ('Dual band operation', '5 GHz band only' or 'Dual band operation with Band Steering')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandSelection")]
		public string BandSelection { get; set; }
		
		/// <summary>
		/// The concentrator to use when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentratorNetworkId")]
		public string ConcentratorNetworkId { get; set; }
		
		/// <summary>
		/// The default VLAN ID used for 'all other APs'. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultVlanId")]
		public System.Nullable<System.Int32> DefaultVlanId { get; set; }
		
		/// <summary>
		/// Disassociate clients when 'VPN' concentrator failover occurs in order to trigger clients to re-associate and generate new DHCP requests. This param is only valid if ipAssignmentMode is 'VPN'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disassociateClientsOnVpnFailover")]
		public System.Nullable<System.Boolean> DisassociateClientsOnVpnFailover { get; set; }
		
		/// <summary>
		/// DNS servers rewrite settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsRewrite")]
		public UpdateNetworkWirelessSsidPutBodyDnsRewrite DnsRewrite { get; set; }
		
		/// <summary>
		/// The current setting for 802.11r
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dot11r")]
		public UpdateNetworkWirelessSsidPutBodyDot11r Dot11r { get; set; }
		
		/// <summary>
		/// The current setting for Protected Management Frames (802.11w).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dot11w")]
		public UpdateNetworkWirelessSsidPutBodyDot11w Dot11w { get; set; }
		
		/// <summary>
		/// Whether or not the SSID is enabled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The psk encryption mode for the SSID ('wep' or 'wpa'). This param is only valid if the authMode is 'psk'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptionMode")]
		public UpdateNetworkApplianceSsidPutBodyEncryptionMode EncryptionMode { get; set; }
		
		/// <summary>
		/// Whether or not an SSID is accessible by 'enterprise' administrators ('access disabled' or 'access enabled')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enterpriseAdminAccess")]
		public System.Nullable<UpdateNetworkWirelessSsidPutBodyEnterpriseAdminAccess> EnterpriseAdminAccess { get; set; }
		
		/// <summary>
		/// Ethernet over GRE settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gre")]
		public UpdateNetworkWirelessSsidPutBodyGre Gre { get; set; }
		
		/// <summary>
		/// The client IP assignment mode ('NAT mode', 'Bridge mode', 'Layer 3 roaming', 'Ethernet over GRE', 'Layer 3 roaming with a concentrator' or 'VPN')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipAssignmentMode")]
		public string IpAssignmentMode { get; set; }
		
		/// <summary>
		/// Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is 'Bridge mode'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lanIsolationEnabled")]
		public System.Nullable<System.Boolean> LanIsolationEnabled { get; set; }
		
		/// <summary>
		/// The current setting for LDAP. Only valid if splashPage is 'Password-protected with LDAP'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ldap")]
		public UpdateNetworkWirelessSsidPutBodyLdap Ldap { get; set; }
		
		/// <summary>
		/// The current setting for Local Authentication, a built-in RADIUS server on the access point. Only valid if authMode is '8021x-localradius'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localRadius")]
		public UpdateNetworkWirelessSsidPutBodyLocalRadius LocalRadius { get; set; }
		
		/// <summary>
		/// If true, Mandatory DHCP will enforce that clients connecting to this SSID must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mandatoryDhcpEnabled")]
		public System.Nullable<System.Boolean> MandatoryDhcpEnabled { get; set; }
		
		/// <summary>
		/// The minimum bitrate in Mbps of this SSID in the default indoor RF profile. ('1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minBitrate")]
		public System.Nullable<System.Single> MinBitrate { get; set; }
		
		/// <summary>
		/// The name of the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The OAuth settings of this SSID. Only valid if splashPage is 'Google OAuth'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oauth")]
		public UpdateNetworkWirelessSsidPutBodyOauth Oauth { get; set; }
		
		/// <summary>
		/// The download bandwidth limit in Kbps. (0 represents no limit.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perClientBandwidthLimitDown")]
		public System.Nullable<System.Int32> PerClientBandwidthLimitDown { get; set; }
		
		/// <summary>
		/// The upload bandwidth limit in Kbps. (0 represents no limit.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perClientBandwidthLimitUp")]
		public System.Nullable<System.Int32> PerClientBandwidthLimitUp { get; set; }
		
		/// <summary>
		/// The total download bandwidth limit in Kbps. (0 represents no limit.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perSsidBandwidthLimitDown")]
		public System.Nullable<System.Int32> PerSsidBandwidthLimitDown { get; set; }
		
		/// <summary>
		/// The total upload bandwidth limit in Kbps. (0 represents no limit.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perSsidBandwidthLimitUp")]
		public System.Nullable<System.Int32> PerSsidBandwidthLimitUp { get; set; }
		
		/// <summary>
		/// The passkey for the SSID. This param is only valid if the authMode is 'psk'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="psk")]
		public string Psk { get; set; }
		
		/// <summary>
		/// Whether or not RADIUS accounting is enabled. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusAccountingEnabled")]
		public System.Nullable<System.Boolean> RadiusAccountingEnabled { get; set; }
		
		/// <summary>
		/// The interval (in seconds) in which accounting information is updated and sent to the RADIUS accounting server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusAccountingInterimInterval")]
		public System.Nullable<System.Int32> RadiusAccountingInterimInterval { get; set; }
		
		/// <summary>
		/// The RADIUS accounting 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius' and radiusAccountingEnabled is 'true'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusAccountingServers")]
		public UpdateNetworkWirelessSsidPutBodyRadiusAccountingServers[] UpdateNetworkWirelessSsidPutBodyRadiusAccountingServers { get; set; }
		
		/// <summary>
		/// Specify the RADIUS attribute used to look up group policies ('Filter-Id', 'Reply-Message', 'Airespace-ACL-Name' or 'Aruba-User-Role'). Access points must receive this attribute in the RADIUS Access-Accept message
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusAttributeForGroupPolicies")]
		public System.Nullable<UpdateNetworkWirelessSsidPutBodyRadiusAttributeForGroupPolicies> RadiusAttributeForGroupPolicies { get; set; }
		
		/// <summary>
		/// The template of the NAS identifier to be used for RADIUS authentication (ex. $NODE_MAC$:$VAP_NUM$).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusAuthenticationNasId")]
		public string RadiusAuthenticationNasId { get; set; }
		
		/// <summary>
		/// The template of the called station identifier to be used for RADIUS (ex. $NODE_MAC$:$VAP_NUM$).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusCalledStationId")]
		public string RadiusCalledStationId { get; set; }
		
		/// <summary>
		/// If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusCoaEnabled")]
		public System.Nullable<System.Boolean> RadiusCoaEnabled { get; set; }
		
		/// <summary>
		/// This policy determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable ('Deny access' or 'Allow access')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusFailoverPolicy")]
		public System.Nullable<UpdateNetworkWirelessSsidPutBodyRadiusFailoverPolicy> RadiusFailoverPolicy { get; set; }
		
		/// <summary>
		/// Whether or not higher priority RADIUS servers should be retried after 60 seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusFallbackEnabled")]
		public System.Nullable<System.Boolean> RadiusFallbackEnabled { get; set; }
		
		/// <summary>
		/// Whether or not RADIUS Guest VLAN is enabled. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusGuestVlanEnabled")]
		public System.Nullable<System.Boolean> RadiusGuestVlanEnabled { get; set; }
		
		/// <summary>
		/// VLAN ID of the RADIUS Guest VLAN. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusGuestVlanId")]
		public System.Nullable<System.Int32> RadiusGuestVlanId { get; set; }
		
		/// <summary>
		/// This policy determines which RADIUS server will be contacted first in an authentication attempt and the ordering of any necessary retry attempts ('Strict priority order' or 'Round robin')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusLoadBalancingPolicy")]
		public System.Nullable<UpdateNetworkWirelessSsidPutBodyRadiusLoadBalancingPolicy> RadiusLoadBalancingPolicy { get; set; }
		
		/// <summary>
		/// If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is 'NAT mode'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusOverride")]
		public System.Nullable<System.Boolean> RadiusOverride { get; set; }
		
		/// <summary>
		/// If true, Meraki devices will proxy RADIUS messages through the Meraki cloud to the configured RADIUS auth and accounting servers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusProxyEnabled")]
		public System.Nullable<System.Boolean> RadiusProxyEnabled { get; set; }
		
		/// <summary>
		/// The maximum number of transmit attempts after which a RADIUS server is failed over (must be between 1-5).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusServerAttemptsLimit")]
		public System.Nullable<System.Int32> RadiusServerAttemptsLimit { get; set; }
		
		/// <summary>
		/// The amount of time for which a RADIUS client waits for a reply from the RADIUS server (must be between 1-10 seconds).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusServerTimeout")]
		public System.Nullable<System.Int32> RadiusServerTimeout { get; set; }
		
		/// <summary>
		/// The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusServers")]
		public UpdateNetworkWirelessSsidPutBodyRadiusServers[] UpdateNetworkWirelessSsidPutBodyRadiusServers { get; set; }
		
		/// <summary>
		/// If true, Meraki devices will periodically send Access-Request messages to configured RADIUS servers using identity 'meraki_8021x_test' to ensure that the RADIUS servers are reachable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radiusTestingEnabled")]
		public System.Nullable<System.Boolean> RadiusTestingEnabled { get; set; }
		
		/// <summary>
		/// The secondary concentrator to use when the ipAssignmentMode is 'VPN'. If configured, the APs will switch to using this concentrator if the primary concentrator is unreachable. This param is optional. ('disabled' represents no secondary concentrator.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondaryConcentratorNetworkId")]
		public string SecondaryConcentratorNetworkId { get; set; }
		
		/// <summary>
		/// The SpeedBurst setting for this SSID'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="speedBurst")]
		public UpdateNetworkWirelessSsidPutBodySpeedBurst SpeedBurst { get; set; }
		
		/// <summary>
		/// Array of valid sponsor email domains for sponsored guest splash type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashGuestSponsorDomains")]
		public string[] SplashGuestSponsorDomains { get; set; }
		
		/// <summary>
		/// The type of splash page for the SSID ('None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Sponsored guest', 'Cisco ISE' or 'Google Apps domain'). This attribute is not supported for template children.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashPage")]
		public System.Nullable<UpdateNetworkWirelessSsidPutBodySplashPage> SplashPage { get; set; }
		
		/// <summary>
		/// Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useVlanTagging")]
		public System.Nullable<System.Boolean> UseVlanTagging { get; set; }
		
		/// <summary>
		/// Boolean indicating whether APs should advertise or hide this SSID. APs will only broadcast this SSID if set to true
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visible")]
		public System.Nullable<System.Boolean> Visible { get; set; }
		
		/// <summary>
		/// The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public System.Nullable<System.Int32> VlanId { get; set; }
		
		/// <summary>
		/// Allow access to a configurable list of IP ranges, which users may access prior to sign-on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="walledGardenEnabled")]
		public System.Nullable<System.Boolean> WalledGardenEnabled { get; set; }
		
		/// <summary>
		/// Specify your walled garden by entering an array of addresses, ranges using CIDR notation, domain names, and domain wildcards (e.g. '192.168.1.1/24', '192.168.37.10/32', 'www.yahoo.com', '*.google.com']). Meraki's splash page is automatically included in your walled garden.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="walledGardenRanges")]
		public string[] WalledGardenRanges { get; set; }
		
		/// <summary>
		/// The types of WPA encryption. ('WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode', 'WPA3 only' or 'WPA3 192-bit Security')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wpaEncryptionMode")]
		public System.Nullable<UpdateNetworkWirelessSsidPutBodyWpaEncryptionMode> WpaEncryptionMode { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidPutBodyActiveDirectory
	{
		
		/// <summary>
		/// (Optional) The credentials of the user account to be used by the AP to bind to your Active Directory server. The Active Directory account should have permissions on all your Active Directory servers. Only valid if the splashPage is 'Password-protected with Active Directory'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="credentials")]
		public UpdateNetworkWirelessSsidPutBodyActiveDirectoryCredentials Credentials { get; set; }
		
		/// <summary>
		/// The Active Directory servers to be used for authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="servers")]
		public UpdateNetworkWirelessSsidPutBodyActiveDirectoryServers[] UpdateNetworkWirelessSsidPutBodyActiveDirectoryServers { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidPutBodyActiveDirectoryCredentials
	{
		
		/// <summary>
		/// The logon name of the Active Directory account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logonName")]
		public string LogonName { get; set; }
		
		/// <summary>
		/// The password to the Active Directory user account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidPutBodyActiveDirectoryServers
	{
		
		/// <summary>
		/// IP address of your Active Directory server.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// (Optional) UDP port the Active Directory server listens on. By default, uses port 3268.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidPutBodyApTagsAndVlanIds
	{
		
		/// <summary>
		/// Array of AP tags
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// Numerical identifier that is assigned to the VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public System.Nullable<System.Int32> VlanId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessSsidPutBodyAuthMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8021x-google")]
		_8021xMinusgoogle = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8021x-localradius")]
		_8021xMinuslocalradius = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8021x-meraki")]
		_8021xMinusmeraki = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8021x-nac")]
		_8021xMinusnac = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8021x-radius")]
		_8021xMinusradius = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ipsk-with-radius")]
		ipskMinuswithMinusradius = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ipsk-without-radius")]
		ipskMinuswithoutMinusradius = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		open = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="open-enhanced")]
		openMinusenhanced = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="open-with-nac")]
		openMinuswithMinusnac = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="open-with-radius")]
		openMinuswithMinusradius = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		psk = 11,
	}
	
	public class UpdateNetworkWirelessSsidPutBodyDnsRewrite
	{
		
		/// <summary>
		/// User specified DNS servers (up to two servers)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsCustomNameservers")]
		public string[] DnsCustomNameservers { get; set; }
		
		/// <summary>
		/// Boolean indicating whether or not DNS server rewrite is enabled. If disabled, upstream DNS will be used
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidPutBodyDot11r
	{
		
		/// <summary>
		/// (Optional) Whether 802.11r is adaptive or not.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adaptive")]
		public System.Nullable<System.Boolean> Adaptive { get; set; }
		
		/// <summary>
		/// Whether 802.11r is enabled or not.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidPutBodyDot11w
	{
		
		/// <summary>
		/// Whether 802.11w is enabled or not.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// (Optional) Whether 802.11w is required or not.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="required")]
		public System.Nullable<System.Boolean> Required { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessSsidPutBodyEnterpriseAdminAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="access disabled")]
		access_disabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="access enabled")]
		access_enabled = 1,
	}
	
	public class UpdateNetworkWirelessSsidPutBodyGre
	{
		
		/// <summary>
		/// The EoGRE concentrator's settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentrator")]
		public UpdateNetworkWirelessSsidPutBodyGreConcentrator Concentrator { get; set; }
		
		/// <summary>
		/// Optional numerical identifier that will add the GRE key field to the GRE header. Used to identify an individual traffic flow within a tunnel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public System.Nullable<System.Int32> Key { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidPutBodyGreConcentrator
	{
		
		/// <summary>
		/// The EoGRE concentrator's IP or FQDN. This param is required when ipAssignmentMode is 'Ethernet over GRE'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidPutBodyLdap
	{
		
		/// <summary>
		/// The base distinguished name of users on the LDAP server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="baseDistinguishedName")]
		public string BaseDistinguishedName { get; set; }
		
		/// <summary>
		/// (Optional) The credentials of the user account to be used by the AP to bind to your LDAP server. The LDAP account should have permissions on all your LDAP servers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="credentials")]
		public UpdateNetworkWirelessSsidPutBodyLdapCredentials Credentials { get; set; }
		
		/// <summary>
		/// The CA certificate used to sign the LDAP server's key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serverCaCertificate")]
		public UpdateNetworkWirelessSsidPutBodyLdapServerCaCertificate ServerCaCertificate { get; set; }
		
		/// <summary>
		/// The LDAP servers to be used for authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="servers")]
		public UpdateNetworkWirelessSsidPutBodyLdapServers[] UpdateNetworkWirelessSsidPutBodyLdapServers { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidPutBodyLdapCredentials
	{
		
		/// <summary>
		/// The distinguished name of the LDAP user account (example: cn=user,dc=meraki,dc=com).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="distinguishedName")]
		public string DistinguishedName { get; set; }
		
		/// <summary>
		/// The password of the LDAP user account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidPutBodyLdapServerCaCertificate
	{
		
		/// <summary>
		/// The contents of the CA certificate. Must be in PEM or DER format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public string Contents { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidPutBodyLdapServers
	{
		
		/// <summary>
		/// IP address of your LDAP server.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// UDP port the LDAP server listens on.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidPutBodyLocalRadius
	{
		
		/// <summary>
		/// The duration (in seconds) for which LDAP and OCSP lookups are cached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cacheTimeout")]
		public System.Nullable<System.Int32> CacheTimeout { get; set; }
		
		/// <summary>
		/// The current setting for certificate verification.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateAuthentication")]
		public UpdateNetworkWirelessSsidPutBodyLocalRadiusCertificateAuthentication CertificateAuthentication { get; set; }
		
		/// <summary>
		/// The current setting for password-based authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="passwordAuthentication")]
		public UpdateNetworkWirelessSsidPutBodyLocalRadiusPasswordAuthentication PasswordAuthentication { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidPutBodyLocalRadiusCertificateAuthentication
	{
		
		/// <summary>
		/// The Client CA Certificate used to sign the client certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientRootCaCertificate")]
		public UpdateNetworkWirelessSsidPutBodyLocalRadiusCertificateAuthenticationClientRootCaCertificate ClientRootCaCertificate { get; set; }
		
		/// <summary>
		/// Whether or not to use EAP-TLS certificate-based authentication to validate wireless clients.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// (Optional) The URL of the OCSP responder to verify client certificate status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ocspResponderUrl")]
		public string OcspResponderUrl { get; set; }
		
		/// <summary>
		/// Whether or not to verify the certificate with LDAP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useLdap")]
		public System.Nullable<System.Boolean> UseLdap { get; set; }
		
		/// <summary>
		/// Whether or not to verify the certificate with OCSP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useOcsp")]
		public System.Nullable<System.Boolean> UseOcsp { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidPutBodyLocalRadiusCertificateAuthenticationClientRootCaCertificate
	{
		
		/// <summary>
		/// The contents of the Client CA Certificate. Must be in PEM or DER format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public string Contents { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidPutBodyLocalRadiusPasswordAuthentication
	{
		
		/// <summary>
		/// Whether or not to use EAP-TTLS/PAP or PEAP-GTC password-based authentication via LDAP lookup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidPutBodyOauth
	{
		
		/// <summary>
		/// (Optional) The list of domains allowed access to the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedDomains")]
		public string[] AllowedDomains { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidPutBodyRadiusAccountingServers
	{
		
		/// <summary>
		/// Certificate used for authorization for the RADSEC Server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caCertificate")]
		public string CaCertificate { get; set; }
		
		/// <summary>
		/// IP address to which the APs will send RADIUS accounting messages
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// Port on the RADIUS server that is listening for accounting messages
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Use RADSEC (TLS over TCP) to connect to this RADIUS accounting server. Requires radiusProxyEnabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radsecEnabled")]
		public System.Nullable<System.Boolean> RadsecEnabled { get; set; }
		
		/// <summary>
		/// Shared key used to authenticate messages between the APs and RADIUS server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessSsidPutBodyRadiusAttributeForGroupPolicies
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Airespace-ACL-Name")]
		AirespaceMinusACLMinusName = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Aruba-User-Role")]
		ArubaMinusUserMinusRole = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Filter-Id")]
		FilterMinusId = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Reply-Message")]
		ReplyMinusMessage = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessSsidPutBodyRadiusFailoverPolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Allow access")]
		Allow_access = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Deny access")]
		Deny_access = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessSsidPutBodyRadiusLoadBalancingPolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Round robin")]
		Round_robin = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Strict priority order")]
		Strict_priority_order = 1,
	}
	
	public class UpdateNetworkWirelessSsidPutBodyRadiusServers
	{
		
		/// <summary>
		/// Certificate used for authorization for the RADSEC Server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caCertificate")]
		public string CaCertificate { get; set; }
		
		/// <summary>
		/// IP address of your RADIUS server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// The ID of the Openroaming Certificate attached to radius server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="openRoamingCertificateId")]
		public System.Nullable<System.Int32> OpenRoamingCertificateId { get; set; }
		
		/// <summary>
		/// UDP port the RADIUS server listens on for Access-requests
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Use RADSEC (TLS over TCP) to connect to this RADIUS server. Requires radiusProxyEnabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radsecEnabled")]
		public System.Nullable<System.Boolean> RadsecEnabled { get; set; }
		
		/// <summary>
		/// RADIUS client shared secret
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidPutBodySpeedBurst
	{
		
		/// <summary>
		/// Boolean indicating whether or not to allow users to temporarily exceed the bandwidth limit for short periods while still keeping them under the bandwidth limit over time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessSsidPutBodySplashPage
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Billing = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Cisco ISE")]
		Cisco_ISE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Click-through splash page")]
		ClickMinusthrough_splash_page = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Facebook Wi-Fi")]
		Facebook_WiMinusFi = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Google Apps domain")]
		Google_Apps_domain = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Google OAuth")]
		Google_OAuth = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		None = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Password-protected with Active Directory")]
		PasswordMinusprotected_with_Active_Directory = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Password-protected with LDAP")]
		PasswordMinusprotected_with_LDAP = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Password-protected with Meraki RADIUS")]
		PasswordMinusprotected_with_Meraki_RADIUS = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Password-protected with custom RADIUS")]
		PasswordMinusprotected_with_custom_RADIUS = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SMS authentication")]
		SMS_authentication = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Sponsored guest")]
		Sponsored_guest = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Systems Manager Sentry")]
		Systems_Manager_Sentry = 13,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessSsidPutBodyWpaEncryptionMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WPA1 and WPA2")]
		WPA1_and_WPA2 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WPA1 only")]
		WPA1_only = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WPA2 only")]
		WPA2_only = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WPA3 192-bit Security")]
		WPA3_192Minusbit_Security = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WPA3 Transition Mode")]
		WPA3_Transition_Mode = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WPA3 only")]
		WPA3_only = 5,
	}
	
	public class UpdateNetworkWirelessSsidBonjourForwardingPutBody
	{
		
		/// <summary>
		/// If true, Bonjour forwarding is enabled on this SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// List of bonjour forwarding rules.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkWirelessSsidBonjourForwardingPutBodyRules[] UpdateNetworkWirelessSsidBonjourForwardingPutBodyRules { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidBonjourForwardingPutBodyRules
	{
		
		/// <summary>
		/// A description for your Bonjour forwarding rule. Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="services")]
		public string[] Services { get; set; }
		
		/// <summary>
		/// The ID of the service VLAN. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public string VlanId { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBody
	{
		
		/// <summary>
		/// List of device type policies.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceTypePolicies")]
		public UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePolicies[] UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePolicies { get; set; }
		
		/// <summary>
		/// If true, the SSID device type group policies are enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePolicies
	{
		
		/// <summary>
		/// The device policy. Can be one of 'Allowed', 'Blocked' or 'Group policy'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devicePolicy")]
		public UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePoliciesDevicePolicy DevicePolicy { get; set; }
		
		/// <summary>
		/// The device type. Can be one of 'Android', 'BlackBerry', 'Chrome OS', 'iPad', 'iPhone', 'iPod', 'Mac OS X', 'Windows', 'Windows Phone', 'B&N Nook' or 'Other OS'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deviceType")]
		public UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePoliciesDeviceType DeviceType { get; set; }
		
		/// <summary>
		/// ID of the group policy object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public System.Nullable<System.Int32> GroupPolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePoliciesDevicePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Allowed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Blocked = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group policy")]
		Group_policy = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesPutBodyDeviceTypePoliciesDeviceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Android = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="B&N Nook")]
		BAndN_Nook = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BlackBerry = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Chrome OS")]
		Chrome_OS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Mac OS X")]
		Mac_OS_X = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Other OS")]
		Other_OS = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Windows = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Windows Phone")]
		Windows_Phone = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		iPad = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		iPhone = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		iPod = 10,
	}
	
	public class GetNetworkWirelessSsidEapOverrideReturn
	{
		
		/// <summary>
		/// EAPOL Key settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eapolKey")]
		public GetNetworkWirelessSsidEapOverrideReturnEapolKey EapolKey { get; set; }
		
		/// <summary>
		/// EAP settings for identity requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="identity")]
		public GetNetworkWirelessSsidEapOverrideReturnIdentity Identity { get; set; }
		
		/// <summary>
		/// Maximum number of general EAP retries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxRetries")]
		public System.Nullable<System.Int32> MaxRetries { get; set; }
		
		/// <summary>
		/// General EAP timeout in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public System.Nullable<System.Int32> Timeout { get; set; }
	}
	
	public class GetNetworkWirelessSsidEapOverrideReturnEapolKey
	{
		
		/// <summary>
		/// Maximum number of EAPOL key retries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retries")]
		public System.Nullable<System.Int32> Retries { get; set; }
		
		/// <summary>
		/// EAPOL Key timeout in milliseconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeoutInMs")]
		public System.Nullable<System.Int32> TimeoutInMs { get; set; }
	}
	
	public class GetNetworkWirelessSsidEapOverrideReturnIdentity
	{
		
		/// <summary>
		/// Maximum number of EAP retries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retries")]
		public System.Nullable<System.Int32> Retries { get; set; }
		
		/// <summary>
		/// EAP timeout in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public System.Nullable<System.Int32> Timeout { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidEapOverridePutBody
	{
		
		/// <summary>
		/// EAPOL Key settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eapolKey")]
		public UpdateNetworkWirelessSsidEapOverridePutBodyEapolKey EapolKey { get; set; }
		
		/// <summary>
		/// EAP settings for identity requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="identity")]
		public UpdateNetworkWirelessSsidEapOverridePutBodyIdentity Identity { get; set; }
		
		/// <summary>
		/// Maximum number of general EAP retries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxRetries")]
		public System.Nullable<System.Int32> MaxRetries { get; set; }
		
		/// <summary>
		/// General EAP timeout in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public System.Nullable<System.Int32> Timeout { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidEapOverridePutBodyEapolKey
	{
		
		/// <summary>
		/// Maximum number of EAPOL key retries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retries")]
		public System.Nullable<System.Int32> Retries { get; set; }
		
		/// <summary>
		/// EAPOL Key timeout in milliseconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeoutInMs")]
		public System.Nullable<System.Int32> TimeoutInMs { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidEapOverridePutBodyIdentity
	{
		
		/// <summary>
		/// Maximum number of EAP retries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retries")]
		public System.Nullable<System.Int32> Retries { get; set; }
		
		/// <summary>
		/// EAP timeout in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public System.Nullable<System.Int32> Timeout { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidEapOverrideReturn
	{
		
		/// <summary>
		/// EAPOL Key settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eapolKey")]
		public UpdateNetworkWirelessSsidEapOverrideReturnEapolKey EapolKey { get; set; }
		
		/// <summary>
		/// EAP settings for identity requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="identity")]
		public UpdateNetworkWirelessSsidEapOverrideReturnIdentity Identity { get; set; }
		
		/// <summary>
		/// Maximum number of general EAP retries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxRetries")]
		public System.Nullable<System.Int32> MaxRetries { get; set; }
		
		/// <summary>
		/// General EAP timeout in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public System.Nullable<System.Int32> Timeout { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidEapOverrideReturnEapolKey
	{
		
		/// <summary>
		/// Maximum number of EAPOL key retries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retries")]
		public System.Nullable<System.Int32> Retries { get; set; }
		
		/// <summary>
		/// EAPOL Key timeout in milliseconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeoutInMs")]
		public System.Nullable<System.Int32> TimeoutInMs { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidEapOverrideReturnIdentity
	{
		
		/// <summary>
		/// Maximum number of EAP retries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retries")]
		public System.Nullable<System.Int32> Retries { get; set; }
		
		/// <summary>
		/// EAP timeout in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public System.Nullable<System.Int32> Timeout { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidFirewallL3FirewallRulesPutBody
	{
		
		/// <summary>
		/// Allow wireless client access to local LAN (boolean value - true allows access and false denies access) (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowLanAccess")]
		public System.Nullable<System.Boolean> AllowLanAccess { get; set; }
		
		/// <summary>
		/// An ordered array of the firewall rules for this SSID (not including the local LAN access rule or the default rule)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkWirelessSsidFirewallL3FirewallRulesPutBodyRules[] UpdateNetworkWirelessSsidFirewallL3FirewallRulesPutBodyRules { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidFirewallL3FirewallRulesPutBodyRules
	{
		
		/// <summary>
		/// Description of the rule (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destCidr")]
		public string DestCidr { get; set; }
		
		/// <summary>
		/// Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destPort")]
		public string DestPort { get; set; }
		
		/// <summary>
		/// 'allow' or 'deny' traffic specified by this rule
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy Policy { get; set; }
		
		/// <summary>
		/// The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol Protocol { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidFirewallL7FirewallRulesPutBody
	{
		
		/// <summary>
		/// An array of L7 firewall rules for this SSID. Rules will get applied in the same order user has specified in request. Empty array will clear the L7 firewall rule configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkWirelessSsidFirewallL7FirewallRulesPutBodyRules[] UpdateNetworkWirelessSsidFirewallL7FirewallRulesPutBodyRules { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidFirewallL7FirewallRulesPutBodyRules
	{
		
		/// <summary>
		/// 'Deny' traffic specified by this rule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesPolicy Policy { get; set; }
		
		/// <summary>
		/// Type of the L7 firewall rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public UpdateNetworkApplianceFirewallL7FirewallRulesPutBodyRulesType Type { get; set; }
		
		/// <summary>
		/// The value of what needs to get blocked. Format of the value varies depending on type of the firewall rule selected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidHotspot20PutBody
	{
		
		/// <summary>
		/// An array of domain names
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domains")]
		public string[] Domains { get; set; }
		
		/// <summary>
		/// Whether or not Hotspot 2.0 for this SSID is enabled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// An array of MCC/MNC pairs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mccMncs")]
		public UpdateNetworkWirelessSsidHotspot20PutBodyMccMncs[] UpdateNetworkWirelessSsidHotspot20PutBodyMccMncs { get; set; }
		
		/// <summary>
		/// An array of NAI realms
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="naiRealms")]
		public UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealms[] UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealms { get; set; }
		
		/// <summary>
		/// The network type of this SSID ('Private network', 'Private network with guest access', 'Chargeable public network', 'Free public network', 'Personal device network', 'Emergency services only network', 'Test or experimental', 'Wildcard')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkAccessType")]
		public System.Nullable<UpdateNetworkWirelessSsidHotspot20PutBodyNetworkAccessType> NetworkAccessType { get; set; }
		
		/// <summary>
		/// Operator settings for this SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operator")]
		public UpdateNetworkWirelessSsidHotspot20PutBodyOperator Operator { get; set; }
		
		/// <summary>
		/// An array of roaming consortium OIs (hexadecimal number 3-5 octets in length)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="roamConsortOis")]
		public string[] RoamConsortOis { get; set; }
		
		/// <summary>
		/// Venue settings for this SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="venue")]
		public UpdateNetworkWirelessSsidHotspot20PutBodyVenue Venue { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidHotspot20PutBodyMccMncs
	{
		
		/// <summary>
		/// MCC value
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mcc")]
		public string Mcc { get; set; }
		
		/// <summary>
		/// MNC value
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mnc")]
		public string Mnc { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealms
	{
		
		/// <summary>
		/// The format for the realm ('1' or '0')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public System.Nullable<UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealmsFormat> Format { get; set; }
		
		/// <summary>
		/// An array of EAP methods for the realm.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="methods")]
		public UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealmsMethods[] UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealmsMethods { get; set; }
		
		/// <summary>
		/// The name of the realm
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="realm")]
		public string Realm { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealmsFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="0")]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1")]
		_1 = 1,
	}
	
	public class UpdateNetworkWirelessSsidHotspot20PutBodyNaiRealmsMethods
	{
		
		/// <summary>
		/// The authentication types for the method. These should be formatted as an object with the EAP method category in camelcase as the key and the list of types as the value (nonEapInnerAuthentication: Reserved, PAP, CHAP, MSCHAP, MSCHAPV2; eapInnerAuthentication: EAP-TLS, EAP-SIM, EAP-AKA, EAP-TTLS with MSCHAPv2; credentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, none, Reserved, Vendor Specific; tunneledEapMethodCredentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, Reserved, Anonymous, Vendor Specific)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authenticationTypes")]
		public string AuthenticationTypes { get; set; }
		
		/// <summary>
		/// ID of method
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessSsidHotspot20PutBodyNetworkAccessType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Chargeable public network")]
		Chargeable_public_network = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Emergency services only network")]
		Emergency_services_only_network = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Free public network")]
		Free_public_network = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Personal device network")]
		Personal_device_network = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Private network")]
		Private_network = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Private network with guest access")]
		Private_network_with_guest_access = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Test or experimental")]
		Test_or_experimental = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Wildcard = 7,
	}
	
	public class UpdateNetworkWirelessSsidHotspot20PutBodyOperator
	{
		
		/// <summary>
		/// Operator name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidHotspot20PutBodyVenue
	{
		
		/// <summary>
		/// Venue name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Venue type ('Unspecified', 'Unspecified Assembly', 'Arena', 'Stadium', 'Passenger Terminal', 'Amphitheater', 'Amusement Park', 'Place of Worship', 'Convention Center', 'Library', 'Museum', 'Restaurant', 'Theater', 'Bar', 'Coffee Shop', 'Zoo or Aquarium', 'Emergency Coordination Center', 'Unspecified Business', 'Doctor or Dentist office', 'Bank', 'Fire Station', 'Police Station', 'Post Office', 'Professional Office', 'Research and Development Facility', 'Attorney Office', 'Unspecified Educational', 'School, Primary', 'School, Secondary', 'University or College', 'Unspecified Factory and Industrial', 'Factory', 'Unspecified Institutional', 'Hospital', 'Long-Term Care Facility', 'Alcohol and Drug Rehabilitation Center', 'Group Home', 'Prison or Jail', 'Unspecified Mercantile', 'Retail Store', 'Grocery Market', 'Automotive Service Station', 'Shopping Mall', 'Gas Station', 'Unspecified Residential', 'Private Residence', 'Hotel or Motel', 'Dormitory', 'Boarding House', 'Unspecified Storage', 'Unspecified Utility and Miscellaneous', 'Unspecified Vehicular', 'Automobile or Truck', 'Airplane', 'Bus', 'Ferry', 'Ship or Boat', 'Train', 'Motor Bike', 'Unspecified Outdoor', 'Muni-mesh Network', 'City Park', 'Rest Area', 'Traffic Control', 'Bus Stop', 'Kiosk')
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<UpdateNetworkWirelessSsidHotspot20PutBodyVenueType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessSsidHotspot20PutBodyVenueType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Airplane = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Alcohol and Drug Rehabilitation Center")]
		Alcohol_and_Drug_Rehabilitation_Center = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Amphitheater = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Amusement Park")]
		Amusement_Park = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Arena = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Attorney Office")]
		Attorney_Office = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Automobile or Truck")]
		Automobile_or_Truck = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Automotive Service Station")]
		Automotive_Service_Station = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Bank = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Bar = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Boarding House")]
		Boarding_House = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Bus = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Bus Stop")]
		Bus_Stop = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="City Park")]
		City_Park = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Coffee Shop")]
		Coffee_Shop = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Convention Center")]
		Convention_Center = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Doctor or Dentist office")]
		Doctor_or_Dentist_office = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Dormitory = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Emergency Coordination Center")]
		Emergency_Coordination_Center = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Factory = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Ferry = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Fire Station")]
		Fire_Station = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Gas Station")]
		Gas_Station = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Grocery Market")]
		Grocery_Market = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Group Home")]
		Group_Home = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Hospital = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Hotel or Motel")]
		Hotel_or_Motel = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Kiosk = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Library = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Long-Term Care Facility")]
		LongMinusTerm_Care_Facility = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Motor Bike")]
		Motor_Bike = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Muni-mesh Network")]
		MuniMinusmesh_Network = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Museum = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Passenger Terminal")]
		Passenger_Terminal = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Place of Worship")]
		Place_of_Worship = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Police Station")]
		Police_Station = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Post Office")]
		Post_Office = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Prison or Jail")]
		Prison_or_Jail = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Private Residence")]
		Private_Residence = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Professional Office")]
		Professional_Office = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Research and Development Facility")]
		Research_and_Development_Facility = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Rest Area")]
		Rest_Area = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Restaurant = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Retail Store")]
		Retail_Store = 43,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="School, Primary")]
		School_Primary = 44,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="School, Secondary")]
		School_Secondary = 45,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Ship or Boat")]
		Ship_or_Boat = 46,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Shopping Mall")]
		Shopping_Mall = 47,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Stadium = 48,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Theater = 49,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Traffic Control")]
		Traffic_Control = 50,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Train = 51,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="University or College")]
		University_or_College = 52,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unspecified = 53,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unspecified Assembly")]
		Unspecified_Assembly = 54,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unspecified Business")]
		Unspecified_Business = 55,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unspecified Educational")]
		Unspecified_Educational = 56,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unspecified Factory and Industrial")]
		Unspecified_Factory_and_Industrial = 57,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unspecified Institutional")]
		Unspecified_Institutional = 58,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unspecified Mercantile")]
		Unspecified_Mercantile = 59,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unspecified Outdoor")]
		Unspecified_Outdoor = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unspecified Residential")]
		Unspecified_Residential = 61,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unspecified Storage")]
		Unspecified_Storage = 62,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unspecified Utility and Miscellaneous")]
		Unspecified_Utility_and_Miscellaneous = 63,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unspecified Vehicular")]
		Unspecified_Vehicular = 64,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Zoo or Aquarium")]
		Zoo_or_Aquarium = 65,
	}
	
	public class GetNetworkWirelessSsidIdentityPsksReturn
	{
		
		/// <summary>
		/// The email associated with the System's Manager User
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Timestamp for when the Identity PSK expires, or 'null' to never expire
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiresAt")]
		public string ExpiresAt { get; set; }
		
		/// <summary>
		/// The group policy to be applied to clients
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
		
		/// <summary>
		/// The unique identifier of the Identity PSK
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the Identity PSK
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The passphrase for client authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="passphrase")]
		public string Passphrase { get; set; }
		
		/// <summary>
		/// The WiFi Personal Network unique identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiPersonalNetworkId")]
		public string WifiPersonalNetworkId { get; set; }
	}
	
	public class CreateNetworkWirelessSsidIdentityPskPostBody
	{
		
		/// <summary>
		/// The group policy to be applied to clients
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
		
		/// <summary>
		/// The name of the Identity PSK
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The passphrase for client authentication. If left blank, one will be auto-generated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="passphrase")]
		public string Passphrase { get; set; }
	}
	
	public class GetNetworkWirelessSsidIdentityPskReturn
	{
		
		/// <summary>
		/// The email associated with the System's Manager User
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Timestamp for when the Identity PSK expires, or 'null' to never expire
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiresAt")]
		public string ExpiresAt { get; set; }
		
		/// <summary>
		/// The group policy to be applied to clients
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
		
		/// <summary>
		/// The unique identifier of the Identity PSK
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the Identity PSK
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The passphrase for client authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="passphrase")]
		public string Passphrase { get; set; }
		
		/// <summary>
		/// The WiFi Personal Network unique identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wifiPersonalNetworkId")]
		public string WifiPersonalNetworkId { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidIdentityPskPutBody
	{
		
		/// <summary>
		/// The group policy to be applied to clients
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPolicyId")]
		public string GroupPolicyId { get; set; }
		
		/// <summary>
		/// The name of the Identity PSK
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The passphrase for client authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="passphrase")]
		public string Passphrase { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSchedulesPutBody
	{
		
		/// <summary>
		/// If true, the SSID outage schedule is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// List of outage ranges. Has a start date and time, and end date and time. If this parameter is passed in along with rangesInSeconds parameter, this will take precedence.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ranges")]
		public UpdateNetworkWirelessSsidSchedulesPutBodyRanges[] UpdateNetworkWirelessSsidSchedulesPutBodyRanges { get; set; }
		
		/// <summary>
		/// List of outage ranges in seconds since Sunday at Midnight. Has a start and end. If this parameter is passed in along with the ranges parameter, ranges will take precedence.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rangesInSeconds")]
		public UpdateNetworkWirelessSsidSchedulesPutBodyRangesInSeconds[] UpdateNetworkWirelessSsidSchedulesPutBodyRangesInSeconds { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSchedulesPutBodyRanges
	{
		
		/// <summary>
		/// Day of when the outage ends. Can be either full day name, or three letter abbreviation
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endDay")]
		public string EndDay { get; set; }
		
		/// <summary>
		/// 24 hour time when the outage ends.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// Day of when the outage starts. Can be either full day name, or three letter abbreviation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startDay")]
		public string StartDay { get; set; }
		
		/// <summary>
		/// 24 hour time when the outage starts.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSchedulesPutBodyRangesInSeconds
	{
		
		/// <summary>
		/// Seconds since Sunday at midnight when that outage range ends.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="end")]
		public int End { get; set; }
		
		/// <summary>
		/// Seconds since Sunday at midnight when the outage range starts.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start")]
		public int Start { get; set; }
	}
	
	public class GetNetworkWirelessSsidSplashSettingsReturn
	{
		
		/// <summary>
		/// Whether or not to allow simultaneous logins from different devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowSimultaneousLogins")]
		public System.Nullable<System.Boolean> AllowSimultaneousLogins { get; set; }
		
		/// <summary>
		/// Details associated with billing splash
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="billing")]
		public GetNetworkWirelessSsidSplashSettingsReturnBilling Billing { get; set; }
		
		/// <summary>
		/// How restricted allowing traffic should be. If true, all traffic types are blocked until the splash page is acknowledged. If false, all non-HTTP traffic is allowed before the splash page is acknowledged.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockAllTrafficBeforeSignOn")]
		public System.Nullable<System.Boolean> BlockAllTrafficBeforeSignOn { get; set; }
		
		/// <summary>
		/// How login attempts should be handled when the controller is unreachable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="controllerDisconnectionBehavior")]
		public string ControllerDisconnectionBehavior { get; set; }
		
		/// <summary>
		/// Details associated with guest sponsored splash
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestSponsorship")]
		public GetNetworkWirelessSsidSplashSettingsReturnGuestSponsorship GuestSponsorship { get; set; }
		
		/// <summary>
		/// The custom redirect URL where the users will go after the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirectUrl")]
		public string RedirectUrl { get; set; }
		
		/// <summary>
		/// Self-registration for splash with Meraki authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfRegistration")]
		public GetNetworkWirelessSsidSplashSettingsReturnSelfRegistration SelfRegistration { get; set; }
		
		/// <summary>
		/// Systems Manager sentry enrollment splash settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sentryEnrollment")]
		public GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollment SentryEnrollment { get; set; }
		
		/// <summary>
		/// The image used in the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashImage")]
		public GetNetworkWirelessSsidSplashSettingsReturnSplashImage SplashImage { get; set; }
		
		/// <summary>
		/// The logo used in the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashLogo")]
		public GetNetworkWirelessSsidSplashSettingsReturnSplashLogo SplashLogo { get; set; }
		
		/// <summary>
		/// The type of splash page for this SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashPage")]
		public string SplashPage { get; set; }
		
		/// <summary>
		/// The prepaid front image used in the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashPrepaidFront")]
		public GetNetworkWirelessSsidSplashSettingsReturnSplashPrepaidFront SplashPrepaidFront { get; set; }
		
		/// <summary>
		/// Splash timeout in minutes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashTimeout")]
		public System.Nullable<System.Int32> SplashTimeout { get; set; }
		
		/// <summary>
		/// The custom splash URL of the click-through splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashUrl")]
		public string SplashUrl { get; set; }
		
		/// <summary>
		/// SSID number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssidNumber")]
		public System.Nullable<System.Int32> SsidNumber { get; set; }
		
		/// <summary>
		/// The Boolean indicating whether the the user will be redirected to the custom redirect URL after the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useRedirectUrl")]
		public System.Nullable<System.Boolean> UseRedirectUrl { get; set; }
		
		/// <summary>
		/// Boolean indicating whether the users will be redirected to the custom splash url
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useSplashUrl")]
		public System.Nullable<System.Boolean> UseSplashUrl { get; set; }
		
		/// <summary>
		/// The welcome message for the users on the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="welcomeMessage")]
		public string WelcomeMessage { get; set; }
	}
	
	public class GetNetworkWirelessSsidSplashSettingsReturnBilling
	{
		
		/// <summary>
		/// Details associated with a free access plan with limits
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="freeAccess")]
		public GetNetworkWirelessSsidSplashSettingsReturnBillingFreeAccess FreeAccess { get; set; }
		
		/// <summary>
		/// Whether or not billing uses the fast login prepaid access option.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prepaidAccessFastLoginEnabled")]
		public System.Nullable<System.Boolean> PrepaidAccessFastLoginEnabled { get; set; }
		
		/// <summary>
		/// The email address that reeceives replies from clients
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replyToEmailAddress")]
		public string ReplyToEmailAddress { get; set; }
	}
	
	public class GetNetworkWirelessSsidSplashSettingsReturnBillingFreeAccess
	{
		
		/// <summary>
		/// How long a device can use a network for free.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationInMinutes")]
		public System.Nullable<System.Int32> DurationInMinutes { get; set; }
		
		/// <summary>
		/// Whether or not free access is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class GetNetworkWirelessSsidSplashSettingsReturnGuestSponsorship
	{
		
		/// <summary>
		/// Duration in minutes of sponsored guest authorization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationInMinutes")]
		public System.Nullable<System.Int32> DurationInMinutes { get; set; }
		
		/// <summary>
		/// Whether or not guests can specify how much time they are requesting.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestCanRequestTimeframe")]
		public System.Nullable<System.Boolean> GuestCanRequestTimeframe { get; set; }
	}
	
	public class GetNetworkWirelessSsidSplashSettingsReturnSelfRegistration
	{
		
		/// <summary>
		/// How created user accounts should be authorized.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizationType")]
		public System.Nullable<GetNetworkWirelessSsidSplashSettingsReturnSelfRegistrationAuthorizationType> AuthorizationType { get; set; }
		
		/// <summary>
		/// Whether or not to allow users to create their own account on the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkWirelessSsidSplashSettingsReturnSelfRegistrationAuthorizationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		admin = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		auto = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		self_email = 2,
	}
	
	public class GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollment
	{
		
		/// <summary>
		/// The system types that the Sentry enforces.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforcedSystems")]
		public string[] EnforcedSystems { get; set; }
		
		/// <summary>
		/// The strength of the enforcement of selected system types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="strength")]
		public System.Nullable<GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentStrength> Strength { get; set; }
		
		/// <summary>
		/// Systems Manager network targeted for sentry enrollment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="systemsManagerNetwork")]
		public GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentSystemsManagerNetwork SystemsManagerNetwork { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentStrength
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="click-through")]
		clickMinusthrough = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		focused = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		strict = 2,
	}
	
	public class GetNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentSystemsManagerNetwork
	{
		
		/// <summary>
		/// The network ID of the Systems Manager network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class GetNetworkWirelessSsidSplashSettingsReturnSplashImage
	{
		
		/// <summary>
		/// The extension of the image file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extension")]
		public string Extension { get; set; }
		
		/// <summary>
		/// The MD5 value of the image file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="md5")]
		public string Md5 { get; set; }
	}
	
	public class GetNetworkWirelessSsidSplashSettingsReturnSplashLogo
	{
		
		/// <summary>
		/// The extension of the logo file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extension")]
		public string Extension { get; set; }
		
		/// <summary>
		/// The MD5 value of the logo file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="md5")]
		public string Md5 { get; set; }
	}
	
	public class GetNetworkWirelessSsidSplashSettingsReturnSplashPrepaidFront
	{
		
		/// <summary>
		/// The extension of the prepaid front image file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extension")]
		public string Extension { get; set; }
		
		/// <summary>
		/// The MD5 value of the prepaid front image file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="md5")]
		public string Md5 { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsPutBody
	{
		
		/// <summary>
		/// Whether or not to allow simultaneous logins from different devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowSimultaneousLogins")]
		public System.Nullable<System.Boolean> AllowSimultaneousLogins { get; set; }
		
		/// <summary>
		/// Details associated with billing splash.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="billing")]
		public UpdateNetworkWirelessSsidSplashSettingsPutBodyBilling Billing { get; set; }
		
		/// <summary>
		/// How restricted allowing traffic should be. If true, all traffic types are blocked until the splash page is acknowledged. If false, all non-HTTP traffic is allowed before the splash page is acknowledged.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockAllTrafficBeforeSignOn")]
		public System.Nullable<System.Boolean> BlockAllTrafficBeforeSignOn { get; set; }
		
		/// <summary>
		/// How login attempts should be handled when the controller is unreachable. Can be either 'open', 'restricted', or 'default'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="controllerDisconnectionBehavior")]
		public System.Nullable<UpdateNetworkWirelessSsidSplashSettingsPutBodyControllerDisconnectionBehavior> ControllerDisconnectionBehavior { get; set; }
		
		/// <summary>
		/// Details associated with guest sponsored splash.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestSponsorship")]
		public UpdateNetworkWirelessSsidSplashSettingsPutBodyGuestSponsorship GuestSponsorship { get; set; }
		
		/// <summary>
		/// The custom redirect URL where the users will go after the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirectUrl")]
		public string RedirectUrl { get; set; }
		
		/// <summary>
		/// Systems Manager sentry enrollment splash settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sentryEnrollment")]
		public UpdateNetworkWirelessSsidSplashSettingsPutBodySentryEnrollment SentryEnrollment { get; set; }
		
		/// <summary>
		/// The image used in the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashImage")]
		public UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImage SplashImage { get; set; }
		
		/// <summary>
		/// The logo used in the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashLogo")]
		public UpdateNetworkWirelessSsidSplashSettingsPutBodySplashLogo SplashLogo { get; set; }
		
		/// <summary>
		/// The prepaid front image used in the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashPrepaidFront")]
		public UpdateNetworkWirelessSsidSplashSettingsPutBodySplashPrepaidFront SplashPrepaidFront { get; set; }
		
		/// <summary>
		/// Splash timeout in minutes. This will determine how often users will see the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashTimeout")]
		public System.Nullable<System.Int32> SplashTimeout { get; set; }
		
		/// <summary>
		/// [optional] The custom splash URL of the click-through splash page. Note that the URL can be configured without necessarily being used. In order to enable the custom URL, see 'useSplashUrl'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashUrl")]
		public string SplashUrl { get; set; }
		
		/// <summary>
		/// The Boolean indicating whether the the user will be redirected to the custom redirect URL after the splash page. A custom redirect URL must be set if this is true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useRedirectUrl")]
		public System.Nullable<System.Boolean> UseRedirectUrl { get; set; }
		
		/// <summary>
		/// [optional] Boolean indicating whether the users will be redirected to the custom splash url. A custom splash URL must be set if this is true. Note that depending on your SSID's access control settings, it may not be possible to use the custom splash URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useSplashUrl")]
		public System.Nullable<System.Boolean> UseSplashUrl { get; set; }
		
		/// <summary>
		/// The welcome message for the users on the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="welcomeMessage")]
		public string WelcomeMessage { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsPutBodyBilling
	{
		
		/// <summary>
		/// Details associated with a free access plan with limits.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="freeAccess")]
		public UpdateNetworkWirelessSsidSplashSettingsPutBodyBillingFreeAccess FreeAccess { get; set; }
		
		/// <summary>
		/// Whether or not billing uses the fast login prepaid access option.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prepaidAccessFastLoginEnabled")]
		public System.Nullable<System.Boolean> PrepaidAccessFastLoginEnabled { get; set; }
		
		/// <summary>
		/// The email address that receives replies from clients.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replyToEmailAddress")]
		public string ReplyToEmailAddress { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsPutBodyBillingFreeAccess
	{
		
		/// <summary>
		/// How long a device can use a network for free.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationInMinutes")]
		public System.Nullable<System.Int32> DurationInMinutes { get; set; }
		
		/// <summary>
		/// Whether or not free access is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessSsidSplashSettingsPutBodyControllerDisconnectionBehavior
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default")]
		_default = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		open = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		restricted = 2,
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsPutBodyGuestSponsorship
	{
		
		/// <summary>
		/// Duration in minutes of sponsored guest authorization. Must be between 1 and 60480 (6 weeks)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationInMinutes")]
		public System.Nullable<System.Int32> DurationInMinutes { get; set; }
		
		/// <summary>
		/// Whether or not guests can specify how much time they are requesting.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestCanRequestTimeframe")]
		public System.Nullable<System.Boolean> GuestCanRequestTimeframe { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsPutBodySentryEnrollment
	{
		
		/// <summary>
		/// The system types that the Sentry enforces. Must be included in: 'iOS, 'Android', 'macOS', and 'Windows'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforcedSystems")]
		public string[] EnforcedSystems { get; set; }
		
		/// <summary>
		/// The strength of the enforcement of selected system types. Must be one of: 'focused', 'click-through', and 'strict'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="strength")]
		public System.Nullable<UpdateNetworkWirelessSsidSplashSettingsPutBodySentryEnrollmentStrength> Strength { get; set; }
		
		/// <summary>
		/// Systems Manager network targeted for sentry enrollment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="systemsManagerNetwork")]
		public UpdateNetworkWirelessSsidSplashSettingsPutBodySentryEnrollmentSystemsManagerNetwork SystemsManagerNetwork { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessSsidSplashSettingsPutBodySentryEnrollmentStrength
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="click-through")]
		clickMinusthrough = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		focused = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		strict = 2,
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsPutBodySentryEnrollmentSystemsManagerNetwork
	{
		
		/// <summary>
		/// The network ID of the Systems Manager network.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImage
	{
		
		/// <summary>
		/// The extension of the image file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extension")]
		public string Extension { get; set; }
		
		/// <summary>
		/// Properties for setting a new image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImage Image { get; set; }
		
		/// <summary>
		/// The MD5 value of the image file. Setting this to null will remove the image from the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="md5")]
		public string Md5 { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImage
	{
		
		/// <summary>
		/// The file contents (a base 64 encoded string) of your new image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public string Contents { get; set; }
		
		/// <summary>
		/// The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public System.Nullable<UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat> Format { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		gif = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		jpg = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		png = 2,
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsPutBodySplashLogo
	{
		
		/// <summary>
		/// The extension of the logo file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extension")]
		public string Extension { get; set; }
		
		/// <summary>
		/// Properties for setting a new image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public UpdateNetworkWirelessSsidSplashSettingsPutBodySplashLogoImage Image { get; set; }
		
		/// <summary>
		/// The MD5 value of the logo file. Setting this to null will remove the logo from the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="md5")]
		public string Md5 { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsPutBodySplashLogoImage
	{
		
		/// <summary>
		/// The file contents (a base 64 encoded string) of your new logo.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public string Contents { get; set; }
		
		/// <summary>
		/// The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat Format { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsPutBodySplashPrepaidFront
	{
		
		/// <summary>
		/// The extension of the prepaid front image file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extension")]
		public string Extension { get; set; }
		
		/// <summary>
		/// Properties for setting a new image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public UpdateNetworkWirelessSsidSplashSettingsPutBodySplashPrepaidFrontImage Image { get; set; }
		
		/// <summary>
		/// The MD5 value of the prepaid front image file. Setting this to null will remove the prepaid front from the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="md5")]
		public string Md5 { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsPutBodySplashPrepaidFrontImage
	{
		
		/// <summary>
		/// The file contents (a base 64 encoded string) of your new prepaid front.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public string Contents { get; set; }
		
		/// <summary>
		/// The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat Format { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsReturn
	{
		
		/// <summary>
		/// Whether or not to allow simultaneous logins from different devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowSimultaneousLogins")]
		public System.Nullable<System.Boolean> AllowSimultaneousLogins { get; set; }
		
		/// <summary>
		/// Details associated with billing splash
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="billing")]
		public UpdateNetworkWirelessSsidSplashSettingsReturnBilling Billing { get; set; }
		
		/// <summary>
		/// How restricted allowing traffic should be. If true, all traffic types are blocked until the splash page is acknowledged. If false, all non-HTTP traffic is allowed before the splash page is acknowledged.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockAllTrafficBeforeSignOn")]
		public System.Nullable<System.Boolean> BlockAllTrafficBeforeSignOn { get; set; }
		
		/// <summary>
		/// How login attempts should be handled when the controller is unreachable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="controllerDisconnectionBehavior")]
		public string ControllerDisconnectionBehavior { get; set; }
		
		/// <summary>
		/// Details associated with guest sponsored splash
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestSponsorship")]
		public UpdateNetworkWirelessSsidSplashSettingsReturnGuestSponsorship GuestSponsorship { get; set; }
		
		/// <summary>
		/// The custom redirect URL where the users will go after the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirectUrl")]
		public string RedirectUrl { get; set; }
		
		/// <summary>
		/// Self-registration for splash with Meraki authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfRegistration")]
		public UpdateNetworkWirelessSsidSplashSettingsReturnSelfRegistration SelfRegistration { get; set; }
		
		/// <summary>
		/// Systems Manager sentry enrollment splash settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sentryEnrollment")]
		public UpdateNetworkWirelessSsidSplashSettingsReturnSentryEnrollment SentryEnrollment { get; set; }
		
		/// <summary>
		/// The image used in the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashImage")]
		public UpdateNetworkWirelessSsidSplashSettingsReturnSplashImage SplashImage { get; set; }
		
		/// <summary>
		/// The logo used in the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashLogo")]
		public UpdateNetworkWirelessSsidSplashSettingsReturnSplashLogo SplashLogo { get; set; }
		
		/// <summary>
		/// The type of splash page for this SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashPage")]
		public string SplashPage { get; set; }
		
		/// <summary>
		/// The prepaid front image used in the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashPrepaidFront")]
		public UpdateNetworkWirelessSsidSplashSettingsReturnSplashPrepaidFront SplashPrepaidFront { get; set; }
		
		/// <summary>
		/// Splash timeout in minutes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashTimeout")]
		public System.Nullable<System.Int32> SplashTimeout { get; set; }
		
		/// <summary>
		/// The custom splash URL of the click-through splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splashUrl")]
		public string SplashUrl { get; set; }
		
		/// <summary>
		/// SSID number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssidNumber")]
		public System.Nullable<System.Int32> SsidNumber { get; set; }
		
		/// <summary>
		/// The Boolean indicating whether the the user will be redirected to the custom redirect URL after the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useRedirectUrl")]
		public System.Nullable<System.Boolean> UseRedirectUrl { get; set; }
		
		/// <summary>
		/// Boolean indicating whether the users will be redirected to the custom splash url
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useSplashUrl")]
		public System.Nullable<System.Boolean> UseSplashUrl { get; set; }
		
		/// <summary>
		/// The welcome message for the users on the splash page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="welcomeMessage")]
		public string WelcomeMessage { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsReturnBilling
	{
		
		/// <summary>
		/// Details associated with a free access plan with limits
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="freeAccess")]
		public UpdateNetworkWirelessSsidSplashSettingsReturnBillingFreeAccess FreeAccess { get; set; }
		
		/// <summary>
		/// Whether or not billing uses the fast login prepaid access option.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prepaidAccessFastLoginEnabled")]
		public System.Nullable<System.Boolean> PrepaidAccessFastLoginEnabled { get; set; }
		
		/// <summary>
		/// The email address that reeceives replies from clients
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replyToEmailAddress")]
		public string ReplyToEmailAddress { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsReturnBillingFreeAccess
	{
		
		/// <summary>
		/// How long a device can use a network for free.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationInMinutes")]
		public System.Nullable<System.Int32> DurationInMinutes { get; set; }
		
		/// <summary>
		/// Whether or not free access is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsReturnGuestSponsorship
	{
		
		/// <summary>
		/// Duration in minutes of sponsored guest authorization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationInMinutes")]
		public System.Nullable<System.Int32> DurationInMinutes { get; set; }
		
		/// <summary>
		/// Whether or not guests can specify how much time they are requesting.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestCanRequestTimeframe")]
		public System.Nullable<System.Boolean> GuestCanRequestTimeframe { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsReturnSelfRegistration
	{
		
		/// <summary>
		/// How created user accounts should be authorized.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizationType")]
		public GetNetworkWirelessSsidSplashSettingsReturnSelfRegistrationAuthorizationType AuthorizationType { get; set; }
		
		/// <summary>
		/// Whether or not to allow users to create their own account on the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsReturnSentryEnrollment
	{
		
		/// <summary>
		/// The system types that the Sentry enforces.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforcedSystems")]
		public string[] EnforcedSystems { get; set; }
		
		/// <summary>
		/// The strength of the enforcement of selected system types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="strength")]
		public System.Nullable<UpdateNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentStrength> Strength { get; set; }
		
		/// <summary>
		/// Systems Manager network targeted for sentry enrollment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="systemsManagerNetwork")]
		public UpdateNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentSystemsManagerNetwork SystemsManagerNetwork { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentStrength
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="click-through")]
		clickMinusthrough = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		focused = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		strict = 2,
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsReturnSentryEnrollmentSystemsManagerNetwork
	{
		
		/// <summary>
		/// The network ID of the Systems Manager network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsReturnSplashImage
	{
		
		/// <summary>
		/// The extension of the image file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extension")]
		public string Extension { get; set; }
		
		/// <summary>
		/// The MD5 value of the image file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="md5")]
		public string Md5 { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsReturnSplashLogo
	{
		
		/// <summary>
		/// The extension of the logo file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extension")]
		public string Extension { get; set; }
		
		/// <summary>
		/// The MD5 value of the logo file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="md5")]
		public string Md5 { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidSplashSettingsReturnSplashPrepaidFront
	{
		
		/// <summary>
		/// The extension of the prepaid front image file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extension")]
		public string Extension { get; set; }
		
		/// <summary>
		/// The MD5 value of the prepaid front image file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="md5")]
		public string Md5 { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidTrafficShapingRulesPutBody
	{
		
		/// <summary>
		/// Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultRulesEnabled")]
		public System.Nullable<System.Boolean> DefaultRulesEnabled { get; set; }
		
		/// <summary>
		///     An array of traffic shaping rules. Rules are applied in the order that
		///    they are specified in. An empty list (or null) means no rules. Note that
		///    you are allowed a maximum of 8 rules.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRules[] UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRules { get; set; }
		
		/// <summary>
		/// Whether traffic shaping rules are applied to clients on your SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trafficShapingEnabled")]
		public System.Nullable<System.Boolean> TrafficShapingEnabled { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRules
	{
		
		/// <summary>
		///     A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="definitions")]
		public UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesDefinitions[] UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesDefinitions { get; set; }
		
		/// <summary>
		///     The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
		///    For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dscpTagValue")]
		public System.Nullable<System.Int32> DscpTagValue { get; set; }
		
		/// <summary>
		///     The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
		///    null means 'Do not set PCP tag'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pcpTagValue")]
		public System.Nullable<System.Int32> PcpTagValue { get; set; }
		
		/// <summary>
		///     An object describing the bandwidth settings for your rule.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perClientBandwidthLimits")]
		public UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesPerClientBandwidthLimits PerClientBandwidthLimits { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesDefinitions
	{
		
		/// <summary>
		/// The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public UpdateNetworkApplianceTrafficShapingRulesPutBodyRulesDefinitionsType Type { get; set; }
		
		/// <summary>
		///     If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
		///    a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
		///    "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
		///    custom ports.
		///     If "type" is 'application' or 'applicationCategory', then "value" must be an object
		///    with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
		///    application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
		///    endpoint).
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesPerClientBandwidthLimits
	{
		
		/// <summary>
		/// The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandwidthLimits")]
		public UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsBandwidthLimits BandwidthLimits { get; set; }
		
		/// <summary>
		/// How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="settings")]
		public string Settings { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidTrafficShapingRulesPutBodyRulesPerClientBandwidthLimitsBandwidthLimits
	{
		
		/// <summary>
		/// The maximum download limit (integer, in Kbps).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitDown")]
		public System.Nullable<System.Int32> LimitDown { get; set; }
		
		/// <summary>
		/// The maximum upload limit (integer, in Kbps).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitUp")]
		public System.Nullable<System.Int32> LimitUp { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidVpnPutBody
	{
		
		/// <summary>
		/// The VPN concentrator settings for this SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentrator")]
		public UpdateNetworkWirelessSsidVpnPutBodyConcentrator Concentrator { get; set; }
		
		/// <summary>
		/// Secondary VPN concentrator settings. This is only used when two VPN concentrators are configured on the SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failover")]
		public UpdateNetworkWirelessSsidVpnPutBodyFailover Failover { get; set; }
		
		/// <summary>
		/// The VPN split tunnel settings for this SSID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splitTunnel")]
		public UpdateNetworkWirelessSsidVpnPutBodySplitTunnel SplitTunnel { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidVpnPutBodyConcentrator
	{
		
		/// <summary>
		/// The NAT ID of the concentrator that should be set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// The VLAN that should be tagged for the concentrator.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanId")]
		public System.Nullable<System.Int32> VlanId { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidVpnPutBodyFailover
	{
		
		/// <summary>
		/// Idle timer interval in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="heartbeatInterval")]
		public System.Nullable<System.Int32> HeartbeatInterval { get; set; }
		
		/// <summary>
		/// Idle timer timeout in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="idleTimeout")]
		public System.Nullable<System.Int32> IdleTimeout { get; set; }
		
		/// <summary>
		/// IP addressed reserved on DHCP server where SSID will terminate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestIp")]
		public string RequestIp { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidVpnPutBodySplitTunnel
	{
		
		/// <summary>
		/// If true, VPN split tunnel is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// List of VPN split tunnel rules.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateNetworkWirelessSsidVpnPutBodySplitTunnelRules[] UpdateNetworkWirelessSsidVpnPutBodySplitTunnelRules { get; set; }
	}
	
	public class UpdateNetworkWirelessSsidVpnPutBodySplitTunnelRules
	{
		
		/// <summary>
		/// Description for this split tunnel rule (optional).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Destination for this split tunnel rule. IP address, fully-qualified domain names (FQDN) or 'any'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destCidr")]
		public string DestCidr { get; set; }
		
		/// <summary>
		/// Destination port for this split tunnel rule, (integer in the range 1-65535), or 'any'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destPort")]
		public string DestPort { get; set; }
		
		/// <summary>
		/// Traffic policy specified for this split tunnel rule, 'allow' or 'deny'.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public string Policy { get; set; }
		
		/// <summary>
		/// Protocol for this split tunnel rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public System.Nullable<UpdateNetworkWirelessSsidVpnPutBodySplitTunnelRulesProtocol> Protocol { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateNetworkWirelessSsidVpnPutBodySplitTunnelRulesProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Any = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TCP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UDP = 2,
	}
	
	public enum GetNetworkWirelessUsageHistoryBand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2.4")]
		_2_4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 2,
	}
	
	public class GetNetworkWirelessUsageHistoryReturn
	{
		
		/// <summary>
		/// The end time of the query range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTs")]
		public System.Nullable<System.DateTimeOffset> EndTs { get; set; }
		
		/// <summary>
		/// Received kilobytes-per-second
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="receivedKbps")]
		public System.Nullable<System.Int32> ReceivedKbps { get; set; }
		
		/// <summary>
		/// Sent kilobytes-per-second
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sentKbps")]
		public System.Nullable<System.Int32> SentKbps { get; set; }
		
		/// <summary>
		/// The start time of the query range
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTs")]
		public System.Nullable<System.DateTimeOffset> StartTs { get; set; }
		
		/// <summary>
		/// Total usage in kilobytes-per-second
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalKbps")]
		public System.Nullable<System.Int32> TotalKbps { get; set; }
	}
	
	public class GetOrganizationsReturn
	{
		
		/// <summary>
		/// API related settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="api")]
		public GetOrganizationsReturnApi Api { get; set; }
		
		/// <summary>
		/// Data for this organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloud")]
		public GetOrganizationsReturnCloud Cloud { get; set; }
		
		/// <summary>
		/// Organization ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Licensing related settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licensing")]
		public GetOrganizationsReturnLicensing Licensing { get; set; }
		
		/// <summary>
		/// Information about the organization's management system
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="management")]
		public GetOrganizationsReturnManagement Management { get; set; }
		
		/// <summary>
		/// Organization name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Organization URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetOrganizationsReturnApi
	{
		
		/// <summary>
		/// Enable API access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class GetOrganizationsReturnCloud
	{
		
		/// <summary>
		/// Region info
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public GetOrganizationsReturnCloudRegion Region { get; set; }
	}
	
	public class GetOrganizationsReturnCloudRegion
	{
		
		/// <summary>
		/// Name of region
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetOrganizationsReturnLicensing
	{
		
		/// <summary>
		/// Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public System.Nullable<GetOrganizationsReturnLicensingModel> Model { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationsReturnLicensingModel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="co-term")]
		coMinusterm = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="per-device")]
		perMinusdevice = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		subscription = 2,
	}
	
	public class GetOrganizationsReturnManagement
	{
		
		/// <summary>
		/// Details related to organization management, possibly empty
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public GetOrganizationsReturnManagementDetails[] GetOrganizationsReturnManagementDetails { get; set; }
	}
	
	public class GetOrganizationsReturnManagementDetails
	{
		
		/// <summary>
		/// Name of management data
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Value of management data
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class CreateOrganizationPostBody
	{
		
		/// <summary>
		/// Information about the organization's management system
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="management")]
		public CreateOrganizationPostBodyManagement Management { get; set; }
		
		/// <summary>
		/// The name of the organization
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class CreateOrganizationPostBodyManagement
	{
		
		/// <summary>
		/// Details related to organization management, possibly empty
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public CreateOrganizationPostBodyManagementDetails[] CreateOrganizationPostBodyManagementDetails { get; set; }
	}
	
	public class CreateOrganizationPostBodyManagementDetails
	{
		
		/// <summary>
		/// Name of management data
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Value of management data
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class GetOrganizationReturn
	{
		
		/// <summary>
		/// API related settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="api")]
		public GetOrganizationReturnApi Api { get; set; }
		
		/// <summary>
		/// Data for this organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloud")]
		public GetOrganizationReturnCloud Cloud { get; set; }
		
		/// <summary>
		/// Organization ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Licensing related settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licensing")]
		public GetOrganizationReturnLicensing Licensing { get; set; }
		
		/// <summary>
		/// Information about the organization's management system
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="management")]
		public GetOrganizationReturnManagement Management { get; set; }
		
		/// <summary>
		/// Organization name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Organization URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetOrganizationReturnApi
	{
		
		/// <summary>
		/// Enable API access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class GetOrganizationReturnCloud
	{
		
		/// <summary>
		/// Region info
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public GetOrganizationReturnCloudRegion Region { get; set; }
	}
	
	public class GetOrganizationReturnCloudRegion
	{
		
		/// <summary>
		/// Name of region
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetOrganizationReturnLicensing
	{
		
		/// <summary>
		/// Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public System.Nullable<GetOrganizationReturnLicensingModel> Model { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationReturnLicensingModel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="co-term")]
		coMinusterm = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="per-device")]
		perMinusdevice = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		subscription = 2,
	}
	
	public class GetOrganizationReturnManagement
	{
		
		/// <summary>
		/// Details related to organization management, possibly empty
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public GetOrganizationReturnManagementDetails[] GetOrganizationReturnManagementDetails { get; set; }
	}
	
	public class GetOrganizationReturnManagementDetails
	{
		
		/// <summary>
		/// Name of management data
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Value of management data
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class UpdateOrganizationPutBody
	{
		
		/// <summary>
		/// API-specific settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="api")]
		public UpdateOrganizationPutBodyApi Api { get; set; }
		
		/// <summary>
		/// Information about the organization's management system
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="management")]
		public UpdateOrganizationPutBodyManagement Management { get; set; }
		
		/// <summary>
		/// The name of the organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateOrganizationPutBodyApi
	{
		
		/// <summary>
		/// If true, enable the access to the Cisco Meraki Dashboard API
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateOrganizationPutBodyManagement
	{
		
		/// <summary>
		/// Details related to organization management, possibly empty
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public UpdateOrganizationPutBodyManagementDetails[] UpdateOrganizationPutBodyManagementDetails { get; set; }
	}
	
	public class UpdateOrganizationPutBodyManagementDetails
	{
		
		/// <summary>
		/// Name of management data
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Value of management data
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class UpdateOrganizationReturn
	{
		
		/// <summary>
		/// API related settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="api")]
		public UpdateOrganizationReturnApi Api { get; set; }
		
		/// <summary>
		/// Data for this organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloud")]
		public UpdateOrganizationReturnCloud Cloud { get; set; }
		
		/// <summary>
		/// Organization ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Licensing related settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licensing")]
		public UpdateOrganizationReturnLicensing Licensing { get; set; }
		
		/// <summary>
		/// Information about the organization's management system
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="management")]
		public UpdateOrganizationReturnManagement Management { get; set; }
		
		/// <summary>
		/// Organization name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Organization URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class UpdateOrganizationReturnApi
	{
		
		/// <summary>
		/// Enable API access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateOrganizationReturnCloud
	{
		
		/// <summary>
		/// Region info
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public UpdateOrganizationReturnCloudRegion Region { get; set; }
	}
	
	public class UpdateOrganizationReturnCloudRegion
	{
		
		/// <summary>
		/// Name of region
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateOrganizationReturnLicensing
	{
		
		/// <summary>
		/// Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public System.Nullable<UpdateOrganizationReturnLicensingModel> Model { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationReturnLicensingModel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="co-term")]
		coMinusterm = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="per-device")]
		perMinusdevice = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		subscription = 2,
	}
	
	public class UpdateOrganizationReturnManagement
	{
		
		/// <summary>
		/// Details related to organization management, possibly empty
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public UpdateOrganizationReturnManagementDetails[] UpdateOrganizationReturnManagementDetails { get; set; }
	}
	
	public class UpdateOrganizationReturnManagementDetails
	{
		
		/// <summary>
		/// Name of management data
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Value of management data
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public enum GetOrganizationActionBatchesStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		completed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 2,
	}
	
	public class CreateOrganizationActionBatchPostBody
	{
		
		/// <summary>
		/// A set of changes to make as part of this action (<a href='https://developer.cisco.com/meraki/api/#/rest/guides/action-batches/'>more details</a>)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actions")]
		public CreateOrganizationActionBatchPostBodyActions[] CreateOrganizationActionBatchPostBodyActions { get; set; }
		
		/// <summary>
		/// Set to true for immediate execution. Set to false if the action should be previewed before executing. This property cannot be unset once it is true. Defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confirmed")]
		public System.Nullable<System.Boolean> Confirmed { get; set; }
		
		/// <summary>
		/// Set to true to force the batch to run synchronous. There can be at most 20 actions in synchronous batch. Defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="synchronous")]
		public System.Nullable<System.Boolean> Synchronous { get; set; }
	}
	
	public class CreateOrganizationActionBatchPostBodyActions
	{
		
		/// <summary>
		/// The body of the action
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// The operation to be used
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operation")]
		public string Operation { get; set; }
		
		/// <summary>
		/// Unique identifier for the resource to be acted on
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
	}
	
	public class GetOrganizationActionBatchReturn
	{
		
		/// <summary>
		/// A set of changes made as part of this action (<a href='https://developer.cisco.com/meraki/api/#/rest/guides/action-batches/'>more details</a>)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actions")]
		public GetOrganizationActionBatchReturnActions[] GetOrganizationActionBatchReturnActions { get; set; }
		
		/// <summary>
		/// Flag describing whether the action should be previewed before executing or not
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confirmed")]
		public System.Nullable<System.Boolean> Confirmed { get; set; }
		
		/// <summary>
		/// ID of the action batch. Can be used to check the status of the action batch at /organizations/{organizationId}/actionBatches/{actionBatchId}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// ID of the organization this action batch belongs to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organizationId")]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// Status of action batch
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public GetOrganizationActionBatchReturnStatus Status { get; set; }
		
		/// <summary>
		/// Flag describing whether actions should run synchronously or asynchronously
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="synchronous")]
		public System.Nullable<System.Boolean> Synchronous { get; set; }
	}
	
	public class GetOrganizationActionBatchReturnActions
	{
		
		/// <summary>
		/// The operation to be used by this action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operation")]
		public string Operation { get; set; }
		
		/// <summary>
		/// Unique identifier for the resource to be acted on
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
	}
	
	public class GetOrganizationActionBatchReturnStatus
	{
		
		/// <summary>
		/// Flag describing whether all actions in the action batch have completed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completed")]
		public System.Nullable<System.Boolean> Completed { get; set; }
		
		/// <summary>
		/// Resources created as a result of this action batch
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdResources")]
		public GetOrganizationActionBatchReturnStatusCreatedResources[] GetOrganizationActionBatchReturnStatusCreatedResources { get; set; }
		
		/// <summary>
		/// List of errors encountered when running actions in the action batch
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public string[] Errors { get; set; }
		
		/// <summary>
		/// Flag describing whether any actions in the action batch failed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failed")]
		public System.Nullable<System.Boolean> Failed { get; set; }
	}
	
	public class GetOrganizationActionBatchReturnStatusCreatedResources
	{
		
		/// <summary>
		/// ID of the created resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// URI, not including base, of the created resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
	}
	
	public class UpdateOrganizationActionBatchPutBody
	{
		
		/// <summary>
		/// A boolean representing whether or not the batch has been confirmed. This property cannot be unset once it is true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confirmed")]
		public System.Nullable<System.Boolean> Confirmed { get; set; }
		
		/// <summary>
		/// Set to true to force the batch to run synchronous. There can be at most 20 actions in synchronous batch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="synchronous")]
		public System.Nullable<System.Boolean> Synchronous { get; set; }
	}
	
	public class CreateOrganizationAdaptivePolicyAclPostBody
	{
		
		/// <summary>
		/// Description of the adaptive policy ACL
		/// </summary>
		[System.ComponentModel.DefaultValue("")]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; } = "";
		
		/// <summary>
		/// IP version of adpative policy ACL. One of: 'any', 'ipv4' or 'ipv6'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipVersion")]
		public GetNetworkSwitchAccessControlListsReturnRulesIpVersion IpVersion { get; set; }
		
		/// <summary>
		/// Name of the adaptive policy ACL
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// An ordered array of the adaptive policy ACL rules.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public CreateOrganizationAdaptivePolicyAclPostBodyRules[] CreateOrganizationAdaptivePolicyAclPostBodyRules { get; set; }
	}
	
	public class CreateOrganizationAdaptivePolicyAclPostBodyRules
	{
		
		/// <summary>
		/// Destination port. Must be in the format of single port: '1', port list: '1,2' or port range: '1-10', and in the range of 1-65535, or 'any'. Default is 'any'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstPort")]
		public string DstPort { get; set; }
		
		/// <summary>
		/// 'allow' or 'deny' traffic specified by this rule.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy Policy { get; set; }
		
		/// <summary>
		/// The type of protocol (must be 'tcp', 'udp', 'icmp' or 'any').
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public CreateOrganizationAdaptivePolicyAclPostBodyRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// Source port. Must be in the format of single port: '1', port list: '1,2' or port range: '1-10', and in the range of 1-65535, or 'any'. Default is 'any'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPort")]
		public string SrcPort { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationAdaptivePolicyAclPostBodyRulesProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		any = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		icmp = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tcp = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		udp = 3,
	}
	
	public class UpdateOrganizationAdaptivePolicyAclPutBody
	{
		
		/// <summary>
		/// Description of the adaptive policy ACL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// IP version of adpative policy ACL. One of: 'any', 'ipv4' or 'ipv6'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipVersion")]
		public GetNetworkSwitchAccessControlListsReturnRulesIpVersion IpVersion { get; set; }
		
		/// <summary>
		/// Name of the adaptive policy ACL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// An ordered array of the adaptive policy ACL rules. An empty array will clear the rules.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateOrganizationAdaptivePolicyAclPutBodyRules[] UpdateOrganizationAdaptivePolicyAclPutBodyRules { get; set; }
	}
	
	public class UpdateOrganizationAdaptivePolicyAclPutBodyRules
	{
		
		/// <summary>
		/// Destination port. Must be in the format of single port: '1', port list: '1,2' or port range: '1-10', and in the range of 1-65535, or 'any'. Default is 'any'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstPort")]
		public string DstPort { get; set; }
		
		/// <summary>
		/// 'allow' or 'deny' traffic specified by this rule.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy Policy { get; set; }
		
		/// <summary>
		/// The type of protocol (must be 'tcp', 'udp', 'icmp' or 'any').
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public CreateOrganizationAdaptivePolicyAclPostBodyRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// Source port. Must be in the format of single port: '1', port list: '1,2' or port range: '1-10', and in the range of 1-65535, or 'any'. Default is 'any'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPort")]
		public string SrcPort { get; set; }
	}
	
	public class CreateOrganizationAdaptivePolicyGroupPostBody
	{
		
		/// <summary>
		/// Description of the group (default: "")
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Name of the group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The policy objects that belong to this group; traffic from addresses specified by these policy objects will be tagged with this group's SGT value if no other tagging scheme is being used (each requires one unique attribute) (default: [])
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policyObjects")]
		public CreateOrganizationAdaptivePolicyGroupPostBodyPolicyObjects[] CreateOrganizationAdaptivePolicyGroupPostBodyPolicyObjects { get; set; }
		
		/// <summary>
		/// SGT value of the group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sgt")]
		public int Sgt { get; set; }
	}
	
	public class CreateOrganizationAdaptivePolicyGroupPostBodyPolicyObjects
	{
		
		/// <summary>
		/// The ID of the policy object
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the policy object
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateOrganizationAdaptivePolicyGroupPutBody
	{
		
		/// <summary>
		/// Description of the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Name of the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The policy objects that belong to this group; traffic from addresses specified by these policy objects will be tagged with this group's SGT value if no other tagging scheme is being used (each requires one unique attribute)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policyObjects")]
		public UpdateOrganizationAdaptivePolicyGroupPutBodyPolicyObjects[] UpdateOrganizationAdaptivePolicyGroupPutBodyPolicyObjects { get; set; }
		
		/// <summary>
		/// SGT value of the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sgt")]
		public System.Nullable<System.Int32> Sgt { get; set; }
	}
	
	public class UpdateOrganizationAdaptivePolicyGroupPutBodyPolicyObjects
	{
		
		/// <summary>
		/// The ID of the policy object
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the policy object
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetOrganizationAdaptivePolicyOverviewReturn
	{
		
		/// <summary>
		/// The current amount of various adaptive policy objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="counts")]
		public GetOrganizationAdaptivePolicyOverviewReturnCounts Counts { get; set; }
		
		/// <summary>
		/// The current limits of various adaptive policy objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limits")]
		public GetOrganizationAdaptivePolicyOverviewReturnLimits Limits { get; set; }
	}
	
	public class GetOrganizationAdaptivePolicyOverviewReturnCounts
	{
		
		/// <summary>
		/// Number of adaptive policies currently in the organization that allow all traffic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowPolicies")]
		public System.Nullable<System.Int32> AllowPolicies { get; set; }
		
		/// <summary>
		/// Number of user-created adaptive policy ACLs currently in the organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customAcls")]
		public System.Nullable<System.Int32> CustomAcls { get; set; }
		
		/// <summary>
		/// Number of user-created adaptive policy groups currently in the organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customGroups")]
		public System.Nullable<System.Int32> CustomGroups { get; set; }
		
		/// <summary>
		/// Number of adaptive policies currently in the organization that deny all traffic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="denyPolicies")]
		public System.Nullable<System.Int32> DenyPolicies { get; set; }
		
		/// <summary>
		/// Number of adaptive policy groups currently in the organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groups")]
		public System.Nullable<System.Int32> Groups { get; set; }
		
		/// <summary>
		/// Number of adaptive policies currently in the organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policies")]
		public System.Nullable<System.Int32> Policies { get; set; }
		
		/// <summary>
		/// Number of policy objects (with the adaptive policy type) currently in the organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policyObjects")]
		public System.Nullable<System.Int32> PolicyObjects { get; set; }
	}
	
	public class GetOrganizationAdaptivePolicyOverviewReturnLimits
	{
		
		/// <summary>
		/// Maximum number of adaptive policy ACLs that can be assigned to an adaptive policy in the organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aclsInAPolicy")]
		public System.Nullable<System.Int32> AclsInAPolicy { get; set; }
		
		/// <summary>
		/// Maximum number of user-created adaptive policy groups allowed in the organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customGroups")]
		public System.Nullable<System.Int32> CustomGroups { get; set; }
		
		/// <summary>
		/// Maximum number of policy objects (with the adaptive policy type) allowed in the organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policyObjects")]
		public System.Nullable<System.Int32> PolicyObjects { get; set; }
		
		/// <summary>
		/// Maximum number of rules allowed in an adaptive policy ACL in the organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rulesInAnAcl")]
		public System.Nullable<System.Int32> RulesInAnAcl { get; set; }
	}
	
	public class CreateOrganizationAdaptivePolicyPolicyPostBody
	{
		
		/// <summary>
		/// An ordered array of adaptive policy ACLs (each requires one unique attribute) that apply to this policy (default: [])
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acls")]
		public CreateOrganizationAdaptivePolicyPolicyPostBodyAcls[] CreateOrganizationAdaptivePolicyPolicyPostBodyAcls { get; set; }
		
		/// <summary>
		/// The destination adaptive policy group (requires one unique attribute)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationGroup")]
		public CreateOrganizationAdaptivePolicyPolicyPostBodyDestinationGroup DestinationGroup { get; set; }
		
		/// <summary>
		/// The rule to apply if there is no matching ACL (default: "default")
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastEntryRule")]
		public System.Nullable<CreateOrganizationAdaptivePolicyPolicyPostBodyLastEntryRule> LastEntryRule { get; set; }
		
		/// <summary>
		/// The source adaptive policy group (requires one unique attribute)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceGroup")]
		public CreateOrganizationAdaptivePolicyPolicyPostBodySourceGroup SourceGroup { get; set; }
	}
	
	public class CreateOrganizationAdaptivePolicyPolicyPostBodyAcls
	{
		
		/// <summary>
		/// The ID of the adaptive policy ACL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the adaptive policy ACL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class CreateOrganizationAdaptivePolicyPolicyPostBodyDestinationGroup
	{
		
		/// <summary>
		/// The ID of the destination adaptive policy group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the destination adaptive policy group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The SGT of the destination adaptive policy group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sgt")]
		public System.Nullable<System.Int32> Sgt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationAdaptivePolicyPolicyPostBodyLastEntryRule
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		allow = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default")]
		_default = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deny = 2,
	}
	
	public class CreateOrganizationAdaptivePolicyPolicyPostBodySourceGroup
	{
		
		/// <summary>
		/// The ID of the source adaptive policy group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the source adaptive policy group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The SGT of the source adaptive policy group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sgt")]
		public System.Nullable<System.Int32> Sgt { get; set; }
	}
	
	public class UpdateOrganizationAdaptivePolicyPolicyPutBody
	{
		
		/// <summary>
		/// An ordered array of adaptive policy ACLs (each requires one unique attribute) that apply to this policy
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acls")]
		public UpdateOrganizationAdaptivePolicyPolicyPutBodyAcls[] UpdateOrganizationAdaptivePolicyPolicyPutBodyAcls { get; set; }
		
		/// <summary>
		/// The destination adaptive policy group (requires one unique attribute)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinationGroup")]
		public UpdateOrganizationAdaptivePolicyPolicyPutBodyDestinationGroup DestinationGroup { get; set; }
		
		/// <summary>
		/// The rule to apply if there is no matching ACL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastEntryRule")]
		public System.Nullable<UpdateOrganizationAdaptivePolicyPolicyPutBodyLastEntryRule> LastEntryRule { get; set; }
		
		/// <summary>
		/// The source adaptive policy group (requires one unique attribute)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceGroup")]
		public UpdateOrganizationAdaptivePolicyPolicyPutBodySourceGroup SourceGroup { get; set; }
	}
	
	public class UpdateOrganizationAdaptivePolicyPolicyPutBodyAcls
	{
		
		/// <summary>
		/// The ID of the adaptive policy ACL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the adaptive policy ACL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateOrganizationAdaptivePolicyPolicyPutBodyDestinationGroup
	{
		
		/// <summary>
		/// The ID of the destination adaptive policy group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the destination adaptive policy group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The SGT of the destination adaptive policy group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sgt")]
		public System.Nullable<System.Int32> Sgt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationAdaptivePolicyPolicyPutBodyLastEntryRule
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		allow = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default")]
		_default = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deny = 2,
	}
	
	public class UpdateOrganizationAdaptivePolicyPolicyPutBodySourceGroup
	{
		
		/// <summary>
		/// The ID of the source adaptive policy group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the source adaptive policy group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The SGT of the source adaptive policy group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sgt")]
		public System.Nullable<System.Int32> Sgt { get; set; }
	}
	
	public class UpdateOrganizationAdaptivePolicySettingsPutBody
	{
		
		/// <summary>
		/// List of network IDs with adaptive policy enabled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabledNetworks")]
		public string[] EnabledNetworks { get; set; }
	}
	
	public class CreateOrganizationAdminPostBody
	{
		
		/// <summary>
		/// The method of authentication the user will use to sign in to the Meraki dashboard. Can be one of 'Email' or 'Cisco SecureX Sign-On'. The default is Email authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authenticationMethod")]
		public System.Nullable<CreateOrganizationAdminPostBodyAuthenticationMethod> AuthenticationMethod { get; set; }
		
		/// <summary>
		/// The email of the dashboard administrator. This attribute can not be updated.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// The name of the dashboard administrator
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The list of networks that the dashboard administrator has privileges on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networks")]
		public CreateOrganizationAdminPostBodyNetworks[] CreateOrganizationAdminPostBodyNetworks { get; set; }
		
		/// <summary>
		/// The privilege of the dashboard administrator on the organization. Can be one of 'full', 'read-only', 'enterprise' or 'none'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="orgAccess")]
		public CreateOrganizationAdminPostBodyOrgAccess OrgAccess { get; set; }
		
		/// <summary>
		/// The list of tags that the dashboard administrator has privileges on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public CreateOrganizationAdminPostBodyTags[] CreateOrganizationAdminPostBodyTags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationAdminPostBodyAuthenticationMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Cisco SecureX Sign-On")]
		Cisco_SecureX_SignMinusOn = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Email = 1,
	}
	
	public class CreateOrganizationAdminPostBodyNetworks
	{
		
		/// <summary>
		/// The privilege of the dashboard administrator on the network. Can be one of 'full', 'read-only', 'guest-ambassador' or 'monitor-only'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public string Access { get; set; }
		
		/// <summary>
		/// The network ID
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationAdminPostBodyOrgAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enterprise = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		full = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="read-only")]
		readMinusonly = 3,
	}
	
	public class CreateOrganizationAdminPostBodyTags
	{
		
		/// <summary>
		/// The privilege of the dashboard administrator on the tag. Can be one of 'full', 'read-only', 'guest-ambassador' or 'monitor-only'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public CreateOrganizationAdminPostBodyTagsAccess Access { get; set; }
		
		/// <summary>
		/// The name of the tag
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public string Tag { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationAdminPostBodyTagsAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		full = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="guest-ambassador")]
		guestMinusambassador = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="monitor-only")]
		monitorMinusonly = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="read-only")]
		readMinusonly = 3,
	}
	
	public class UpdateOrganizationAdminPutBody
	{
		
		/// <summary>
		/// The name of the dashboard administrator
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The list of networks that the dashboard administrator has privileges on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networks")]
		public UpdateOrganizationAdminPutBodyNetworks[] UpdateOrganizationAdminPutBodyNetworks { get; set; }
		
		/// <summary>
		/// The privilege of the dashboard administrator on the organization. Can be one of 'full', 'read-only', 'enterprise' or 'none'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orgAccess")]
		public System.Nullable<UpdateOrganizationAdminPutBodyOrgAccess> OrgAccess { get; set; }
		
		/// <summary>
		/// The list of tags that the dashboard administrator has privileges on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public UpdateOrganizationAdminPutBodyTags[] UpdateOrganizationAdminPutBodyTags { get; set; }
	}
	
	public class UpdateOrganizationAdminPutBodyNetworks
	{
		
		/// <summary>
		/// The privilege of the dashboard administrator on the network. Can be one of 'full', 'read-only', 'guest-ambassador' or 'monitor-only'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public string Access { get; set; }
		
		/// <summary>
		/// The network ID
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationAdminPutBodyOrgAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enterprise = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		full = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="read-only")]
		readMinusonly = 3,
	}
	
	public class UpdateOrganizationAdminPutBodyTags
	{
		
		/// <summary>
		/// The privilege of the dashboard administrator on the tag. Can be one of 'full', 'read-only', 'guest-ambassador' or 'monitor-only'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public UpdateOrganizationAdminPutBodyTagsAccess Access { get; set; }
		
		/// <summary>
		/// The name of the tag
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public string Tag { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationAdminPutBodyTagsAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		full = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="guest-ambassador")]
		guestMinusambassador = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="monitor-only")]
		monitorMinusonly = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="read-only")]
		readMinusonly = 3,
	}
	
	public class CreateOrganizationAlertsProfilePostBody
	{
		
		/// <summary>
		/// The conditions that determine if the alert triggers
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="alertCondition")]
		public CreateOrganizationAlertsProfilePostBodyAlertCondition AlertCondition { get; set; }
		
		/// <summary>
		/// User supplied description of the alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Networks with these tags will be monitored for the alert
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="networkTags")]
		public string[] NetworkTags { get; set; }
		
		/// <summary>
		/// List of recipients that will recieve the alert.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="recipients")]
		public CreateOrganizationAlertsProfilePostBodyRecipients Recipients { get; set; }
		
		/// <summary>
		/// The alert type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CreateOrganizationAlertsProfilePostBodyType Type { get; set; }
	}
	
	public class CreateOrganizationAlertsProfilePostBodyAlertCondition
	{
		
		/// <summary>
		/// The threshold the metric must cross to be valid for alerting. Used only for WAN Utilization alerts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bit_rate_bps")]
		public System.Nullable<System.Int32> Bit_rate_bps { get; set; }
		
		/// <summary>
		/// The total duration in seconds that the threshold should be crossed before alerting
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<System.Int32> Duration { get; set; }
		
		/// <summary>
		/// The uplink observed for the alert.  interface must be one of the following: wan1, wan2, cellular
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interface")]
		public GetDeviceLossAndLatencyHistoryUplink Interface { get; set; }
		
		/// <summary>
		/// The threshold the metric must cross to be valid for alerting. Used only for VoIP Jitter alerts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jitter_ms")]
		public System.Nullable<System.Int32> Jitter_ms { get; set; }
		
		/// <summary>
		/// The threshold the metric must cross to be valid for alerting. Used only for WAN Latency alerts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latency_ms")]
		public System.Nullable<System.Int32> Latency_ms { get; set; }
		
		/// <summary>
		/// The threshold the metric must cross to be valid for alerting. Used only for Packet Loss alerts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loss_ratio")]
		public System.Nullable<System.Single> Loss_ratio { get; set; }
		
		/// <summary>
		/// The threshold the metric must drop below to be valid for alerting. Used only for VoIP MOS alerts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mos")]
		public System.Nullable<System.Single> Mos { get; set; }
		
		/// <summary>
		/// The look back period in seconds for sensing the alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="window")]
		public System.Nullable<System.Int32> Window { get; set; }
	}
	
	public class CreateOrganizationAlertsProfilePostBodyRecipients
	{
		
		/// <summary>
		/// A list of emails that will receive information about the alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emails")]
		public string[] Emails { get; set; }
		
		/// <summary>
		/// A list base64 encoded urls of webhook endpoints that will receive information about the alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpServerIds")]
		public string[] HttpServerIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationAlertsProfilePostBodyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		appOutage = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		voipJitter = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		voipMos = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		voipPacketLoss = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wanLatency = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wanPacketLoss = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wanStatus = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wanUtilization = 7,
	}
	
	public class UpdateOrganizationAlertsProfilePutBody
	{
		
		/// <summary>
		/// The conditions that determine if the alert triggers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alertCondition")]
		public UpdateOrganizationAlertsProfilePutBodyAlertCondition AlertCondition { get; set; }
		
		/// <summary>
		/// User supplied description of the alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Is the alert config enabled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Networks with these tags will be monitored for the alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkTags")]
		public string[] NetworkTags { get; set; }
		
		/// <summary>
		/// List of recipients that will recieve the alert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recipients")]
		public UpdateOrganizationAlertsProfilePutBodyRecipients Recipients { get; set; }
		
		/// <summary>
		/// The alert type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CreateOrganizationAlertsProfilePostBodyType Type { get; set; }
	}
	
	public class UpdateOrganizationAlertsProfilePutBodyAlertCondition
	{
		
		/// <summary>
		/// The threshold the metric must cross to be valid for alerting. Used only for WAN Utilization alerts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bit_rate_bps")]
		public System.Nullable<System.Int32> Bit_rate_bps { get; set; }
		
		/// <summary>
		/// The total duration in seconds that the threshold should be crossed before alerting
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<System.Int32> Duration { get; set; }
		
		/// <summary>
		/// The uplink observed for the alert.  interface must be one of the following: wan1, wan2, cellular
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interface")]
		public GetDeviceLossAndLatencyHistoryUplink Interface { get; set; }
		
		/// <summary>
		/// The threshold the metric must cross to be valid for alerting. Used only for VoIP Jitter alerts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jitter_ms")]
		public System.Nullable<System.Int32> Jitter_ms { get; set; }
		
		/// <summary>
		/// The threshold the metric must cross to be valid for alerting. Used only for WAN Latency alerts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latency_ms")]
		public System.Nullable<System.Int32> Latency_ms { get; set; }
		
		/// <summary>
		/// The threshold the metric must cross to be valid for alerting. Used only for Packet Loss alerts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loss_ratio")]
		public System.Nullable<System.Single> Loss_ratio { get; set; }
		
		/// <summary>
		/// The threshold the metric must drop below to be valid for alerting. Used only for VoIP MOS alerts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mos")]
		public System.Nullable<System.Single> Mos { get; set; }
		
		/// <summary>
		/// The look back period in seconds for sensing the alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="window")]
		public System.Nullable<System.Int32> Window { get; set; }
	}
	
	public class UpdateOrganizationAlertsProfilePutBodyRecipients
	{
		
		/// <summary>
		/// A list of emails that will receive information about the alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emails")]
		public string[] Emails { get; set; }
		
		/// <summary>
		/// A list base64 encoded urls of webhook endpoints that will receive information about the alert
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpServerIds")]
		public string[] HttpServerIds { get; set; }
	}
	
	public enum GetOrganizationApiRequestsMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GET = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POST = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUT = 3,
	}
	
	public enum GetOrganizationApiRequestsVersion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
	}
	
	public class GetOrganizationApiRequestsReturn
	{
		
		/// <summary>
		/// Database ID for the admin user who made the API request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adminId")]
		public string AdminId { get; set; }
		
		/// <summary>
		/// The host which the API request was directed at.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// HTTP method used in the API request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="method")]
		public string Method { get; set; }
		
		/// <summary>
		/// Operation ID for the endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operationId")]
		public string OperationId { get; set; }
		
		/// <summary>
		/// The API request path.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// The query string sent with the API request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queryString")]
		public string QueryString { get; set; }
		
		/// <summary>
		/// API request response code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseCode")]
		public System.Nullable<System.Int32> ResponseCode { get; set; }
		
		/// <summary>
		/// Public IP address from which the API request was made.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceIp")]
		public string SourceIp { get; set; }
		
		/// <summary>
		/// Timestamp, in iso8601 format, indicating when the API request was made.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ts")]
		public System.Nullable<System.DateTimeOffset> Ts { get; set; }
		
		/// <summary>
		/// The API request user agent.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userAgent")]
		public string UserAgent { get; set; }
		
		/// <summary>
		/// API version of the endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public System.Nullable<GetOrganizationApiRequestsReturnVersion> Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationApiRequestsReturnVersion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
	}
	
	public enum GetOrganizationApiRequestsOverviewResponseCodesByIntervalVersion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
	}
	
	public class GetOrganizationApiRequestsOverviewResponseCodesByIntervalReturn
	{
		
		/// <summary>
		/// list of response codes and a count of how many requests had that code in the given time period
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="counts")]
		public GetOrganizationApiRequestsOverviewResponseCodesByIntervalReturnCounts[] GetOrganizationApiRequestsOverviewResponseCodesByIntervalReturnCounts { get; set; }
		
		/// <summary>
		/// The end time of the access period
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTs")]
		public System.Nullable<System.DateTimeOffset> EndTs { get; set; }
		
		/// <summary>
		/// The start time of the access period
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTs")]
		public System.Nullable<System.DateTimeOffset> StartTs { get; set; }
	}
	
	public class GetOrganizationApiRequestsOverviewResponseCodesByIntervalReturnCounts
	{
		
		/// <summary>
		/// Response status code of the API response
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// Number of records that match the status code
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public System.Nullable<System.Int32> Count { get; set; }
	}
	
	public class UpdateOrganizationApplianceSecurityIntrusionPutBody
	{
		
		/// <summary>
		/// Sets a list of specific SNORT signatures to allow
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="allowedRules")]
		public UpdateOrganizationApplianceSecurityIntrusionPutBodyAllowedRules[] UpdateOrganizationApplianceSecurityIntrusionPutBodyAllowedRules { get; set; }
	}
	
	public class UpdateOrganizationApplianceSecurityIntrusionPutBodyAllowedRules
	{
		
		/// <summary>
		/// Message is optional and is ignored on a PUT call. It is allowed in order for PUT to be compatible with GET
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// A rule identifier of the format meraki:intrusion/snort/GID/<gid>/SID/<sid>. gid and sid can be obtained from either https://www.snort.org/rule-docs or as ruleIds from the security events in /organization/[orgId]/securityEvents
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ruleId")]
		public string RuleId { get; set; }
	}
	
	public class GetOrganizationApplianceVpnThirdPartyVPNPeersReturn
	{
		
		/// <summary>
		/// The list of VPN peers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peers")]
		public GetOrganizationApplianceVpnThirdPartyVPNPeersReturnPeers[] GetOrganizationApplianceVpnThirdPartyVPNPeersReturnPeers { get; set; }
	}
	
	public class GetOrganizationApplianceVpnThirdPartyVPNPeersReturnPeers
	{
		
		/// <summary>
		/// [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeVersion")]
		public System.Nullable<GetOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersIkeVersion> IkeVersion { get; set; }
		
		/// <summary>
		/// Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipsecPolicies")]
		public GetOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersIpsecPolicies IpsecPolicies { get; set; }
		
		/// <summary>
		/// One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipsecPoliciesPreset")]
		public string IpsecPoliciesPreset { get; set; }
		
		/// <summary>
		/// [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localId")]
		public string LocalId { get; set; }
		
		/// <summary>
		/// The name of the VPN peer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all'].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkTags")]
		public string[] NetworkTags { get; set; }
		
		/// <summary>
		/// The list of the private subnets of the VPN peer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateSubnets")]
		public string[] PrivateSubnets { get; set; }
		
		/// <summary>
		/// [optional] The public IP of the VPN peer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicIp")]
		public string PublicIp { get; set; }
		
		/// <summary>
		/// [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remoteId")]
		public string RemoteId { get; set; }
		
		/// <summary>
		/// The shared secret with the VPN peer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersIkeVersion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1")]
		_1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2")]
		_2 = 1,
	}
	
	public class GetOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersIpsecPolicies
	{
		
		/// <summary>
		/// This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="childAuthAlgo")]
		public string[] ChildAuthAlgo { get; set; }
		
		/// <summary>
		/// This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="childCipherAlgo")]
		public string[] ChildCipherAlgo { get; set; }
		
		/// <summary>
		/// The lifetime of the Phase 2 SA in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="childLifetime")]
		public System.Nullable<System.Int32> ChildLifetime { get; set; }
		
		/// <summary>
		/// This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="childPfsGroup")]
		public string[] ChildPfsGroup { get; set; }
		
		/// <summary>
		/// This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeAuthAlgo")]
		public string[] IkeAuthAlgo { get; set; }
		
		/// <summary>
		/// This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeCipherAlgo")]
		public string[] IkeCipherAlgo { get; set; }
		
		/// <summary>
		/// This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeDiffieHellmanGroup")]
		public string[] IkeDiffieHellmanGroup { get; set; }
		
		/// <summary>
		/// The lifetime of the Phase 1 SA in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeLifetime")]
		public System.Nullable<System.Int32> IkeLifetime { get; set; }
		
		/// <summary>
		/// [optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikePrfAlgo")]
		public string[] IkePrfAlgo { get; set; }
	}
	
	public class UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBody
	{
		
		/// <summary>
		/// The list of VPN peers
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="peers")]
		public UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyPeers[] UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyPeers { get; set; }
	}
	
	public class UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyPeers
	{
		
		/// <summary>
		/// [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeVersion")]
		public System.Nullable<UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyPeersIkeVersion> IkeVersion { get; set; }
		
		/// <summary>
		/// Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipsecPolicies")]
		public UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyPeersIpsecPolicies IpsecPolicies { get; set; }
		
		/// <summary>
		/// One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipsecPoliciesPreset")]
		public string IpsecPoliciesPreset { get; set; }
		
		/// <summary>
		/// [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localId")]
		public string LocalId { get; set; }
		
		/// <summary>
		/// The name of the VPN peer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all'].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkTags")]
		public string[] NetworkTags { get; set; }
		
		/// <summary>
		/// The list of the private subnets of the VPN peer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="privateSubnets")]
		public string[] PrivateSubnets { get; set; }
		
		/// <summary>
		/// [optional] The public IP of the VPN peer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicIp")]
		public string PublicIp { get; set; }
		
		/// <summary>
		/// [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remoteId")]
		public string RemoteId { get; set; }
		
		/// <summary>
		/// The shared secret with the VPN peer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyPeersIkeVersion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1")]
		_1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2")]
		_2 = 1,
	}
	
	public class UpdateOrganizationApplianceVpnThirdPartyVPNPeersPutBodyPeersIpsecPolicies
	{
		
		/// <summary>
		/// This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="childAuthAlgo")]
		public string[] ChildAuthAlgo { get; set; }
		
		/// <summary>
		/// This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="childCipherAlgo")]
		public string[] ChildCipherAlgo { get; set; }
		
		/// <summary>
		/// The lifetime of the Phase 2 SA in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="childLifetime")]
		public System.Nullable<System.Int32> ChildLifetime { get; set; }
		
		/// <summary>
		/// This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="childPfsGroup")]
		public string[] ChildPfsGroup { get; set; }
		
		/// <summary>
		/// This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeAuthAlgo")]
		public string[] IkeAuthAlgo { get; set; }
		
		/// <summary>
		/// This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeCipherAlgo")]
		public string[] IkeCipherAlgo { get; set; }
		
		/// <summary>
		/// This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeDiffieHellmanGroup")]
		public string[] IkeDiffieHellmanGroup { get; set; }
		
		/// <summary>
		/// The lifetime of the Phase 1 SA in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeLifetime")]
		public System.Nullable<System.Int32> IkeLifetime { get; set; }
		
		/// <summary>
		/// [optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikePrfAlgo")]
		public string[] IkePrfAlgo { get; set; }
	}
	
	public class UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturn
	{
		
		/// <summary>
		/// The list of VPN peers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peers")]
		public UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnPeers[] UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnPeers { get; set; }
	}
	
	public class UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnPeers
	{
		
		/// <summary>
		/// [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeVersion")]
		public System.Nullable<UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersIkeVersion> IkeVersion { get; set; }
		
		/// <summary>
		/// Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipsecPolicies")]
		public UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersIpsecPolicies IpsecPolicies { get; set; }
		
		/// <summary>
		/// One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipsecPoliciesPreset")]
		public string IpsecPoliciesPreset { get; set; }
		
		/// <summary>
		/// [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localId")]
		public string LocalId { get; set; }
		
		/// <summary>
		/// The name of the VPN peer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all'].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkTags")]
		public string[] NetworkTags { get; set; }
		
		/// <summary>
		/// The list of the private subnets of the VPN peer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateSubnets")]
		public string[] PrivateSubnets { get; set; }
		
		/// <summary>
		/// [optional] The public IP of the VPN peer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicIp")]
		public string PublicIp { get; set; }
		
		/// <summary>
		/// [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remoteId")]
		public string RemoteId { get; set; }
		
		/// <summary>
		/// The shared secret with the VPN peer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersIkeVersion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1")]
		_1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2")]
		_2 = 1,
	}
	
	public class UpdateOrganizationApplianceVpnThirdPartyVPNPeersReturnPeersIpsecPolicies
	{
		
		/// <summary>
		/// This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="childAuthAlgo")]
		public string[] ChildAuthAlgo { get; set; }
		
		/// <summary>
		/// This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="childCipherAlgo")]
		public string[] ChildCipherAlgo { get; set; }
		
		/// <summary>
		/// The lifetime of the Phase 2 SA in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="childLifetime")]
		public System.Nullable<System.Int32> ChildLifetime { get; set; }
		
		/// <summary>
		/// This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="childPfsGroup")]
		public string[] ChildPfsGroup { get; set; }
		
		/// <summary>
		/// This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeAuthAlgo")]
		public string[] IkeAuthAlgo { get; set; }
		
		/// <summary>
		/// This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeCipherAlgo")]
		public string[] IkeCipherAlgo { get; set; }
		
		/// <summary>
		/// This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeDiffieHellmanGroup")]
		public string[] IkeDiffieHellmanGroup { get; set; }
		
		/// <summary>
		/// The lifetime of the Phase 1 SA in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeLifetime")]
		public System.Nullable<System.Int32> IkeLifetime { get; set; }
		
		/// <summary>
		/// [optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikePrfAlgo")]
		public string[] IkePrfAlgo { get; set; }
	}
	
	public class UpdateOrganizationApplianceVpnVpnFirewallRulesPutBody
	{
		
		/// <summary>
		/// An ordered array of the firewall rules (not including the default rule)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public UpdateOrganizationApplianceVpnVpnFirewallRulesPutBodyRules[] UpdateOrganizationApplianceVpnVpnFirewallRulesPutBodyRules { get; set; }
		
		/// <summary>
		/// Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syslogDefaultRule")]
		public System.Nullable<System.Boolean> SyslogDefaultRule { get; set; }
	}
	
	public class UpdateOrganizationApplianceVpnVpnFirewallRulesPutBodyRules
	{
		
		/// <summary>
		/// Description of the rule (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Comma-separated list of destination IP address(es) (in IP or CIDR notation) or 'any' (FQDN not supported)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destCidr")]
		public string DestCidr { get; set; }
		
		/// <summary>
		/// Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destPort")]
		public string DestPort { get; set; }
		
		/// <summary>
		/// 'allow' or 'deny' traffic specified by this rule
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesPolicy Policy { get; set; }
		
		/// <summary>
		/// The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public UpdateNetworkApplianceFirewallCellularFirewallRulesUpdatenetworkappliancefirewallcellularfirewallrulesRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (FQDN not supported)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="srcCidr")]
		public string SrcCidr { get; set; }
		
		/// <summary>
		/// Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPort")]
		public string SrcPort { get; set; }
		
		/// <summary>
		/// Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syslogEnabled")]
		public System.Nullable<System.Boolean> SyslogEnabled { get; set; }
	}
	
	public class GetOrganizationBrandingPoliciesReturn
	{
		
		/// <summary>
		/// Settings for describing which kinds of admins this policy applies to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adminSettings")]
		public GetOrganizationBrandingPoliciesReturnAdminSettings AdminSettings { get; set; }
		
		/// <summary>
		/// Properties describing the custom logo attached to the branding policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customLogo")]
		public GetOrganizationBrandingPoliciesReturnCustomLogo CustomLogo { get; set; }
		
		/// <summary>
		/// Boolean indicating whether this policy is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		///       Settings for describing the modifications to various Help page features. Each property in this object accepts one of
		///      'default or inherit' (do not modify functionality), 'hide' (remove the section from Dashboard), or 'show' (always show
		///      the section on Dashboard). Some properties in this object also accept custom HTML used to replace the section on
		///      Dashboard; see the documentation for each property to see the allowed values.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helpSettings")]
		public GetOrganizationBrandingPoliciesReturnHelpSettings HelpSettings { get; set; }
		
		/// <summary>
		/// Name of the Dashboard branding policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetOrganizationBrandingPoliciesReturnAdminSettings
	{
		
		/// <summary>
		/// Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appliesTo")]
		public System.Nullable<GetOrganizationBrandingPoliciesReturnAdminSettingsAppliesTo> AppliesTo { get; set; }
		
		/// <summary>
		///       If 'appliesTo' is set to one of 'Specific admins...', 'All admins of networks...' or 'All admins of networks tagged...', then you must specify this 'values' property to provide the set of
		///      entities to apply the branding policy to. For 'Specific admins...', specify an array of admin IDs. For 'All admins of
		///      networks...', specify an array of network IDs and/or configuration template IDs. For 'All admins of networks tagged...',
		///      specify an array of tag names.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="values")]
		public string[] Values { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPoliciesReturnAdminSettingsAppliesTo
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All SAML admins")]
		All_SAML_admins = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All admins")]
		All_admins = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All admins of networks tagged...")]
		All_admins_of_networks_tagged___ = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All admins of networks...")]
		All_admins_of_networks___ = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All enterprise admins")]
		All_enterprise_admins = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All network admins")]
		All_network_admins = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All organization admins")]
		All_organization_admins = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Specific admins...")]
		Specific_admins___ = 7,
	}
	
	public class GetOrganizationBrandingPoliciesReturnCustomLogo
	{
		
		/// <summary>
		/// Whether or not there is a custom logo enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Properties of the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public GetOrganizationBrandingPoliciesReturnCustomLogoImage Image { get; set; }
	}
	
	public class GetOrganizationBrandingPoliciesReturnCustomLogoImage
	{
		
		/// <summary>
		/// Preview of the image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preview")]
		public GetOrganizationBrandingPoliciesReturnCustomLogoImagePreview Preview { get; set; }
	}
	
	public class GetOrganizationBrandingPoliciesReturnCustomLogoImagePreview
	{
		
		/// <summary>
		/// Timestamp of the preview image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiresAt")]
		public System.Nullable<System.DateTimeOffset> ExpiresAt { get; set; }
		
		/// <summary>
		/// Url of the preview image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetOrganizationBrandingPoliciesReturnHelpSettings
	{
		
		/// <summary>
		///       The 'Help -> API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
		///      'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiDocsSubtab")]
		public System.Nullable<GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab> ApiDocsSubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
		///      of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="casesSubtab")]
		public System.Nullable<GetOrganizationBrandingPoliciesReturnHelpSettingsCasesSubtab> CasesSubtab { get; set; }
		
		/// <summary>
		///       The 'Product Manuals' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ciscoMerakiProductDocumentation")]
		public string CiscoMerakiProductDocumentation { get; set; }
		
		/// <summary>
		///       The 'Help -> Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="communitySubtab")]
		public System.Nullable<GetOrganizationBrandingPoliciesReturnHelpSettingsCommunitySubtab> CommunitySubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
		///      be audited. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataProtectionRequestsSubtab")]
		public System.Nullable<GetOrganizationBrandingPoliciesReturnHelpSettingsDataProtectionRequestsSubtab> DataProtectionRequestsSubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
		///      listed. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewallInfoSubtab")]
		public System.Nullable<GetOrganizationBrandingPoliciesReturnHelpSettingsFirewallInfoSubtab> FirewallInfoSubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
		///      that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
		///      and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="getHelpSubtab")]
		public System.Nullable<GetOrganizationBrandingPoliciesReturnHelpSettingsGetHelpSubtab> GetHelpSubtab { get; set; }
		
		/// <summary>
		///       The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="getHelpSubtabKnowledgeBaseSearch")]
		public string GetHelpSubtabKnowledgeBaseSearch { get; set; }
		
		/// <summary>
		///       The 'Help -> Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
		///      'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hardwareReplacementsSubtab")]
		public System.Nullable<GetOrganizationBrandingPoliciesReturnHelpSettingsHardwareReplacementsSubtab> HardwareReplacementsSubtab { get; set; }
		
		/// <summary>
		///       The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
		///      customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helpTab")]
		public System.Nullable<GetOrganizationBrandingPoliciesReturnHelpSettingsHelpTab> HelpTab { get; set; }
		
		/// <summary>
		///       The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
		///      and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helpWidget")]
		public System.Nullable<GetOrganizationBrandingPoliciesReturnHelpSettingsHelpWidget> HelpWidget { get; set; }
		
		/// <summary>
		///       The 'Help -> New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newFeaturesSubtab")]
		public System.Nullable<GetOrganizationBrandingPoliciesReturnHelpSettingsNewFeaturesSubtab> NewFeaturesSubtab { get; set; }
		
		/// <summary>
		///       The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
		///      organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smForums")]
		public System.Nullable<GetOrganizationBrandingPoliciesReturnHelpSettingsSmForums> SmForums { get; set; }
		
		/// <summary>
		///       The 'Contact Meraki Support' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="supportContactInfo")]
		public string SupportContactInfo { get; set; }
		
		/// <summary>
		///       The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
		///      whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="universalSearchKnowledgeBaseSearch")]
		public System.Nullable<GetOrganizationBrandingPoliciesReturnHelpSettingsUniversalSearchKnowledgeBaseSearch> UniversalSearchKnowledgeBaseSearch { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPoliciesReturnHelpSettingsApiDocsSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPoliciesReturnHelpSettingsCasesSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPoliciesReturnHelpSettingsCommunitySubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPoliciesReturnHelpSettingsDataProtectionRequestsSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPoliciesReturnHelpSettingsFirewallInfoSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPoliciesReturnHelpSettingsGetHelpSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPoliciesReturnHelpSettingsHardwareReplacementsSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPoliciesReturnHelpSettingsHelpTab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPoliciesReturnHelpSettingsHelpWidget
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPoliciesReturnHelpSettingsNewFeaturesSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPoliciesReturnHelpSettingsSmForums
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPoliciesReturnHelpSettingsUniversalSearchKnowledgeBaseSearch
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	public class CreateOrganizationBrandingPolicyPostBody
	{
		
		/// <summary>
		/// Settings for describing which kinds of admins this policy applies to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adminSettings")]
		public CreateOrganizationBrandingPolicyPostBodyAdminSettings AdminSettings { get; set; }
		
		/// <summary>
		/// Properties describing the custom logo attached to the branding policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customLogo")]
		public CreateOrganizationBrandingPolicyPostBodyCustomLogo CustomLogo { get; set; }
		
		/// <summary>
		/// Boolean indicating whether this policy is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		///       Settings for describing the modifications to various Help page features. Each property in this object accepts one of
		///      'default or inherit' (do not modify functionality), 'hide' (remove the section from Dashboard), or 'show' (always show
		///      the section on Dashboard). Some properties in this object also accept custom HTML used to replace the section on
		///      Dashboard; see the documentation for each property to see the allowed values.
		/// Each property defaults to 'default or inherit' when not provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helpSettings")]
		public CreateOrganizationBrandingPolicyPostBodyHelpSettings HelpSettings { get; set; }
		
		/// <summary>
		/// Name of the Dashboard branding policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class CreateOrganizationBrandingPolicyPostBodyAdminSettings
	{
		
		/// <summary>
		/// Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appliesTo")]
		public System.Nullable<CreateOrganizationBrandingPolicyPostBodyAdminSettingsAppliesTo> AppliesTo { get; set; }
		
		/// <summary>
		///       If 'appliesTo' is set to one of 'Specific admins...', 'All admins of networks...' or 'All admins of networks tagged...', then you must specify this 'values' property to provide the set of
		///      entities to apply the branding policy to. For 'Specific admins...', specify an array of admin IDs. For 'All admins of
		///      networks...', specify an array of network IDs and/or configuration template IDs. For 'All admins of networks tagged...',
		///      specify an array of tag names.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="values")]
		public string[] Values { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationBrandingPolicyPostBodyAdminSettingsAppliesTo
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All SAML admins")]
		All_SAML_admins = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All admins")]
		All_admins = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All admins of networks tagged...")]
		All_admins_of_networks_tagged___ = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All admins of networks...")]
		All_admins_of_networks___ = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All enterprise admins")]
		All_enterprise_admins = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All network admins")]
		All_network_admins = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All organization admins")]
		All_organization_admins = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Specific admins...")]
		Specific_admins___ = 7,
	}
	
	public class CreateOrganizationBrandingPolicyPostBodyCustomLogo
	{
		
		/// <summary>
		/// Whether or not there is a custom logo enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Properties for setting the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public CreateOrganizationBrandingPolicyPostBodyCustomLogoImage Image { get; set; }
	}
	
	public class CreateOrganizationBrandingPolicyPostBodyCustomLogoImage
	{
		
		/// <summary>
		/// The file contents (a base 64 encoded string) of your new logo.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public string Contents { get; set; }
		
		/// <summary>
		/// The format of the encoded contents.  Supported formats are 'png', 'gif', and jpg'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat Format { get; set; }
	}
	
	public class CreateOrganizationBrandingPolicyPostBodyHelpSettings
	{
		
		/// <summary>
		///       The 'Help -> API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
		///      'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiDocsSubtab")]
		public System.Nullable<CreateOrganizationBrandingPolicyPostBodyHelpSettingsApiDocsSubtab> ApiDocsSubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
		///      of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="casesSubtab")]
		public System.Nullable<CreateOrganizationBrandingPolicyPostBodyHelpSettingsCasesSubtab> CasesSubtab { get; set; }
		
		/// <summary>
		///       The 'Product Manuals' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ciscoMerakiProductDocumentation")]
		public string CiscoMerakiProductDocumentation { get; set; }
		
		/// <summary>
		///       The 'Help -> Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="communitySubtab")]
		public System.Nullable<CreateOrganizationBrandingPolicyPostBodyHelpSettingsCommunitySubtab> CommunitySubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
		///      be audited. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataProtectionRequestsSubtab")]
		public System.Nullable<CreateOrganizationBrandingPolicyPostBodyHelpSettingsDataProtectionRequestsSubtab> DataProtectionRequestsSubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
		///      listed. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewallInfoSubtab")]
		public System.Nullable<CreateOrganizationBrandingPolicyPostBodyHelpSettingsFirewallInfoSubtab> FirewallInfoSubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
		///      that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
		///      and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="getHelpSubtab")]
		public System.Nullable<CreateOrganizationBrandingPolicyPostBodyHelpSettingsGetHelpSubtab> GetHelpSubtab { get; set; }
		
		/// <summary>
		///       The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="getHelpSubtabKnowledgeBaseSearch")]
		public string GetHelpSubtabKnowledgeBaseSearch { get; set; }
		
		/// <summary>
		///       The 'Help -> Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
		///      'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hardwareReplacementsSubtab")]
		public System.Nullable<CreateOrganizationBrandingPolicyPostBodyHelpSettingsHardwareReplacementsSubtab> HardwareReplacementsSubtab { get; set; }
		
		/// <summary>
		///       The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
		///      customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helpTab")]
		public System.Nullable<CreateOrganizationBrandingPolicyPostBodyHelpSettingsHelpTab> HelpTab { get; set; }
		
		/// <summary>
		///       The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
		///      and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helpWidget")]
		public System.Nullable<CreateOrganizationBrandingPolicyPostBodyHelpSettingsHelpWidget> HelpWidget { get; set; }
		
		/// <summary>
		///       The 'Help -> New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newFeaturesSubtab")]
		public System.Nullable<CreateOrganizationBrandingPolicyPostBodyHelpSettingsNewFeaturesSubtab> NewFeaturesSubtab { get; set; }
		
		/// <summary>
		///       The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
		///      organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smForums")]
		public System.Nullable<CreateOrganizationBrandingPolicyPostBodyHelpSettingsSmForums> SmForums { get; set; }
		
		/// <summary>
		///       The 'Contact Meraki Support' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="supportContactInfo")]
		public string SupportContactInfo { get; set; }
		
		/// <summary>
		///       The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
		///      whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="universalSearchKnowledgeBaseSearch")]
		public System.Nullable<CreateOrganizationBrandingPolicyPostBodyHelpSettingsUniversalSearchKnowledgeBaseSearch> UniversalSearchKnowledgeBaseSearch { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationBrandingPolicyPostBodyHelpSettingsApiDocsSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationBrandingPolicyPostBodyHelpSettingsCasesSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationBrandingPolicyPostBodyHelpSettingsCommunitySubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationBrandingPolicyPostBodyHelpSettingsDataProtectionRequestsSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationBrandingPolicyPostBodyHelpSettingsFirewallInfoSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationBrandingPolicyPostBodyHelpSettingsGetHelpSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationBrandingPolicyPostBodyHelpSettingsHardwareReplacementsSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationBrandingPolicyPostBodyHelpSettingsHelpTab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationBrandingPolicyPostBodyHelpSettingsHelpWidget
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationBrandingPolicyPostBodyHelpSettingsNewFeaturesSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationBrandingPolicyPostBodyHelpSettingsSmForums
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationBrandingPolicyPostBodyHelpSettingsUniversalSearchKnowledgeBaseSearch
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	public class GetOrganizationBrandingPoliciesPrioritiesReturn
	{
		
		/// <summary>
		///       An ordered list of branding policy IDs that determines the priority order of how to apply the policies
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="brandingPolicyIds")]
		public string[] BrandingPolicyIds { get; set; }
	}
	
	public class UpdateOrganizationBrandingPoliciesPrioritiesPutBody
	{
		
		/// <summary>
		///       An ordered list of branding policy IDs that determines the priority order of how to apply the policies
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="brandingPolicyIds")]
		public string[] BrandingPolicyIds { get; set; }
	}
	
	public class UpdateOrganizationBrandingPoliciesPrioritiesReturn
	{
		
		/// <summary>
		///       An ordered list of branding policy IDs that determines the priority order of how to apply the policies
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="brandingPolicyIds")]
		public string[] BrandingPolicyIds { get; set; }
	}
	
	public class GetOrganizationBrandingPolicyReturn
	{
		
		/// <summary>
		/// Settings for describing which kinds of admins this policy applies to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adminSettings")]
		public GetOrganizationBrandingPolicyReturnAdminSettings AdminSettings { get; set; }
		
		/// <summary>
		/// Properties describing the custom logo attached to the branding policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customLogo")]
		public GetOrganizationBrandingPolicyReturnCustomLogo CustomLogo { get; set; }
		
		/// <summary>
		/// Boolean indicating whether this policy is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		///       Settings for describing the modifications to various Help page features. Each property in this object accepts one of
		///      'default or inherit' (do not modify functionality), 'hide' (remove the section from Dashboard), or 'show' (always show
		///      the section on Dashboard). Some properties in this object also accept custom HTML used to replace the section on
		///      Dashboard; see the documentation for each property to see the allowed values.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helpSettings")]
		public GetOrganizationBrandingPolicyReturnHelpSettings HelpSettings { get; set; }
		
		/// <summary>
		/// Name of the Dashboard branding policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetOrganizationBrandingPolicyReturnAdminSettings
	{
		
		/// <summary>
		/// Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appliesTo")]
		public System.Nullable<GetOrganizationBrandingPolicyReturnAdminSettingsAppliesTo> AppliesTo { get; set; }
		
		/// <summary>
		///       If 'appliesTo' is set to one of 'Specific admins...', 'All admins of networks...' or 'All admins of networks tagged...', then you must specify this 'values' property to provide the set of
		///      entities to apply the branding policy to. For 'Specific admins...', specify an array of admin IDs. For 'All admins of
		///      networks...', specify an array of network IDs and/or configuration template IDs. For 'All admins of networks tagged...',
		///      specify an array of tag names.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="values")]
		public string[] Values { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPolicyReturnAdminSettingsAppliesTo
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All SAML admins")]
		All_SAML_admins = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All admins")]
		All_admins = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All admins of networks tagged...")]
		All_admins_of_networks_tagged___ = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All admins of networks...")]
		All_admins_of_networks___ = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All enterprise admins")]
		All_enterprise_admins = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All network admins")]
		All_network_admins = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All organization admins")]
		All_organization_admins = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Specific admins...")]
		Specific_admins___ = 7,
	}
	
	public class GetOrganizationBrandingPolicyReturnCustomLogo
	{
		
		/// <summary>
		/// Whether or not there is a custom logo enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Properties of the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public GetOrganizationBrandingPolicyReturnCustomLogoImage Image { get; set; }
	}
	
	public class GetOrganizationBrandingPolicyReturnCustomLogoImage
	{
		
		/// <summary>
		/// Preview of the image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preview")]
		public GetOrganizationBrandingPolicyReturnCustomLogoImagePreview Preview { get; set; }
	}
	
	public class GetOrganizationBrandingPolicyReturnCustomLogoImagePreview
	{
		
		/// <summary>
		/// Timestamp of the preview image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiresAt")]
		public System.Nullable<System.DateTimeOffset> ExpiresAt { get; set; }
		
		/// <summary>
		/// Url of the preview image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetOrganizationBrandingPolicyReturnHelpSettings
	{
		
		/// <summary>
		///       The 'Help -> API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
		///      'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiDocsSubtab")]
		public System.Nullable<GetOrganizationBrandingPolicyReturnHelpSettingsApiDocsSubtab> ApiDocsSubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
		///      of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="casesSubtab")]
		public System.Nullable<GetOrganizationBrandingPolicyReturnHelpSettingsCasesSubtab> CasesSubtab { get; set; }
		
		/// <summary>
		///       The 'Product Manuals' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ciscoMerakiProductDocumentation")]
		public string CiscoMerakiProductDocumentation { get; set; }
		
		/// <summary>
		///       The 'Help -> Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="communitySubtab")]
		public System.Nullable<GetOrganizationBrandingPolicyReturnHelpSettingsCommunitySubtab> CommunitySubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
		///      be audited. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataProtectionRequestsSubtab")]
		public System.Nullable<GetOrganizationBrandingPolicyReturnHelpSettingsDataProtectionRequestsSubtab> DataProtectionRequestsSubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
		///      listed. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewallInfoSubtab")]
		public System.Nullable<GetOrganizationBrandingPolicyReturnHelpSettingsFirewallInfoSubtab> FirewallInfoSubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
		///      that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
		///      and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="getHelpSubtab")]
		public System.Nullable<GetOrganizationBrandingPolicyReturnHelpSettingsGetHelpSubtab> GetHelpSubtab { get; set; }
		
		/// <summary>
		///       The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="getHelpSubtabKnowledgeBaseSearch")]
		public string GetHelpSubtabKnowledgeBaseSearch { get; set; }
		
		/// <summary>
		///       The 'Help -> Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
		///      'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hardwareReplacementsSubtab")]
		public System.Nullable<GetOrganizationBrandingPolicyReturnHelpSettingsHardwareReplacementsSubtab> HardwareReplacementsSubtab { get; set; }
		
		/// <summary>
		///       The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
		///      customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helpTab")]
		public System.Nullable<GetOrganizationBrandingPolicyReturnHelpSettingsHelpTab> HelpTab { get; set; }
		
		/// <summary>
		///       The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
		///      and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helpWidget")]
		public System.Nullable<GetOrganizationBrandingPolicyReturnHelpSettingsHelpWidget> HelpWidget { get; set; }
		
		/// <summary>
		///       The 'Help -> New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newFeaturesSubtab")]
		public System.Nullable<GetOrganizationBrandingPolicyReturnHelpSettingsNewFeaturesSubtab> NewFeaturesSubtab { get; set; }
		
		/// <summary>
		///       The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
		///      organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smForums")]
		public System.Nullable<GetOrganizationBrandingPolicyReturnHelpSettingsSmForums> SmForums { get; set; }
		
		/// <summary>
		///       The 'Contact Meraki Support' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="supportContactInfo")]
		public string SupportContactInfo { get; set; }
		
		/// <summary>
		///       The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
		///      whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="universalSearchKnowledgeBaseSearch")]
		public System.Nullable<GetOrganizationBrandingPolicyReturnHelpSettingsUniversalSearchKnowledgeBaseSearch> UniversalSearchKnowledgeBaseSearch { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPolicyReturnHelpSettingsApiDocsSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPolicyReturnHelpSettingsCasesSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPolicyReturnHelpSettingsCommunitySubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPolicyReturnHelpSettingsDataProtectionRequestsSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPolicyReturnHelpSettingsFirewallInfoSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPolicyReturnHelpSettingsGetHelpSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPolicyReturnHelpSettingsHardwareReplacementsSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPolicyReturnHelpSettingsHelpTab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPolicyReturnHelpSettingsHelpWidget
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPolicyReturnHelpSettingsNewFeaturesSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPolicyReturnHelpSettingsSmForums
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationBrandingPolicyReturnHelpSettingsUniversalSearchKnowledgeBaseSearch
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	public class UpdateOrganizationBrandingPolicyPutBody
	{
		
		/// <summary>
		/// Settings for describing which kinds of admins this policy applies to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adminSettings")]
		public UpdateOrganizationBrandingPolicyPutBodyAdminSettings AdminSettings { get; set; }
		
		/// <summary>
		/// Properties describing the custom logo attached to the branding policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customLogo")]
		public UpdateOrganizationBrandingPolicyPutBodyCustomLogo CustomLogo { get; set; }
		
		/// <summary>
		/// Boolean indicating whether this policy is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		///       Settings for describing the modifications to various Help page features. Each property in this object accepts one of
		///      'default or inherit' (do not modify functionality), 'hide' (remove the section from Dashboard), or 'show' (always show
		///      the section on Dashboard). Some properties in this object also accept custom HTML used to replace the section on
		///      Dashboard; see the documentation for each property to see the allowed values.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helpSettings")]
		public UpdateOrganizationBrandingPolicyPutBodyHelpSettings HelpSettings { get; set; }
		
		/// <summary>
		/// Name of the Dashboard branding policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateOrganizationBrandingPolicyPutBodyAdminSettings
	{
		
		/// <summary>
		/// Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appliesTo")]
		public System.Nullable<UpdateOrganizationBrandingPolicyPutBodyAdminSettingsAppliesTo> AppliesTo { get; set; }
		
		/// <summary>
		///       If 'appliesTo' is set to one of 'Specific admins...', 'All admins of networks...' or 'All admins of networks tagged...', then you must specify this 'values' property to provide the set of
		///      entities to apply the branding policy to. For 'Specific admins...', specify an array of admin IDs. For 'All admins of
		///      networks...', specify an array of network IDs and/or configuration template IDs. For 'All admins of networks tagged...',
		///      specify an array of tag names.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="values")]
		public string[] Values { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyPutBodyAdminSettingsAppliesTo
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All SAML admins")]
		All_SAML_admins = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All admins")]
		All_admins = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All admins of networks tagged...")]
		All_admins_of_networks_tagged___ = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All admins of networks...")]
		All_admins_of_networks___ = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All enterprise admins")]
		All_enterprise_admins = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All network admins")]
		All_network_admins = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All organization admins")]
		All_organization_admins = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Specific admins...")]
		Specific_admins___ = 7,
	}
	
	public class UpdateOrganizationBrandingPolicyPutBodyCustomLogo
	{
		
		/// <summary>
		/// Whether or not there is a custom logo enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Properties for setting the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public UpdateOrganizationBrandingPolicyPutBodyCustomLogoImage Image { get; set; }
	}
	
	public class UpdateOrganizationBrandingPolicyPutBodyCustomLogoImage
	{
		
		/// <summary>
		/// The file contents (a base 64 encoded string) of your new logo.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public string Contents { get; set; }
		
		/// <summary>
		/// The format of the encoded contents.  Supported formats are 'png', 'gif', and jpg'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public UpdateNetworkWirelessSsidSplashSettingsPutBodySplashImageImageFormat Format { get; set; }
	}
	
	public class UpdateOrganizationBrandingPolicyPutBodyHelpSettings
	{
		
		/// <summary>
		///       The 'Help -> API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
		///      'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiDocsSubtab")]
		public System.Nullable<UpdateOrganizationBrandingPolicyPutBodyHelpSettingsApiDocsSubtab> ApiDocsSubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
		///      of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="casesSubtab")]
		public System.Nullable<UpdateOrganizationBrandingPolicyPutBodyHelpSettingsCasesSubtab> CasesSubtab { get; set; }
		
		/// <summary>
		///       The 'Product Manuals' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ciscoMerakiProductDocumentation")]
		public string CiscoMerakiProductDocumentation { get; set; }
		
		/// <summary>
		///       The 'Help -> Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="communitySubtab")]
		public System.Nullable<UpdateOrganizationBrandingPolicyPutBodyHelpSettingsCommunitySubtab> CommunitySubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
		///      be audited. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataProtectionRequestsSubtab")]
		public System.Nullable<UpdateOrganizationBrandingPolicyPutBodyHelpSettingsDataProtectionRequestsSubtab> DataProtectionRequestsSubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
		///      listed. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewallInfoSubtab")]
		public System.Nullable<UpdateOrganizationBrandingPolicyPutBodyHelpSettingsFirewallInfoSubtab> FirewallInfoSubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
		///      that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
		///      and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="getHelpSubtab")]
		public System.Nullable<UpdateOrganizationBrandingPolicyPutBodyHelpSettingsGetHelpSubtab> GetHelpSubtab { get; set; }
		
		/// <summary>
		///       The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="getHelpSubtabKnowledgeBaseSearch")]
		public string GetHelpSubtabKnowledgeBaseSearch { get; set; }
		
		/// <summary>
		///       The 'Help -> Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
		///      'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hardwareReplacementsSubtab")]
		public System.Nullable<UpdateOrganizationBrandingPolicyPutBodyHelpSettingsHardwareReplacementsSubtab> HardwareReplacementsSubtab { get; set; }
		
		/// <summary>
		///       The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
		///      customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helpTab")]
		public System.Nullable<UpdateOrganizationBrandingPolicyPutBodyHelpSettingsHelpTab> HelpTab { get; set; }
		
		/// <summary>
		///       The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
		///      and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helpWidget")]
		public System.Nullable<UpdateOrganizationBrandingPolicyPutBodyHelpSettingsHelpWidget> HelpWidget { get; set; }
		
		/// <summary>
		///       The 'Help -> New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newFeaturesSubtab")]
		public System.Nullable<UpdateOrganizationBrandingPolicyPutBodyHelpSettingsNewFeaturesSubtab> NewFeaturesSubtab { get; set; }
		
		/// <summary>
		///       The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
		///      organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smForums")]
		public System.Nullable<UpdateOrganizationBrandingPolicyPutBodyHelpSettingsSmForums> SmForums { get; set; }
		
		/// <summary>
		///       The 'Contact Meraki Support' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="supportContactInfo")]
		public string SupportContactInfo { get; set; }
		
		/// <summary>
		///       The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
		///      whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="universalSearchKnowledgeBaseSearch")]
		public System.Nullable<UpdateOrganizationBrandingPolicyPutBodyHelpSettingsUniversalSearchKnowledgeBaseSearch> UniversalSearchKnowledgeBaseSearch { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyPutBodyHelpSettingsApiDocsSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyPutBodyHelpSettingsCasesSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyPutBodyHelpSettingsCommunitySubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyPutBodyHelpSettingsDataProtectionRequestsSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyPutBodyHelpSettingsFirewallInfoSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyPutBodyHelpSettingsGetHelpSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyPutBodyHelpSettingsHardwareReplacementsSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyPutBodyHelpSettingsHelpTab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyPutBodyHelpSettingsHelpWidget
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyPutBodyHelpSettingsNewFeaturesSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyPutBodyHelpSettingsSmForums
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyPutBodyHelpSettingsUniversalSearchKnowledgeBaseSearch
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	public class UpdateOrganizationBrandingPolicyReturn
	{
		
		/// <summary>
		/// Settings for describing which kinds of admins this policy applies to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adminSettings")]
		public UpdateOrganizationBrandingPolicyReturnAdminSettings AdminSettings { get; set; }
		
		/// <summary>
		/// Properties describing the custom logo attached to the branding policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customLogo")]
		public UpdateOrganizationBrandingPolicyReturnCustomLogo CustomLogo { get; set; }
		
		/// <summary>
		/// Boolean indicating whether this policy is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		///       Settings for describing the modifications to various Help page features. Each property in this object accepts one of
		///      'default or inherit' (do not modify functionality), 'hide' (remove the section from Dashboard), or 'show' (always show
		///      the section on Dashboard). Some properties in this object also accept custom HTML used to replace the section on
		///      Dashboard; see the documentation for each property to see the allowed values.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helpSettings")]
		public UpdateOrganizationBrandingPolicyReturnHelpSettings HelpSettings { get; set; }
		
		/// <summary>
		/// Name of the Dashboard branding policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateOrganizationBrandingPolicyReturnAdminSettings
	{
		
		/// <summary>
		/// Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appliesTo")]
		public System.Nullable<UpdateOrganizationBrandingPolicyReturnAdminSettingsAppliesTo> AppliesTo { get; set; }
		
		/// <summary>
		///       If 'appliesTo' is set to one of 'Specific admins...', 'All admins of networks...' or 'All admins of networks tagged...', then you must specify this 'values' property to provide the set of
		///      entities to apply the branding policy to. For 'Specific admins...', specify an array of admin IDs. For 'All admins of
		///      networks...', specify an array of network IDs and/or configuration template IDs. For 'All admins of networks tagged...',
		///      specify an array of tag names.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="values")]
		public string[] Values { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyReturnAdminSettingsAppliesTo
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All SAML admins")]
		All_SAML_admins = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All admins")]
		All_admins = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All admins of networks tagged...")]
		All_admins_of_networks_tagged___ = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All admins of networks...")]
		All_admins_of_networks___ = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All enterprise admins")]
		All_enterprise_admins = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All network admins")]
		All_network_admins = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All organization admins")]
		All_organization_admins = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Specific admins...")]
		Specific_admins___ = 7,
	}
	
	public class UpdateOrganizationBrandingPolicyReturnCustomLogo
	{
		
		/// <summary>
		/// Whether or not there is a custom logo enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Properties of the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public UpdateOrganizationBrandingPolicyReturnCustomLogoImage Image { get; set; }
	}
	
	public class UpdateOrganizationBrandingPolicyReturnCustomLogoImage
	{
		
		/// <summary>
		/// Preview of the image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preview")]
		public UpdateOrganizationBrandingPolicyReturnCustomLogoImagePreview Preview { get; set; }
	}
	
	public class UpdateOrganizationBrandingPolicyReturnCustomLogoImagePreview
	{
		
		/// <summary>
		/// Timestamp of the preview image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiresAt")]
		public System.Nullable<System.DateTimeOffset> ExpiresAt { get; set; }
		
		/// <summary>
		/// Url of the preview image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class UpdateOrganizationBrandingPolicyReturnHelpSettings
	{
		
		/// <summary>
		///       The 'Help -> API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
		///      'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiDocsSubtab")]
		public System.Nullable<UpdateOrganizationBrandingPolicyReturnHelpSettingsApiDocsSubtab> ApiDocsSubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
		///      of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="casesSubtab")]
		public System.Nullable<UpdateOrganizationBrandingPolicyReturnHelpSettingsCasesSubtab> CasesSubtab { get; set; }
		
		/// <summary>
		///       The 'Product Manuals' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ciscoMerakiProductDocumentation")]
		public string CiscoMerakiProductDocumentation { get; set; }
		
		/// <summary>
		///       The 'Help -> Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="communitySubtab")]
		public System.Nullable<UpdateOrganizationBrandingPolicyReturnHelpSettingsCommunitySubtab> CommunitySubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
		///      be audited. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataProtectionRequestsSubtab")]
		public System.Nullable<UpdateOrganizationBrandingPolicyReturnHelpSettingsDataProtectionRequestsSubtab> DataProtectionRequestsSubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
		///      listed. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewallInfoSubtab")]
		public System.Nullable<UpdateOrganizationBrandingPolicyReturnHelpSettingsFirewallInfoSubtab> FirewallInfoSubtab { get; set; }
		
		/// <summary>
		///       The 'Help -> Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
		///      that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
		///      and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="getHelpSubtab")]
		public System.Nullable<UpdateOrganizationBrandingPolicyReturnHelpSettingsGetHelpSubtab> GetHelpSubtab { get; set; }
		
		/// <summary>
		///       The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="getHelpSubtabKnowledgeBaseSearch")]
		public string GetHelpSubtabKnowledgeBaseSearch { get; set; }
		
		/// <summary>
		///       The 'Help -> Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
		///      'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hardwareReplacementsSubtab")]
		public System.Nullable<UpdateOrganizationBrandingPolicyReturnHelpSettingsHardwareReplacementsSubtab> HardwareReplacementsSubtab { get; set; }
		
		/// <summary>
		///       The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
		///      customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helpTab")]
		public System.Nullable<UpdateOrganizationBrandingPolicyReturnHelpSettingsHelpTab> HelpTab { get; set; }
		
		/// <summary>
		///       The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
		///      and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helpWidget")]
		public System.Nullable<UpdateOrganizationBrandingPolicyReturnHelpSettingsHelpWidget> HelpWidget { get; set; }
		
		/// <summary>
		///       The 'Help -> New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newFeaturesSubtab")]
		public System.Nullable<UpdateOrganizationBrandingPolicyReturnHelpSettingsNewFeaturesSubtab> NewFeaturesSubtab { get; set; }
		
		/// <summary>
		///       The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
		///      organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smForums")]
		public System.Nullable<UpdateOrganizationBrandingPolicyReturnHelpSettingsSmForums> SmForums { get; set; }
		
		/// <summary>
		///       The 'Contact Meraki Support' section of the 'Help -> Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="supportContactInfo")]
		public string SupportContactInfo { get; set; }
		
		/// <summary>
		///       The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
		///      whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="universalSearchKnowledgeBaseSearch")]
		public System.Nullable<UpdateOrganizationBrandingPolicyReturnHelpSettingsUniversalSearchKnowledgeBaseSearch> UniversalSearchKnowledgeBaseSearch { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyReturnHelpSettingsApiDocsSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyReturnHelpSettingsCasesSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyReturnHelpSettingsCommunitySubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyReturnHelpSettingsDataProtectionRequestsSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyReturnHelpSettingsFirewallInfoSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyReturnHelpSettingsGetHelpSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyReturnHelpSettingsHardwareReplacementsSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyReturnHelpSettingsHelpTab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyReturnHelpSettingsHelpWidget
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyReturnHelpSettingsNewFeaturesSubtab
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyReturnHelpSettingsSmForums
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationBrandingPolicyReturnHelpSettingsUniversalSearchKnowledgeBaseSearch
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default or inherit")]
		default_or_inherit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hide = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 2,
	}
	
	public class CreateOrganizationCameraCustomAnalyticsArtifactPostBody
	{
		
		/// <summary>
		/// Unique name of the artifact
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateOrganizationCameraOnboardingStatusesPutBody
	{
		
		/// <summary>
		/// Serial of camera
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// Note whether credentials were sent successfully
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wirelessCredentialsSent")]
		public System.Nullable<System.Boolean> WirelessCredentialsSent { get; set; }
	}
	
	public class GetOrganizationCellularGatewayUplinkStatusesReturn
	{
		
		/// <summary>
		/// Last reported time for the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastReportedAt")]
		public System.Nullable<System.DateTimeOffset> LastReportedAt { get; set; }
		
		/// <summary>
		/// Device model
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public string Model { get; set; }
		
		/// <summary>
		/// Network Id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// Serial number of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// Uplinks info
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uplinks")]
		public GetOrganizationCellularGatewayUplinkStatusesReturnUplinks[] GetOrganizationCellularGatewayUplinkStatusesReturnUplinks { get; set; }
	}
	
	public class GetOrganizationCellularGatewayUplinkStatusesReturnUplinks
	{
		
		/// <summary>
		/// Access Point Name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apn")]
		public string Apn { get; set; }
		
		/// <summary>
		/// Connection Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionType")]
		public string ConnectionType { get; set; }
		
		/// <summary>
		/// Primary DNS IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dns1")]
		public string Dns1 { get; set; }
		
		/// <summary>
		/// Secondary DNS IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dns2")]
		public string Dns2 { get; set; }
		
		/// <summary>
		/// Gateway IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// Integrated Circuit Card Identification Number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iccid")]
		public string Iccid { get; set; }
		
		/// <summary>
		/// Uplink interface
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interface")]
		public string Interface { get; set; }
		
		/// <summary>
		/// Uplink IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// Uplink model
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public string Model { get; set; }
		
		/// <summary>
		/// Network Provider
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provider")]
		public string Provider { get; set; }
		
		/// <summary>
		/// Public IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicIp")]
		public string PublicIp { get; set; }
		
		/// <summary>
		/// Tower Signal Status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signalStat")]
		public GetOrganizationCellularGatewayUplinkStatusesReturnUplinksSignalStat SignalStat { get; set; }
		
		/// <summary>
		/// Signal Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signalType")]
		public string SignalType { get; set; }
		
		/// <summary>
		/// Uplink status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	public class GetOrganizationCellularGatewayUplinkStatusesReturnUplinksSignalStat
	{
		
		/// <summary>
		/// Reference Signal Received Power
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rsrp")]
		public string Rsrp { get; set; }
		
		/// <summary>
		/// Reference Signal Received Quality
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rsrq")]
		public string Rsrq { get; set; }
	}
	
	public class ClaimIntoOrganizationPostBody
	{
		
		/// <summary>
		/// The licenses that should be claimed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenses")]
		public ClaimIntoOrganizationPostBodyLicenses[] ClaimIntoOrganizationPostBodyLicenses { get; set; }
		
		/// <summary>
		/// The numbers of the orders that should be claimed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orders")]
		public string[] Orders { get; set; }
		
		/// <summary>
		/// The serials of the devices that should be claimed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string[] Serials { get; set; }
	}
	
	public class ClaimIntoOrganizationPostBodyLicenses
	{
		
		/// <summary>
		/// The key of the license
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. This parameter is legacy and does not apply to organizations with per-device licensing enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public System.Nullable<ClaimIntoOrganizationPostBodyLicensesMode> Mode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ClaimIntoOrganizationPostBodyLicensesMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		addDevices = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		renew = 1,
	}
	
	public class GetOrganizationClientsBandwidthUsageHistoryReturn
	{
		
		/// <summary>
		/// Downloaded data, in mbps.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="downstream")]
		public System.Nullable<System.Int32> Downstream { get; set; }
		
		/// <summary>
		/// Total bandwidth usage, in mbps.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
		
		/// <summary>
		/// Timestamp for the bandwidth usage snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ts")]
		public System.Nullable<System.DateTimeOffset> Ts { get; set; }
		
		/// <summary>
		/// Uploaded data, in mbps.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upstream")]
		public System.Nullable<System.Int32> Upstream { get; set; }
	}
	
	public class GetOrganizationClientsOverviewReturn
	{
		
		/// <summary>
		/// Client count information
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="counts")]
		public GetOrganizationClientsOverviewReturnCounts Counts { get; set; }
		
		/// <summary>
		/// Usage information of all clients across organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usage")]
		public GetOrganizationClientsOverviewReturnUsage Usage { get; set; }
	}
	
	public class GetOrganizationClientsOverviewReturnCounts
	{
		
		/// <summary>
		/// Total number of clients with data usage in organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	public class GetOrganizationClientsOverviewReturnUsage
	{
		
		/// <summary>
		/// Average data usage (in kb) of each client in organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="average")]
		public System.Nullable<System.Single> Average { get; set; }
		
		/// <summary>
		/// Overall data usage of all clients across organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="overall")]
		public GetOrganizationClientsOverviewReturnUsageOverall Overall { get; set; }
	}
	
	public class GetOrganizationClientsOverviewReturnUsageOverall
	{
		
		/// <summary>
		/// Downstream data usage (in kb) of all clients across organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="downstream")]
		public System.Nullable<System.Single> Downstream { get; set; }
		
		/// <summary>
		/// Total data usage (in kb) of all clients across organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Single> Total { get; set; }
		
		/// <summary>
		/// Upstream data usage (in kb) of all clients across organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upstream")]
		public System.Nullable<System.Single> Upstream { get; set; }
	}
	
	public class CloneOrganizationPostBody
	{
		
		/// <summary>
		/// The name of the new organization
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class CreateOrganizationConfigTemplatePostBody
	{
		
		/// <summary>
		/// The ID of the network or config template to copy configuration from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="copyFromNetworkId")]
		public string CopyFromNetworkId { get; set; }
		
		/// <summary>
		/// The name of the configuration template
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The timezone of the configuration template. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article</a>. Not applicable if copying from existing network or template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeZone")]
		public string TimeZone { get; set; }
	}
	
	public class UpdateOrganizationConfigTemplatePutBody
	{
		
		/// <summary>
		/// The name of the configuration template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The timezone of the configuration template. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeZone")]
		public string TimeZone { get; set; }
	}
	
	public class GetOrganizationConfigTemplateSwitchProfilesReturn
	{
		
		/// <summary>
		/// Switch model
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public string Model { get; set; }
		
		/// <summary>
		/// Switch profile name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Switch profile id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="switchProfileId")]
		public string SwitchProfileId { get; set; }
	}
	
	public class GetOrganizationConfigTemplateSwitchProfilePortsReturn
	{
		
		/// <summary>
		/// The number of a custom access policy to configure on the switch profile port. Only applicable when 'accessPolicyType' is 'Custom access policy'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyNumber")]
		public System.Nullable<System.Int32> AccessPolicyNumber { get; set; }
		
		/// <summary>
		/// The type of the access policy of the switch profile port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyType")]
		public System.Nullable<GetOrganizationConfigTemplateSwitchProfilePortsReturnAccessPolicyType> AccessPolicyType { get; set; }
		
		/// <summary>
		/// The VLANs allowed on the switch profile port. Only applicable to trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedVlans")]
		public string AllowedVlans { get; set; }
		
		/// <summary>
		/// If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="daiTrusted")]
		public System.Nullable<System.Boolean> DaiTrusted { get; set; }
		
		/// <summary>
		/// The status of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="flexibleStackingEnabled")]
		public System.Nullable<System.Boolean> FlexibleStackingEnabled { get; set; }
		
		/// <summary>
		/// The isolation status of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isolationEnabled")]
		public System.Nullable<System.Boolean> IsolationEnabled { get; set; }
		
		/// <summary>
		/// The link speed for the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkNegotiation")]
		public string LinkNegotiation { get; set; }
		
		/// <summary>
		/// Available link speeds for the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkNegotiationCapabilities")]
		public string[] LinkNegotiationCapabilities { get; set; }
		
		/// <summary>
		/// Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="macAllowList")]
		public string[] MacAllowList { get; set; }
		
		/// <summary>
		/// The name of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The PoE status of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="poeEnabled")]
		public System.Nullable<System.Boolean> PoeEnabled { get; set; }
		
		/// <summary>
		/// The identifier of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portId")]
		public string PortId { get; set; }
		
		/// <summary>
		/// The ID of the port schedule. A value of null will clear the port schedule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portScheduleId")]
		public string PortScheduleId { get; set; }
		
		/// <summary>
		/// Profile attributes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile")]
		public GetOrganizationConfigTemplateSwitchProfilePortsReturnProfile Profile { get; set; }
		
		/// <summary>
		/// The rapid spanning tree protocol status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rstpEnabled")]
		public System.Nullable<System.Boolean> RstpEnabled { get; set; }
		
		/// <summary>
		/// The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stickyMacAllowList")]
		public string[] StickyMacAllowList { get; set; }
		
		/// <summary>
		/// The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stickyMacAllowListLimit")]
		public System.Nullable<System.Int32> StickyMacAllowListLimit { get; set; }
		
		/// <summary>
		/// The storm control status of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stormControlEnabled")]
		public System.Nullable<System.Boolean> StormControlEnabled { get; set; }
		
		/// <summary>
		/// The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stpGuard")]
		public System.Nullable<GetOrganizationConfigTemplateSwitchProfilePortsReturnStpGuard> StpGuard { get; set; }
		
		/// <summary>
		/// The list of tags of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// The type of the switch profile port ('trunk' or 'access').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GetDeviceSwitchPortsReturnType Type { get; set; }
		
		/// <summary>
		/// The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="udld")]
		public System.Nullable<GetOrganizationConfigTemplateSwitchProfilePortsReturnUdld> Udld { get; set; }
		
		/// <summary>
		/// The VLAN of the switch profile port. A null value will clear the value set for trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
		
		/// <summary>
		/// The voice VLAN of the switch profile port. Only applicable to access ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlan")]
		public System.Nullable<System.Int32> VoiceVlan { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationConfigTemplateSwitchProfilePortsReturnAccessPolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Custom access policy")]
		Custom_access_policy = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAC allow list")]
		MAC_allow_list = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Open = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Sticky MAC allow list")]
		Sticky_MAC_allow_list = 3,
	}
	
	public class GetOrganizationConfigTemplateSwitchProfilePortsReturnProfile
	{
		
		/// <summary>
		/// When enabled, override this port's configuration with a port profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// When enabled, the ID of the port profile used to override the port's configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// When enabled, the IName of the profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iname")]
		public string Iname { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationConfigTemplateSwitchProfilePortsReturnStpGuard
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bpdu guard")]
		bpdu_guard = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="loop guard")]
		loop_guard = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="root guard")]
		root_guard = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationConfigTemplateSwitchProfilePortsReturnUdld
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Alert only")]
		Alert_only = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enforce = 1,
	}
	
	public class GetOrganizationConfigTemplateSwitchProfilePortReturn
	{
		
		/// <summary>
		/// The number of a custom access policy to configure on the switch profile port. Only applicable when 'accessPolicyType' is 'Custom access policy'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyNumber")]
		public System.Nullable<System.Int32> AccessPolicyNumber { get; set; }
		
		/// <summary>
		/// The type of the access policy of the switch profile port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyType")]
		public System.Nullable<GetOrganizationConfigTemplateSwitchProfilePortReturnAccessPolicyType> AccessPolicyType { get; set; }
		
		/// <summary>
		/// The VLANs allowed on the switch profile port. Only applicable to trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedVlans")]
		public string AllowedVlans { get; set; }
		
		/// <summary>
		/// If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="daiTrusted")]
		public System.Nullable<System.Boolean> DaiTrusted { get; set; }
		
		/// <summary>
		/// The status of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="flexibleStackingEnabled")]
		public System.Nullable<System.Boolean> FlexibleStackingEnabled { get; set; }
		
		/// <summary>
		/// The isolation status of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isolationEnabled")]
		public System.Nullable<System.Boolean> IsolationEnabled { get; set; }
		
		/// <summary>
		/// The link speed for the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkNegotiation")]
		public string LinkNegotiation { get; set; }
		
		/// <summary>
		/// Available link speeds for the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkNegotiationCapabilities")]
		public string[] LinkNegotiationCapabilities { get; set; }
		
		/// <summary>
		/// Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="macAllowList")]
		public string[] MacAllowList { get; set; }
		
		/// <summary>
		/// The name of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The PoE status of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="poeEnabled")]
		public System.Nullable<System.Boolean> PoeEnabled { get; set; }
		
		/// <summary>
		/// The identifier of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portId")]
		public string PortId { get; set; }
		
		/// <summary>
		/// The ID of the port schedule. A value of null will clear the port schedule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portScheduleId")]
		public string PortScheduleId { get; set; }
		
		/// <summary>
		/// Profile attributes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile")]
		public GetOrganizationConfigTemplateSwitchProfilePortReturnProfile Profile { get; set; }
		
		/// <summary>
		/// The rapid spanning tree protocol status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rstpEnabled")]
		public System.Nullable<System.Boolean> RstpEnabled { get; set; }
		
		/// <summary>
		/// The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stickyMacAllowList")]
		public string[] StickyMacAllowList { get; set; }
		
		/// <summary>
		/// The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stickyMacAllowListLimit")]
		public System.Nullable<System.Int32> StickyMacAllowListLimit { get; set; }
		
		/// <summary>
		/// The storm control status of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stormControlEnabled")]
		public System.Nullable<System.Boolean> StormControlEnabled { get; set; }
		
		/// <summary>
		/// The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stpGuard")]
		public System.Nullable<GetOrganizationConfigTemplateSwitchProfilePortReturnStpGuard> StpGuard { get; set; }
		
		/// <summary>
		/// The list of tags of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// The type of the switch profile port ('trunk' or 'access').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GetDeviceSwitchPortsReturnType Type { get; set; }
		
		/// <summary>
		/// The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="udld")]
		public System.Nullable<GetOrganizationConfigTemplateSwitchProfilePortReturnUdld> Udld { get; set; }
		
		/// <summary>
		/// The VLAN of the switch profile port. A null value will clear the value set for trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
		
		/// <summary>
		/// The voice VLAN of the switch profile port. Only applicable to access ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlan")]
		public System.Nullable<System.Int32> VoiceVlan { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationConfigTemplateSwitchProfilePortReturnAccessPolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Custom access policy")]
		Custom_access_policy = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAC allow list")]
		MAC_allow_list = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Open = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Sticky MAC allow list")]
		Sticky_MAC_allow_list = 3,
	}
	
	public class GetOrganizationConfigTemplateSwitchProfilePortReturnProfile
	{
		
		/// <summary>
		/// When enabled, override this port's configuration with a port profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// When enabled, the ID of the port profile used to override the port's configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// When enabled, the IName of the profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iname")]
		public string Iname { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationConfigTemplateSwitchProfilePortReturnStpGuard
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bpdu guard")]
		bpdu_guard = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="loop guard")]
		loop_guard = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="root guard")]
		root_guard = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationConfigTemplateSwitchProfilePortReturnUdld
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Alert only")]
		Alert_only = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enforce = 1,
	}
	
	public class UpdateOrganizationConfigTemplateSwitchProfilePortPutBody
	{
		
		/// <summary>
		/// The number of a custom access policy to configure on the switch profile port. Only applicable when 'accessPolicyType' is 'Custom access policy'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyNumber")]
		public System.Nullable<System.Int32> AccessPolicyNumber { get; set; }
		
		/// <summary>
		/// The type of the access policy of the switch profile port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyType")]
		public System.Nullable<UpdateOrganizationConfigTemplateSwitchProfilePortPutBodyAccessPolicyType> AccessPolicyType { get; set; }
		
		/// <summary>
		/// The VLANs allowed on the switch profile port. Only applicable to trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedVlans")]
		public string AllowedVlans { get; set; }
		
		/// <summary>
		/// If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="daiTrusted")]
		public System.Nullable<System.Boolean> DaiTrusted { get; set; }
		
		/// <summary>
		/// The status of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="flexibleStackingEnabled")]
		public System.Nullable<System.Boolean> FlexibleStackingEnabled { get; set; }
		
		/// <summary>
		/// The isolation status of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isolationEnabled")]
		public System.Nullable<System.Boolean> IsolationEnabled { get; set; }
		
		/// <summary>
		/// The link speed for the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkNegotiation")]
		public string LinkNegotiation { get; set; }
		
		/// <summary>
		/// Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="macAllowList")]
		public string[] MacAllowList { get; set; }
		
		/// <summary>
		/// The name of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The PoE status of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="poeEnabled")]
		public System.Nullable<System.Boolean> PoeEnabled { get; set; }
		
		/// <summary>
		/// The ID of the port schedule. A value of null will clear the port schedule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portScheduleId")]
		public string PortScheduleId { get; set; }
		
		/// <summary>
		/// Profile attributes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile")]
		public UpdateOrganizationConfigTemplateSwitchProfilePortPutBodyProfile Profile { get; set; }
		
		/// <summary>
		/// The rapid spanning tree protocol status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rstpEnabled")]
		public System.Nullable<System.Boolean> RstpEnabled { get; set; }
		
		/// <summary>
		/// The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stickyMacAllowList")]
		public string[] StickyMacAllowList { get; set; }
		
		/// <summary>
		/// The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stickyMacAllowListLimit")]
		public System.Nullable<System.Int32> StickyMacAllowListLimit { get; set; }
		
		/// <summary>
		/// The storm control status of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stormControlEnabled")]
		public System.Nullable<System.Boolean> StormControlEnabled { get; set; }
		
		/// <summary>
		/// The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stpGuard")]
		public System.Nullable<UpdateOrganizationConfigTemplateSwitchProfilePortPutBodyStpGuard> StpGuard { get; set; }
		
		/// <summary>
		/// The list of tags of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// The type of the switch profile port ('trunk' or 'access').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GetDeviceSwitchPortsReturnType Type { get; set; }
		
		/// <summary>
		/// The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="udld")]
		public System.Nullable<UpdateOrganizationConfigTemplateSwitchProfilePortPutBodyUdld> Udld { get; set; }
		
		/// <summary>
		/// The VLAN of the switch profile port. A null value will clear the value set for trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
		
		/// <summary>
		/// The voice VLAN of the switch profile port. Only applicable to access ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlan")]
		public System.Nullable<System.Int32> VoiceVlan { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationConfigTemplateSwitchProfilePortPutBodyAccessPolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Custom access policy")]
		Custom_access_policy = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAC allow list")]
		MAC_allow_list = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Open = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Sticky MAC allow list")]
		Sticky_MAC_allow_list = 3,
	}
	
	public class UpdateOrganizationConfigTemplateSwitchProfilePortPutBodyProfile
	{
		
		/// <summary>
		/// When enabled, override this port's configuration with a port profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// When enabled, the ID of the port profile used to override the port's configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// When enabled, the IName of the profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iname")]
		public string Iname { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationConfigTemplateSwitchProfilePortPutBodyStpGuard
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bpdu guard")]
		bpdu_guard = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="loop guard")]
		loop_guard = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="root guard")]
		root_guard = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationConfigTemplateSwitchProfilePortPutBodyUdld
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Alert only")]
		Alert_only = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enforce = 1,
	}
	
	public class UpdateOrganizationConfigTemplateSwitchProfilePortReturn
	{
		
		/// <summary>
		/// The number of a custom access policy to configure on the switch profile port. Only applicable when 'accessPolicyType' is 'Custom access policy'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyNumber")]
		public System.Nullable<System.Int32> AccessPolicyNumber { get; set; }
		
		/// <summary>
		/// The type of the access policy of the switch profile port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyType")]
		public System.Nullable<UpdateOrganizationConfigTemplateSwitchProfilePortReturnAccessPolicyType> AccessPolicyType { get; set; }
		
		/// <summary>
		/// The VLANs allowed on the switch profile port. Only applicable to trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedVlans")]
		public string AllowedVlans { get; set; }
		
		/// <summary>
		/// If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="daiTrusted")]
		public System.Nullable<System.Boolean> DaiTrusted { get; set; }
		
		/// <summary>
		/// The status of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="flexibleStackingEnabled")]
		public System.Nullable<System.Boolean> FlexibleStackingEnabled { get; set; }
		
		/// <summary>
		/// The isolation status of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isolationEnabled")]
		public System.Nullable<System.Boolean> IsolationEnabled { get; set; }
		
		/// <summary>
		/// The link speed for the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkNegotiation")]
		public string LinkNegotiation { get; set; }
		
		/// <summary>
		/// Available link speeds for the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkNegotiationCapabilities")]
		public string[] LinkNegotiationCapabilities { get; set; }
		
		/// <summary>
		/// Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="macAllowList")]
		public string[] MacAllowList { get; set; }
		
		/// <summary>
		/// The name of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The PoE status of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="poeEnabled")]
		public System.Nullable<System.Boolean> PoeEnabled { get; set; }
		
		/// <summary>
		/// The identifier of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portId")]
		public string PortId { get; set; }
		
		/// <summary>
		/// The ID of the port schedule. A value of null will clear the port schedule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portScheduleId")]
		public string PortScheduleId { get; set; }
		
		/// <summary>
		/// Profile attributes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile")]
		public UpdateOrganizationConfigTemplateSwitchProfilePortReturnProfile Profile { get; set; }
		
		/// <summary>
		/// The rapid spanning tree protocol status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rstpEnabled")]
		public System.Nullable<System.Boolean> RstpEnabled { get; set; }
		
		/// <summary>
		/// The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stickyMacAllowList")]
		public string[] StickyMacAllowList { get; set; }
		
		/// <summary>
		/// The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stickyMacAllowListLimit")]
		public System.Nullable<System.Int32> StickyMacAllowListLimit { get; set; }
		
		/// <summary>
		/// The storm control status of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stormControlEnabled")]
		public System.Nullable<System.Boolean> StormControlEnabled { get; set; }
		
		/// <summary>
		/// The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stpGuard")]
		public System.Nullable<UpdateOrganizationConfigTemplateSwitchProfilePortReturnStpGuard> StpGuard { get; set; }
		
		/// <summary>
		/// The list of tags of the switch profile port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// The type of the switch profile port ('trunk' or 'access').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GetDeviceSwitchPortsReturnType Type { get; set; }
		
		/// <summary>
		/// The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="udld")]
		public System.Nullable<UpdateOrganizationConfigTemplateSwitchProfilePortReturnUdld> Udld { get; set; }
		
		/// <summary>
		/// The VLAN of the switch profile port. A null value will clear the value set for trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
		
		/// <summary>
		/// The voice VLAN of the switch profile port. Only applicable to access ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlan")]
		public System.Nullable<System.Int32> VoiceVlan { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationConfigTemplateSwitchProfilePortReturnAccessPolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Custom access policy")]
		Custom_access_policy = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAC allow list")]
		MAC_allow_list = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Open = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Sticky MAC allow list")]
		Sticky_MAC_allow_list = 3,
	}
	
	public class UpdateOrganizationConfigTemplateSwitchProfilePortReturnProfile
	{
		
		/// <summary>
		/// When enabled, override this port's configuration with a port profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// When enabled, the ID of the port profile used to override the port's configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// When enabled, the IName of the profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iname")]
		public string Iname { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationConfigTemplateSwitchProfilePortReturnStpGuard
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bpdu guard")]
		bpdu_guard = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="loop guard")]
		loop_guard = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="root guard")]
		root_guard = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationConfigTemplateSwitchProfilePortReturnUdld
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Alert only")]
		Alert_only = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Enforce = 1,
	}
	
	public enum GetOrganizationDevicesTagsFilterType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		withAllTags = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		withAnyTags = 1,
	}
	
	public class GetOrganizationDevicesReturn
	{
		
		/// <summary>
		/// Physical address of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// Firmware version of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public string Firmware { get; set; }
		
		/// <summary>
		/// LAN IP address of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lanIp")]
		public string LanIp { get; set; }
		
		/// <summary>
		/// Latitude of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Single> Lat { get; set; }
		
		/// <summary>
		/// Longitude of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Single> Lng { get; set; }
		
		/// <summary>
		/// MAC address of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// Model of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public string Model { get; set; }
		
		/// <summary>
		/// Name of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// ID of the network the device belongs to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// Notes for the device, limited to 255 characters
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// Product type of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productType")]
		public string ProductType { get; set; }
		
		/// <summary>
		/// Serial number of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// List of tags assigned to the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
	}
	
	public class GetOrganizationDevicesAvailabilitiesReturn
	{
		
		/// <summary>
		/// The device MAC address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// The device name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Network info.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public GetOrganizationDevicesAvailabilitiesReturnNetwork Network { get; set; }
		
		/// <summary>
		/// Device product type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productType")]
		public System.Nullable<GetOrganizationDevicesAvailabilitiesReturnProductType> ProductType { get; set; }
		
		/// <summary>
		/// The device serial number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// Status of the device. Possible values are: online, alerting, offline, dormant.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<GetOrganizationDevicesAvailabilitiesReturnStatus> Status { get; set; }
		
		/// <summary>
		/// List of custom tags for the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
	}
	
	public class GetOrganizationDevicesAvailabilitiesReturnNetwork
	{
		
		/// <summary>
		/// ID for the network containing the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationDevicesAvailabilitiesReturnProductType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		appliance = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		camera = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cellularGateway = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sensor = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="switch")]
		_switch = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		systemsManager = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wireless = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationDevicesAvailabilitiesReturnStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		alerting = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dormant = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		offline = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		online = 3,
	}
	
	public class GetOrganizationDevicesPowerModulesStatusesByDeviceReturn
	{
		
		/// <summary>
		/// The device MAC address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// The device name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Network info.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public GetOrganizationDevicesPowerModulesStatusesByDeviceReturnNetwork Network { get; set; }
		
		/// <summary>
		/// Device product type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productType")]
		public System.Nullable<GetOrganizationDevicesPowerModulesStatusesByDeviceReturnProductType> ProductType { get; set; }
		
		/// <summary>
		/// The device serial number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// Information for the device's AC power supplies.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slots")]
		public GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlots[] GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlots { get; set; }
		
		/// <summary>
		/// List of custom tags for the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
	}
	
	public class GetOrganizationDevicesPowerModulesStatusesByDeviceReturnNetwork
	{
		
		/// <summary>
		/// ID for the network that the device is associated with.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationDevicesPowerModulesStatusesByDeviceReturnProductType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		appliance = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		camera = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cellularGateway = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sensor = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="switch")]
		_switch = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		systemsManager = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wireless = 6,
	}
	
	public class GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlots
	{
		
		/// <summary>
		/// The power supply unit model.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public string Model { get; set; }
		
		/// <summary>
		/// Which slot the AC power supply occupies. Possible values are: 0, 1, 2.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlotsNumber> Number { get; set; }
		
		/// <summary>
		/// The power supply unit serial number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// Status of the power supply unit. Possible values are: connected, not connected, powering.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlotsStatus> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlotsNumber
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2 = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationDevicesPowerModulesStatusesByDeviceReturnSlotsStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		connected = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="not connected")]
		not_connected = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		powering = 2,
	}
	
	public class GetOrganizationDevicesStatusesReturn
	{
		
		/// <summary>
		/// Components
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="components")]
		public GetOrganizationDevicesStatusesReturnComponents Components { get; set; }
		
		/// <summary>
		/// IP Gateway
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// IP Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipType")]
		public string IpType { get; set; }
		
		/// <summary>
		/// LAN IP Address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lanIp")]
		public string LanIp { get; set; }
		
		/// <summary>
		/// Device Last Reported Location
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastReportedAt")]
		public string LastReportedAt { get; set; }
		
		/// <summary>
		/// MAC Address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// Model
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public string Model { get; set; }
		
		/// <summary>
		/// Device Name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Network ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// Primary DNS
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primaryDns")]
		public string PrimaryDns { get; set; }
		
		/// <summary>
		/// Product Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productType")]
		public string ProductType { get; set; }
		
		/// <summary>
		/// Public IP Address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicIp")]
		public string PublicIp { get; set; }
		
		/// <summary>
		/// Secondary DNS
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondaryDns")]
		public string SecondaryDns { get; set; }
		
		/// <summary>
		/// Device Serial Number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// Device Status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// Tags
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
	}
	
	public class GetOrganizationDevicesStatusesReturnComponents
	{
		
		/// <summary>
		/// Power Supplies
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="powerSupplies")]
		public string[] PowerSupplies { get; set; }
	}
	
	public class GetOrganizationDevicesStatusesOverviewReturn
	{
		
		/// <summary>
		/// counts
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="counts")]
		public GetOrganizationDevicesStatusesOverviewReturnCounts Counts { get; set; }
	}
	
	public class GetOrganizationDevicesStatusesOverviewReturnCounts
	{
		
		/// <summary>
		/// byStatus
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="byStatus")]
		public GetOrganizationDevicesStatusesOverviewReturnCountsByStatus ByStatus { get; set; }
	}
	
	public class GetOrganizationDevicesStatusesOverviewReturnCountsByStatus
	{
		
		/// <summary>
		/// alerting count
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alerting")]
		public System.Nullable<System.Int32> Alerting { get; set; }
		
		/// <summary>
		/// dormant count
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dormant")]
		public System.Nullable<System.Int32> Dormant { get; set; }
		
		/// <summary>
		/// offline count
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="offline")]
		public System.Nullable<System.Int32> Offline { get; set; }
		
		/// <summary>
		/// online count
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="online")]
		public System.Nullable<System.Int32> Online { get; set; }
	}
	
	public class GetOrganizationDevicesUplinksAddressesByDeviceReturn
	{
		
		/// <summary>
		/// The device MAC address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// The device name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Network info.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public GetOrganizationDevicesUplinksAddressesByDeviceReturnNetwork Network { get; set; }
		
		/// <summary>
		/// Device product type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productType")]
		public System.Nullable<GetOrganizationDevicesUplinksAddressesByDeviceReturnProductType> ProductType { get; set; }
		
		/// <summary>
		/// The device serial number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// List of custom tags for the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// List of device uplink addresses information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uplinks")]
		public GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinks[] GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinks { get; set; }
	}
	
	public class GetOrganizationDevicesUplinksAddressesByDeviceReturnNetwork
	{
		
		/// <summary>
		/// ID for the network containing the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationDevicesUplinksAddressesByDeviceReturnProductType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		appliance = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		camera = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cellularGateway = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sensor = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="switch")]
		_switch = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		systemsManager = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wireless = 6,
	}
	
	public class GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinks
	{
		
		/// <summary>
		/// Available addresses for the interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddresses[] GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddresses { get; set; }
		
		/// <summary>
		/// Interface for the device uplink. Available options are: cellular, man1, man2, wan1, wan2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interface")]
		public System.Nullable<GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksInterface> Interface { get; set; }
	}
	
	public class GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddresses
	{
		
		/// <summary>
		/// Device uplink address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// Indicates how the device uplink address is assigned. Available options are: static, dynamic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignmentMode")]
		public System.Nullable<GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddressesAssignmentMode> AssignmentMode { get; set; }
		
		/// <summary>
		/// Device uplink gateway address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// Type of address for the device uplink. Available options are: ipv4, ipv6.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public System.Nullable<GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddressesProtocol> Protocol { get; set; }
		
		/// <summary>
		/// Public interface information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="public")]
		public GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddressesPublic Public { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddressesAssignmentMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dynamic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="static")]
		_static = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddressesProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ipv4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ipv6 = 1,
	}
	
	public class GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksAddressesPublic
	{
		
		/// <summary>
		/// The device uplink public IP address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationDevicesUplinksAddressesByDeviceReturnUplinksInterface
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cellular = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		man1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		man2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wan1 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wan2 = 4,
	}
	
	public class GetOrganizationDevicesUplinksLossAndLatencyReturn
	{
		
		/// <summary>
		/// IP address of uplink
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// Network ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// Serial of MX device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// Loss and latency timeseries data
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeSeries")]
		public GetOrganizationDevicesUplinksLossAndLatencyReturnTimeSeries[] GetOrganizationDevicesUplinksLossAndLatencyReturnTimeSeries { get; set; }
		
		/// <summary>
		/// Uplink interface (wan1, wan2, or cellular)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uplink")]
		public string Uplink { get; set; }
	}
	
	public class GetOrganizationDevicesUplinksLossAndLatencyReturnTimeSeries
	{
		
		/// <summary>
		/// Latency in milliseconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latencyMs")]
		public System.Nullable<System.Single> LatencyMs { get; set; }
		
		/// <summary>
		/// Loss percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lossPercent")]
		public System.Nullable<System.Single> LossPercent { get; set; }
		
		/// <summary>
		/// Timestamp for this data point
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ts")]
		public System.Nullable<System.DateTimeOffset> Ts { get; set; }
	}
	
	public class CreateOrganizationEarlyAccessFeaturesOptInPostBody
	{
		
		/// <summary>
		/// A list of network IDs to apply the opt-in to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitScopeToNetworks")]
		public string[] LimitScopeToNetworks { get; set; }
		
		/// <summary>
		/// Short name of the early access feature
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class UpdateOrganizationEarlyAccessFeaturesOptInPutBody
	{
		
		/// <summary>
		/// A list of network IDs to apply the opt-in to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitScopeToNetworks")]
		public string[] LimitScopeToNetworks { get; set; }
	}
	
	public class GetOrganizationFirmwareUpgradesReturn
	{
		
		/// <summary>
		/// Timestamp when upgrade completed. Null if status pending.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completedAt")]
		public string CompletedAt { get; set; }
		
		/// <summary>
		/// ID of the upgrade's starting version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fromVersion")]
		public GetOrganizationFirmwareUpgradesReturnFromVersion FromVersion { get; set; }
		
		/// <summary>
		/// Network of the upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public GetOrganizationFirmwareUpgradesReturnNetwork Network { get; set; }
		
		/// <summary>
		/// product upgraded [wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor]
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productType")]
		public string ProductType { get; set; }
		
		/// <summary>
		/// Status of upgrade event: [Cancelled, Completed]
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// Scheduled start time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.DateTimeOffset> Time { get; set; }
		
		/// <summary>
		/// ID of the upgrade's target version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public GetOrganizationFirmwareUpgradesReturnToVersion ToVersion { get; set; }
		
		/// <summary>
		/// The upgrade batch
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradeBatchId")]
		public string UpgradeBatchId { get; set; }
		
		/// <summary>
		/// The upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradeId")]
		public string UpgradeId { get; set; }
	}
	
	public class GetOrganizationFirmwareUpgradesReturnFromVersion
	{
		
		/// <summary>
		/// Firmware version ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetOrganizationFirmwareUpgradesReturnNetwork
	{
		
		/// <summary>
		/// ID of network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetOrganizationFirmwareUpgradesReturnToVersion
	{
		
		/// <summary>
		/// Firmware version ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateTimeOffset> ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetOrganizationFirmwareUpgradesByDeviceReturn
	{
		
		/// <summary>
		/// Status of the device upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceStatus")]
		public string DeviceStatus { get; set; }
		
		/// <summary>
		/// Name assigned to the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Serial of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// The devices upgrade details and status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgrade")]
		public GetOrganizationFirmwareUpgradesByDeviceReturnUpgrade Upgrade { get; set; }
	}
	
	public class GetOrganizationFirmwareUpgradesByDeviceReturnUpgrade
	{
		
		/// <summary>
		/// The initial version of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fromVersion")]
		public GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeFromVersion FromVersion { get; set; }
		
		/// <summary>
		/// ID of the upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Staged upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staged")]
		public GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeStaged Staged { get; set; }
		
		/// <summary>
		/// Status of the upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// Start time of the upgrade
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public string Time { get; set; }
		
		/// <summary>
		/// Version the device is upgrading to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toVersion")]
		public GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeToVersion ToVersion { get; set; }
		
		/// <summary>
		/// ID of the upgrade batch
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradeBatchId")]
		public string UpgradeBatchId { get; set; }
	}
	
	public class GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeFromVersion
	{
		
		/// <summary>
		/// ID of the initial firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public string ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeStaged
	{
		
		/// <summary>
		/// The staged upgrade group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeStagedGroup Group { get; set; }
	}
	
	public class GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeStagedGroup
	{
		
		/// <summary>
		/// Id of the staged upgrade group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class GetOrganizationFirmwareUpgradesByDeviceReturnUpgradeToVersion
	{
		
		/// <summary>
		/// ID of the initial firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Release date of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public string ReleaseDate { get; set; }
		
		/// <summary>
		/// Release type of the firmware version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseType")]
		public string ReleaseType { get; set; }
		
		/// <summary>
		/// Firmware version short name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	public class GetOrganizationInsightApplicationsReturn
	{
		
		/// <summary>
		/// Application identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applicationId")]
		public string ApplicationId { get; set; }
		
		/// <summary>
		/// Application name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Thresholds defined by a user or Meraki models for each application
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thresholds")]
		public GetOrganizationInsightApplicationsReturnThresholds Thresholds { get; set; }
	}
	
	public class GetOrganizationInsightApplicationsReturnThresholds
	{
		
		/// <summary>
		/// Threshold for each network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="byNetwork")]
		public GetOrganizationInsightApplicationsReturnThresholdsByNetwork[] GetOrganizationInsightApplicationsReturnThresholdsByNetwork { get; set; }
		
		/// <summary>
		/// Threshold type (static or smart)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class GetOrganizationInsightApplicationsReturnThresholdsByNetwork
	{
		
		/// <summary>
		/// Number of useful information bits delivered over a network per unit of time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="goodput")]
		public System.Nullable<System.Int32> Goodput { get; set; }
		
		/// <summary>
		/// Network identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// Duration of the response, in milliseconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseDuration")]
		public System.Nullable<System.Int32> ResponseDuration { get; set; }
	}
	
	public class GetOrganizationInsightMonitoredMediaServersReturn
	{
		
		/// <summary>
		/// The IP address (IPv4 only) or hostname of the media server to monitor
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bestEffortMonitoringEnabled")]
		public System.Nullable<System.Boolean> BestEffortMonitoringEnabled { get; set; }
		
		/// <summary>
		/// Monitored media server id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the VoIP provider
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class CreateOrganizationInsightMonitoredMediaServerPostBody
	{
		
		/// <summary>
		/// The IP address (IPv4 only) or hostname of the media server to monitor
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bestEffortMonitoringEnabled")]
		public System.Nullable<System.Boolean> BestEffortMonitoringEnabled { get; set; }
		
		/// <summary>
		/// The name of the VoIP provider
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class UpdateOrganizationInsightMonitoredMediaServerPutBody
	{
		
		/// <summary>
		/// The IP address (IPv4 only) or hostname of the media server to monitor
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bestEffortMonitoringEnabled")]
		public System.Nullable<System.Boolean> BestEffortMonitoringEnabled { get; set; }
		
		/// <summary>
		/// The name of the VoIP provider
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class ClaimIntoOrganizationInventoryPostBody
	{
		
		/// <summary>
		/// The licenses that should be claimed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenses")]
		public ClaimIntoOrganizationInventoryPostBodyLicenses[] ClaimIntoOrganizationInventoryPostBodyLicenses { get; set; }
		
		/// <summary>
		/// The numbers of the orders that should be claimed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orders")]
		public string[] Orders { get; set; }
		
		/// <summary>
		/// The serials of the devices that should be claimed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string[] Serials { get; set; }
	}
	
	public class ClaimIntoOrganizationInventoryPostBodyLicenses
	{
		
		/// <summary>
		/// The key of the license
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Co-term licensing only: either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. Does not apply to organizations using per-device licensing model.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public ClaimIntoOrganizationPostBodyLicensesMode Mode { get; set; }
	}
	
	public enum GetOrganizationInventoryDevicesUsedState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unused = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		used = 1,
	}
	
	public class GetOrganizationInventoryDevicesReturn
	{
		
		/// <summary>
		/// Claimed time of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="claimedAt")]
		public System.Nullable<System.DateTimeOffset> ClaimedAt { get; set; }
		
		/// <summary>
		/// License expiration date of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseExpirationDate")]
		public System.Nullable<System.DateTimeOffset> LicenseExpirationDate { get; set; }
		
		/// <summary>
		/// MAC address of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// Model type of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public string Model { get; set; }
		
		/// <summary>
		/// Name of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Network Id of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// Order number of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orderNumber")]
		public string OrderNumber { get; set; }
		
		/// <summary>
		/// Product type of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productType")]
		public string ProductType { get; set; }
		
		/// <summary>
		/// Serial number of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// Device tags
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
	}
	
	public class GetOrganizationInventoryDeviceReturn
	{
		
		/// <summary>
		/// Claimed time of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="claimedAt")]
		public System.Nullable<System.DateTimeOffset> ClaimedAt { get; set; }
		
		/// <summary>
		/// License expiration date of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseExpirationDate")]
		public System.Nullable<System.DateTimeOffset> LicenseExpirationDate { get; set; }
		
		/// <summary>
		/// MAC address of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// Model type of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public string Model { get; set; }
		
		/// <summary>
		/// Name of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Network Id of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// Order number of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orderNumber")]
		public string OrderNumber { get; set; }
		
		/// <summary>
		/// Product type of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productType")]
		public string ProductType { get; set; }
		
		/// <summary>
		/// Serial number of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// Device tags
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
	}
	
	public class CreateOrganizationInventoryOnboardingCloudMonitoringExportEventPostBody
	{
		
		/// <summary>
		/// The type of log event this is recording, e.g. download or opening a banner
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logEvent")]
		public string LogEvent { get; set; }
		
		/// <summary>
		/// Used to describe if this event was the result of a redirect. E.g. a query param if an info banner is being used
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="request")]
		public string Request { get; set; }
		
		/// <summary>
		/// The name of the onboarding distro being downloaded
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetOS")]
		public string TargetOS { get; set; }
		
		/// <summary>
		/// A JavaScript UTC datetime stamp for when the even occurred
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public int Timestamp { get; set; }
	}
	
	public class GetOrganizationInventoryOnboardingCloudMonitoringImportsReturn
	{
		
		/// <summary>
		/// Represents the details of an imported device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="device")]
		public GetOrganizationInventoryOnboardingCloudMonitoringImportsReturnDevice Device { get; set; }
		
		/// <summary>
		/// Database ID for the new entity entry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="importId")]
		public string ImportId { get; set; }
	}
	
	public class GetOrganizationInventoryOnboardingCloudMonitoringImportsReturnDevice
	{
		
		/// <summary>
		/// Whether or not the device was successfully created in dashboard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.Boolean> Created { get; set; }
		
		/// <summary>
		/// Represents the current state of importing the device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// The url to the device details page within dashboard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class CreateOrganizationInventoryOnboardingCloudMonitoringImportPostBody
	{
		
		/// <summary>
		/// A set of device imports to commit
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devices")]
		public CreateOrganizationInventoryOnboardingCloudMonitoringImportPostBodyDevices[] CreateOrganizationInventoryOnboardingCloudMonitoringImportPostBodyDevices { get; set; }
	}
	
	public class CreateOrganizationInventoryOnboardingCloudMonitoringImportPostBodyDevices
	{
		
		/// <summary>
		/// Import ID from the Import operation
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deviceId")]
		public string DeviceId { get; set; }
		
		/// <summary>
		/// Network Id
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// Device UDI certificate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="udi")]
		public string Udi { get; set; }
	}
	
	public enum GetOrganizationInventoryOnboardingCloudMonitoringNetworksDeviceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="switch")]
		_switch = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wireless_controller = 1,
	}
	
	public class CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBody
	{
		
		/// <summary>
		/// A set of devices to import (or update)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="devices")]
		public CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevices[] CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevices { get; set; }
	}
	
	public class CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevices
	{
		
		/// <summary>
		/// Device SUDI certificate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sudi")]
		public string Sudi { get; set; }
		
		/// <summary>
		/// TLS Related Parameters
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tunnel")]
		public CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesTunnel Tunnel { get; set; }
		
		/// <summary>
		/// User parameters
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesUser User { get; set; }
		
		/// <summary>
		/// VTY Related Parameters
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vty")]
		public CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVty Vty { get; set; }
	}
	
	public class CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesTunnel
	{
		
		/// <summary>
		/// Name of the configured TLS certificate
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateName")]
		public string CertificateName { get; set; }
		
		/// <summary>
		/// Number of the vlan expected to be used to connect to the cloud
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localInterface")]
		public System.Nullable<System.Int32> LocalInterface { get; set; }
		
		/// <summary>
		/// Number of the configured Loopback Interface used for TLS overlay
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loopbackNumber")]
		public System.Nullable<System.Int32> LoopbackNumber { get; set; }
		
		/// <summary>
		/// Name of the configured TLS tunnel
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesUser
	{
		
		/// <summary>
		/// The name of the device user for Meraki monitoring
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	public class CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVty
	{
		
		/// <summary>
		/// AccessList details
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessList")]
		public CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessList AccessList { get; set; }
		
		/// <summary>
		/// VTY AAA authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthentication Authentication { get; set; }
		
		/// <summary>
		/// VTY AAA authorization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorization")]
		public CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthorization Authorization { get; set; }
		
		/// <summary>
		/// Ending line VTY number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endLineNumber")]
		public System.Nullable<System.Int32> EndLineNumber { get; set; }
		
		/// <summary>
		/// SSH rotary number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rotaryNumber")]
		public System.Nullable<System.Int32> RotaryNumber { get; set; }
		
		/// <summary>
		/// Starting line VTY number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startLineNumber")]
		public System.Nullable<System.Int32> StartLineNumber { get; set; }
	}
	
	public class CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessList
	{
		
		/// <summary>
		/// VTY in ACL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vtyIn")]
		public CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessListVtyIn VtyIn { get; set; }
		
		/// <summary>
		/// VTY out ACL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vtyOut")]
		public CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessListVtyOut VtyOut { get; set; }
	}
	
	public class CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessListVtyIn
	{
		
		/// <summary>
		/// Name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAccessListVtyOut
	{
		
		/// <summary>
		/// Name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthentication
	{
		
		/// <summary>
		/// Group Details
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthenticationGroup Group { get; set; }
	}
	
	public class CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthenticationGroup
	{
		
		/// <summary>
		/// Group Name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthorization
	{
		
		/// <summary>
		/// Group Details
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthorizationGroup Group { get; set; }
	}
	
	public class CreateOrganizationInventoryOnboardingCloudMonitoringPreparePostBodyDevicesVtyAuthorizationGroup
	{
		
		/// <summary>
		/// Group Name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class ReleaseFromOrganizationInventoryPostBody
	{
		
		/// <summary>
		/// Serials of the devices that should be released
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serials")]
		public string[] Serials { get; set; }
	}
	
	public enum GetOrganizationLicensesState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		expired = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		expiring = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		recentlyQueued = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unused = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unusedActive = 5,
	}
	
	public class GetOrganizationLicensesReturn
	{
		
		/// <summary>
		/// The date the license started burning
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="activationDate")]
		public string ActivationDate { get; set; }
		
		/// <summary>
		/// The date the license was claimed into the organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="claimDate")]
		public string ClaimDate { get; set; }
		
		/// <summary>
		/// Serial number of the device the license is assigned to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceSerial")]
		public string DeviceSerial { get; set; }
		
		/// <summary>
		/// The duration of the individual license
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationInDays")]
		public System.Nullable<System.Int32> DurationInDays { get; set; }
		
		/// <summary>
		/// The date the license will expire
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expirationDate")]
		public string ExpirationDate { get; set; }
		
		/// <summary>
		/// The id of the head license this license is queued behind. If there is no head license, it returns nil.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headLicenseId")]
		public string HeadLicenseId { get; set; }
		
		/// <summary>
		/// License ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// License key
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseKey")]
		public string LicenseKey { get; set; }
		
		/// <summary>
		/// License type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseType")]
		public string LicenseType { get; set; }
		
		/// <summary>
		/// ID of the network the license is assigned to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// Order number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orderNumber")]
		public string OrderNumber { get; set; }
		
		/// <summary>
		/// DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permanentlyQueuedLicenses")]
		public GetOrganizationLicensesReturnPermanentlyQueuedLicenses[] GetOrganizationLicensesReturnPermanentlyQueuedLicenses { get; set; }
		
		/// <summary>
		/// The number of seats of the license. Only applicable to SM licenses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seatCount")]
		public System.Nullable<System.Int32> SeatCount { get; set; }
		
		/// <summary>
		/// The state of the license. All queued licenses have a status of `recentlyQueued`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public GetOrganizationLicensesState State { get; set; }
		
		/// <summary>
		/// The duration of the license plus all permanently queued licenses associated with it
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalDurationInDays")]
		public System.Nullable<System.Int32> TotalDurationInDays { get; set; }
	}
	
	public class GetOrganizationLicensesReturnPermanentlyQueuedLicenses
	{
		
		/// <summary>
		/// The duration of the individual license
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationInDays")]
		public System.Nullable<System.Int32> DurationInDays { get; set; }
		
		/// <summary>
		/// Permanently queued license ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// License key
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseKey")]
		public string LicenseKey { get; set; }
		
		/// <summary>
		/// License type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseType")]
		public string LicenseType { get; set; }
		
		/// <summary>
		/// Order number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orderNumber")]
		public string OrderNumber { get; set; }
	}
	
	public class AssignOrganizationLicensesSeatsPostBody
	{
		
		/// <summary>
		/// The ID of the SM license to assign seats from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="licenseId")]
		public string LicenseId { get; set; }
		
		/// <summary>
		/// The ID of the SM network to assign the seats to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// The number of seats to assign to the SM network. Must be less than or equal to the total number of seats of the license
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="seatCount")]
		public int SeatCount { get; set; }
	}
	
	public class AssignOrganizationLicensesSeatsReturn
	{
		
		/// <summary>
		/// Resulting licenses from the move
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resultingLicenses")]
		public AssignOrganizationLicensesSeatsReturnResultingLicenses[] AssignOrganizationLicensesSeatsReturnResultingLicenses { get; set; }
	}
	
	public class AssignOrganizationLicensesSeatsReturnResultingLicenses
	{
		
		/// <summary>
		/// The date the license started burning
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="activationDate")]
		public string ActivationDate { get; set; }
		
		/// <summary>
		/// The date the license was claimed into the organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="claimDate")]
		public string ClaimDate { get; set; }
		
		/// <summary>
		/// Serial number of the device the license is assigned to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceSerial")]
		public string DeviceSerial { get; set; }
		
		/// <summary>
		/// The duration of the individual license
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationInDays")]
		public System.Nullable<System.Int32> DurationInDays { get; set; }
		
		/// <summary>
		/// The date the license will expire
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expirationDate")]
		public string ExpirationDate { get; set; }
		
		/// <summary>
		/// The id of the head license this license is queued behind. If there is no head license, it returns nil.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headLicenseId")]
		public string HeadLicenseId { get; set; }
		
		/// <summary>
		/// License ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// License key
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseKey")]
		public string LicenseKey { get; set; }
		
		/// <summary>
		/// License type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseType")]
		public string LicenseType { get; set; }
		
		/// <summary>
		/// ID of the network the license is assigned to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// Order number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orderNumber")]
		public string OrderNumber { get; set; }
		
		/// <summary>
		/// DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permanentlyQueuedLicenses")]
		public AssignOrganizationLicensesSeatsReturnResultingLicensesPermanentlyQueuedLicenses[] AssignOrganizationLicensesSeatsReturnResultingLicensesPermanentlyQueuedLicenses { get; set; }
		
		/// <summary>
		/// The number of seats of the license. Only applicable to SM licenses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seatCount")]
		public System.Nullable<System.Int32> SeatCount { get; set; }
		
		/// <summary>
		/// The state of the license. All queued licenses have a status of `recentlyQueued`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public GetOrganizationLicensesState State { get; set; }
		
		/// <summary>
		/// The duration of the license plus all permanently queued licenses associated with it
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalDurationInDays")]
		public System.Nullable<System.Int32> TotalDurationInDays { get; set; }
	}
	
	public class AssignOrganizationLicensesSeatsReturnResultingLicensesPermanentlyQueuedLicenses
	{
		
		/// <summary>
		/// The duration of the individual license
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationInDays")]
		public System.Nullable<System.Int32> DurationInDays { get; set; }
		
		/// <summary>
		/// Permanently queued license ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// License key
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseKey")]
		public string LicenseKey { get; set; }
		
		/// <summary>
		/// License type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseType")]
		public string LicenseType { get; set; }
		
		/// <summary>
		/// Order number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orderNumber")]
		public string OrderNumber { get; set; }
	}
	
	public class MoveOrganizationLicensesPostBody
	{
		
		/// <summary>
		/// The ID of the organization to move the licenses to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destOrganizationId")]
		public string DestOrganizationId { get; set; }
		
		/// <summary>
		/// A list of IDs of licenses to move to the new organization
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="licenseIds")]
		public string[] LicenseIds { get; set; }
	}
	
	public class MoveOrganizationLicensesReturn
	{
		
		/// <summary>
		/// The ID of the organization to move the licenses to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destOrganizationId")]
		public string DestOrganizationId { get; set; }
		
		/// <summary>
		/// A list of IDs of licenses to move to the new organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseIds")]
		public string[] LicenseIds { get; set; }
	}
	
	public class MoveOrganizationLicensesSeatsPostBody
	{
		
		/// <summary>
		/// The ID of the organization to move the SM seats to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destOrganizationId")]
		public string DestOrganizationId { get; set; }
		
		/// <summary>
		/// The ID of the SM license to move the seats from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="licenseId")]
		public string LicenseId { get; set; }
		
		/// <summary>
		/// The number of seats to move to the new organization. Must be less than or equal to the total number of seats of the license
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="seatCount")]
		public int SeatCount { get; set; }
	}
	
	public class MoveOrganizationLicensesSeatsReturn
	{
		
		/// <summary>
		/// The ID of the organization to move the SM seats to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destOrganizationId")]
		public string DestOrganizationId { get; set; }
		
		/// <summary>
		/// The ID of the SM license to move the seats from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseId")]
		public string LicenseId { get; set; }
		
		/// <summary>
		/// The number of seats to move to the new organization. Must be less than or equal to the total number of seats of the license
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seatCount")]
		public System.Nullable<System.Int32> SeatCount { get; set; }
	}
	
	public class RenewOrganizationLicensesSeatsPostBody
	{
		
		/// <summary>
		/// The ID of the SM license to renew. This license must already be assigned to an SM network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="licenseIdToRenew")]
		public string LicenseIdToRenew { get; set; }
		
		/// <summary>
		/// The SM license to use to renew the seats on 'licenseIdToRenew'. This license must have at least as many seats available as there are seats on 'licenseIdToRenew'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="unusedLicenseId")]
		public string UnusedLicenseId { get; set; }
	}
	
	public class RenewOrganizationLicensesSeatsReturn
	{
		
		/// <summary>
		/// Resulting licenses from the move
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resultingLicenses")]
		public RenewOrganizationLicensesSeatsReturnResultingLicenses[] RenewOrganizationLicensesSeatsReturnResultingLicenses { get; set; }
	}
	
	public class RenewOrganizationLicensesSeatsReturnResultingLicenses
	{
		
		/// <summary>
		/// The date the license started burning
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="activationDate")]
		public string ActivationDate { get; set; }
		
		/// <summary>
		/// The date the license was claimed into the organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="claimDate")]
		public string ClaimDate { get; set; }
		
		/// <summary>
		/// Serial number of the device the license is assigned to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceSerial")]
		public string DeviceSerial { get; set; }
		
		/// <summary>
		/// The duration of the individual license
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationInDays")]
		public System.Nullable<System.Int32> DurationInDays { get; set; }
		
		/// <summary>
		/// The date the license will expire
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expirationDate")]
		public string ExpirationDate { get; set; }
		
		/// <summary>
		/// The id of the head license this license is queued behind. If there is no head license, it returns nil.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headLicenseId")]
		public string HeadLicenseId { get; set; }
		
		/// <summary>
		/// License ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// License key
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseKey")]
		public string LicenseKey { get; set; }
		
		/// <summary>
		/// License type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseType")]
		public string LicenseType { get; set; }
		
		/// <summary>
		/// ID of the network the license is assigned to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// Order number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orderNumber")]
		public string OrderNumber { get; set; }
		
		/// <summary>
		/// DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permanentlyQueuedLicenses")]
		public RenewOrganizationLicensesSeatsReturnResultingLicensesPermanentlyQueuedLicenses[] RenewOrganizationLicensesSeatsReturnResultingLicensesPermanentlyQueuedLicenses { get; set; }
		
		/// <summary>
		/// The number of seats of the license. Only applicable to SM licenses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seatCount")]
		public System.Nullable<System.Int32> SeatCount { get; set; }
		
		/// <summary>
		/// The state of the license. All queued licenses have a status of `recentlyQueued`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public GetOrganizationLicensesState State { get; set; }
		
		/// <summary>
		/// The duration of the license plus all permanently queued licenses associated with it
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalDurationInDays")]
		public System.Nullable<System.Int32> TotalDurationInDays { get; set; }
	}
	
	public class RenewOrganizationLicensesSeatsReturnResultingLicensesPermanentlyQueuedLicenses
	{
		
		/// <summary>
		/// The duration of the individual license
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationInDays")]
		public System.Nullable<System.Int32> DurationInDays { get; set; }
		
		/// <summary>
		/// Permanently queued license ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// License key
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseKey")]
		public string LicenseKey { get; set; }
		
		/// <summary>
		/// License type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseType")]
		public string LicenseType { get; set; }
		
		/// <summary>
		/// Order number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orderNumber")]
		public string OrderNumber { get; set; }
	}
	
	public class GetOrganizationLicenseReturn
	{
		
		/// <summary>
		/// The date the license started burning
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="activationDate")]
		public string ActivationDate { get; set; }
		
		/// <summary>
		/// The date the license was claimed into the organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="claimDate")]
		public string ClaimDate { get; set; }
		
		/// <summary>
		/// Serial number of the device the license is assigned to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceSerial")]
		public string DeviceSerial { get; set; }
		
		/// <summary>
		/// The duration of the individual license
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationInDays")]
		public System.Nullable<System.Int32> DurationInDays { get; set; }
		
		/// <summary>
		/// The date the license will expire
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expirationDate")]
		public string ExpirationDate { get; set; }
		
		/// <summary>
		/// The id of the head license this license is queued behind. If there is no head license, it returns nil.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headLicenseId")]
		public string HeadLicenseId { get; set; }
		
		/// <summary>
		/// License ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// License key
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseKey")]
		public string LicenseKey { get; set; }
		
		/// <summary>
		/// License type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseType")]
		public string LicenseType { get; set; }
		
		/// <summary>
		/// ID of the network the license is assigned to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// Order number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orderNumber")]
		public string OrderNumber { get; set; }
		
		/// <summary>
		/// DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permanentlyQueuedLicenses")]
		public GetOrganizationLicenseReturnPermanentlyQueuedLicenses[] GetOrganizationLicenseReturnPermanentlyQueuedLicenses { get; set; }
		
		/// <summary>
		/// The number of seats of the license. Only applicable to SM licenses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seatCount")]
		public System.Nullable<System.Int32> SeatCount { get; set; }
		
		/// <summary>
		/// The state of the license. All queued licenses have a status of `recentlyQueued`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public GetOrganizationLicensesState State { get; set; }
		
		/// <summary>
		/// The duration of the license plus all permanently queued licenses associated with it
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalDurationInDays")]
		public System.Nullable<System.Int32> TotalDurationInDays { get; set; }
	}
	
	public class GetOrganizationLicenseReturnPermanentlyQueuedLicenses
	{
		
		/// <summary>
		/// The duration of the individual license
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationInDays")]
		public System.Nullable<System.Int32> DurationInDays { get; set; }
		
		/// <summary>
		/// Permanently queued license ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// License key
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseKey")]
		public string LicenseKey { get; set; }
		
		/// <summary>
		/// License type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseType")]
		public string LicenseType { get; set; }
		
		/// <summary>
		/// Order number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orderNumber")]
		public string OrderNumber { get; set; }
	}
	
	public class UpdateOrganizationLicensePutBody
	{
		
		/// <summary>
		/// The serial number of the device to assign this license to. Set this to  null to unassign the license. If a different license is already active on the device, this parameter will control queueing/dequeuing this license.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceSerial")]
		public string DeviceSerial { get; set; }
	}
	
	public class UpdateOrganizationLicenseReturn
	{
		
		/// <summary>
		/// The date the license started burning
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="activationDate")]
		public string ActivationDate { get; set; }
		
		/// <summary>
		/// The date the license was claimed into the organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="claimDate")]
		public string ClaimDate { get; set; }
		
		/// <summary>
		/// Serial number of the device the license is assigned to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceSerial")]
		public string DeviceSerial { get; set; }
		
		/// <summary>
		/// The duration of the individual license
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationInDays")]
		public System.Nullable<System.Int32> DurationInDays { get; set; }
		
		/// <summary>
		/// The date the license will expire
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expirationDate")]
		public string ExpirationDate { get; set; }
		
		/// <summary>
		/// The id of the head license this license is queued behind. If there is no head license, it returns nil.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headLicenseId")]
		public string HeadLicenseId { get; set; }
		
		/// <summary>
		/// License ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// License key
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseKey")]
		public string LicenseKey { get; set; }
		
		/// <summary>
		/// License type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseType")]
		public string LicenseType { get; set; }
		
		/// <summary>
		/// ID of the network the license is assigned to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// Order number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orderNumber")]
		public string OrderNumber { get; set; }
		
		/// <summary>
		/// DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permanentlyQueuedLicenses")]
		public UpdateOrganizationLicenseReturnPermanentlyQueuedLicenses[] UpdateOrganizationLicenseReturnPermanentlyQueuedLicenses { get; set; }
		
		/// <summary>
		/// The number of seats of the license. Only applicable to SM licenses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seatCount")]
		public System.Nullable<System.Int32> SeatCount { get; set; }
		
		/// <summary>
		/// The state of the license. All queued licenses have a status of `recentlyQueued`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public GetOrganizationLicensesState State { get; set; }
		
		/// <summary>
		/// The duration of the license plus all permanently queued licenses associated with it
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalDurationInDays")]
		public System.Nullable<System.Int32> TotalDurationInDays { get; set; }
	}
	
	public class UpdateOrganizationLicenseReturnPermanentlyQueuedLicenses
	{
		
		/// <summary>
		/// The duration of the individual license
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationInDays")]
		public System.Nullable<System.Int32> DurationInDays { get; set; }
		
		/// <summary>
		/// Permanently queued license ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// License key
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseKey")]
		public string LicenseKey { get; set; }
		
		/// <summary>
		/// License type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseType")]
		public string LicenseType { get; set; }
		
		/// <summary>
		/// Order number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orderNumber")]
		public string OrderNumber { get; set; }
	}
	
	public class GetOrganizationLicensingCotermLicensesReturn
	{
		
		/// <summary>
		/// When the license was claimed into the organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="claimedAt")]
		public System.Nullable<System.DateTimeOffset> ClaimedAt { get; set; }
		
		/// <summary>
		/// The counts of the license by model type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="counts")]
		public GetOrganizationLicensingCotermLicensesReturnCounts[] GetOrganizationLicensingCotermLicensesReturnCounts { get; set; }
		
		/// <summary>
		/// The duration (term length) of the license, measured in days
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<System.Int32> Duration { get; set; }
		
		/// <summary>
		/// The editions of the license for each relevant product type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="editions")]
		public GetOrganizationLicensingCotermLicensesReturnEditions[] GetOrganizationLicensingCotermLicensesReturnEditions { get; set; }
		
		/// <summary>
		/// Flag to indicate if the license is expired
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expired")]
		public System.Nullable<System.Boolean> Expired { get; set; }
		
		/// <summary>
		/// Flag to indicated that the license is invalidated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="invalidated")]
		public System.Nullable<System.Boolean> Invalidated { get; set; }
		
		/// <summary>
		/// When the license was invalidated. Will be null for active licenses
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="invalidatedAt")]
		public System.Nullable<System.DateTimeOffset> InvalidatedAt { get; set; }
		
		/// <summary>
		/// The key of the license
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// The operation mode of the license when it was claimed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public ClaimIntoOrganizationPostBodyLicensesMode Mode { get; set; }
		
		/// <summary>
		/// The ID of the organization that the license is claimed in
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organizationId")]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// When the license's term began (approximately the date when the license was created)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startedAt")]
		public System.Nullable<System.DateTimeOffset> StartedAt { get; set; }
	}
	
	public class GetOrganizationLicensingCotermLicensesReturnCounts
	{
		
		/// <summary>
		/// The number of counts the license contains of this model
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public System.Nullable<System.Int32> Count { get; set; }
		
		/// <summary>
		/// The license model type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public string Model { get; set; }
	}
	
	public class GetOrganizationLicensingCotermLicensesReturnEditions
	{
		
		/// <summary>
		/// The name of the license edition
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="edition")]
		public string Edition { get; set; }
		
		/// <summary>
		/// The product type of the license edition
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productType")]
		public string ProductType { get; set; }
	}
	
	public class MoveOrganizationLicensingCotermLicensesPostBody
	{
		
		/// <summary>
		/// Destination data for the license move
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public MoveOrganizationLicensingCotermLicensesPostBodyDestination Destination { get; set; }
		
		/// <summary>
		/// The list of licenses to move
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="licenses")]
		public MoveOrganizationLicensingCotermLicensesPostBodyLicenses[] MoveOrganizationLicensingCotermLicensesPostBodyLicenses { get; set; }
	}
	
	public class MoveOrganizationLicensingCotermLicensesPostBodyDestination
	{
		
		/// <summary>
		/// The claim mode of the moved license
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public ClaimIntoOrganizationPostBodyLicensesMode Mode { get; set; }
		
		/// <summary>
		/// The organization to move the license to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organizationId")]
		public string OrganizationId { get; set; }
	}
	
	public class MoveOrganizationLicensingCotermLicensesPostBodyLicenses
	{
		
		/// <summary>
		/// The counts to move from the license by model type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="counts")]
		public MoveOrganizationLicensingCotermLicensesPostBodyLicensesCounts[] MoveOrganizationLicensingCotermLicensesPostBodyLicensesCounts { get; set; }
		
		/// <summary>
		/// The license key to move counts from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
	}
	
	public class MoveOrganizationLicensingCotermLicensesPostBodyLicensesCounts
	{
		
		/// <summary>
		/// The number of counts to move
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="count")]
		public int Count { get; set; }
		
		/// <summary>
		/// The license model type to move counts of
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="model")]
		public string Model { get; set; }
	}
	
	public class MoveOrganizationLicensingCotermLicensesReturn
	{
		
		/// <summary>
		/// Newly moved licenses created in the destination organization of the license move operation
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="movedLicenses")]
		public MoveOrganizationLicensingCotermLicensesReturnMovedLicenses[] MoveOrganizationLicensingCotermLicensesReturnMovedLicenses { get; set; }
		
		/// <summary>
		/// Remainder licenses created in the source organization as a result of moving a subset of the counts of a license
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remainderLicenses")]
		public MoveOrganizationLicensingCotermLicensesReturnRemainderLicenses[] MoveOrganizationLicensingCotermLicensesReturnRemainderLicenses { get; set; }
	}
	
	public class MoveOrganizationLicensingCotermLicensesReturnMovedLicenses
	{
		
		/// <summary>
		/// When the license was claimed into the organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="claimedAt")]
		public System.Nullable<System.DateTimeOffset> ClaimedAt { get; set; }
		
		/// <summary>
		/// The counts of the license by model type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="counts")]
		public MoveOrganizationLicensingCotermLicensesReturnMovedLicensesCounts[] MoveOrganizationLicensingCotermLicensesReturnMovedLicensesCounts { get; set; }
		
		/// <summary>
		/// The duration (term length) of the license, measured in days
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<System.Int32> Duration { get; set; }
		
		/// <summary>
		/// The editions of the license for each relevant product type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="editions")]
		public MoveOrganizationLicensingCotermLicensesReturnMovedLicensesEditions[] MoveOrganizationLicensingCotermLicensesReturnMovedLicensesEditions { get; set; }
		
		/// <summary>
		/// Flag to indicate if the license is expired
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expired")]
		public System.Nullable<System.Boolean> Expired { get; set; }
		
		/// <summary>
		/// Flag to indicated that the license is invalidated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="invalidated")]
		public System.Nullable<System.Boolean> Invalidated { get; set; }
		
		/// <summary>
		/// When the license was invalidated. Will be null for active licenses
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="invalidatedAt")]
		public System.Nullable<System.DateTimeOffset> InvalidatedAt { get; set; }
		
		/// <summary>
		/// The key of the license
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// The operation mode of the license when it was claimed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public ClaimIntoOrganizationPostBodyLicensesMode Mode { get; set; }
		
		/// <summary>
		/// The ID of the organization that the license is claimed in
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organizationId")]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// When the license's term began (approximately the date when the license was created)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startedAt")]
		public System.Nullable<System.DateTimeOffset> StartedAt { get; set; }
	}
	
	public class MoveOrganizationLicensingCotermLicensesReturnMovedLicensesCounts
	{
		
		/// <summary>
		/// The number of counts the license contains of this model
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public System.Nullable<System.Int32> Count { get; set; }
		
		/// <summary>
		/// The license model type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public string Model { get; set; }
	}
	
	public class MoveOrganizationLicensingCotermLicensesReturnMovedLicensesEditions
	{
		
		/// <summary>
		/// The name of the license edition
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="edition")]
		public string Edition { get; set; }
		
		/// <summary>
		/// The product type of the license edition
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productType")]
		public string ProductType { get; set; }
	}
	
	public class MoveOrganizationLicensingCotermLicensesReturnRemainderLicenses
	{
		
		/// <summary>
		/// When the license was claimed into the organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="claimedAt")]
		public System.Nullable<System.DateTimeOffset> ClaimedAt { get; set; }
		
		/// <summary>
		/// The counts of the license by model type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="counts")]
		public MoveOrganizationLicensingCotermLicensesReturnRemainderLicensesCounts[] MoveOrganizationLicensingCotermLicensesReturnRemainderLicensesCounts { get; set; }
		
		/// <summary>
		/// The duration (term length) of the license, measured in days
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<System.Int32> Duration { get; set; }
		
		/// <summary>
		/// The editions of the license for each relevant product type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="editions")]
		public MoveOrganizationLicensingCotermLicensesReturnRemainderLicensesEditions[] MoveOrganizationLicensingCotermLicensesReturnRemainderLicensesEditions { get; set; }
		
		/// <summary>
		/// Flag to indicate if the license is expired
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expired")]
		public System.Nullable<System.Boolean> Expired { get; set; }
		
		/// <summary>
		/// Flag to indicated that the license is invalidated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="invalidated")]
		public System.Nullable<System.Boolean> Invalidated { get; set; }
		
		/// <summary>
		/// When the license was invalidated. Will be null for active licenses
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="invalidatedAt")]
		public System.Nullable<System.DateTimeOffset> InvalidatedAt { get; set; }
		
		/// <summary>
		/// The key of the license
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// The operation mode of the license when it was claimed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public ClaimIntoOrganizationPostBodyLicensesMode Mode { get; set; }
		
		/// <summary>
		/// The ID of the organization that the license is claimed in
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organizationId")]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// When the license's term began (approximately the date when the license was created)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startedAt")]
		public System.Nullable<System.DateTimeOffset> StartedAt { get; set; }
	}
	
	public class MoveOrganizationLicensingCotermLicensesReturnRemainderLicensesCounts
	{
		
		/// <summary>
		/// The number of counts the license contains of this model
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public System.Nullable<System.Int32> Count { get; set; }
		
		/// <summary>
		/// The license model type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public string Model { get; set; }
	}
	
	public class MoveOrganizationLicensingCotermLicensesReturnRemainderLicensesEditions
	{
		
		/// <summary>
		/// The name of the license edition
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="edition")]
		public string Edition { get; set; }
		
		/// <summary>
		/// The product type of the license edition
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productType")]
		public string ProductType { get; set; }
	}
	
	public class GetOrganizationLoginSecurityReturn
	{
		
		/// <summary>
		/// Number of consecutive failed login attempts after which users' accounts will be locked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accountLockoutAttempts")]
		public System.Nullable<System.Int32> AccountLockoutAttempts { get; set; }
		
		/// <summary>
		/// Details for indicating whether organization will restrict access to API (but not Dashboard) to certain IP addresses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiAuthentication")]
		public GetOrganizationLoginSecurityReturnApiAuthentication ApiAuthentication { get; set; }
		
		/// <summary>
		/// Boolean indicating whether users' Dashboard accounts will be locked out after a specified number of consecutive failed login attempts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceAccountLockout")]
		public System.Nullable<System.Boolean> EnforceAccountLockout { get; set; }
		
		/// <summary>
		/// Boolean indicating whether users, when setting a new password, are forced to choose a new password that is different from any past passwords.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceDifferentPasswords")]
		public System.Nullable<System.Boolean> EnforceDifferentPasswords { get; set; }
		
		/// <summary>
		/// Boolean indicating whether users will be logged out after being idle for the specified number of minutes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceIdleTimeout")]
		public System.Nullable<System.Boolean> EnforceIdleTimeout { get; set; }
		
		/// <summary>
		/// Boolean indicating whether organization will restrict access to Dashboard (including the API) from certain IP addresses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceLoginIpRanges")]
		public System.Nullable<System.Boolean> EnforceLoginIpRanges { get; set; }
		
		/// <summary>
		/// Boolean indicating whether users are forced to change their password every X number of days.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforcePasswordExpiration")]
		public System.Nullable<System.Boolean> EnforcePasswordExpiration { get; set; }
		
		/// <summary>
		/// Boolean indicating whether users will be forced to choose strong passwords for their accounts. Strong passwords are at least 8 characters that contain 3 of the following: number, uppercase letter, lowercase letter, and symbol
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceStrongPasswords")]
		public System.Nullable<System.Boolean> EnforceStrongPasswords { get; set; }
		
		/// <summary>
		/// Boolean indicating whether users in this organization will be required to use an extra verification code when logging in to Dashboard. This code will be sent to their mobile phone via SMS, or can be generated by the authenticator application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceTwoFactorAuth")]
		public System.Nullable<System.Boolean> EnforceTwoFactorAuth { get; set; }
		
		/// <summary>
		/// Number of minutes users can remain idle before being logged out of their accounts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="idleTimeoutMinutes")]
		public System.Nullable<System.Int32> IdleTimeoutMinutes { get; set; }
		
		/// <summary>
		/// List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loginIpRanges")]
		public string[] LoginIpRanges { get; set; }
		
		/// <summary>
		/// Number of recent passwords that new password must be distinct from.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numDifferentPasswords")]
		public System.Nullable<System.Int32> NumDifferentPasswords { get; set; }
		
		/// <summary>
		/// Number of days after which users will be forced to change their password.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="passwordExpirationDays")]
		public System.Nullable<System.Int32> PasswordExpirationDays { get; set; }
	}
	
	public class GetOrganizationLoginSecurityReturnApiAuthentication
	{
		
		/// <summary>
		/// Details for API-only IP restrictions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipRestrictionsForKeys")]
		public GetOrganizationLoginSecurityReturnApiAuthenticationIpRestrictionsForKeys IpRestrictionsForKeys { get; set; }
	}
	
	public class GetOrganizationLoginSecurityReturnApiAuthenticationIpRestrictionsForKeys
	{
		
		/// <summary>
		/// Boolean indicating whether the organization will restrict API key (not Dashboard GUI) usage to a specific list of IP addresses or CIDR ranges.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ranges")]
		public string[] Ranges { get; set; }
	}
	
	public class UpdateOrganizationLoginSecurityPutBody
	{
		
		/// <summary>
		/// Number of consecutive failed login attempts after which users' accounts will be locked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accountLockoutAttempts")]
		public System.Nullable<System.Int32> AccountLockoutAttempts { get; set; }
		
		/// <summary>
		/// Details for indicating whether organization will restrict access to API (but not Dashboard) to certain IP addresses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiAuthentication")]
		public UpdateOrganizationLoginSecurityPutBodyApiAuthentication ApiAuthentication { get; set; }
		
		/// <summary>
		/// Boolean indicating whether users' Dashboard accounts will be locked out after a specified number of consecutive failed login attempts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceAccountLockout")]
		public System.Nullable<System.Boolean> EnforceAccountLockout { get; set; }
		
		/// <summary>
		/// Boolean indicating whether users, when setting a new password, are forced to choose a new password that is different from any past passwords.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceDifferentPasswords")]
		public System.Nullable<System.Boolean> EnforceDifferentPasswords { get; set; }
		
		/// <summary>
		/// Boolean indicating whether users will be logged out after being idle for the specified number of minutes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceIdleTimeout")]
		public System.Nullable<System.Boolean> EnforceIdleTimeout { get; set; }
		
		/// <summary>
		/// Boolean indicating whether organization will restrict access to Dashboard (including the API) from certain IP addresses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceLoginIpRanges")]
		public System.Nullable<System.Boolean> EnforceLoginIpRanges { get; set; }
		
		/// <summary>
		/// Boolean indicating whether users are forced to change their password every X number of days.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforcePasswordExpiration")]
		public System.Nullable<System.Boolean> EnforcePasswordExpiration { get; set; }
		
		/// <summary>
		/// Boolean indicating whether users will be forced to choose strong passwords for their accounts. Strong passwords are at least 8 characters that contain 3 of the following: number, uppercase letter, lowercase letter, and symbol
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceStrongPasswords")]
		public System.Nullable<System.Boolean> EnforceStrongPasswords { get; set; }
		
		/// <summary>
		/// Boolean indicating whether users in this organization will be required to use an extra verification code when logging in to Dashboard. This code will be sent to their mobile phone via SMS, or can be generated by the authenticator application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceTwoFactorAuth")]
		public System.Nullable<System.Boolean> EnforceTwoFactorAuth { get; set; }
		
		/// <summary>
		/// Number of minutes users can remain idle before being logged out of their accounts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="idleTimeoutMinutes")]
		public System.Nullable<System.Int32> IdleTimeoutMinutes { get; set; }
		
		/// <summary>
		/// List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loginIpRanges")]
		public string[] LoginIpRanges { get; set; }
		
		/// <summary>
		/// Number of recent passwords that new password must be distinct from.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numDifferentPasswords")]
		public System.Nullable<System.Int32> NumDifferentPasswords { get; set; }
		
		/// <summary>
		/// Number of days after which users will be forced to change their password.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="passwordExpirationDays")]
		public System.Nullable<System.Int32> PasswordExpirationDays { get; set; }
	}
	
	public class UpdateOrganizationLoginSecurityPutBodyApiAuthentication
	{
		
		/// <summary>
		/// Details for API-only IP restrictions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipRestrictionsForKeys")]
		public UpdateOrganizationLoginSecurityPutBodyApiAuthenticationIpRestrictionsForKeys IpRestrictionsForKeys { get; set; }
	}
	
	public class UpdateOrganizationLoginSecurityPutBodyApiAuthenticationIpRestrictionsForKeys
	{
		
		/// <summary>
		/// Boolean indicating whether the organization will restrict API key (not Dashboard GUI) usage to a specific list of IP addresses or CIDR ranges.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ranges")]
		public string[] Ranges { get; set; }
	}
	
	public class UpdateOrganizationLoginSecurityReturn
	{
		
		/// <summary>
		/// Number of consecutive failed login attempts after which users' accounts will be locked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accountLockoutAttempts")]
		public System.Nullable<System.Int32> AccountLockoutAttempts { get; set; }
		
		/// <summary>
		/// Details for indicating whether organization will restrict access to API (but not Dashboard) to certain IP addresses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiAuthentication")]
		public UpdateOrganizationLoginSecurityReturnApiAuthentication ApiAuthentication { get; set; }
		
		/// <summary>
		/// Boolean indicating whether users' Dashboard accounts will be locked out after a specified number of consecutive failed login attempts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceAccountLockout")]
		public System.Nullable<System.Boolean> EnforceAccountLockout { get; set; }
		
		/// <summary>
		/// Boolean indicating whether users, when setting a new password, are forced to choose a new password that is different from any past passwords.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceDifferentPasswords")]
		public System.Nullable<System.Boolean> EnforceDifferentPasswords { get; set; }
		
		/// <summary>
		/// Boolean indicating whether users will be logged out after being idle for the specified number of minutes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceIdleTimeout")]
		public System.Nullable<System.Boolean> EnforceIdleTimeout { get; set; }
		
		/// <summary>
		/// Boolean indicating whether organization will restrict access to Dashboard (including the API) from certain IP addresses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceLoginIpRanges")]
		public System.Nullable<System.Boolean> EnforceLoginIpRanges { get; set; }
		
		/// <summary>
		/// Boolean indicating whether users are forced to change their password every X number of days.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforcePasswordExpiration")]
		public System.Nullable<System.Boolean> EnforcePasswordExpiration { get; set; }
		
		/// <summary>
		/// Boolean indicating whether users will be forced to choose strong passwords for their accounts. Strong passwords are at least 8 characters that contain 3 of the following: number, uppercase letter, lowercase letter, and symbol
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceStrongPasswords")]
		public System.Nullable<System.Boolean> EnforceStrongPasswords { get; set; }
		
		/// <summary>
		/// Boolean indicating whether users in this organization will be required to use an extra verification code when logging in to Dashboard. This code will be sent to their mobile phone via SMS, or can be generated by the authenticator application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceTwoFactorAuth")]
		public System.Nullable<System.Boolean> EnforceTwoFactorAuth { get; set; }
		
		/// <summary>
		/// Number of minutes users can remain idle before being logged out of their accounts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="idleTimeoutMinutes")]
		public System.Nullable<System.Int32> IdleTimeoutMinutes { get; set; }
		
		/// <summary>
		/// List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loginIpRanges")]
		public string[] LoginIpRanges { get; set; }
		
		/// <summary>
		/// Number of recent passwords that new password must be distinct from.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numDifferentPasswords")]
		public System.Nullable<System.Int32> NumDifferentPasswords { get; set; }
		
		/// <summary>
		/// Number of days after which users will be forced to change their password.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="passwordExpirationDays")]
		public System.Nullable<System.Int32> PasswordExpirationDays { get; set; }
	}
	
	public class UpdateOrganizationLoginSecurityReturnApiAuthentication
	{
		
		/// <summary>
		/// Details for API-only IP restrictions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipRestrictionsForKeys")]
		public UpdateOrganizationLoginSecurityReturnApiAuthenticationIpRestrictionsForKeys IpRestrictionsForKeys { get; set; }
	}
	
	public class UpdateOrganizationLoginSecurityReturnApiAuthenticationIpRestrictionsForKeys
	{
		
		/// <summary>
		/// Boolean indicating whether the organization will restrict API key (not Dashboard GUI) usage to a specific list of IP addresses or CIDR ranges.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ranges")]
		public string[] Ranges { get; set; }
	}
	
	public class GetOrganizationNetworksReturn
	{
		
		/// <summary>
		/// Enrollment string for the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enrollmentString")]
		public string EnrollmentString { get; set; }
		
		/// <summary>
		/// Network ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// If the network is bound to a config template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isBoundToConfigTemplate")]
		public System.Nullable<System.Boolean> IsBoundToConfigTemplate { get; set; }
		
		/// <summary>
		/// Network name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Notes for the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// Organization ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organizationId")]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// List of the product types that the network supports
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productTypes")]
		public string[] ProductTypes { get; set; }
		
		/// <summary>
		/// Network tags
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// Timezone of the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeZone")]
		public string TimeZone { get; set; }
		
		/// <summary>
		/// URL to the network Dashboard UI
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class CreateOrganizationNetworkPostBody
	{
		
		/// <summary>
		/// The ID of the network to copy configuration from. Other provided parameters will override the copied configuration, except type which must match this network's type exactly.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="copyFromNetworkId")]
		public string CopyFromNetworkId { get; set; }
		
		/// <summary>
		/// The name of the new network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Add any notes or additional information about this network here.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// The product type(s) of the new network. If more than one type is included, the network will be a combined network.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="productTypes")]
		public string[] ProductTypes { get; set; }
		
		/// <summary>
		/// A list of tags to be applied to the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// The timezone of the network. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeZone")]
		public string TimeZone { get; set; }
	}
	
	public class CombineOrganizationNetworksPostBody
	{
		
		/// <summary>
		/// A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break. All networks that are part of this combined network will have their enrollment string appended by '-network_type'. If left empty, all exisitng enrollment strings will be deleted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enrollmentString")]
		public string EnrollmentString { get; set; }
		
		/// <summary>
		/// The name of the combined network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A list of the network IDs that will be combined. If an ID of a combined network is included in this list, the other networks in the list will be grouped into that network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="networkIds")]
		public string[] NetworkIds { get; set; }
	}
	
	public class CombineOrganizationNetworksReturn
	{
		
		/// <summary>
		/// Network after the combination
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resultingNetwork")]
		public CombineOrganizationNetworksReturnResultingNetwork ResultingNetwork { get; set; }
	}
	
	public class CombineOrganizationNetworksReturnResultingNetwork
	{
		
		/// <summary>
		/// Enrollment string for the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enrollmentString")]
		public string EnrollmentString { get; set; }
		
		/// <summary>
		/// Network ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// If the network is bound to a config template
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isBoundToConfigTemplate")]
		public System.Nullable<System.Boolean> IsBoundToConfigTemplate { get; set; }
		
		/// <summary>
		/// Network name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Notes for the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// Organization ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organizationId")]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// List of the product types that the network supports
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productTypes")]
		public string[] ProductTypes { get; set; }
		
		/// <summary>
		/// Network tags
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// Timezone of the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeZone")]
		public string TimeZone { get; set; }
		
		/// <summary>
		/// URL to the network Dashboard UI
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class CreateOrganizationPolicyObjectPostBody
	{
		
		/// <summary>
		/// Category of a policy object (one of: adaptivePolicy, network)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		/// <summary>
		/// CIDR Value of a policy object (e.g. 10.11.12.1/24")
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// Fully qualified domain name of policy object (e.g. "example.com")
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fqdn")]
		public string Fqdn { get; set; }
		
		/// <summary>
		/// The IDs of policy object groups the policy object belongs to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupIds")]
		public int[] GroupIds { get; set; }
		
		/// <summary>
		/// IP Address of a policy object (e.g. "1.2.3.4")
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// Mask of a policy object (e.g. "255.255.0.0")
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mask")]
		public string Mask { get; set; }
		
		/// <summary>
		/// Name of a policy object, unique within the organization (alphanumeric, space, dash, or underscore characters only)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Type of a policy object (one of: adaptivePolicyIpv4Cidr, cidr, fqdn, ipAndMask)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class CreateOrganizationPolicyObjectsGroupPostBody
	{
		
		/// <summary>
		/// Category of a policy object group (one of: NetworkObjectGroup, GeoLocationGroup, PortObjectGroup, ApplicationGroup)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		/// <summary>
		/// A name for the group of network addresses, unique within the organization (alphanumeric, space, dash, or underscore characters only)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A list of Policy Object ID's that this NetworkObjectGroup should be associated to (note: these ID's will replace the existing associated Policy Objects)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectIds")]
		public int[] ObjectIds { get; set; }
	}
	
	public class UpdateOrganizationPolicyObjectsGroupPutBody
	{
		
		/// <summary>
		/// A name for the group of network addresses, unique within the organization (alphanumeric, space, dash, or underscore characters only)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A list of Policy Object ID's that this NetworkObjectGroup should be associated to (note: these ID's will replace the existing associated Policy Objects)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectIds")]
		public int[] ObjectIds { get; set; }
	}
	
	public class UpdateOrganizationPolicyObjectPutBody
	{
		
		/// <summary>
		/// CIDR Value of a policy object (e.g. 10.11.12.1/24")
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidr")]
		public string Cidr { get; set; }
		
		/// <summary>
		/// Fully qualified domain name of policy object (e.g. "example.com")
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fqdn")]
		public string Fqdn { get; set; }
		
		/// <summary>
		/// The IDs of policy object groups the policy object belongs to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupIds")]
		public int[] GroupIds { get; set; }
		
		/// <summary>
		/// IP Address of a policy object (e.g. "1.2.3.4")
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// Mask of a policy object (e.g. "255.255.0.0")
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mask")]
		public string Mask { get; set; }
		
		/// <summary>
		/// Name of a policy object, unique within the organization (alphanumeric, space, dash, or underscore characters only)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetOrganizationSamlReturn
	{
		
		/// <summary>
		/// Toggle depicting if SAML SSO settings are enabled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateOrganizationSamlPutBody
	{
		
		/// <summary>
		/// Boolean for updating SAML SSO enabled settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class UpdateOrganizationSamlReturn
	{
		
		/// <summary>
		/// Toggle depicting if SAML SSO settings are enabled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	public class GetOrganizationSamlIdpsReturn
	{
		
		/// <summary>
		/// URL that is consuming SAML Identity Provider (IdP)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="consumerUrl")]
		public string ConsumerUrl { get; set; }
		
		/// <summary>
		/// ID associated with the SAML Identity Provider (IdP)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="idpId")]
		public string IdpId { get; set; }
		
		/// <summary>
		/// Dashboard will redirect users to this URL when they sign out.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sloLogoutUrl")]
		public string SloLogoutUrl { get; set; }
		
		/// <summary>
		/// Fingerprint (SHA1) of the SAML certificate provided by your Identity Provider (IdP). This will be used for encryption / validation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="x509certSha1Fingerprint")]
		public string X509certSha1Fingerprint { get; set; }
	}
	
	public class CreateOrganizationSamlIdpPostBody
	{
		
		/// <summary>
		/// Dashboard will redirect users to this URL when they sign out.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sloLogoutUrl")]
		public string SloLogoutUrl { get; set; }
		
		/// <summary>
		/// Fingerprint (SHA1) of the SAML certificate provided by your Identity Provider (IdP). This will be used for encryption / validation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="x509certSha1Fingerprint")]
		public string X509certSha1Fingerprint { get; set; }
	}
	
	public class GetOrganizationSamlIdpReturn
	{
		
		/// <summary>
		/// URL that is consuming SAML Identity Provider (IdP)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="consumerUrl")]
		public string ConsumerUrl { get; set; }
		
		/// <summary>
		/// ID associated with the SAML Identity Provider (IdP)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="idpId")]
		public string IdpId { get; set; }
		
		/// <summary>
		/// Dashboard will redirect users to this URL when they sign out.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sloLogoutUrl")]
		public string SloLogoutUrl { get; set; }
		
		/// <summary>
		/// Fingerprint (SHA1) of the SAML certificate provided by your Identity Provider (IdP). This will be used for encryption / validation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="x509certSha1Fingerprint")]
		public string X509certSha1Fingerprint { get; set; }
	}
	
	public class UpdateOrganizationSamlIdpPutBody
	{
		
		/// <summary>
		/// Dashboard will redirect users to this URL when they sign out.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sloLogoutUrl")]
		public string SloLogoutUrl { get; set; }
		
		/// <summary>
		/// Fingerprint (SHA1) of the SAML certificate provided by your Identity Provider (IdP). This will be used for encryption / validation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="x509certSha1Fingerprint")]
		public string X509certSha1Fingerprint { get; set; }
	}
	
	public class UpdateOrganizationSamlIdpReturn
	{
		
		/// <summary>
		/// URL that is consuming SAML Identity Provider (IdP)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="consumerUrl")]
		public string ConsumerUrl { get; set; }
		
		/// <summary>
		/// ID associated with the SAML Identity Provider (IdP)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="idpId")]
		public string IdpId { get; set; }
		
		/// <summary>
		/// Dashboard will redirect users to this URL when they sign out.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sloLogoutUrl")]
		public string SloLogoutUrl { get; set; }
		
		/// <summary>
		/// Fingerprint (SHA1) of the SAML certificate provided by your Identity Provider (IdP). This will be used for encryption / validation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="x509certSha1Fingerprint")]
		public string X509certSha1Fingerprint { get; set; }
	}
	
	public class CreateOrganizationSamlRolePostBody
	{
		
		/// <summary>
		/// The list of networks that the SAML administrator has privileges on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networks")]
		public CreateOrganizationSamlRolePostBodyNetworks[] CreateOrganizationSamlRolePostBodyNetworks { get; set; }
		
		/// <summary>
		/// The privilege of the SAML administrator on the organization. Can be one of 'none', 'read-only', 'full' or 'enterprise'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="orgAccess")]
		public CreateOrganizationSamlRolePostBodyOrgAccess OrgAccess { get; set; }
		
		/// <summary>
		/// The role of the SAML administrator
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="role")]
		public string Role { get; set; }
		
		/// <summary>
		/// The list of tags that the SAML administrator has privleges on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public CreateOrganizationSamlRolePostBodyTags[] CreateOrganizationSamlRolePostBodyTags { get; set; }
	}
	
	public class CreateOrganizationSamlRolePostBodyNetworks
	{
		
		/// <summary>
		/// The privilege of the SAML administrator on the network. Can be one of 'full', 'read-only', 'guest-ambassador', 'monitor-only' or 'ssid-admin'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public CreateOrganizationSamlRolePostBodyNetworksAccess Access { get; set; }
		
		/// <summary>
		/// The network ID
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationSamlRolePostBodyNetworksAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		full = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="guest-ambassador")]
		guestMinusambassador = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="monitor-only")]
		monitorMinusonly = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="read-only")]
		readMinusonly = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ssid-admin")]
		ssidMinusadmin = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationSamlRolePostBodyOrgAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enterprise = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		full = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="read-only")]
		readMinusonly = 3,
	}
	
	public class CreateOrganizationSamlRolePostBodyTags
	{
		
		/// <summary>
		/// The privilege of the SAML administrator on the tag. Can be one of 'full', 'read-only', 'guest-ambassador' or 'monitor-only'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public CreateOrganizationSamlRolePostBodyTagsAccess Access { get; set; }
		
		/// <summary>
		/// The name of the tag
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public string Tag { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateOrganizationSamlRolePostBodyTagsAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		full = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="guest-ambassador")]
		guestMinusambassador = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="monitor-only")]
		monitorMinusonly = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="read-only")]
		readMinusonly = 3,
	}
	
	public class UpdateOrganizationSamlRolePutBody
	{
		
		/// <summary>
		/// The list of networks that the SAML administrator has privileges on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networks")]
		public UpdateOrganizationSamlRolePutBodyNetworks[] UpdateOrganizationSamlRolePutBodyNetworks { get; set; }
		
		/// <summary>
		/// The privilege of the SAML administrator on the organization. Can be one of 'none', 'read-only', 'full' or 'enterprise'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orgAccess")]
		public System.Nullable<UpdateOrganizationSamlRolePutBodyOrgAccess> OrgAccess { get; set; }
		
		/// <summary>
		/// The role of the SAML administrator
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="role")]
		public string Role { get; set; }
		
		/// <summary>
		/// The list of tags that the SAML administrator has privleges on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public UpdateOrganizationSamlRolePutBodyTags[] UpdateOrganizationSamlRolePutBodyTags { get; set; }
	}
	
	public class UpdateOrganizationSamlRolePutBodyNetworks
	{
		
		/// <summary>
		/// The privilege of the SAML administrator on the network. Can be one of 'full', 'read-only', 'guest-ambassador', 'monitor-only' or 'ssid-admin'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public UpdateOrganizationSamlRolePutBodyNetworksAccess Access { get; set; }
		
		/// <summary>
		/// The network ID
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationSamlRolePutBodyNetworksAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		full = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="guest-ambassador")]
		guestMinusambassador = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="monitor-only")]
		monitorMinusonly = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="read-only")]
		readMinusonly = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ssid-admin")]
		ssidMinusadmin = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationSamlRolePutBodyOrgAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enterprise = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		full = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="read-only")]
		readMinusonly = 3,
	}
	
	public class UpdateOrganizationSamlRolePutBodyTags
	{
		
		/// <summary>
		/// The privilege of the SAML administrator on the tag. Can be one of 'full', 'read-only', 'guest-ambassador' or 'monitor-only'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public UpdateOrganizationSamlRolePutBodyTagsAccess Access { get; set; }
		
		/// <summary>
		/// The name of the tag
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public string Tag { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationSamlRolePutBodyTagsAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		full = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="guest-ambassador")]
		guestMinusambassador = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="monitor-only")]
		monitorMinusonly = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="read-only")]
		readMinusonly = 3,
	}
	
	public class UpdateOrganizationSamlRoleReturn
	{
		
		/// <summary>
		/// ID associated with the SAML role
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The list of networks that the SAML administrator has privileges on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networks")]
		public UpdateOrganizationSamlRoleReturnNetworks[] UpdateOrganizationSamlRoleReturnNetworks { get; set; }
		
		/// <summary>
		/// The privilege of the SAML administrator on the organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orgAccess")]
		public string OrgAccess { get; set; }
		
		/// <summary>
		/// The role of the SAML administrator
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="role")]
		public string Role { get; set; }
		
		/// <summary>
		/// The list of tags that the SAML administrator has privleges on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public UpdateOrganizationSamlRoleReturnTags[] UpdateOrganizationSamlRoleReturnTags { get; set; }
	}
	
	public class UpdateOrganizationSamlRoleReturnNetworks
	{
		
		/// <summary>
		/// The privilege of the SAML administrator on the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="access")]
		public string Access { get; set; }
		
		/// <summary>
		/// The network ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class UpdateOrganizationSamlRoleReturnTags
	{
		
		/// <summary>
		/// The privilege of the SAML administrator on the tag
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="access")]
		public string Access { get; set; }
		
		/// <summary>
		/// The name of the tag
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public string Tag { get; set; }
	}
	
	public class GetOrganizationSensorReadingsHistoryReturn
	{
		
		/// <summary>
		/// Reading for the 'battery' metric. This will only be present if the 'metric' property equals 'battery'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="battery")]
		public GetOrganizationSensorReadingsHistoryReturnBattery Battery { get; set; }
		
		/// <summary>
		/// Reading for the 'button' metric. This will only be present if the 'metric' property equals 'button'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="button")]
		public GetOrganizationSensorReadingsHistoryReturnButton Button { get; set; }
		
		/// <summary>
		/// Reading for the 'door' metric. This will only be present if the 'metric' property equals 'door'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="door")]
		public GetOrganizationSensorReadingsHistoryReturnDoor Door { get; set; }
		
		/// <summary>
		/// Reading for the 'humidity' metric. This will only be present if the 'metric' property equals 'humidity'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="humidity")]
		public GetOrganizationSensorReadingsHistoryReturnHumidity Humidity { get; set; }
		
		/// <summary>
		/// Reading for the 'indoorAirQuality' metric. This will only be present if the 'metric' property equals 'indoorAirQuality'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="indoorAirQuality")]
		public GetOrganizationSensorReadingsHistoryReturnIndoorAirQuality IndoorAirQuality { get; set; }
		
		/// <summary>
		/// Type of sensor reading.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metric")]
		public System.Nullable<GetOrganizationSensorReadingsHistoryReturnMetric> Metric { get; set; }
		
		/// <summary>
		/// Network to which the sensor belongs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public GetOrganizationSensorReadingsHistoryReturnNetwork Network { get; set; }
		
		/// <summary>
		/// Reading for the 'noise' metric. This will only be present if the 'metric' property equals 'noise'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noise")]
		public GetOrganizationSensorReadingsHistoryReturnNoise Noise { get; set; }
		
		/// <summary>
		/// Reading for the 'pm25' metric. This will only be present if the 'metric' property equals 'pm25'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pm25")]
		public GetOrganizationSensorReadingsHistoryReturnPm25 Pm25 { get; set; }
		
		/// <summary>
		/// Serial number of the sensor that took the reading.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// Reading for the 'temperature' metric. This will only be present if the 'metric' property equals 'temperature'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="temperature")]
		public GetOrganizationSensorReadingsHistoryReturnTemperature Temperature { get; set; }
		
		/// <summary>
		/// Time at which the reading occurred, in ISO8601 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ts")]
		public string Ts { get; set; }
		
		/// <summary>
		/// Reading for the 'tvoc' metric. This will only be present if the 'metric' property equals 'tvoc'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tvoc")]
		public GetOrganizationSensorReadingsHistoryReturnTvoc Tvoc { get; set; }
		
		/// <summary>
		/// Reading for the 'water' metric. This will only be present if the 'metric' property equals 'water'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="water")]
		public GetOrganizationSensorReadingsHistoryReturnWater Water { get; set; }
	}
	
	public class GetOrganizationSensorReadingsHistoryReturnBattery
	{
		
		/// <summary>
		/// Remaining battery life.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage")]
		public System.Nullable<System.Int32> Percentage { get; set; }
	}
	
	public class GetOrganizationSensorReadingsHistoryReturnButton
	{
		
		/// <summary>
		/// Type of button press that occurred.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pressType")]
		public System.Nullable<GetOrganizationSensorReadingsHistoryReturnButtonPressType> PressType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationSensorReadingsHistoryReturnButtonPressType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="long")]
		_long = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="short")]
		_short = 1,
	}
	
	public class GetOrganizationSensorReadingsHistoryReturnDoor
	{
		
		/// <summary>
		/// True if the door is open.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="open")]
		public System.Nullable<System.Boolean> Open { get; set; }
	}
	
	public class GetOrganizationSensorReadingsHistoryReturnHumidity
	{
		
		/// <summary>
		/// Humidity reading in %RH.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relativePercentage")]
		public System.Nullable<System.Int32> RelativePercentage { get; set; }
	}
	
	public class GetOrganizationSensorReadingsHistoryReturnIndoorAirQuality
	{
		
		/// <summary>
		/// Indoor air quality score between 0 and 100.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="score")]
		public System.Nullable<System.Int32> Score { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationSensorReadingsHistoryReturnMetric
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		battery = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		button = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		door = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		humidity = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		indoorAirQuality = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		noise = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pm25 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		temperature = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tvoc = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		water = 9,
	}
	
	public class GetOrganizationSensorReadingsHistoryReturnNetwork
	{
		
		/// <summary>
		/// ID of the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetOrganizationSensorReadingsHistoryReturnNoise
	{
		
		/// <summary>
		/// Ambient noise reading.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ambient")]
		public GetOrganizationSensorReadingsHistoryReturnNoiseAmbient Ambient { get; set; }
	}
	
	public class GetOrganizationSensorReadingsHistoryReturnNoiseAmbient
	{
		
		/// <summary>
		/// Ambient noise reading in adjusted decibels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="level")]
		public System.Nullable<System.Int32> Level { get; set; }
	}
	
	public class GetOrganizationSensorReadingsHistoryReturnPm25
	{
		
		/// <summary>
		/// PM2.5 reading in micrograms per cubic meter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentration")]
		public System.Nullable<System.Int32> Concentration { get; set; }
	}
	
	public class GetOrganizationSensorReadingsHistoryReturnTemperature
	{
		
		/// <summary>
		/// Temperature reading in degrees Celsius.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="celsius")]
		public System.Nullable<System.Single> Celsius { get; set; }
		
		/// <summary>
		/// Temperature reading in degrees Fahrenheit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fahrenheit")]
		public System.Nullable<System.Single> Fahrenheit { get; set; }
	}
	
	public class GetOrganizationSensorReadingsHistoryReturnTvoc
	{
		
		/// <summary>
		/// TVOC reading in micrograms per cubic meter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentration")]
		public System.Nullable<System.Int32> Concentration { get; set; }
	}
	
	public class GetOrganizationSensorReadingsHistoryReturnWater
	{
		
		/// <summary>
		/// True if water is detected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="present")]
		public System.Nullable<System.Boolean> Present { get; set; }
	}
	
	public class GetOrganizationSensorReadingsLatestReturn
	{
		
		/// <summary>
		/// Network to which the sensor belongs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public GetOrganizationSensorReadingsLatestReturnNetwork Network { get; set; }
		
		/// <summary>
		/// Array of latest readings from the sensor. Each object represents a single reading for a single metric.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="readings")]
		public GetOrganizationSensorReadingsLatestReturnReadings[] GetOrganizationSensorReadingsLatestReturnReadings { get; set; }
		
		/// <summary>
		/// Serial number of the sensor that took the readings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class GetOrganizationSensorReadingsLatestReturnNetwork
	{
		
		/// <summary>
		/// ID of the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetOrganizationSensorReadingsLatestReturnReadings
	{
		
		/// <summary>
		/// Reading for the 'battery' metric. This will only be present if the 'metric' property equals 'battery'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="battery")]
		public GetOrganizationSensorReadingsLatestReturnReadingsBattery Battery { get; set; }
		
		/// <summary>
		/// Reading for the 'button' metric. This will only be present if the 'metric' property equals 'button'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="button")]
		public GetOrganizationSensorReadingsLatestReturnReadingsButton Button { get; set; }
		
		/// <summary>
		/// Reading for the 'door' metric. This will only be present if the 'metric' property equals 'door'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="door")]
		public GetOrganizationSensorReadingsLatestReturnReadingsDoor Door { get; set; }
		
		/// <summary>
		/// Reading for the 'humidity' metric. This will only be present if the 'metric' property equals 'humidity'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="humidity")]
		public GetOrganizationSensorReadingsLatestReturnReadingsHumidity Humidity { get; set; }
		
		/// <summary>
		/// Reading for the 'indoorAirQuality' metric. This will only be present if the 'metric' property equals 'indoorAirQuality'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="indoorAirQuality")]
		public GetOrganizationSensorReadingsLatestReturnReadingsIndoorAirQuality IndoorAirQuality { get; set; }
		
		/// <summary>
		/// Type of sensor reading.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metric")]
		public GetOrganizationSensorReadingsHistoryReturnMetric Metric { get; set; }
		
		/// <summary>
		/// Reading for the 'noise' metric. This will only be present if the 'metric' property equals 'noise'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noise")]
		public GetOrganizationSensorReadingsLatestReturnReadingsNoise Noise { get; set; }
		
		/// <summary>
		/// Reading for the 'pm25' metric. This will only be present if the 'metric' property equals 'pm25'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pm25")]
		public GetOrganizationSensorReadingsLatestReturnReadingsPm25 Pm25 { get; set; }
		
		/// <summary>
		/// Reading for the 'temperature' metric. This will only be present if the 'metric' property equals 'temperature'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="temperature")]
		public GetOrganizationSensorReadingsLatestReturnReadingsTemperature Temperature { get; set; }
		
		/// <summary>
		/// Time at which the reading occurred, in ISO8601 format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ts")]
		public string Ts { get; set; }
		
		/// <summary>
		/// Reading for the 'tvoc' metric. This will only be present if the 'metric' property equals 'tvoc'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tvoc")]
		public GetOrganizationSensorReadingsLatestReturnReadingsTvoc Tvoc { get; set; }
		
		/// <summary>
		/// Reading for the 'water' metric. This will only be present if the 'metric' property equals 'water'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="water")]
		public GetOrganizationSensorReadingsLatestReturnReadingsWater Water { get; set; }
	}
	
	public class GetOrganizationSensorReadingsLatestReturnReadingsBattery
	{
		
		/// <summary>
		/// Remaining battery life.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage")]
		public System.Nullable<System.Int32> Percentage { get; set; }
	}
	
	public class GetOrganizationSensorReadingsLatestReturnReadingsButton
	{
		
		/// <summary>
		/// Type of button press that occurred.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pressType")]
		public System.Nullable<GetOrganizationSensorReadingsLatestReturnReadingsButtonPressType> PressType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationSensorReadingsLatestReturnReadingsButtonPressType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="long")]
		_long = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="short")]
		_short = 1,
	}
	
	public class GetOrganizationSensorReadingsLatestReturnReadingsDoor
	{
		
		/// <summary>
		/// True if the door is open.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="open")]
		public System.Nullable<System.Boolean> Open { get; set; }
	}
	
	public class GetOrganizationSensorReadingsLatestReturnReadingsHumidity
	{
		
		/// <summary>
		/// Humidity reading in %RH.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relativePercentage")]
		public System.Nullable<System.Int32> RelativePercentage { get; set; }
	}
	
	public class GetOrganizationSensorReadingsLatestReturnReadingsIndoorAirQuality
	{
		
		/// <summary>
		/// Indoor air quality score between 0 and 100.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="score")]
		public System.Nullable<System.Int32> Score { get; set; }
	}
	
	public class GetOrganizationSensorReadingsLatestReturnReadingsNoise
	{
		
		/// <summary>
		/// Ambient noise reading.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ambient")]
		public GetOrganizationSensorReadingsLatestReturnReadingsNoiseAmbient Ambient { get; set; }
	}
	
	public class GetOrganizationSensorReadingsLatestReturnReadingsNoiseAmbient
	{
		
		/// <summary>
		/// Ambient noise reading in adjusted decibels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="level")]
		public System.Nullable<System.Int32> Level { get; set; }
	}
	
	public class GetOrganizationSensorReadingsLatestReturnReadingsPm25
	{
		
		/// <summary>
		/// PM2.5 reading in micrograms per cubic meter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentration")]
		public System.Nullable<System.Int32> Concentration { get; set; }
	}
	
	public class GetOrganizationSensorReadingsLatestReturnReadingsTemperature
	{
		
		/// <summary>
		/// Temperature reading in degrees Celsius.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="celsius")]
		public System.Nullable<System.Single> Celsius { get; set; }
		
		/// <summary>
		/// Temperature reading in degrees Fahrenheit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fahrenheit")]
		public System.Nullable<System.Single> Fahrenheit { get; set; }
	}
	
	public class GetOrganizationSensorReadingsLatestReturnReadingsTvoc
	{
		
		/// <summary>
		/// TVOC reading in micrograms per cubic meter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="concentration")]
		public System.Nullable<System.Int32> Concentration { get; set; }
	}
	
	public class GetOrganizationSensorReadingsLatestReturnReadingsWater
	{
		
		/// <summary>
		/// True if water is detected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="present")]
		public System.Nullable<System.Boolean> Present { get; set; }
	}
	
	public class GetOrganizationSmApnsCertReturn
	{
		
		/// <summary>
		/// Organization APNS Certificate used by devices to communication with Apple
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificate")]
		public string Certificate { get; set; }
	}
	
	public class GetOrganizationSmVppAccountsReturn
	{
		
		/// <summary>
		/// The id of the VPP Account
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The VPP Account's Service Token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vppServiceToken")]
		public string VppServiceToken { get; set; }
	}
	
	public class GetOrganizationSmVppAccountReturn
	{
		
		/// <summary>
		/// The id of the VPP Account
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The VPP Account's Service Token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vppServiceToken")]
		public string VppServiceToken { get; set; }
	}
	
	public class UpdateOrganizationSnmpPutBody
	{
		
		/// <summary>
		/// The list of IPv4 addresses that are allowed to access the SNMP server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerIps")]
		public string[] PeerIps { get; set; }
		
		/// <summary>
		/// Boolean indicating whether SNMP version 2c is enabled for the organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="v2cEnabled")]
		public System.Nullable<System.Boolean> V2cEnabled { get; set; }
		
		/// <summary>
		/// The SNMP version 3 authentication mode. Can be either 'MD5' or 'SHA'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="v3AuthMode")]
		public System.Nullable<UpdateOrganizationSnmpPutBodyV3AuthMode> V3AuthMode { get; set; }
		
		/// <summary>
		/// The SNMP version 3 authentication password. Must be at least 8 characters if specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="v3AuthPass")]
		public string V3AuthPass { get; set; }
		
		/// <summary>
		/// Boolean indicating whether SNMP version 3 is enabled for the organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="v3Enabled")]
		public System.Nullable<System.Boolean> V3Enabled { get; set; }
		
		/// <summary>
		/// The SNMP version 3 privacy mode. Can be either 'DES' or 'AES128'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="v3PrivMode")]
		public System.Nullable<UpdateOrganizationSnmpPutBodyV3PrivMode> V3PrivMode { get; set; }
		
		/// <summary>
		/// The SNMP version 3 privacy password. Must be at least 8 characters if specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="v3PrivPass")]
		public string V3PrivPass { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationSnmpPutBodyV3AuthMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MD5 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHA = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateOrganizationSnmpPutBodyV3PrivMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AES128 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DES = 1,
	}
	
	public class GetOrganizationSummaryTopAppliancesByUtilizationReturn
	{
		
		/// <summary>
		/// Mac address of the appliance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// Model of the appliance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public string Model { get; set; }
		
		/// <summary>
		/// Name of the appliance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Network info
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public GetOrganizationSummaryTopAppliancesByUtilizationReturnNetwork Network { get; set; }
		
		/// <summary>
		/// Serial number of the appliance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// Utilization of the appliance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="utilization")]
		public GetOrganizationSummaryTopAppliancesByUtilizationReturnUtilization Utilization { get; set; }
	}
	
	public class GetOrganizationSummaryTopAppliancesByUtilizationReturnNetwork
	{
		
		/// <summary>
		/// Network id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Network name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetOrganizationSummaryTopAppliancesByUtilizationReturnUtilization
	{
		
		/// <summary>
		/// Average utilization of the appliance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="average")]
		public GetOrganizationSummaryTopAppliancesByUtilizationReturnUtilizationAverage Average { get; set; }
	}
	
	public class GetOrganizationSummaryTopAppliancesByUtilizationReturnUtilizationAverage
	{
		
		/// <summary>
		/// Average percentage utilization of the appliance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage")]
		public System.Nullable<System.Single> Percentage { get; set; }
	}
	
	public class GetOrganizationSummaryTopClientsByUsageReturn
	{
		
		/// <summary>
		/// ID of client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// MAC address of client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// Name of client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="network")]
		public GetOrganizationSummaryTopClientsByUsageReturnNetwork Network { get; set; }
		
		/// <summary>
		/// Data usage information
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usage")]
		public GetOrganizationSummaryTopClientsByUsageReturnUsage Usage { get; set; }
	}
	
	public class GetOrganizationSummaryTopClientsByUsageReturnNetwork
	{
		
		/// <summary>
		/// ID of network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetOrganizationSummaryTopClientsByUsageReturnUsage
	{
		
		/// <summary>
		/// Downstream data usage by client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="downstream")]
		public System.Nullable<System.Single> Downstream { get; set; }
		
		/// <summary>
		/// Percentage of total data usage by client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage")]
		public System.Nullable<System.Single> Percentage { get; set; }
		
		/// <summary>
		/// Total data usage by client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Single> Total { get; set; }
		
		/// <summary>
		/// Upstream data usage by client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upstream")]
		public System.Nullable<System.Single> Upstream { get; set; }
	}
	
	public class GetOrganizationSummaryTopClientsManufacturersByUsageReturn
	{
		
		/// <summary>
		/// Clients info
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clients")]
		public GetOrganizationSummaryTopClientsManufacturersByUsageReturnClients Clients { get; set; }
		
		/// <summary>
		/// Name of the manufacturer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Clients usage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usage")]
		public GetOrganizationSummaryTopClientsManufacturersByUsageReturnUsage Usage { get; set; }
	}
	
	public class GetOrganizationSummaryTopClientsManufacturersByUsageReturnClients
	{
		
		/// <summary>
		/// Counts of clients
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="counts")]
		public GetOrganizationSummaryTopClientsManufacturersByUsageReturnClientsCounts Counts { get; set; }
	}
	
	public class GetOrganizationSummaryTopClientsManufacturersByUsageReturnClientsCounts
	{
		
		/// <summary>
		/// Total counts of clients
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	public class GetOrganizationSummaryTopClientsManufacturersByUsageReturnUsage
	{
		
		/// <summary>
		/// Downstream data usage by client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="downstream")]
		public System.Nullable<System.Single> Downstream { get; set; }
		
		/// <summary>
		/// Total data usage by client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Single> Total { get; set; }
		
		/// <summary>
		/// Upstream data usage by client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upstream")]
		public System.Nullable<System.Single> Upstream { get; set; }
	}
	
	public class GetOrganizationSummaryTopDevicesByUsageReturn
	{
		
		/// <summary>
		/// Clients
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clients")]
		public GetOrganizationSummaryTopDevicesByUsageReturnClients Clients { get; set; }
		
		/// <summary>
		/// Mac address of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// Model of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public string Model { get; set; }
		
		/// <summary>
		/// Name of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Network info
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public GetOrganizationSummaryTopDevicesByUsageReturnNetwork Network { get; set; }
		
		/// <summary>
		/// Product type of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="productType")]
		public string ProductType { get; set; }
		
		/// <summary>
		/// Serial number of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// Data usage of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usage")]
		public GetOrganizationSummaryTopDevicesByUsageReturnUsage Usage { get; set; }
	}
	
	public class GetOrganizationSummaryTopDevicesByUsageReturnClients
	{
		
		/// <summary>
		/// Counts of clients
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="counts")]
		public GetOrganizationSummaryTopDevicesByUsageReturnClientsCounts Counts { get; set; }
	}
	
	public class GetOrganizationSummaryTopDevicesByUsageReturnClientsCounts
	{
		
		/// <summary>
		/// Total counts of clients
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	public class GetOrganizationSummaryTopDevicesByUsageReturnNetwork
	{
		
		/// <summary>
		/// Network id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Network name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetOrganizationSummaryTopDevicesByUsageReturnUsage
	{
		
		/// <summary>
		/// Data usage of the device by percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage")]
		public System.Nullable<System.Single> Percentage { get; set; }
		
		/// <summary>
		/// Total data usage of the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Single> Total { get; set; }
	}
	
	public class GetOrganizationSummaryTopDevicesModelsByUsageReturn
	{
		
		/// <summary>
		/// Total number of devices per model
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public System.Nullable<System.Int32> Count { get; set; }
		
		/// <summary>
		/// The device model
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public string Model { get; set; }
		
		/// <summary>
		/// Usage info in megabytes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usage")]
		public GetOrganizationSummaryTopDevicesModelsByUsageReturnUsage Usage { get; set; }
	}
	
	public class GetOrganizationSummaryTopDevicesModelsByUsageReturnUsage
	{
		
		/// <summary>
		/// Average usage in megabytes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="average")]
		public System.Nullable<System.Single> Average { get; set; }
		
		/// <summary>
		/// Total usage in megabytes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Single> Total { get; set; }
	}
	
	public class GetOrganizationSummaryTopSsidsByUsageReturn
	{
		
		/// <summary>
		/// Clients info of the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clients")]
		public GetOrganizationSummaryTopSsidsByUsageReturnClients Clients { get; set; }
		
		/// <summary>
		/// Name of the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Date usage of the SSID, in megabytes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usage")]
		public GetOrganizationSummaryTopSsidsByUsageReturnUsage Usage { get; set; }
	}
	
	public class GetOrganizationSummaryTopSsidsByUsageReturnClients
	{
		
		/// <summary>
		/// Counts of the clients
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="counts")]
		public GetOrganizationSummaryTopSsidsByUsageReturnClientsCounts Counts { get; set; }
	}
	
	public class GetOrganizationSummaryTopSsidsByUsageReturnClientsCounts
	{
		
		/// <summary>
		/// Total counts of the clients
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	public class GetOrganizationSummaryTopSsidsByUsageReturnUsage
	{
		
		/// <summary>
		/// Downstream usage of the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="downstream")]
		public System.Nullable<System.Single> Downstream { get; set; }
		
		/// <summary>
		/// Percentage usage of the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage")]
		public System.Nullable<System.Single> Percentage { get; set; }
		
		/// <summary>
		/// Total usage of the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Single> Total { get; set; }
		
		/// <summary>
		/// Upstream usage of the SSID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upstream")]
		public System.Nullable<System.Single> Upstream { get; set; }
	}
	
	public class GetOrganizationSummaryTopSwitchesByEnergyUsageReturn
	{
		
		/// <summary>
		/// Mac address of the switch
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// Model of the switch
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public string Model { get; set; }
		
		/// <summary>
		/// Name of the switch
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Network info
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public GetOrganizationSummaryTopSwitchesByEnergyUsageReturnNetwork Network { get; set; }
		
		/// <summary>
		/// Energy usage of the switch
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usage")]
		public GetOrganizationSummaryTopSwitchesByEnergyUsageReturnUsage Usage { get; set; }
	}
	
	public class GetOrganizationSummaryTopSwitchesByEnergyUsageReturnNetwork
	{
		
		/// <summary>
		/// Network id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Network name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetOrganizationSummaryTopSwitchesByEnergyUsageReturnUsage
	{
		
		/// <summary>
		/// Total energy usage of the switch
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Single> Total { get; set; }
	}
	
	public class CloneOrganizationSwitchDevicesPostBody
	{
		
		/// <summary>
		/// Serial number of the source switch (must be on a network not bound to a template)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceSerial")]
		public string SourceSerial { get; set; }
		
		/// <summary>
		/// Array of serial numbers of one or more target switches (must be on a network not bound to a template)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetSerials")]
		public string[] TargetSerials { get; set; }
	}
	
	public class GetOrganizationSwitchPortsBySwitchReturn
	{
		
		/// <summary>
		/// MAC address of the switch
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mac")]
		public string Mac { get; set; }
		
		/// <summary>
		/// Model of the switch
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public string Model { get; set; }
		
		/// <summary>
		/// Name of the switch
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The network that the switch belongs to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public GetOrganizationSwitchPortsBySwitchReturnNetwork Network { get; set; }
		
		/// <summary>
		/// Ports belonging to the switch
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ports")]
		public GetOrganizationSwitchPortsBySwitchReturnPorts[] GetOrganizationSwitchPortsBySwitchReturnPorts { get; set; }
		
		/// <summary>
		/// Serial of the switch
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class GetOrganizationSwitchPortsBySwitchReturnNetwork
	{
		
		/// <summary>
		/// ID of the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class GetOrganizationSwitchPortsBySwitchReturnPorts
	{
		
		/// <summary>
		/// The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessPolicyType")]
		public System.Nullable<GetOrganizationSwitchPortsBySwitchReturnPortsAccessPolicyType> AccessPolicyType { get; set; }
		
		/// <summary>
		/// The VLANs allowed on the switch port. Only applicable to trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedVlans")]
		public string AllowedVlans { get; set; }
		
		/// <summary>
		/// The status of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The link speed for the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkNegotiation")]
		public string LinkNegotiation { get; set; }
		
		/// <summary>
		/// The name of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The PoE status of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="poeEnabled")]
		public System.Nullable<System.Boolean> PoeEnabled { get; set; }
		
		/// <summary>
		/// The identifier of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portId")]
		public string PortId { get; set; }
		
		/// <summary>
		/// The rapid spanning tree protocol status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rstpEnabled")]
		public System.Nullable<System.Boolean> RstpEnabled { get; set; }
		
		/// <summary>
		/// The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stickyMacAllowList")]
		public string[] StickyMacAllowList { get; set; }
		
		/// <summary>
		/// The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stickyMacAllowListLimit")]
		public System.Nullable<System.Int32> StickyMacAllowListLimit { get; set; }
		
		/// <summary>
		/// The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stpGuard")]
		public System.Nullable<GetOrganizationSwitchPortsBySwitchReturnPortsStpGuard> StpGuard { get; set; }
		
		/// <summary>
		/// The list of tags of the switch port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// The type of the switch port ('trunk' or 'access').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GetDeviceSwitchPortsReturnType Type { get; set; }
		
		/// <summary>
		/// The VLAN of the switch port. A null value will clear the value set for trunk ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public System.Nullable<System.Int32> Vlan { get; set; }
		
		/// <summary>
		/// The voice VLAN of the switch port. Only applicable to access ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceVlan")]
		public System.Nullable<System.Int32> VoiceVlan { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationSwitchPortsBySwitchReturnPortsAccessPolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Custom access policy")]
		Custom_access_policy = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAC allow list")]
		MAC_allow_list = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Open = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Sticky MAC allow list")]
		Sticky_MAC_allow_list = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationSwitchPortsBySwitchReturnPortsStpGuard
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bpdu guard")]
		bpdu_guard = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="loop guard")]
		loop_guard = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="root guard")]
		root_guard = 3,
	}
	
	public class GetOrganizationUplinksStatusesReturn
	{
		
		/// <summary>
		/// Last reported time for the device
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastReportedAt")]
		public System.Nullable<System.DateTimeOffset> LastReportedAt { get; set; }
		
		/// <summary>
		/// The uplink model
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="model")]
		public string Model { get; set; }
		
		/// <summary>
		/// Network identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// The uplink serial
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
		
		/// <summary>
		/// Uplinks
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uplinks")]
		public GetOrganizationUplinksStatusesReturnUplinks[] GetOrganizationUplinksStatusesReturnUplinks { get; set; }
	}
	
	public class GetOrganizationUplinksStatusesReturnUplinks
	{
		
		/// <summary>
		/// Access Point Name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apn")]
		public string Apn { get; set; }
		
		/// <summary>
		/// Connection Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionType")]
		public string ConnectionType { get; set; }
		
		/// <summary>
		/// Primary DNS IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dns1")]
		public string Dns1 { get; set; }
		
		/// <summary>
		/// Secondary DNS IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dns2")]
		public string Dns2 { get; set; }
		
		/// <summary>
		/// Gateway IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// Integrated Circuit Card Identification Number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iccid")]
		public string Iccid { get; set; }
		
		/// <summary>
		/// Uplink interface
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interface")]
		public GetDeviceLossAndLatencyHistoryUplink Interface { get; set; }
		
		/// <summary>
		/// Uplink IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// The way in which the IP is assigned
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipAssignedBy")]
		public string IpAssignedBy { get; set; }
		
		/// <summary>
		/// Primary DNS IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primaryDns")]
		public string PrimaryDns { get; set; }
		
		/// <summary>
		/// Network Provider
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provider")]
		public string Provider { get; set; }
		
		/// <summary>
		/// Public IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicIp")]
		public string PublicIp { get; set; }
		
		/// <summary>
		/// Secondary DNS IP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondaryDns")]
		public string SecondaryDns { get; set; }
		
		/// <summary>
		/// Tower Signal Status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signalStat")]
		public GetOrganizationUplinksStatusesReturnUplinksSignalStat SignalStat { get; set; }
		
		/// <summary>
		/// Signal Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signalType")]
		public string SignalType { get; set; }
		
		/// <summary>
		/// Uplink status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<GetOrganizationUplinksStatusesReturnUplinksStatus> Status { get; set; }
	}
	
	public class GetOrganizationUplinksStatusesReturnUplinksSignalStat
	{
		
		/// <summary>
		/// Reference Signal Received Power
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rsrp")]
		public string Rsrp { get; set; }
		
		/// <summary>
		/// Reference Signal Received Quality
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rsrq")]
		public string Rsrq { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GetOrganizationUplinksStatusesReturnUplinksStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		connecting = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="not connected")]
		not_connected = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ready = 4,
	}
	
	public enum GetOrganizationWebhooksAlertTypesProductType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		appliance = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		camera = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cellularGateway = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		health = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		platform = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sensor = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sm = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="switch")]
		_switch = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wireless = 8,
	}
	
	public class GetOrganizationWebhooksLogsReturn
	{
		
		/// <summary>
		/// Type of alert that the webhook is delivering
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alertType")]
		public string AlertType { get; set; }
		
		/// <summary>
		/// When the webhook log was created, in ISO8601 format
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loggedAt")]
		public System.Nullable<System.DateTimeOffset> LoggedAt { get; set; }
		
		/// <summary>
		/// Network ID for the webhook log
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkId")]
		public string NetworkId { get; set; }
		
		/// <summary>
		/// ID for the webhook log's organization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organizationId")]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// Response code from the webhook
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseCode")]
		public System.Nullable<System.Int32> ResponseCode { get; set; }
		
		/// <summary>
		/// Duration of the response, in milliseconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseDuration")]
		public System.Nullable<System.Int32> ResponseDuration { get; set; }
		
		/// <summary>
		/// When the webhook was sent, in ISO8601 format
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sentAt")]
		public System.Nullable<System.DateTimeOffset> SentAt { get; set; }
		
		/// <summary>
		/// URL where the webhook was sent
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetOrganizationWirelessDevicesEthernetStatusesReturn
	{
		
		/// <summary>
		/// Aggregation details object
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aggregation")]
		public GetOrganizationWirelessDevicesEthernetStatusesReturnAggregation Aggregation { get; set; }
		
		/// <summary>
		/// The name of the AP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Network details object
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public GetOrganizationWirelessDevicesEthernetStatusesReturnNetwork Network { get; set; }
		
		/// <summary>
		/// List of port details
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ports")]
		public GetOrganizationWirelessDevicesEthernetStatusesReturnPorts[] GetOrganizationWirelessDevicesEthernetStatusesReturnPorts { get; set; }
		
		/// <summary>
		/// Power details object
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="power")]
		public GetOrganizationWirelessDevicesEthernetStatusesReturnPower Power { get; set; }
		
		/// <summary>
		/// The serial number of the AP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serial")]
		public string Serial { get; set; }
	}
	
	public class GetOrganizationWirelessDevicesEthernetStatusesReturnAggregation
	{
		
		/// <summary>
		/// Link Aggregation enabled flag
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// Link Aggregation speed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="speed")]
		public System.Nullable<System.Int32> Speed { get; set; }
	}
	
	public class GetOrganizationWirelessDevicesEthernetStatusesReturnNetwork
	{
		
		/// <summary>
		/// The network ID the AP is associated to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	public class GetOrganizationWirelessDevicesEthernetStatusesReturnPorts
	{
		
		/// <summary>
		/// Link negotiation details object for the port
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkNegotiation")]
		public GetOrganizationWirelessDevicesEthernetStatusesReturnPortsLinkNegotiation LinkNegotiation { get; set; }
		
		/// <summary>
		/// Label of the port
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// PoE details object for the port
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="poe")]
		public GetOrganizationWirelessDevicesEthernetStatusesReturnPortsPoe Poe { get; set; }
	}
	
	public class GetOrganizationWirelessDevicesEthernetStatusesReturnPortsLinkNegotiation
	{
		
		/// <summary>
		/// The duplex mode of the port. Can be 'full' or 'half'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duplex")]
		public string Duplex { get; set; }
		
		/// <summary>
		/// The speed of the port
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="speed")]
		public System.Nullable<System.Int32> Speed { get; set; }
	}
	
	public class GetOrganizationWirelessDevicesEthernetStatusesReturnPortsPoe
	{
		
		/// <summary>
		/// The PoE Standard for the port. Can be '802.3at', '802.3af', '802.3bt', or null
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="standard")]
		public string Standard { get; set; }
	}
	
	public class GetOrganizationWirelessDevicesEthernetStatusesReturnPower
	{
		
		/// <summary>
		/// AC power details object
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ac")]
		public GetOrganizationWirelessDevicesEthernetStatusesReturnPowerAc Ac { get; set; }
		
		/// <summary>
		/// The PoE power mode for the AP. Can be 'full' or 'low'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public string Mode { get; set; }
		
		/// <summary>
		/// PoE power details object
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="poe")]
		public GetOrganizationWirelessDevicesEthernetStatusesReturnPowerPoe Poe { get; set; }
	}
	
	public class GetOrganizationWirelessDevicesEthernetStatusesReturnPowerAc
	{
		
		/// <summary>
		/// AC power connected
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isConnected")]
		public System.Nullable<System.Boolean> IsConnected { get; set; }
	}
	
	public class GetOrganizationWirelessDevicesEthernetStatusesReturnPowerPoe
	{
		
		/// <summary>
		/// PoE power connected
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isConnected")]
		public System.Nullable<System.Boolean> IsConnected { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
