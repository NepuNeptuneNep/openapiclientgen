//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Changelog
	{
		
		/// <summary>
		/// Body content of the changelog
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Visibility of the changelog
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hidden")]
		public System.Nullable<System.Boolean> Hidden { get; set; }
		
		/// <summary>
		/// Title of the changelog
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<ChangelogType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ChangelogType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="")]
		_ = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		added = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="fixed")]
		_fixed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		improved = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deprecated = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		removed = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CustomPage
	{
		
		/// <summary>
		/// Body formatted in Markdown (displayed by default).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Visibility of the custom page
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hidden")]
		public System.Nullable<System.Boolean> Hidden { get; set; }
		
		/// <summary>
		/// Body formatted in HTML (sanitized, only displayed if `htmlmode` is **true**).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="html")]
		public string Html { get; set; }
		
		/// <summary>
		/// **true** if `html` should be displayed, **false** if `body` should be displayed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="htmlmode")]
		public System.Nullable<System.Boolean> Htmlmode { get; set; }
		
		/// <summary>
		/// Title of the custom page
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Doc
	{
		
		/// <summary>
		/// Body content of the page, formatted in ReadMe or Github flavored Markdown. Accepts long page content, for example, greater than 100k characters
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Category ID of the page, which you can get through https://docs.readme.com/developers/reference/categories#getcategory 
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		/// <summary>
		/// Visibility of the page
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hidden")]
		public System.Nullable<System.Boolean> Hidden { get; set; }
		
		/// <summary>
		/// For a subpage, specify the parent doc ID, which you can get through https://docs.readme.com/developers/reference/docs#getdoc
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parentDoc")]
		public string ParentDoc { get; set; }
		
		/// <summary>
		/// Title of the page
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Type of the page. The available types all show up under the /docs/ URL path of your docs project (also known as the "guides" section). Can be "basic" (most common), "error" (page desribing an API error), or "link" (page that redirects to an external link)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<DocType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DocType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		basic = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		error = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		link = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Version
	{
		
		/// <summary>
		/// Dubbed name of version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="codename")]
		public string Codename { get; set; }
		
		/// <summary>
		/// Semantic Version to use as the base fork
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="is_beta")]
		public System.Nullable<System.Boolean> Is_beta { get; set; }
		
		/// <summary>
		/// Should this be deprecated? Only allowed in PUT operations
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_deprecated")]
		public System.Nullable<System.Boolean> Is_deprecated { get; set; }
		
		/// <summary>
		/// Should this be publically accessible?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_hidden")]
		public System.Nullable<System.Boolean> Is_hidden { get; set; }
		
		/// <summary>
		/// Should this be the **main** version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_stable")]
		public System.Nullable<System.Boolean> Is_stable { get; set; }
		
		/// <summary>
		/// Semantic Version
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version1 { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Get metadata about the current project
		/// Returns project data for API key
		/// GetProject 
		/// </summary>
		/// <returns>Project data</returns>
		public async Task GetProjectAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get API specification metadata
		/// GetAPISpecification api-specification
		/// </summary>
		/// <param name="perPage">Number of items to include in pagination (up to 100, defaults to 10)
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="page">Used to specify further pages (starts at 1)
		/// Minimum: 1
		// </param>
		/// <returns>Successfully retrieved API specification metadata.</returns>
		public async Task GetAPISpecificationAsync(int perPage, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api-specification?perPage="+perPage+"&page="+page;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete an API specification in ReadMe
		/// DeleteAPISpecification api-specification/{id}
		/// </summary>
		/// <param name="id">ID of the API specification. The unique ID for each API can be found by navigating to your **API Definitions** page.</param>
		public async Task DeleteAPISpecificationAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api-specification/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get category
		/// Returns the category with this slug
		/// GetCategory categories/{slug}
		/// </summary>
		/// <param name="slug">Slug of category. Slugs must be all lowercase, and replace spaces with hyphens. For example, for the the category "Getting Started", enter the slug "getting-started"</param>
		/// <returns>The category exists and has been returned</returns>
		public async Task GetCategoryAsync(string slug, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "categories/"+ (slug==null? "" : System.Uri.EscapeDataString(slug));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get docs for category
		/// Returns the docs and children docs within this category
		/// GetCategoryDocs categories/{slug}/docs
		/// </summary>
		/// <param name="slug">Slug of category. Slugs must be all lowercase, and replace spaces with hyphens. For example, for the the category "Getting Started", enter the slug "getting-started"</param>
		/// <returns>The category exists and all of the docs have been returned</returns>
		public async Task GetCategoryDocsAsync(string slug, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "categories/"+ (slug==null? "" : System.Uri.EscapeDataString(slug))+"/docs";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get changelogs
		/// Returns a list of changelogs associated with the project API key
		/// GetChangelogs changelogs
		/// </summary>
		/// <param name="perPage">Number of items to include in pagination (up to 100, defaults to 10)
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="page">Used to specify further pages (starts at 1)
		/// Minimum: 1
		// </param>
		/// <returns>OK</returns>
		public async Task GetChangelogsAsync(int perPage, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "changelogs?perPage="+perPage+"&page="+page;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create changelog
		/// Create a new changelog inside of this project
		/// CreateChangelog changelogs
		/// </summary>
		/// <param name="requestBody">Changelog object</param>
		public async Task CreateChangelogAsync(Changelog requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "changelogs";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete changelog
		/// Delete the changelog with this slug
		/// DeleteChangelog changelogs/{slug}
		/// </summary>
		/// <param name="slug">Slug of changelog</param>
		public async Task DeleteChangelogAsync(string slug, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "changelogs/"+ (slug==null? "" : System.Uri.EscapeDataString(slug));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get changelog
		/// Returns the changelog with this slug
		/// GetChangelog changelogs/{slug}
		/// </summary>
		/// <param name="slug">Slug of changelog</param>
		/// <returns>The changelog exists and has been returned</returns>
		public async Task GetChangelogAsync(string slug, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "changelogs/"+ (slug==null? "" : System.Uri.EscapeDataString(slug));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update changelog
		/// Update a changelog with this slug
		/// UpdateChangelog changelogs/{slug}
		/// </summary>
		/// <param name="slug">Slug of changelog</param>
		/// <param name="requestBody">Changelog object</param>
		/// <returns>The changelog has successfully been updated</returns>
		public async Task UpdateChangelogAsync(string slug, Changelog requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "changelogs/"+ (slug==null? "" : System.Uri.EscapeDataString(slug));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get custom pages
		/// Returns a list of custom pages associated with the project API key
		/// GetCustomPages custompages
		/// </summary>
		/// <param name="perPage">Number of items to include in pagination (up to 100, defaults to 10)
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="page">Used to specify further pages (starts at 1)
		/// Minimum: 1
		// </param>
		/// <returns>OK</returns>
		public async Task GetCustomPagesAsync(int perPage, int page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "custompages?perPage="+perPage+"&page="+page;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create custom page
		/// Create a new custom page inside of this project
		/// CreateCustomPage custompages
		/// </summary>
		/// <param name="requestBody">CustomPage object</param>
		public async Task CreateCustomPageAsync(CustomPage requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "custompages";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete custom page
		/// Delete the custom page with this slug
		/// DeleteCustomPage custompages/{slug}
		/// </summary>
		/// <param name="slug">Slug of custom page</param>
		public async Task DeleteCustomPageAsync(string slug, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "custompages/"+ (slug==null? "" : System.Uri.EscapeDataString(slug));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get custom page
		/// Returns the custom page with this slug
		/// GetCustomPage custompages/{slug}
		/// </summary>
		/// <param name="slug">Slug of custom page</param>
		/// <returns>The custom page exists and has been returned</returns>
		public async Task GetCustomPageAsync(string slug, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "custompages/"+ (slug==null? "" : System.Uri.EscapeDataString(slug));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update custom page
		/// Update a custom page with this slug
		/// UpdateCustomPage custompages/{slug}
		/// </summary>
		/// <param name="slug">Slug of custom page</param>
		/// <param name="requestBody">CustomPage object</param>
		/// <returns>The custom page has successfully been updated</returns>
		public async Task UpdateCustomPageAsync(string slug, CustomPage requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "custompages/"+ (slug==null? "" : System.Uri.EscapeDataString(slug));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create doc
		/// Create a new doc inside of this project
		/// CreateDoc docs
		/// </summary>
		/// <param name="requestBody">Doc object</param>
		public async Task CreateDocAsync(Doc requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "docs";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Search docs
		/// Returns all docs that match the search
		/// SearchDocs docs/search
		/// </summary>
		/// <param name="search">Search string to look for</param>
		/// <returns>The search was successful and results were returned</returns>
		public async Task SearchDocsAsync(string search, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "docs/search?search=" + (search==null? "" : System.Uri.EscapeDataString(search));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete doc
		/// Delete the doc with this slug
		/// DeleteDoc docs/{slug}
		/// </summary>
		/// <param name="slug">Slug of doc. must be lowercase, and replace spaces with hyphens. For example, for the page titled "New Features", enter the slug "new-features"</param>
		public async Task DeleteDocAsync(string slug, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "docs/"+ (slug==null? "" : System.Uri.EscapeDataString(slug));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get doc
		/// Returns the doc with this slug
		/// GetDoc docs/{slug}
		/// </summary>
		/// <param name="slug">Slug of doc. must be lowercase, and replace spaces with hyphens. For example, for the page titled "New Features", enter the slug "new-features"</param>
		/// <returns>The doc exists and has been returned</returns>
		public async Task GetDocAsync(string slug, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "docs/"+ (slug==null? "" : System.Uri.EscapeDataString(slug));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update doc
		/// Update a doc with this slug
		/// UpdateDoc docs/{slug}
		/// </summary>
		/// <param name="slug">Slug of doc. must be lowercase, and replace spaces with hyphens. For example, for the page titled "New Features", enter the slug "new-features"</param>
		/// <param name="requestBody">Doc object</param>
		/// <returns>The doc has successfully been updated</returns>
		public async Task UpdateDocAsync(string slug, Doc requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "docs/"+ (slug==null? "" : System.Uri.EscapeDataString(slug));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get errors
		/// Returns with all of the error page types for this project
		/// GetErrors errors
		/// </summary>
		/// <returns>An array of the errors</returns>
		public async Task GetErrorsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "errors";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// DEPRECATED. Instead, use https://docs.readme.com/developers/reference/api-specification#deleteapispecification to delete a Swagger file in ReadMe
		/// DeleteSwagger swagger/{id}
		/// </summary>
		/// <param name="id">ID of swagger the file</param>
		public async Task DeleteSwaggerAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "swagger/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get versions
		/// Retrieve a list of versions associated with a project API key
		/// GetVersions version
		/// </summary>
		/// <returns>JSON list of versions</returns>
		public async Task GetVersionsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create version
		/// Create a new version
		/// CreateVersion version
		/// </summary>
		/// <param name="requestBody">Version object</param>
		/// <returns>The model was successfully created and associated with the target project</returns>
		public async Task CreateVersionAsync(Version requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete version
		/// Delete a version
		/// DeleteVersion version/{versionId}
		/// </summary>
		/// <param name="versionId">Semver version indentifier</param>
		/// <returns>The target version was successfully deleted</returns>
		public async Task DeleteVersionAsync(string versionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version/"+ (versionId==null? "" : System.Uri.EscapeDataString(versionId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get version
		/// Returns the version with this version ID
		/// GetVersion version/{versionId}
		/// </summary>
		/// <param name="versionId">Semver version indentifier</param>
		/// <returns>JSON version model</returns>
		public async Task GetVersionAsync(string versionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version/"+ (versionId==null? "" : System.Uri.EscapeDataString(versionId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update version
		/// Update an existing version
		/// UpdateVersion version/{versionId}
		/// </summary>
		/// <param name="versionId">Semver version indentifier</param>
		/// <param name="requestBody">Version object</param>
		/// <returns>The target version was successfully updated</returns>
		public async Task UpdateVersionAsync(string versionId, Version requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version/"+ (versionId==null? "" : System.Uri.EscapeDataString(versionId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
