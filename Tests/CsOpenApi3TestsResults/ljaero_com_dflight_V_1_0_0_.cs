//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AerodromeDistanceResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AerodromePolyResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AerodromeRouteResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for point/distance requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AerodromesByDistance
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="distance")]
		public double Distance { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for polygon requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AerodromesByPolygon
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="poly")]
		public string Poly { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for along-route requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AerodromesByRoute
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="route")]
		public string Route { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for point/distance requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AirspaceByDistance
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="asptypes")]
		public string[] Asptypes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="distance")]
		public double Distance { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for polygon requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AirspaceByPolygon
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="asptypes")]
		public string[] Asptypes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="poly")]
		public string Poly { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for along-route requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AirspaceByRoute
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="asptypes")]
		public string[] Asptypes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="route")]
		public string Route { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AirspaceDistanceResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string[] Found { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AirspacePolyResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string[] Found { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AirspaceRouteResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string[] Found { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class HTTPValidationError
	{
		
		[System.Runtime.Serialization.DataMember(Name="detail")]
		public ValidationError[] Detail { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ValidationError
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="loc")]
		public string[] Loc { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="msg")]
		public string Msg { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for point/distance requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NOTAMsByDistance
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="distance")]
		public double Distance { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for polygon requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NOTAMsByPolygon
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="poly")]
		public string Poly { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for along-route requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NOTAMsByRoute
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="route")]
		public string Route { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NOTAMsDistanceResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NOTAMsPolyResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NOTAMsRouteResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ObstacleDistanceResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ObstaclePolyResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ObstacleRouteResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for point/distance requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ObstaclesByDistance
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="distance")]
		public double Distance { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for polygon requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ObstaclesByPolygon
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="poly")]
		public string Poly { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for along-route requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ObstaclesByRoute
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="route")]
		public string Route { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for point/distance requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SSAByDistance
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="distance")]
		public double Distance { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for polygon requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SSAByPolygon
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="poly")]
		public string Poly { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for along-route requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SSAByRoute
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="route")]
		public string Route { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SSADistanceResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SSAPolyResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SSARouteResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for point/distance requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UOAsByDistance
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="distance")]
		public double Distance { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for polygon requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UOAsByPolygon
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="poly")]
		public string Poly { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for along-route requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UOAsByRoute
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="route")]
		public string Route { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UOAsDistanceResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UOAsPolyResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UOAsRouteResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VenueDistanceResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VenuePolyResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VenueRouteResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for point/distance requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VenuesByDistance
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="distance")]
		public double Distance { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for polygon requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VenuesByPolygon
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="poly")]
		public string Poly { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for along-route requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VenuesByRoute
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="route")]
		public string Route { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for point/distance requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WxByDistance
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="distance")]
		public double Distance { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hours")]
		public int Hours { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="wxtypes")]
		public string[] Wxtypes { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for polygon requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WxByPolygon
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hours")]
		public int Hours { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="poly")]
		public string Poly { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="wxtypes")]
		public string[] Wxtypes { get; set; }
	}
	
	/// <summary>
	/// Geometry-defining arguments for along-route requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WxByRoute
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hours")]
		public int Hours { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="route")]
		public string Route { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="wxtypes")]
		public string[] Wxtypes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WxDistanceResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WxPolyResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WxRouteResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="found")]
		public string Found { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Retrieve aerodromes within given distance of location.
		/// Retrieve aerodromes within given distance of a point. Request body parameters are:
		/// * latitude:  WGS84 latitude coordinate of your selected point, in decimal degrees
		/// * longitude:  WGS84 longitude coordinate of your selected point, in decimal degrees
		/// * distance:  distance in meters (max allowed value is 25000)
		/// 
		/// Successful requests return a GeoJSON FeatureCollection, with a separate Feature for each
		/// Aerodrome found. All Features will include properties for the facility name, ident,
		/// type, and operational status.
		/// Aerodromes_by_distance_us_v1_aerodromes_distance_query_post us/v1/aerodromes/distance-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection, one Feature for each aerodrome found.</returns>
		public async Task<AerodromeDistanceResponse> Aerodromes_by_distance_us_v1_aerodromes_distance_query_postAsync(AerodromesByDistance requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/aerodromes/distance-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AerodromeDistanceResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve aerodromes located within given area.
		/// Retrieve aerodromes located within given area. Request body parameters are:
		/// * poly:  [GeoJSON Polygon](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the area. Max allowed area is 1000 km^2.
		/// 
		/// Successful requests return a GeoJSON FeatureCollection, with a separate Feature for each
		/// Aerodrome found. All Features will include properties for the facility name, ident,
		/// type, and operational status.
		/// Aerodromes_by_poly_us_v1_aerodromes_polygon_query_post us/v1/aerodromes/polygon-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection, one Feature for each aerodrome found.</returns>
		public async Task<AerodromePolyResponse> Aerodromes_by_poly_us_v1_aerodromes_polygon_query_postAsync(AerodromesByPolygon requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/aerodromes/polygon-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AerodromePolyResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve aerodromes found along a route.
		/// Retrieve aerodromes found along a route. Request body parameters are:
		/// * route: [GeoJSON Linestring](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the route. Max allowed length is 50 km.
		/// 
		/// Successful requests return a GeoJSON FeatureCollection, with a separate Feature for each
		/// Aerodrome found. All Features will include properties for the facility name, ident,
		/// type, and operational status.
		/// Aerodromes_by_route_us_v1_aerodromes_route_query_post us/v1/aerodromes/route-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection, one Feature for each aerodrome found.</returns>
		public async Task<AerodromeRouteResponse> Aerodromes_by_route_us_v1_aerodromes_route_query_postAsync(AerodromesByRoute requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/aerodromes/route-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AerodromeRouteResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve all requested types of airspace located within given distance of location.
		/// Retrieve selected types of airspace existing within given distance from a point. Request body parameters are:
		/// * latitude:  WGS84 latitude coordinate of your selected point, in decimal degrees
		/// * longitude:  WGS84 longitude coordinate of your selected point, in decimal degrees
		/// * distance:  distance in meters (max allowed value is 25000)
		/// * asptypes:  list of one or more airspace types you wish to retrieve. Allowed values are 'CAS', 'SUA', 'MAA', and 'MTR'.
		/// 
		/// Successful requests return a list of GeoJSON FeatureCollections, one for each Airspace type indicated in the request. Within each feature collection, there will be a separate Feature for each Airspace instance found. All Features will include a property indicating the *airspace_type*. Additional properties for each *airspace_type* are as follows:
		/// * CAS (Controlled Airspace)
		/// - *name*
		/// - *cas_class*: B, C, D, or E2
		/// - *floor*: integer value in ft MSL
		/// - *ceiling*: integer value in ft MSL
		/// - *lannc*: true/false indicating whether or not authorization for this airspace may be obtained via LAANC
		/// * SUA (Special Use Airspace)
		/// - *name*
		/// - *sua_type*: AA = Alert Area, MOA = Military Operations Area, NSA = National Security Area, PA = Prohibited Area, RA = Restricted Area, WA = Warning Area
		/// - *floor*: lower limit of the airspace
		/// - *floor_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)
		/// - *floor_ref*: reference level used for the numeric floor value: AGL, MSL, or STD (standard atmosphere, used for flight level values)
		/// - *ceiling*: upper limit of the airspace
		/// - *ceiling_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)
		/// - *ceiling_ref*: reference level used for the numeric ceiling value: AGL, MSL, or STD (standard atmosphere, used for flight level values)
		/// - *ceiling_ref*: reference level used for the numeric ceiling value: AGL, MSL, or STD (standard atmosphere, used for flight level values)
		/// - *schedule*: default activation days/times (other times by NOTAM)
		/// * MAA (Miscellaneous Activity Area)
		/// - *name*
		/// - *maa_type*: one of the following - ULTRALIGHT, PARACHUTE JUMP AREA, AEROBATIC PRACTICE, GLIDER, HANG GLIDER, SPACE LAUNCH ACTIVITY
		/// - *use_times*: textual description of days/times when activity in the area should be expected
		/// * MTR (Military Training Route)
		/// - *name*
		/// - *use_times*: textual description of days/times when MTR is active/hot
		/// - *terrain_following*: boolean value indicating whether terrain following activity occurs on the route
		/// - *max_extent_nm*: maximum distance that aircraft can deviate from route centerline
		/// Asp_by_distance_us_v1_airspace_distance_query_post us/v1/airspace/distance-query
		/// </summary>
		/// <returns>A list of GeoJSON FeatureCollections, one for each Airspace type requested.</returns>
		public async Task<AirspaceDistanceResponse> Asp_by_distance_us_v1_airspace_distance_query_postAsync(AirspaceByDistance requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/airspace/distance-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AirspaceDistanceResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve all requested types of airspace located within given GeoJSON Polygon.
		/// Retrieve selected types of airspace located within given area. Request body parameters are:
		/// * poly:  [GeoJSON Polygon](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the area. Max allowed area is 1000 km^2.
		/// * asptypes:  list of one or more airspace types you wish to retrieve. Allowed values are 'CAS', 'SUA', 'MAA', and 'MTR'.
		/// 
		/// Successful requests return a list of GeoJSON FeatureCollections, one for each Airspace type indicated in the request. Within each feature collection, there will be a separate Feature for each Airspace instance found. All Features will include a property indicating the *airspace_type*. Additional properties for each *airspace_type* are as follows:
		/// * CAS (Controlled Airspace)
		/// - *name*
		/// - *cas_class*: B, C, D, or E2
		/// - *floor*: integer value in ft MSL
		/// - *ceiling*: integer value in ft MSL
		/// - *lannc*: true/false indicating whether or not authorization for this airspace may be obtained via LAANC
		/// * SUA (Special Use Airspace)
		/// - *name*
		/// - *sua_type*: AA = Alert Area, MOA = Military Operations Area, NSA = National Security Area, PA = Prohibited Area, RA = Restricted Area, WA = Warning Area
		/// - *floor*: lower limit of the airspace
		/// - *floor_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)
		/// - *floor_ref*: reference level used for the numeric floor value: AGL, MSL, or STD (standard atmosphere, used for flight level values)
		/// - *ceiling*: upper limit of the airspace
		/// - *ceiling_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)
		/// - *ceiling_ref*: reference level used for the numeric ceiling value: AGL, MSL, or STD (standard atmosphere, used for flight level values)
		/// - *schedule*: default activation days/times (other times by NOTAM)
		/// * MAA (Miscellaneous Activity Area)
		/// - *name*
		/// - *maa_type*: one of the following - ULTRALIGHT, PARACHUTE JUMP AREA, AEROBATIC PRACTICE, GLIDER, HANG GLIDER, SPACE LAUNCH ACTIVITY
		/// - *use_times*: textual description of days/times when activity in the area should be expected
		/// * MTR (Military Training Route)
		/// - *name*
		/// - *use_times*: textual description of days/times when MTR is active/hot
		/// - *terrain_following*: boolean value indicating whether terrain following activity occurs on the route
		/// - *max_extent_nm*: maximum distance that aircraft can deviate from route centerline
		/// Asp_by_poly_us_v1_airspace_polygon_query_post us/v1/airspace/polygon-query
		/// </summary>
		/// <returns>A list of GeoJSON FeatureCollections, one for each Airspace type requested.</returns>
		public async Task<AirspacePolyResponse> Asp_by_poly_us_v1_airspace_polygon_query_postAsync(AirspaceByPolygon requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/airspace/polygon-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AirspacePolyResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve all requested types of airspace traversed by route.
		/// Retrieve selected types of airspace traversed by route. Request body parameters are:
		/// * route:  [GeoJSON Linestring](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the route. Max allowed length is 50 km.
		/// * asptypes:  list of one or more airspace types you wish to retrieve. Allowed values are 'CAS', 'SUA', 'MAA', and 'MTR'.
		/// 
		/// Successful requests return a list of GeoJSON FeatureCollections, one for each Airspace type indicated in the request. Within each feature collection, there will be a separate Feature for each Airspace instance found. All Features will include a property indicating the *airspace_type*. Additional properties for each *airspace_type* are as follows:
		/// * CAS (Controlled Airspace)
		/// - *name*
		/// - *cas_class*: B, C, D, or E2
		/// - *floor*: integer value in ft MSL
		/// - *ceiling*: integer value in ft MSL
		/// - *lannc*: true/false indicating whether or not authorization for this airspace may be obtained via LAANC
		/// * SUA (Special Use Airspace)
		/// - *name*
		/// - *sua_type*: AA = Alert Area, MOA = Military Operations Area, NSA = National Security Area, PA = Prohibited Area, RA = Restricted Area, WA = Warning Area
		/// - *floor*: lower limit of the airspace
		/// - *floor_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)
		/// - *floor_ref*: reference level used for the numeric floor value: AGL, MSL, or STD (standard atmosphere, used for flight level values)
		/// - *ceiling*: upper limit of the airspace
		/// - *ceiling_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)
		/// - *ceiling_ref*: reference level used for the numeric ceiling value: AGL, MSL, or STD (standard atmosphere, used for flight level values)
		/// - *schedule*: default activation days/times (other times by NOTAM)
		/// * MAA (Miscellaneous Activity Area)
		/// - *name*
		/// - *maa_type*: one of the following - ULTRALIGHT, PARACHUTE JUMP AREA, AEROBATIC PRACTICE, GLIDER, HANG GLIDER, SPACE LAUNCH ACTIVITY
		/// - *use_times*: textual description of days/times when activity in the area should be expected
		/// * MTR (Military Training Route)
		/// - *name*
		/// - *use_times*: textual description of days/times when MTR is active/hot
		/// - *terrain_following*: boolean value indicating whether terrain following activity occurs on the route
		/// - *max_extent_nm*: maximum distance that aircraft can deviate from route centerline
		/// Asp_by_route_us_v1_airspace_route_query_post us/v1/airspace/route-query
		/// </summary>
		/// <returns>A list of GeoJSON FeatureCollections, one for each Airspace type requested.</returns>
		public async Task<AirspaceRouteResponse> Asp_by_route_us_v1_airspace_route_query_postAsync(AirspaceByRoute requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/airspace/route-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AirspaceRouteResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve obstacles within given distance of location.
		/// Retrieve obstacles within given distance of a point. Request body parameters are:
		/// * latitude:  WGS84 latitude coordinate of your selected point, in decimal degrees
		/// * longitude:  WGS84 longitude coordinate of your selected point, in decimal degrees
		/// * distance:  distance in meters (max allowed value is 25000)
		/// Obstacles_by_distance_us_v1_obstacles_distance_query_post us/v1/obstacles/distance-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection, one Feature for each obstacle found.</returns>
		public async Task<ObstacleDistanceResponse> Obstacles_by_distance_us_v1_obstacles_distance_query_postAsync(ObstaclesByDistance requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/obstacles/distance-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ObstacleDistanceResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve obstacles located within given area.
		/// Retrieve obstacles located within given area. Request body parameters are:
		/// * poly:  [GeoJSON Polygon](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the area. Max allowed area is 1000 km^2.
		/// Obstacles_by_poly_us_v1_obstacles_polygon_query_post us/v1/obstacles/polygon-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection, one Feature for each obstacle found.</returns>
		public async Task<ObstaclePolyResponse> Obstacles_by_poly_us_v1_obstacles_polygon_query_postAsync(ObstaclesByPolygon requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/obstacles/polygon-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ObstaclePolyResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve obstacles found along a route.
		/// Retrieve obstacles found along a route. Request body parameters are:
		/// * route: [GeoJSON Linestring](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the route. Max allowed length is 50 km.
		/// Obstacles_by_route_us_v1_obstacles_route_query_post us/v1/obstacles/route-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection, one Feature for each obstacle found.</returns>
		public async Task<ObstacleRouteResponse> Obstacles_by_route_us_v1_obstacles_route_query_postAsync(ObstaclesByRoute requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/obstacles/route-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ObstacleRouteResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve flight restrictions applicable within given distance of location.
		/// Retrieve Flight Restrictions applicable within given distance of a point. Request body parameters are:
		/// * latitude:  WGS84 latitude coordinate of your selected point, in decimal degrees
		/// * longitude:  WGS84 longitude coordinate of your selected point, in decimal degrees
		/// * distance:  distance in meters (max allowed value is 25000)
		/// Tfr_by_distance_us_v1_restrictions_distance_query_post us/v1/restrictions/distance-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection, one Feature for each restriction.</returns>
		public async Task<NOTAMsDistanceResponse> Tfr_by_distance_us_v1_restrictions_distance_query_postAsync(NOTAMsByDistance requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/restrictions/distance-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<NOTAMsDistanceResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve flight restrictions applicable within given area.
		/// Retrieve Flight Restrictions located within given area. Request body parameters are:
		/// * poly:  [GeoJSON Polygon](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the area. Max allowed area is 1000 km^2.
		/// Tfr_by_poly_us_v1_restrictions_polygon_query_post us/v1/restrictions/polygon-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection, one Feature for each restriction.</returns>
		public async Task<NOTAMsPolyResponse> Tfr_by_poly_us_v1_restrictions_polygon_query_postAsync(NOTAMsByPolygon requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/restrictions/polygon-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<NOTAMsPolyResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve flight restrictions applicable along route.
		/// Retrieve Flight Restrictions applicable along your route. Request body parameters are:
		/// * route:  [GeoJSON Linestring](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the route. Max allowed length is 50 km.
		/// Tfr_by_route_us_v1_restrictions_route_query_post us/v1/restrictions/route-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection, one Feature for each restriction.</returns>
		public async Task<NOTAMsRouteResponse> Tfr_by_route_us_v1_restrictions_route_query_postAsync(NOTAMsByRoute requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/restrictions/route-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<NOTAMsRouteResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve all special security areas located within given distance of location.
		/// Retrieve special security areas existing within given distance from a point. Request body parameters are:
		/// * latitude:  WGS84 latitude coordinate of your selected point, in decimal degrees
		/// * longitude:  WGS84 longitude coordinate of your selected point, in decimal degrees
		/// * distance:  distance in meters (max allowed value is 25000)
		/// Ssa_by_distance_us_v1_ssa_distance_query_post us/v1/ssa/distance-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection, one Feature for each area found.</returns>
		public async Task<SSADistanceResponse> Ssa_by_distance_us_v1_ssa_distance_query_postAsync(SSAByDistance requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/ssa/distance-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<SSADistanceResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve all special security areas located within given GeoJSON Polygon.
		/// Retrieve all special security areas located within given area. Request body parameters are:
		/// * poly:  [GeoJSON Polygon](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the area. Max allowed area is 1000 km^2.
		/// Ssa_by_poly_us_v1_ssa_polygon_query_post us/v1/ssa/polygon-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection, one Feature for each area found.</returns>
		public async Task<SSAPolyResponse> Ssa_by_poly_us_v1_ssa_polygon_query_postAsync(SSAByPolygon requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/ssa/polygon-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<SSAPolyResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve all special security areas traversed by route.
		/// Retrieve all special security areas intersected by route. Request body parameters are:
		/// * route: [GeoJSON Linestring](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the route. Max allowed length is 50 km.
		/// Ssa_by_route_us_v1_ssa_route_query_post us/v1/ssa/route-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection, one Feature for each area found.</returns>
		public async Task<SSARouteResponse> Ssa_by_route_us_v1_ssa_route_query_postAsync(SSAByRoute requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/ssa/route-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<SSARouteResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve UAS Operating Areas (UOAs) found within given distance of location.
		/// Retrieve UAS Operating Areas (UOAs) found within given distance of a point. Request body parameters are:
		/// * latitude:  WGS84 latitude coordinate of your selected point, in decimal degrees
		/// * longitude:  WGS84 longitude coordinate of your selected point, in decimal degrees
		/// * distance:  distance in meters (max allowed value is 25000)
		/// Uoa_by_distance_us_v1_uoa_distance_query_post us/v1/uoa/distance-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection, one Feature for each UOA.</returns>
		public async Task<UOAsDistanceResponse> Uoa_by_distance_us_v1_uoa_distance_query_postAsync(UOAsByDistance requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/uoa/distance-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UOAsDistanceResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve UAS Operating Areas (UOAs) found within given area.
		/// Retrieve UAS Operating Areas (UOAs) found within given area. Request body parameters are:
		/// * poly:  [GeoJSON Polygon](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the area. Max allowed area is 1000 km^2.
		/// Uoa_by_poly_us_v1_uoa_polygon_query_post us/v1/uoa/polygon-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection, one Feature for each UOA.</returns>
		public async Task<UOAsPolyResponse> Uoa_by_poly_us_v1_uoa_polygon_query_postAsync(UOAsByPolygon requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/uoa/polygon-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UOAsPolyResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve UAS Operating Areas (UOAs) found along route.
		/// Retrieve UAS Operating Areas (UOAs) found along your route. Request body parameters are:
		/// * route:  [GeoJSON Linestring](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the route. Max allowed length is 50 km.
		/// Uoa_by_route_us_v1_uoa_route_query_post us/v1/uoa/route-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection, one Feature for each UOA.</returns>
		public async Task<UOAsRouteResponse> Uoa_by_route_us_v1_uoa_route_query_postAsync(UOAsByRoute requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/uoa/route-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UOAsRouteResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve all restricted public venues located within given distance of location.
		/// Retrieve venues existing within given distance from a point. Request body parameters are:
		/// * latitude:  WGS84 latitude coordinate of your selected point, in decimal degrees
		/// * longitude:  WGS84 longitude coordinate of your selected point, in decimal degrees
		/// * distance:  distance in meters (max allowed value is 25000)
		/// Ven_by_distance_us_v1_venues_distance_query_post us/v1/venues/distance-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection, one Feature for each venue found.</returns>
		public async Task<VenueDistanceResponse> Ven_by_distance_us_v1_venues_distance_query_postAsync(VenuesByDistance requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/venues/distance-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<VenueDistanceResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve all restricted public venues located within given GeoJSON Polygon.
		/// Retrieve all restricted public venues located within given area. Request body parameters are:
		/// * poly:  [GeoJSON Polygon](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the area. Max allowed area is 1000 km^2.
		/// Ven_by_poly_us_v1_venues_polygon_query_post us/v1/venues/polygon-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection, one Feature for each venue found.</returns>
		public async Task<VenuePolyResponse> Ven_by_poly_us_v1_venues_polygon_query_postAsync(VenuesByPolygon requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/venues/polygon-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<VenuePolyResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve all restricted public venues traversed by route.
		/// Retrieve all restricted public venues intersected by route. Request body parameters are:
		/// * route: [GeoJSON Linestring](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the route. Max allowed length is 50 km.
		/// Ven_by_route_us_v1_venues_route_query_post us/v1/venues/route-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection, one Feature for each venue found.</returns>
		public async Task<VenueRouteResponse> Ven_by_route_us_v1_venues_route_query_postAsync(VenuesByRoute requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/venues/route-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<VenueRouteResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve forecast values within given distance of location for all requested weather elements and time periods.
		/// Retrieve forecast values for selected weather elements and time period. Request body parameters are:
		/// * latitude:  WGS84 latitude coordinate of your selected point, in decimal degrees
		/// * longitude:  WGS84 longitude coordinate of your selected point, in decimal degrees
		/// * distance:  distance in meters (max allowed value is 25000)
		/// * wxtypes:  list of one or more weather forecast elements you wish to retrieve. Allowed values are "CIG", "DEWPT", "SKY", "TEMP", "VIS", "WINDDIR", "WINDGUST", "WINDSPEED".
		/// * hours:  number of hourly forecasts to return (1-24). For current hour only you should enter value of 1. To also retrieve values for each of the next n hours, enter n.
		/// 
		/// 
		/// The response will consist of a GeoJSON FeatureCollection with one Feature for each forecast location found within requested area,
		/// properties of which will include an ordered list of forecast values for each requested weather element, for each requested hour. Units for each element are as follows:
		/// * CIG: meters AGL
		/// * DEWPT: degrees Celsius
		/// * SKY: % cloud cover
		/// * TEMP: degrees Celsius
		/// * VIS: meters
		/// * WINDDIR: degrees true
		/// * WINDGUST: meters/sec
		/// * WINDSPEED: meters/sec
		/// Wx_by_distance_us_v1_wx_forecast_distance_query_post us/v1/wx-forecast/distance-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection with one Feature for each forecast location found within requested area.</returns>
		public async Task<WxDistanceResponse> Wx_by_distance_us_v1_wx_forecast_distance_query_postAsync(WxByDistance requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/wx-forecast/distance-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<WxDistanceResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve forecast values within given GeoJSON polygon for all requested weather elements and time periods.
		/// Retrieve forecast values located within given area for requested weather elements and time period. Request body parameters are:
		/// * poly:  [GeoJSON Polygon](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the area. Max allowed area is 1000 km^2.
		/// * wxtypes:  list of one or more weather forecast elements you wish to retrieve. Allowed values are "CIG", "DEWPT", "SKY", "TEMP", "VIS", "WINDDIR", "WINDGUST", "WINDSPEED".
		/// * hours:  number of hourly forecasts to return (1-24). For current hour only you should enter value of 1. To also retrieve values for each of the next n hours, enter n.
		/// 
		/// 
		/// The response will consist of a GeoJSON FeatureCollection with one Feature for each forecast location found within requested area,
		/// properties of which will include an ordered list of forecast values for each requested weather element, for each requested hour. Units for each element are as follows:
		/// * CIG: meters AGL
		/// * DEWPT: degrees Celsius
		/// * SKY: % cloud cover
		/// * TEMP: degrees Celsius
		/// * VIS: meters
		/// * WINDDIR: degrees true
		/// * WINDGUST: meters/sec
		/// * WINDSPEED: meters/sec
		/// Wx_by_poly_us_v1_wx_forecast_polygon_query_post us/v1/wx-forecast/polygon-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection with one Feature for each forecast location found within requested area.</returns>
		public async Task<WxPolyResponse> Wx_by_poly_us_v1_wx_forecast_polygon_query_postAsync(WxByPolygon requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/wx-forecast/polygon-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<WxPolyResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieve forecast values along a route for all requested weather elements and time periods.
		/// Retrieve forecast values along route for requested weather elements and time period. Request body parameters are:
		/// * route:  [GeoJSON Linestring](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the route. Max allowed length is 50 km.
		/// * wxtypes:  list of one or more weather forecast elements you wish to retrieve. Allowed values are "CIG", "DEWPT", "SKY", "TEMP", "VIS", "WINDDIR", "WINDGUST", "WINDSPEED".
		/// * hours:  number of hourly forecasts to return (1-24). For current hour only you should enter value of 1. To also retrieve values for each of the next n hours, enter n.
		/// 
		/// 
		/// The response will consist of a GeoJSON FeatureCollection with one Feature for each forecast location found within requested area,
		/// properties of which will include an ordered list of forecast values for each requested weather element, for each requested hour. Units for each element are as follows:
		/// * CIG: meters AGL
		/// * DEWPT: degrees Celsius
		/// * SKY: % cloud cover
		/// * TEMP: degrees Celsius
		/// * VIS: meters
		/// * WINDDIR: degrees true
		/// * WINDGUST: meters/sec
		/// * WINDSPEED: meters/sec
		/// Wx_by_route_us_v1_wx_forecast_route_query_post us/v1/wx-forecast/route-query
		/// </summary>
		/// <returns>A GeoJSON FeatureCollection with one Feature for each forecast location found within requested area.</returns>
		public async Task<WxRouteResponse> Wx_by_route_us_v1_wx_forecast_route_query_postAsync(WxByRoute requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "us/v1/wx-forecast/route-query";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<WxRouteResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
