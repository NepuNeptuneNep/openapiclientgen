//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Represents an area. Used to represent regions such as water, parks, etc. Next ID: 10
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Area
	{
		
		/// <summary>
		/// Metadata necessary to determine the ordering of a particular basemap element relative to others. To render the basemap correctly, sort by z-plane, then z-grade, then z-within-grade.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="basemapZOrder")]
		public BasemapZOrder BasemapZOrder { get; set; }
		
		/// <summary>
		/// True if the polygon is not entirely internal to the feature that it belongs to: that is, some of the edges are bordering another feature.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasExternalEdges")]
		public System.Nullable<System.Boolean> HasExternalEdges { get; set; }
		
		/// <summary>
		/// When has_external_edges is true, the polygon has some edges that border another feature. This field indicates the internal edges that do not border another feature. Each value is an index into the vertices array, and denotes the start vertex of the internal edge (the next vertex in the boundary loop is the end of the edge). If the selected vertex is the last vertex in the boundary loop, then the edge between that vertex and the starting vertex of the loop is internal. This field may be used for styling. For example, building parapets could be placed only on the external edges of a building polygon, or water could be lighter colored near the external edges of a body of water. If has_external_edges is false, all edges are internal and this field will be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="internalEdges")]
		public int[] InternalEdges { get; set; }
		
		/// <summary>
		/// Identifies the boundary loops of the polygon. Only set for INDEXED_TRIANGLE polygons. Each value is an index into the vertices array indicating the beginning of a loop. For instance, values of [2, 5] would indicate loop_data contained 3 loops with indices 0-1, 2-4, and 5-end. This may be used in conjunction with the internal_edges field for styling polygon boundaries. Note that an edge may be on a polygon boundary but still internal to the feature. For example, a feature split across multiple tiles will have an internal polygon boundary edge along the edge of the tile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loopBreaks")]
		public int[] LoopBreaks { get; set; }
		
		/// <summary>
		/// When the polygon encoding is of type INDEXED_TRIANGLES, this contains the indices of the triangle vertices in the vertex_offsets field. There are 3 vertex indices per triangle.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="triangleIndices")]
		public int[] TriangleIndices { get; set; }
		
		/// <summary>
		/// The polygon encoding type used for this area.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<AreaType> Type { get; set; }
		
		/// <summary>
		/// 2D vertex list used for lines and areas. Each entry represents an offset from the previous one in local tile coordinates. The first entry is offset from (0, 0). For example, the list of vertices [(1,1), (2, 2), (1, 2)] would be encoded in vertex offsets as [(1, 1), (1, 1), (-1, 0)].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vertexOffsets")]
		public Vertex2DList VertexOffsets { get; set; }
		
		/// <summary>
		/// The z-ordering of this area. Areas with a lower z-order should be rendered beneath areas with a higher z-order. This z-ordering does not imply anything about the altitude of the line relative to the ground, but it can be used to prevent z-fighting during rendering on the client. This z-ordering can only be used to compare areas, and cannot be compared with the z_order field in the Line message. The z-order may be negative or zero. Prefer Area.basemap_z_order.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zOrder")]
		public System.Nullable<System.Int32> ZOrder { get; set; }
	}
	
	/// <summary>
	/// Metadata necessary to determine the ordering of a particular basemap element relative to others. To render the basemap correctly, sort by z-plane, then z-grade, then z-within-grade.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BasemapZOrder
	{
		
		/// <summary>
		/// The second most significant component of the ordering of a component to be rendered onto the basemap.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zGrade")]
		public System.Nullable<System.Int32> ZGrade { get; set; }
		
		/// <summary>
		/// The most significant component of the ordering of a component to be rendered onto the basemap.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zPlane")]
		public System.Nullable<System.Int32> ZPlane { get; set; }
		
		/// <summary>
		/// The least significant component of the ordering of a component to be rendered onto the basemap.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zWithinGrade")]
		public System.Nullable<System.Int32> ZWithinGrade { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AreaType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TRIANGLE_FAN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INDEXED_TRIANGLES = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TRIANGLE_STRIP = 2,
	}
	
	/// <summary>
	/// 2D vertex list used for lines and areas. Each entry represents an offset from the previous one in local tile coordinates. The first entry is offset from (0, 0). For example, the list of vertices [(1,1), (2, 2), (1, 2)] would be encoded in vertex offsets as [(1, 1), (1, 1), (-1, 0)].
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Vertex2DList
	{
		
		/// <summary>
		/// List of x-offsets in local tile coordinates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xOffsets")]
		public int[] XOffsets { get; set; }
		
		/// <summary>
		/// List of y-offsets in local tile coordinates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="yOffsets")]
		public int[] YOffsets { get; set; }
	}
	
	/// <summary>
	/// Represents a height-extruded area: a 3D prism with a constant X-Y plane cross section. Used to represent extruded buildings. A single building may consist of several extruded areas. The min_z and max_z fields are scaled to the size of the tile. An extruded area with a max_z value of 4096 has the same height as the width of the tile that it is on.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ExtrudedArea
	{
		
		/// <summary>
		/// Represents an area. Used to represent regions such as water, parks, etc. Next ID: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="area")]
		public Area Area { get; set; }
		
		/// <summary>
		/// The z-value in local tile coordinates where the extruded area ends.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxZ")]
		public System.Nullable<System.Int32> MaxZ { get; set; }
		
		/// <summary>
		/// The z-value in local tile coordinates where the extruded area begins. This is non-zero for extruded areas that begin off the ground. For example, a building with a skybridge may have an extruded area component with a non-zero min_z.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minZ")]
		public System.Nullable<System.Int32> MinZ { get; set; }
	}
	
	/// <summary>
	/// A feature representing a single geographic entity.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Feature
	{
		
		/// <summary>
		/// The localized name of this feature. Currently only returned for roads.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Represents the geometry of a feature, that is, the shape that it has on the map. The local tile coordinate system has the origin at the north-west (upper-left) corner of the tile, and is scaled to 4096 units across each edge. The height (Z) axis has the same scale factor: an extruded area with a max_z value of 4096 has the same height as the width of the tile that it is on. There is no clipping boundary, so it is possible that some coordinates will lie outside the tile boundaries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="geometry")]
		public Geometry Geometry { get; set; }
		
		/// <summary>
		/// Place ID of this feature, suitable for use in Places API details requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="placeId")]
		public string PlaceId { get; set; }
		
		/// <summary>
		/// Relations to other features.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relations")]
		public Relation[] Relations { get; set; }
		
		/// <summary>
		/// Extra metadata relating to segments.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="segmentInfo")]
		public SegmentInfo SegmentInfo { get; set; }
		
		/// <summary>
		/// The type of this feature.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<FeatureType> Type { get; set; }
	}
	
	/// <summary>
	/// Represents the geometry of a feature, that is, the shape that it has on the map. The local tile coordinate system has the origin at the north-west (upper-left) corner of the tile, and is scaled to 4096 units across each edge. The height (Z) axis has the same scale factor: an extruded area with a max_z value of 4096 has the same height as the width of the tile that it is on. There is no clipping boundary, so it is possible that some coordinates will lie outside the tile boundaries.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Geometry
	{
		
		/// <summary>
		/// The areas present in this geometry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="areas")]
		public Area[] Areas { get; set; }
		
		/// <summary>
		/// The extruded areas present in this geometry. Not populated if modeled_volumes are included in this geometry unless always_include_building_footprints is set in GetFeatureTileRequest, in which case the client should decide which (extruded areas or modeled volumes) should be used (they should not be rendered together).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extrudedAreas")]
		public ExtrudedArea[] ExtrudedAreas { get; set; }
		
		/// <summary>
		/// The lines present in this geometry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lines")]
		public Line[] Lines { get; set; }
		
		/// <summary>
		/// The modeled volumes present in this geometry. Not populated unless enable_modeled_volumes has been set in GetFeatureTileRequest.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modeledVolumes")]
		public ModeledVolume[] ModeledVolumes { get; set; }
	}
	
	/// <summary>
	/// Represents a 2D polyline. Used to represent segments such as roads, train tracks, etc.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Line
	{
		
		/// <summary>
		/// Metadata necessary to determine the ordering of a particular basemap element relative to others. To render the basemap correctly, sort by z-plane, then z-grade, then z-within-grade.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="basemapZOrder")]
		public BasemapZOrder BasemapZOrder { get; set; }
		
		/// <summary>
		/// 2D vertex list used for lines and areas. Each entry represents an offset from the previous one in local tile coordinates. The first entry is offset from (0, 0). For example, the list of vertices [(1,1), (2, 2), (1, 2)] would be encoded in vertex offsets as [(1, 1), (1, 1), (-1, 0)].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vertexOffsets")]
		public Vertex2DList VertexOffsets { get; set; }
		
		/// <summary>
		/// The z-order of the line. Lines with a lower z-order should be rendered beneath lines with a higher z-order. This z-ordering does not imply anything about the altitude of the area relative to the ground, but it can be used to prevent z-fighting during rendering on the client. In general, larger and more important road features will have a higher z-order line associated with them. This z-ordering can only be used to compare lines, and cannot be compared with the z_order field in the Area message. The z-order may be negative or zero. Prefer Line.basemap_z_order.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zOrder")]
		public System.Nullable<System.Int32> ZOrder { get; set; }
	}
	
	/// <summary>
	/// Represents a modeled volume in 3D space. Used to represent 3D buildings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ModeledVolume
	{
		
		/// <summary>
		/// The triangle strips present in this mesh.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="strips")]
		public TriangleStrip[] Strips { get; set; }
		
		/// <summary>
		/// 3D vertex list used for modeled volumes. Each entry represents an offset from the previous one in local tile coordinates. The first coordinate is offset from (0, 0, 0).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vertexOffsets")]
		public Vertex3DList VertexOffsets { get; set; }
	}
	
	/// <summary>
	/// Represents a strip of triangles. Each triangle uses the last edge of the previous one. The following diagram shows an example of a triangle strip, with each vertex labeled with its index in the vertex_index array. (1)-----(3) / \ / \ / \ / \ / \ / \ (0)-----(2)-----(4) Vertices may be in either clockwise or counter-clockwise order.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TriangleStrip
	{
		
		/// <summary>
		/// Index into the vertex_offset array representing the next vertex in the triangle strip.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vertexIndices")]
		public int[] VertexIndices { get; set; }
	}
	
	/// <summary>
	/// 3D vertex list used for modeled volumes. Each entry represents an offset from the previous one in local tile coordinates. The first coordinate is offset from (0, 0, 0).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Vertex3DList
	{
		
		/// <summary>
		/// List of x-offsets in local tile coordinates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xOffsets")]
		public int[] XOffsets { get; set; }
		
		/// <summary>
		/// List of y-offsets in local tile coordinates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="yOffsets")]
		public int[] YOffsets { get; set; }
		
		/// <summary>
		/// List of z-offsets in local tile coordinates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zOffsets")]
		public int[] ZOffsets { get; set; }
	}
	
	/// <summary>
	/// Represents a relation to another feature in the tile. For example, a building might be occupied by a given POI. The related feature can be retrieved using the related feature index.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Relation
	{
		
		/// <summary>
		/// Zero-based index to look up the related feature from the list of features in the tile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relatedFeatureIndex")]
		public System.Nullable<System.Int32> RelatedFeatureIndex { get; set; }
		
		/// <summary>
		/// Relation type between the origin feature to the related feature.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relationType")]
		public System.Nullable<RelationRelationType> RelationType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RelationRelationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RELATION_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OCCUPIES = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIMARILY_OCCUPIED_BY = 2,
	}
	
	/// <summary>
	/// Extra metadata relating to segments.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SegmentInfo
	{
		
		/// <summary>
		/// Extra metadata relating to roads.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="roadInfo")]
		public RoadInfo RoadInfo { get; set; }
	}
	
	/// <summary>
	/// Extra metadata relating to roads.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RoadInfo
	{
		
		/// <summary>
		/// Road has signage discouraging or prohibiting use by the general public. E.g., roads with signs that say "Private", or "No trespassing."
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPrivate")]
		public System.Nullable<System.Boolean> IsPrivate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum FeatureType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FEATURE_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STRUCTURE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BAR = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BANK = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LODGING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CAFE = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTAURANT = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EVENT_VENUE = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TOURIST_DESTINATION = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHOPPING = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SCHOOL = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SEGMENT = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ROAD = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCAL_ROAD = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ARTERIAL_ROAD = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HIGHWAY = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONTROLLED_ACCESS_HIGHWAY = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOOTPATH = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RAIL = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FERRY = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REGION = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PARK = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BEACH = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOREST = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POLITICAL = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADMINISTRATIVE_AREA1 = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCALITY = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUBLOCALITY = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WATER = 28,
	}
	
	/// <summary>
	/// A tile containing information about the map features located in the region it covers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FeatureTile
	{
		
		/// <summary>
		/// Global tile coordinates. Global tile coordinates reference a specific tile on the map at a specific zoom level. The origin of this coordinate system is always at the northwest corner of the map, with x values increasing from west to east and y values increasing from north to south. Tiles are indexed using x, y coordinates from that origin. The zoom level containing the entire world in a tile is 0, and it increases as you zoom in. Zoom level n + 1 will contain 4 times as many tiles as zoom level n. The zoom level controls the level of detail of the data that is returned. In particular, this affects the set of feature types returned, their density, and geometry simplification. The exact tile contents may change over time, but care will be taken to keep supporting the most important use cases. For example, zoom level 15 shows roads for orientation and planning in the local neighborhood and zoom level 17 shows buildings to give users on foot a sense of situational awareness.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="coordinates")]
		public TileCoordinates Coordinates { get; set; }
		
		/// <summary>
		/// Features present on this map tile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="features")]
		public Feature[] Features { get; set; }
		
		/// <summary>
		/// Resource name of the tile. The tile resource name is prefixed by its collection ID `tiles/` followed by the resource ID, which encodes the tile's global x and y coordinates and zoom level as `@,,z`. For example, `tiles/@1,2,3z`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Data providers for the data contained in this tile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="providers")]
		public ProviderInfo[] Providers { get; set; }
		
		/// <summary>
		/// Tile response status code to support tile caching.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<FeatureTileStatus> Status { get; set; }
		
		/// <summary>
		/// An opaque value, usually less than 30 characters, that contains version info about this tile and the data that was used to generate it. The client should store this value in its tile cache and pass it back to the API in the client_tile_version_id field of subsequent tile requests in order to enable the API to detect when the new tile would be the same as the one the client already has in its cache. Also see STATUS_OK_DATA_UNCHANGED.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="versionId")]
		public string VersionId { get; set; }
	}
	
	/// <summary>
	/// Global tile coordinates. Global tile coordinates reference a specific tile on the map at a specific zoom level. The origin of this coordinate system is always at the northwest corner of the map, with x values increasing from west to east and y values increasing from north to south. Tiles are indexed using x, y coordinates from that origin. The zoom level containing the entire world in a tile is 0, and it increases as you zoom in. Zoom level n + 1 will contain 4 times as many tiles as zoom level n. The zoom level controls the level of detail of the data that is returned. In particular, this affects the set of feature types returned, their density, and geometry simplification. The exact tile contents may change over time, but care will be taken to keep supporting the most important use cases. For example, zoom level 15 shows roads for orientation and planning in the local neighborhood and zoom level 17 shows buildings to give users on foot a sense of situational awareness.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TileCoordinates
	{
		
		/// <summary>
		/// Required. The x coordinate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="x")]
		public System.Nullable<System.Int32> X { get; set; }
		
		/// <summary>
		/// Required. The y coordinate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="y")]
		public System.Nullable<System.Int32> Y { get; set; }
		
		/// <summary>
		/// Required. The Google Maps API zoom level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zoom")]
		public System.Nullable<System.Int32> Zoom { get; set; }
	}
	
	/// <summary>
	/// Information about the data providers that should be included in the attribution string shown by the client.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ProviderInfo
	{
		
		/// <summary>
		/// Attribution string for this provider. This string is not localized.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum FeatureTileStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATUS_OK = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATUS_OK_DATA_UNCHANGED = 1,
	}
	
	/// <summary>
	/// A packed representation of a 2D grid of uniformly spaced points containing elevation data. Each point within the grid represents the altitude in meters above average sea level at that location within the tile. Elevations provided are (generally) relative to the EGM96 geoid, however some areas will be relative to NAVD88. EGM96 and NAVD88 are off by no more than 2 meters. The grid is oriented north-west to south-east, as illustrated: rows[0].a[0] rows[0].a[m] +-----------------+ | | | N | | ^ | | | | | W <-----> E | | | | | v | | S | | | +-----------------+ rows[n].a[0] rows[n].a[m] Rather than storing the altitudes directly, we store the diffs between them as integers at some requested level of precision to take advantage of integer packing. The actual altitude values a[] can be reconstructed using the scale and each row's first_altitude and altitude_diff fields. More details in go/elevation-encoding-options-for-enduro under "Recommended implementation".
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FirstDerivativeElevationGrid
	{
		
		/// <summary>
		/// A multiplier applied to the altitude fields below to extract the actual altitudes in meters from the elevation grid.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="altitudeMultiplier")]
		public System.Nullable<System.Single> AltitudeMultiplier { get; set; }
		
		/// <summary>
		/// Rows of points containing altitude data making up the elevation grid. Each row is the same length. Rows are ordered from north to south. E.g: rows[0] is the north-most row, and rows[n] is the south-most row.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rows")]
		public Row[] Rows { get; set; }
	}
	
	/// <summary>
	/// A row of altitude points in the elevation grid, ordered from west to east.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Row
	{
		
		/// <summary>
		/// The difference between each successive pair of altitudes, from west to east. The first, westmost point, is just the altitude rather than a diff. The units are specified by the altitude_multiplier parameter above; the value in meters is given by altitude_multiplier * altitude_diffs[n]. The altitude row (in metres above sea level) can be reconstructed with: a[0] = altitude_diffs[0] * altitude_multiplier when n > 0, a[n] = a[n-1] + altitude_diffs[n-1] * altitude_multiplier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="altitudeDiffs")]
		public int[] AltitudeDiffs { get; set; }
	}
	
	/// <summary>
	/// A packed representation of a 2D grid of uniformly spaced points containing elevation data. Each point within the grid represents the altitude in meters above average sea level at that location within the tile. Elevations provided are (generally) relative to the EGM96 geoid, however some areas will be relative to NAVD88. EGM96 and NAVD88 are off by no more than 2 meters. The grid is oriented north-west to south-east, as illustrated: rows[0].a[0] rows[0].a[m] +-----------------+ | | | N | | ^ | | | | | W <-----> E | | | | | v | | S | | | +-----------------+ rows[n].a[0] rows[n].a[m] Rather than storing the altitudes directly, we store the diffs of the diffs between them as integers at some requested level of precision to take advantage of integer packing. Note that the data is packed in such a way that is fast to decode in Unity and that further optimizes wire size.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SecondDerivativeElevationGrid
	{
		
		/// <summary>
		/// A multiplier applied to the elements in the encoded data to extract the actual altitudes in meters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="altitudeMultiplier")]
		public System.Nullable<System.Single> AltitudeMultiplier { get; set; }
		
		/// <summary>
		/// The number of columns included in the encoded elevation data (i.e. the horizontal resolution of the grid).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="columnCount")]
		public System.Nullable<System.Int32> ColumnCount { get; set; }
		
		/// <summary>
		/// A stream of elements each representing a point on the tile running across each row from left to right, top to bottom. There will be precisely horizontal_resolution * vertical_resolution elements in the stream. The elements are not the heights, rather the second order derivative of the values one would expect in a stream of height data. Each element is a varint with the following encoding: ------------------------------------------------------------------------| | Head Nibble | ------------------------------------------------------------------------| | Bit 0 | Bit 1 | Bits 2-3 | | Terminator| Sign (1=neg) | Least significant 2 bits of absolute error | ------------------------------------------------------------------------| | Tail Nibble #1 | ------------------------------------------------------------------------| | Bit 0 | Bit 1-3 | | Terminator| Least significant 3 bits of absolute error | ------------------------------------------------------------------------| | ... | Tail Nibble #n | ------------------------------------------------------------------------| | Bit 0 | Bit 1-3 | | Terminator| Least significant 3 bits of absolute error | ------------------------------------------------------------------------|
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encodedData")]
		public string EncodedData { get; set; }
		
		/// <summary>
		/// The number of rows included in the encoded elevation data (i.e. the vertical resolution of the grid).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rowCount")]
		public System.Nullable<System.Int32> RowCount { get; set; }
	}
	
	/// <summary>
	/// A tile containing information about the terrain located in the region it covers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TerrainTile
	{
		
		/// <summary>
		/// Global tile coordinates. Global tile coordinates reference a specific tile on the map at a specific zoom level. The origin of this coordinate system is always at the northwest corner of the map, with x values increasing from west to east and y values increasing from north to south. Tiles are indexed using x, y coordinates from that origin. The zoom level containing the entire world in a tile is 0, and it increases as you zoom in. Zoom level n + 1 will contain 4 times as many tiles as zoom level n. The zoom level controls the level of detail of the data that is returned. In particular, this affects the set of feature types returned, their density, and geometry simplification. The exact tile contents may change over time, but care will be taken to keep supporting the most important use cases. For example, zoom level 15 shows roads for orientation and planning in the local neighborhood and zoom level 17 shows buildings to give users on foot a sense of situational awareness.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="coordinates")]
		public TileCoordinates Coordinates { get; set; }
		
		/// <summary>
		/// A packed representation of a 2D grid of uniformly spaced points containing elevation data. Each point within the grid represents the altitude in meters above average sea level at that location within the tile. Elevations provided are (generally) relative to the EGM96 geoid, however some areas will be relative to NAVD88. EGM96 and NAVD88 are off by no more than 2 meters. The grid is oriented north-west to south-east, as illustrated: rows[0].a[0] rows[0].a[m] +-----------------+ | | | N | | ^ | | | | | W <-----> E | | | | | v | | S | | | +-----------------+ rows[n].a[0] rows[n].a[m] Rather than storing the altitudes directly, we store the diffs between them as integers at some requested level of precision to take advantage of integer packing. The actual altitude values a[] can be reconstructed using the scale and each row's first_altitude and altitude_diff fields. More details in go/elevation-encoding-options-for-enduro under "Recommended implementation".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firstDerivative")]
		public FirstDerivativeElevationGrid FirstDerivative { get; set; }
		
		/// <summary>
		/// Resource name of the tile. The tile resource name is prefixed by its collection ID `terrain/` followed by the resource ID, which encodes the tile's global x and y coordinates and zoom level as `@,,z`. For example, `terrain/@1,2,3z`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A packed representation of a 2D grid of uniformly spaced points containing elevation data. Each point within the grid represents the altitude in meters above average sea level at that location within the tile. Elevations provided are (generally) relative to the EGM96 geoid, however some areas will be relative to NAVD88. EGM96 and NAVD88 are off by no more than 2 meters. The grid is oriented north-west to south-east, as illustrated: rows[0].a[0] rows[0].a[m] +-----------------+ | | | N | | ^ | | | | | W <-----> E | | | | | v | | S | | | +-----------------+ rows[n].a[0] rows[n].a[m] Rather than storing the altitudes directly, we store the diffs of the diffs between them as integers at some requested level of precision to take advantage of integer packing. Note that the data is packed in such a way that is fast to decode in Unity and that further optimizes wire size.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondDerivative")]
		public SecondDerivativeElevationGrid SecondDerivative { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Gets a terrain tile by its tile resource name.
		/// Vectortile_terraintiles_get v1/{name}
		/// </summary>
		/// <param name="name">Required. Resource name of the tile. The tile resource name is prefixed by its collection ID `terraintiles/` followed by the resource ID, which encodes the tile's global x and y coordinates and zoom level as `@,,z`. For example, `terraintiles/@1,2,3z`.</param>
		/// <param name="altitudePrecisionCentimeters">The precision of terrain altitudes in centimeters. Possible values: between 1 (cm level precision) and 1,000,000 (10-kilometer level precision).</param>
		/// <param name="clientInfo_apiClient">API client name and version. For example, the SDK calling the API. The exact format is up to the client.</param>
		/// <param name="clientInfo_applicationId">Application ID, such as the package name on Android and the bundle identifier on iOS platforms.</param>
		/// <param name="clientInfo_applicationVersion">Application version number, such as "1.2.3". The exact format is application-dependent.</param>
		/// <param name="clientInfo_deviceModel">Device model as reported by the device. The exact format is platform-dependent.</param>
		/// <param name="clientInfo_operatingSystem">Operating system name and version as reported by the OS. For example, "Mac OS X 10.10.4". The exact format is platform-dependent.</param>
		/// <param name="clientInfo_platform">Platform where the application is running.</param>
		/// <param name="clientInfo_userId">Required. A client-generated user ID. The ID should be generated and persisted during the first user session or whenever a pre-existing ID is not found. The exact format is up to the client. This must be non-empty in a GetFeatureTileRequest (whether via the header or GetFeatureTileRequest.client_info).</param>
		/// <param name="maxElevationResolutionCells">The maximum allowed resolution for the returned elevation heightmap. Possible values: between 1 and 1024 (and not less than min_elevation_resolution_cells). Over-sized heightmaps will be non-uniformly down-sampled such that each edge is no longer than this value. Non-uniformity is chosen to maximise the amount of preserved data. For example: Original resolution: 100px (width) * 30px (height) max_elevation_resolution: 30 New resolution: 30px (width) * 30px (height)</param>
		/// <param name="minElevationResolutionCells"> api-linter: core::0131::request-unknown-fields=disabled aip.dev/not-precedent: Maintaining existing request parameter pattern. The minimum allowed resolution for the returned elevation heightmap. Possible values: between 0 and 1024 (and not more than max_elevation_resolution_cells). Zero is supported for backward compatibility. Under-sized heightmaps will be non-uniformly up-sampled such that each edge is no shorter than this value. Non-uniformity is chosen to maximise the amount of preserved data. For example: Original resolution: 30px (width) * 10px (height) min_elevation_resolution: 30 New resolution: 30px (width) * 30px (height)</param>
		/// <param name="terrainFormats">Terrain formats that the client understands.</param>
		/// <param name="enableModeledVolumes">Flag indicating whether 3D building models should be enabled. If this is set structures will be returned as 3D modeled volumes rather than 2.5D extruded areas where possible.</param>
		/// <param name="enablePoliticalFeatures">Flag indicating whether political features should be returned.</param>
		/// <param name="enablePrivateRoads">Flag indicating whether the returned tile will contain road features that are marked private. Private roads are indicated by the Feature.segment_info.road_info.is_private field.</param>
		/// <param name="enableUnclippedBuildings">Flag indicating whether unclipped buildings should be returned. If this is set, building render ops will extend beyond the tile boundary. Buildings will only be returned on the tile that contains their centroid.</param>
		/// <param name="languageCode">Required. The BCP-47 language code corresponding to the language in which the name was requested, such as "en-US" or "sr-Latn". For more information, see http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.</param>
		/// <param name="regionCode">Required. The Unicode country/region code (CLDR) of the location from which the request is coming from, such as "US" and "419". For more information, see http://www.unicode.org/reports/tr35/#unicode_region_subtag.</param>
		/// <returns>Successful response</returns>
		public async Task<TerrainTile> Vectortile_terraintiles_getAsync(
					string name, 
					int altitudePrecisionCentimeters, 
					string clientInfo_apiClient, 
					string clientInfo_applicationId, 
					string clientInfo_applicationVersion, 
					string clientInfo_deviceModel, 
					string clientInfo_operatingSystem, 
					Vectortile_terraintiles_getClientInfo_platform clientInfo_platform, 
					string clientInfo_userId, 
					int maxElevationResolutionCells, 
					int minElevationResolutionCells, 
					string[] terrainFormats, 
					bool enableModeledVolumes, 
					bool enablePoliticalFeatures, 
					bool enablePrivateRoads, 
					bool enableUnclippedBuildings, 
					string languageCode, 
					string regionCode, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&altitudePrecisionCentimeters="+altitudePrecisionCentimeters+"&clientInfo.apiClient=" + (clientInfo_apiClient==null? "" : System.Uri.EscapeDataString(clientInfo_apiClient))+"&clientInfo.applicationId=" + (clientInfo_applicationId==null? "" : System.Uri.EscapeDataString(clientInfo_applicationId))+"&clientInfo.applicationVersion=" + (clientInfo_applicationVersion==null? "" : System.Uri.EscapeDataString(clientInfo_applicationVersion))+"&clientInfo.deviceModel=" + (clientInfo_deviceModel==null? "" : System.Uri.EscapeDataString(clientInfo_deviceModel))+"&clientInfo.operatingSystem=" + (clientInfo_operatingSystem==null? "" : System.Uri.EscapeDataString(clientInfo_operatingSystem))+"&clientInfo.platform=" + clientInfo_platform+"&clientInfo.userId=" + (clientInfo_userId==null? "" : System.Uri.EscapeDataString(clientInfo_userId))+"&maxElevationResolutionCells="+maxElevationResolutionCells+"&minElevationResolutionCells="+minElevationResolutionCells+"&"+string.Join("&", terrainFormats.Select(z => $"terrainFormats={System.Uri.EscapeDataString(z.ToString())}"))+"&enableModeledVolumes="+enableModeledVolumes+"&enablePoliticalFeatures="+enablePoliticalFeatures+"&enablePrivateRoads="+enablePrivateRoads+"&enableUnclippedBuildings="+enableUnclippedBuildings+"&languageCode=" + (languageCode==null? "" : System.Uri.EscapeDataString(languageCode))+"&regionCode=" + (regionCode==null? "" : System.Uri.EscapeDataString(regionCode));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<TerrainTile>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
	}
	
	public enum Vectortile_terraintiles_getClientInfo_platform
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PLATFORM_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EDITOR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MAC_OS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WINDOWS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINUX = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANDROID = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IOS = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEB_GL = 7,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
