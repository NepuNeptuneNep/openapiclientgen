//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BatchGetChannelResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="channels")]
		public Channel[] Channels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public BatchError[] Errors { get; set; }
	}
	
	/// <summary>
	/// Object specifying a channel.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Channel
	{
		
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorized")]
		public System.Nullable<System.Boolean> Authorized { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ingestEndpoint")]
		public string IngestEndpoint { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="insecureIngest")]
		public System.Nullable<System.Boolean> InsecureIngest { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="latencyMode")]
		public ChannelLatencyMode LatencyMode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="playbackUrl")]
		public string PlaybackUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="preset")]
		public TranscodePreset Preset { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="recordingConfigurationArn")]
		public string RecordingConfigurationArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tags Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ChannelType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ChannelLatencyMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NORMAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOW = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum TranscodePreset
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HIGHER_BANDWIDTH_DELIVERY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONSTRAINED_BANDWIDTH_DELIVERY = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Tags
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ChannelType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BASIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STANDARD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADVANCED_SD = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADVANCED_HD = 3,
	}
	
	/// <summary>
	/// Error related to a specific channel, specified by its ARN.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BatchError
	{
		
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BatchGetStreamKeyResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public BatchError[] Errors { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="streamKeys")]
		public StreamKey[] StreamKeys { get; set; }
	}
	
	/// <summary>
	/// Object specifying a stream key.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StreamKey
	{
		
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tags Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BatchStartViewerSessionRevocationResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public BatchStartViewerSessionRevocationError[] Errors { get; set; }
	}
	
	/// <summary>
	/// Error for a request in the batch for BatchStartViewerSessionRevocation. Each error is related to a specific channel-ARN and viewer-ID pair.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BatchStartViewerSessionRevocationError
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="viewerId")]
		public string ViewerId { get; set; }
	}
	
	/// <summary>
	/// A viewer session to revoke in the call to <a>BatchStartViewerSessionRevocation</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BatchStartViewerSessionRevocationViewerSession
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		public string ChannelArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="viewerId")]
		public string ViewerId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="viewerSessionVersionsLessThanOrEqualTo")]
		public System.Nullable<System.Int32> ViewerSessionVersionsLessThanOrEqualTo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AccessDeniedException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ValidationException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PendingVerification
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ThrottlingException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateChannelResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="channel")]
		public Channel Channel { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="streamKey")]
		public StreamKey StreamKey { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ResourceNotFoundException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ServiceQuotaExceededException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateRecordingConfigurationResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="recordingConfiguration")]
		public RecordingConfiguration RecordingConfiguration { get; set; }
	}
	
	/// <summary>
	/// An object representing a configuration to record a channel stream.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RecordingConfiguration
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationConfiguration")]
		public DestinationConfiguration DestinationConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="recordingReconnectWindowSeconds")]
		public System.Nullable<System.Int32> RecordingReconnectWindowSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="renditionConfiguration")]
		public RenditionConfiguration RenditionConfiguration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public RecordingConfigurationState State { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tags Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="thumbnailConfiguration")]
		public ThumbnailConfiguration ThumbnailConfiguration { get; set; }
	}
	
	/// <summary>
	/// A complex type that describes a location where recorded videos will be stored. Each member represents a type of destination configuration. For recording, you define one and only one type of destination configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="s3")]
		public S3DestinationConfiguration S3 { get; set; }
	}
	
	/// <summary>
	/// A complex type that describes an S3 location where recorded videos will be stored.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class S3DestinationConfiguration
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bucketName")]
		public string BucketName { get; set; }
	}
	
	/// <summary>
	/// Object that describes which renditions should be recorded for a stream.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RenditionConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="renditionSelection")]
		public RenditionConfigurationRenditionSelection RenditionSelection { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="renditions")]
		public RenditionConfigurationRendition[] Renditions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RenditionConfigurationRenditionSelection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUSTOM = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RenditionConfigurationRendition
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FULL_HD = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SD = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOWEST_RESOLUTION = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RecordingConfigurationState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATE_FAILED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 2,
	}
	
	/// <summary>
	/// An object representing a configuration of thumbnails for recorded video.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ThumbnailConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="recordingMode")]
		public RecordingMode RecordingMode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public RenditionConfigurationRendition Resolution { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="storage")]
		public ThumbnailConfigurationStorage[] Storage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="targetIntervalSeconds")]
		public System.Nullable<System.Int32> TargetIntervalSeconds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RecordingMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERVAL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ThumbnailConfigurationStorage
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SEQUENTIAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LATEST = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ThumbnailConfigurationResolution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FULL_HD = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SD = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOWEST_RESOLUTION = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InternalServerException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ConflictException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateStreamKeyResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="streamKey")]
		public StreamKey StreamKey { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeletePlaybackKeyPairResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetChannelResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="channel")]
		public Channel Channel { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetPlaybackKeyPairResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="keyPair")]
		public PlaybackKeyPair KeyPair { get; set; }
	}
	
	/// <summary>
	/// A key pair used to sign and validate a playback authorization token.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PlaybackKeyPair
	{
		
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tags Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetRecordingConfigurationResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="recordingConfiguration")]
		public RecordingConfiguration RecordingConfiguration { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetStreamResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="stream")]
		public Stream Stream { get; set; }
	}
	
	/// <summary>
	/// Specifies a live video stream that has been ingested and distributed.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Stream
	{
		
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="health")]
		public StreamHealth Health { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="playbackUrl")]
		public string PlaybackUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="state")]
		public StreamState State { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="streamId")]
		public string StreamId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="viewerCount")]
		public System.Nullable<System.Int32> ViewerCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum StreamHealth
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HEALTHY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARVING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum StreamState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OFFLINE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ChannelNotBroadcasting
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetStreamKeyResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="streamKey")]
		public StreamKey StreamKey { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetStreamSessionResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="streamSession")]
		public StreamSession StreamSession { get; set; }
	}
	
	/// <summary>
	/// Object that captures the Amazon IVS configuration that the customer provisioned, the ingest configurations that the broadcaster used, and the most recent Amazon IVS stream events it encountered.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StreamSession
	{
		
		[System.Runtime.Serialization.DataMember(Name="channel")]
		public Channel Channel { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ingestConfiguration")]
		public IngestConfiguration IngestConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="recordingConfiguration")]
		public RecordingConfiguration RecordingConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="streamId")]
		public string StreamId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="truncatedEvents")]
		public StreamEvent[] TruncatedEvents { get; set; }
	}
	
	/// <summary>
	/// Object specifying the ingest configuration set up by the broadcaster, usually in an encoder.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IngestConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="audio")]
		public AudioConfiguration Audio { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="video")]
		public VideoConfiguration Video { get; set; }
	}
	
	/// <summary>
	/// Object specifying a stream’s audio configuration, as set up by the broadcaster (usually in an encoder). This is part of the <a>IngestConfiguration</a> object and used for monitoring stream health.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AudioConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="channels")]
		public System.Nullable<System.Int32> Channels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="codec")]
		public string Codec { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sampleRate")]
		public System.Nullable<System.Int32> SampleRate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="targetBitrate")]
		public System.Nullable<System.Int32> TargetBitrate { get; set; }
	}
	
	/// <summary>
	/// Object specifying a stream’s video configuration, as set up by the broadcaster (usually in an encoder). This is part of the <a>IngestConfiguration</a> object and used for monitoring stream health.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VideoConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="avcLevel")]
		public string AvcLevel { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="avcProfile")]
		public string AvcProfile { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="codec")]
		public string Codec { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="encoder")]
		public string Encoder { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="targetBitrate")]
		public System.Nullable<System.Int32> TargetBitrate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="targetFramerate")]
		public System.Nullable<System.Int32> TargetFramerate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="videoHeight")]
		public System.Nullable<System.Int32> VideoHeight { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="videoWidth")]
		public System.Nullable<System.Int32> VideoWidth { get; set; }
	}
	
	/// <summary>
	/// Object specifying a stream’s events. For a list of events, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/eventbridge.html">Using Amazon EventBridge with Amazon IVS</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StreamEvent
	{
		
		[System.Runtime.Serialization.DataMember(Name="eventTime")]
		public System.DateTimeOffset EventTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ImportPlaybackKeyPairResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="keyPair")]
		public PlaybackKeyPair KeyPair { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListChannelsResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channels")]
		public ChannelSummary[] Channels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Summary information about a channel.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ChannelSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorized")]
		public System.Nullable<System.Boolean> Authorized { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="insecureIngest")]
		public System.Nullable<System.Boolean> InsecureIngest { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="latencyMode")]
		public ChannelLatencyMode LatencyMode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="preset")]
		public TranscodePreset Preset { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="recordingConfigurationArn")]
		public string RecordingConfigurationArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tags Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ChannelType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListPlaybackKeyPairsResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keyPairs")]
		public PlaybackKeyPairSummary[] KeyPairs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Summary information about a playback key pair.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PlaybackKeyPairSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tags Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListRecordingConfigurationsResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="recordingConfigurations")]
		public RecordingConfigurationSummary[] RecordingConfigurations { get; set; }
	}
	
	/// <summary>
	/// Summary information about a RecordingConfiguration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RecordingConfigurationSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationConfiguration")]
		public DestinationConfiguration DestinationConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public RecordingConfigurationState State { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tags Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListStreamKeysResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="streamKeys")]
		public StreamKeySummary[] StreamKeys { get; set; }
	}
	
	/// <summary>
	/// Summary information about a stream key.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StreamKeySummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tags Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListStreamSessionsResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="streamSessions")]
		public StreamSessionSummary[] StreamSessions { get; set; }
	}
	
	/// <summary>
	/// Summary information about a stream session.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StreamSessionSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hasErrorEvent")]
		public System.Nullable<System.Boolean> HasErrorEvent { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="streamId")]
		public string StreamId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListStreamsResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="streams")]
		public StreamSummary[] Streams { get; set; }
	}
	
	/// <summary>
	/// Summary information about a stream.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StreamSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="health")]
		public StreamHealth Health { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="state")]
		public StreamState State { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="streamId")]
		public string StreamId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="viewerCount")]
		public System.Nullable<System.Int32> ViewerCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListTagsForResourceResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tags Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StartViewerSessionRevocationResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StopStreamResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StreamUnavailable
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TagResourceResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UntagResourceResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateChannelResponse
	{
		
		/// <summary>
		/// Object specifying a channel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="channel")]
		public Channel Channel { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BatchGetChannelRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arns")]
		public string[] Arns { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BatchGetStreamKeyRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arns")]
		public string[] Arns { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BatchStartViewerSessionRevocationRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="viewerSessions")]
		public BatchStartViewerSessionRevocationViewerSession[] ViewerSessions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateChannelRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="authorized")]
		public System.Nullable<System.Boolean> Authorized { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="insecureIngest")]
		public System.Nullable<System.Boolean> InsecureIngest { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="latencyMode")]
		public ChannelLatencyMode LatencyMode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="preset")]
		public TranscodePreset Preset { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="recordingConfigurationArn")]
		public string RecordingConfigurationArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tags Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ChannelType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateRecordingConfigurationRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationConfiguration")]
		public DestinationConfiguration DestinationConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="recordingReconnectWindowSeconds")]
		public System.Nullable<System.Int32> RecordingReconnectWindowSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="renditionConfiguration")]
		public RenditionConfiguration RenditionConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tags Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="thumbnailConfiguration")]
		public ThumbnailConfiguration ThumbnailConfiguration { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateStreamKeyRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tags Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteChannelRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeletePlaybackKeyPairRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteRecordingConfigurationRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteStreamKeyRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetChannelRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetPlaybackKeyPairRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetRecordingConfigurationRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetStreamKeyRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetStreamRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		public string ChannelArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetStreamSessionRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="streamId")]
		public string StreamId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ImportPlaybackKeyPairRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="publicKeyMaterial")]
		public string PublicKeyMaterial { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tags Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListChannelsRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="filterByName")]
		public string FilterByName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="filterByRecordingConfigurationArn")]
		public string FilterByRecordingConfigurationArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListPlaybackKeyPairsRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListRecordingConfigurationsRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListStreamKeysRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListStreamSessionsRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Object specifying the stream attribute on which to filter.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StreamFilters
	{
		
		[System.Runtime.Serialization.DataMember(Name="health")]
		public StreamHealth Health { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListStreamsRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="filterBy")]
		public StreamFilters FilterBy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListTagsForResourceRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PutMetadataRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		public string ChannelArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StartViewerSessionRevocationRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		public string ChannelArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="viewerId")]
		public string ViewerId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="viewerSessionVersionsLessThanOrEqualTo")]
		public System.Nullable<System.Int32> ViewerSessionVersionsLessThanOrEqualTo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StopStreamRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		public string ChannelArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TagResourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tags Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UntagResourceRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateChannelRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorized")]
		public System.Nullable<System.Boolean> Authorized { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="insecureIngest")]
		public System.Nullable<System.Boolean> InsecureIngest { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="latencyMode")]
		public ChannelLatencyMode LatencyMode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="preset")]
		public TranscodePreset Preset { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="recordingConfigurationArn")]
		public string RecordingConfigurationArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ChannelType Type { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Performs <a>GetChannel</a> on multiple ARNs simultaneously.
		/// BatchGetChannel BatchGetChannel
		/// </summary>
		/// <returns>Success</returns>
		public async Task<BatchGetChannelResponse> BatchGetChannelAsync(BatchGetChannelPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "BatchGetChannel";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<BatchGetChannelResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Performs <a>GetStreamKey</a> on multiple ARNs simultaneously.
		/// BatchGetStreamKey BatchGetStreamKey
		/// </summary>
		/// <returns>Success</returns>
		public async Task<BatchGetStreamKeyResponse> BatchGetStreamKeyAsync(BatchGetStreamKeyPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "BatchGetStreamKey";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<BatchGetStreamKeyResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Performs <a>StartViewerSessionRevocation</a> on multiple channel ARN and viewer ID pairs simultaneously.
		/// BatchStartViewerSessionRevocation BatchStartViewerSessionRevocation
		/// </summary>
		/// <returns>Success</returns>
		public async Task<BatchStartViewerSessionRevocationResponse> BatchStartViewerSessionRevocationAsync(BatchStartViewerSessionRevocationPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "BatchStartViewerSessionRevocation";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<BatchStartViewerSessionRevocationResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Creates a new channel and an associated stream key to start streaming.
		/// CreateChannel CreateChannel
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateChannelResponse> CreateChannelAsync(CreateChannelPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "CreateChannel";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<CreateChannelResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// <p>Creates a new recording configuration, used to enable recording to Amazon S3.</p> <p> <b>Known issue:</b> In the us-east-1 region, if you use the Amazon Web Services CLI to create a recording configuration, it returns success even if the S3 bucket is in a different region. In this case, the <code>state</code> of the recording configuration is <code>CREATE_FAILED</code> (instead of <code>ACTIVE</code>). (In other regions, the CLI correctly returns failure if the bucket is in a different region.)</p> <p> <b>Workaround:</b> Ensure that your S3 bucket is in the same region as the recording configuration. If you create a recording configuration in a different region as your S3 bucket, delete that recording configuration and create a new one with an S3 bucket from the correct region.</p>
		/// CreateRecordingConfiguration CreateRecordingConfiguration
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateRecordingConfigurationResponse> CreateRecordingConfigurationAsync(CreateRecordingConfigurationPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "CreateRecordingConfiguration";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<CreateRecordingConfigurationResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// <p>Creates a stream key, used to initiate a stream, for the specified channel ARN.</p> <p>Note that <a>CreateChannel</a> creates a stream key. If you subsequently use CreateStreamKey on the same channel, it will fail because a stream key already exists and there is a limit of 1 stream key per channel. To reset the stream key on a channel, use <a>DeleteStreamKey</a> and then CreateStreamKey.</p>
		/// CreateStreamKey CreateStreamKey
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateStreamKeyResponse> CreateStreamKeyAsync(CreateStreamKeyPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "CreateStreamKey";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<CreateStreamKeyResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// <p>Deletes the specified channel and its associated stream keys.</p> <p>If you try to delete a live channel, you will get an error (409 ConflictException). To delete a channel that is live, call <a>StopStream</a>, wait for the Amazon EventBridge "Stream End" event (to verify that the stream's state is no longer Live), then call DeleteChannel. (See <a href="https://docs.aws.amazon.com/ivs/latest/userguide/eventbridge.html"> Using EventBridge with Amazon IVS</a>.) </p>
		/// DeleteChannel DeleteChannel
		/// </summary>
		public async Task DeleteChannelAsync(DeleteChannelPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "DeleteChannel";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Deletes a specified authorization key pair. This invalidates future viewer tokens generated using the key pair’s <code>privateKey</code>. For more information, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Setting Up Private Channels</a> in the <i>Amazon IVS User Guide</i>.
		/// DeletePlaybackKeyPair DeletePlaybackKeyPair
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeletePlaybackKeyPairResponse> DeletePlaybackKeyPairAsync(DeletePlaybackKeyPairPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "DeletePlaybackKeyPair";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DeletePlaybackKeyPairResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// <p>Deletes the recording configuration for the specified ARN.</p> <p>If you try to delete a recording configuration that is associated with a channel, you will get an error (409 ConflictException). To avoid this, for all channels that reference the recording configuration, first use <a>UpdateChannel</a> to set the <code>recordingConfigurationArn</code> field to an empty string, then use DeleteRecordingConfiguration.</p>
		/// DeleteRecordingConfiguration DeleteRecordingConfiguration
		/// </summary>
		public async Task DeleteRecordingConfigurationAsync(DeleteRecordingConfigurationPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "DeleteRecordingConfiguration";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Deletes the stream key for the specified ARN, so it can no longer be used to stream.
		/// DeleteStreamKey DeleteStreamKey
		/// </summary>
		public async Task DeleteStreamKeyAsync(DeleteStreamKeyPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "DeleteStreamKey";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets the channel configuration for the specified channel ARN. See also <a>BatchGetChannel</a>.
		/// GetChannel GetChannel
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetChannelResponse> GetChannelAsync(GetChannelPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "GetChannel";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetChannelResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets a specified playback authorization key pair and returns the <code>arn</code> and <code>fingerprint</code>. The <code>privateKey</code> held by the caller can be used to generate viewer authorization tokens, to grant viewers access to private channels. For more information, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Setting Up Private Channels</a> in the <i>Amazon IVS User Guide</i>.
		/// GetPlaybackKeyPair GetPlaybackKeyPair
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetPlaybackKeyPairResponse> GetPlaybackKeyPairAsync(GetPlaybackKeyPairPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "GetPlaybackKeyPair";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetPlaybackKeyPairResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets the recording configuration for the specified ARN.
		/// GetRecordingConfiguration GetRecordingConfiguration
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetRecordingConfigurationResponse> GetRecordingConfigurationAsync(GetRecordingConfigurationPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "GetRecordingConfiguration";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetRecordingConfigurationResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets information about the active (live) stream on a specified channel.
		/// GetStream GetStream
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetStreamResponse> GetStreamAsync(GetStreamPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "GetStream";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetStreamResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets stream-key information for a specified ARN.
		/// GetStreamKey GetStreamKey
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetStreamKeyResponse> GetStreamKeyAsync(GetStreamKeyPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "GetStreamKey";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetStreamKeyResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets metadata on a specified stream.
		/// GetStreamSession GetStreamSession
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetStreamSessionResponse> GetStreamSessionAsync(GetStreamSessionPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "GetStreamSession";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetStreamSessionResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Imports the public portion of a new key pair and returns its <code>arn</code> and <code>fingerprint</code>. The <code>privateKey</code> can then be used to generate viewer authorization tokens, to grant viewers access to private channels. For more information, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Setting Up Private Channels</a> in the <i>Amazon IVS User Guide</i>.
		/// ImportPlaybackKeyPair ImportPlaybackKeyPair
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ImportPlaybackKeyPairResponse> ImportPlaybackKeyPairAsync(ImportPlaybackKeyPairPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ImportPlaybackKeyPair";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ImportPlaybackKeyPairResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets summary information about all channels in your account, in the Amazon Web Services region where the API request is processed. This list can be filtered to match a specified name or recording-configuration ARN. Filters are mutually exclusive and cannot be used together. If you try to use both filters, you will get an error (409 ConflictException).
		/// ListChannels ListChannels
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListChannelsResponse> ListChannelsAsync(string maxResults, string nextToken, ListChannelsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ListChannels?maxResults=" + (maxResults==null? "" : System.Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ListChannelsResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets summary information about playback key pairs. For more information, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Setting Up Private Channels</a> in the <i>Amazon IVS User Guide</i>.
		/// ListPlaybackKeyPairs ListPlaybackKeyPairs
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListPlaybackKeyPairsResponse> ListPlaybackKeyPairsAsync(string maxResults, string nextToken, ListPlaybackKeyPairsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ListPlaybackKeyPairs?maxResults=" + (maxResults==null? "" : System.Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ListPlaybackKeyPairsResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets summary information about all recording configurations in your account, in the Amazon Web Services region where the API request is processed.
		/// ListRecordingConfigurations ListRecordingConfigurations
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListRecordingConfigurationsResponse> ListRecordingConfigurationsAsync(string maxResults, string nextToken, ListRecordingConfigurationsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ListRecordingConfigurations?maxResults=" + (maxResults==null? "" : System.Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ListRecordingConfigurationsResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets summary information about stream keys for the specified channel.
		/// ListStreamKeys ListStreamKeys
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListStreamKeysResponse> ListStreamKeysAsync(string maxResults, string nextToken, ListStreamKeysPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ListStreamKeys?maxResults=" + (maxResults==null? "" : System.Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ListStreamKeysResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets a summary of current and previous streams for a specified channel in your account, in the AWS region where the API request is processed.
		/// ListStreamSessions ListStreamSessions
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListStreamSessionsResponse> ListStreamSessionsAsync(string maxResults, string nextToken, ListStreamSessionsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ListStreamSessions?maxResults=" + (maxResults==null? "" : System.Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ListStreamSessionsResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets summary information about live streams in your account, in the Amazon Web Services region where the API request is processed.
		/// ListStreams ListStreams
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListStreamsResponse> ListStreamsAsync(string maxResults, string nextToken, ListStreamsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ListStreams?maxResults=" + (maxResults==null? "" : System.Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ListStreamsResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets information about Amazon Web Services tags for the specified ARN.
		/// ListTagsForResource tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">The ARN of the resource to be retrieved. The ARN must be URL-encoded.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceResponse> ListTagsForResourceAsync(string resourceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ListTagsForResourceResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Adds or updates tags for the Amazon Web Services resource with the specified ARN.
		/// TagResource tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">ARN of the resource for which tags are to be added or updated. The ARN must be URL-encoded.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <returns>Success</returns>
		public async Task<TagResourceResponse> TagResourceAsync(string resourceArn, TagResourcePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<TagResourceResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Inserts metadata into the active stream of the specified channel. At most 5 requests per second per channel are allowed, each with a maximum 1 KB payload. (If 5 TPS is not sufficient for your needs, we recommend batching your data into a single PutMetadata call.) At most 155 requests per second per account are allowed. Also see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/metadata.html">Embedding Metadata within a Video Stream</a> in the <i>Amazon IVS User Guide</i>.
		/// PutMetadata PutMetadata
		/// </summary>
		public async Task PutMetadataAsync(PutMetadataPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "PutMetadata";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Starts the process of revoking the viewer session associated with a specified channel ARN and viewer ID. Optionally, you can provide a version to revoke viewer sessions less than and including that version. For instructions on associating a viewer ID with a viewer session, see <a href="https://docs.aws.amazon.com/ivs/latest/userguide/private-channels.html">Setting Up Private Channels</a>.
		/// StartViewerSessionRevocation StartViewerSessionRevocation
		/// </summary>
		/// <returns>Success</returns>
		public async Task<StartViewerSessionRevocationResponse> StartViewerSessionRevocationAsync(StartViewerSessionRevocationPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "StartViewerSessionRevocation";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<StartViewerSessionRevocationResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// <p>Disconnects the incoming RTMPS stream for the specified channel. Can be used in conjunction with <a>DeleteStreamKey</a> to prevent further streaming to a channel.</p> <note> <p>Many streaming client-software libraries automatically reconnect a dropped RTMPS session, so to stop the stream permanently, you may want to first revoke the <code>streamKey</code> attached to the channel.</p> </note>
		/// StopStream StopStream
		/// </summary>
		/// <returns>Success</returns>
		public async Task<StopStreamResponse> StopStreamAsync(StopStreamPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "StopStream";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<StopStreamResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Removes tags from the resource with the specified ARN.
		/// UntagResource tags/{resourceArn}#tagKeys
		/// </summary>
		/// <param name="resourceArn">ARN of the resource for which tags are to be removed. The ARN must be URL-encoded.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="tagKeys">Array of tags to be removed. Array of maps, each of the form s<code>tring:string (key:value)</code>. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services Resources</a> for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
		/// Minimum items: 0
		/// Maximum items: 50
		// </param>
		/// <returns>Success</returns>
		public async Task<UntagResourceResponse> UntagResourceAsync(string resourceArn, string[] tagKeys, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn))+"#tagKeys&"+string.Join("&", tagKeys.Select(z => $"tagKeys={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UntagResourceResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates a channel's configuration. Live channels cannot be updated. You must stop the ongoing stream, update the channel, and restart the stream for the changes to take effect.
		/// UpdateChannel UpdateChannel
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateChannelResponse> UpdateChannelAsync(UpdateChannelPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "UpdateChannel";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateChannelResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
	}
	
	public class BatchGetChannelPostBody
	{
		
		/// <summary>
		/// Array of ARNs, one per channel.
		/// Required
		/// Minimum items: 1
		/// Maximum items: 50
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string[] Arns { get; set; }
	}
	
	public class BatchGetStreamKeyPostBody
	{
		
		/// <summary>
		/// Array of ARNs, one per stream key.
		/// Required
		/// Minimum items: 1
		/// Maximum items: 50
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string[] Arns { get; set; }
	}
	
	public class BatchStartViewerSessionRevocationPostBody
	{
		
		/// <summary>
		/// Array of viewer sessions, one per channel-ARN and viewer-ID pair.
		/// Required
		/// Minimum items: 1
		/// Maximum items: 20
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="viewerSessions")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(20)]
		public BatchStartViewerSessionRevocationViewerSession[] ViewerSessions { get; set; }
	}
	
	public class CreateChannelPostBody
	{
		
		/// <summary>
		/// Whether the channel is private (enabled for playback authorization). Default: <code>false</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorized")]
		public System.Nullable<System.Boolean> Authorized { get; set; }
		
		/// <summary>
		/// Whether the channel allows insecure RTMP ingest. Default: <code>false</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="insecureIngest")]
		public System.Nullable<System.Boolean> InsecureIngest { get; set; }
		
		/// <summary>
		/// Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. (Note: In the Amazon IVS console, <code>LOW</code> and <code>NORMAL</code> correspond to Ultra-low and Standard, respectively.) Default: <code>LOW</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latencyMode")]
		public ChannelLatencyMode LatencyMode { get; set; }
		
		/// <summary>
		/// Channel name.
		/// Min length: 0
		/// Max length: 128
		/// Pattern: ^[a-zA-Z0-9-_]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9-_]*$")]
		public string Name { get; set; }
		
		/// <summary>
		/// Optional transcode preset for the channel. This is selectable only for <code>ADVANCED_HD</code> and <code>ADVANCED_SD</code> channel types. For those channel types, the default <code>preset</code> is <code>HIGHER_BANDWIDTH_DELIVERY</code>. For other channel types (<code>BASIC</code> and <code>STANDARD</code>), <code>preset</code> is the empty string (<code>""</code>).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preset")]
		public TranscodePreset Preset { get; set; }
		
		/// <summary>
		/// Recording-configuration ARN. Default: "" (empty string, recording is disabled).
		/// Min length: 0
		/// Max length: 128
		/// Pattern: ^$|^arn:aws:ivs:[a-z0-9-]+:[0-9]+:recording-configuration/[a-zA-Z0-9-]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recordingConfigurationArn")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^$|^arn:aws:ivs:[a-z0-9-]+:[0-9]+:recording-configuration/[a-zA-Z0-9-]+$")]
		public string RecordingConfigurationArn { get; set; }
		
		/// <summary>
		/// Array of 1-50 maps, each of the form <code>string:string (key:value)</code>. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services Resources</a> for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
		
		/// <summary>
		/// <p>Channel type, which determines the allowable resolution and bitrate. <i>If you exceed the allowable input resolution or bitrate, the stream probably will disconnect immediately.</i> Some types generate multiple qualities (renditions) from the original input; this automatically gives viewers the best experience for their devices and network conditions. Some types provide transcoded video; transcoding allows higher playback quality across a range of download speeds. Default: <code>STANDARD</code>. Valid values:</p> <ul> <li> <p> <code>BASIC</code>: Video is transmuxed: Amazon IVS delivers the original input quality to viewers. The viewer’s video-quality choice is limited to the original input. Input resolution can be up to 1080p and bitrate can be up to 1.5 Mbps for 480p and up to 3.5 Mbps for resolutions between 480p and 1080p. Original audio is passed through.</p> </li> <li> <p> <code>STANDARD</code>: Video is transcoded: multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Transcoding allows higher playback quality across a range of download speeds. Resolution can be up to 1080p and bitrate can be up to 8.5 Mbps. Audio is transcoded only for renditions 360p and below; above that, audio is passed through. This is the default when you create a channel.</p> </li> <li> <p> <code>ADVANCED_SD</code>: Video is transcoded; multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Input resolution can be up to 1080p and bitrate can be up to 8.5 Mbps; output is capped at SD quality (480p). You can select an optional transcode preset (see below). Audio for all renditions is transcoded, and an audio-only rendition is available.</p> </li> <li> <p> <code>ADVANCED_HD</code>: Video is transcoded; multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Input resolution can be up to 1080p and bitrate can be up to 8.5 Mbps; output is capped at HD quality (720p). You can select an optional transcode preset (see below). Audio for all renditions is transcoded, and an audio-only rendition is available.</p> </li> </ul> <p>Optional <i>transcode presets</i> (available for the <code>ADVANCED</code> types) allow you to trade off available download bandwidth and video quality, to optimize the viewing experience. There are two presets:</p> <ul> <li> <p> <i>Constrained bandwidth delivery</i> uses a lower bitrate for each quality level. Use it if you have low download bandwidth and/or simple video content (e.g., talking heads)</p> </li> <li> <p> <i>Higher bandwidth delivery</i> uses a higher bitrate for each quality level. Use it if you have high download bandwidth and/or complex video content (e.g., flashes and quick scene changes).</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ChannelType Type { get; set; }
	}
	
	public class CreateRecordingConfigurationPostBody
	{
		
		/// <summary>
		/// A complex type that describes a location where recorded videos will be stored. Each member represents a type of destination configuration. For recording, you define one and only one type of destination configuration.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationConfiguration")]
		public CreateRecordingConfigurationPostBodyDestinationConfiguration DestinationConfiguration { get; set; }
		
		/// <summary>
		/// Recording-configuration name. The value does not need to be unique.
		/// Min length: 0
		/// Max length: 128
		/// Pattern: ^[a-zA-Z0-9-_]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9-_]*$")]
		public string Name { get; set; }
		
		/// <summary>
		/// If a broadcast disconnects and then reconnects within the specified interval, the multiple streams will be considered a single broadcast and merged together. Default: 0.
		/// Minimum: 0
		/// Maximum: 300
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recordingReconnectWindowSeconds")]
		[System.ComponentModel.DataAnnotations.Range(0, 300)]
		public System.Nullable<System.Int32> RecordingReconnectWindowSeconds { get; set; }
		
		/// <summary>
		/// Object that describes which renditions should be recorded for a stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="renditionConfiguration")]
		public CreateRecordingConfigurationPostBodyRenditionConfiguration RenditionConfiguration { get; set; }
		
		/// <summary>
		/// Array of 1-50 maps, each of the form <code>string:string (key:value)</code>. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services Resources</a> for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
		
		/// <summary>
		/// An object representing a configuration of thumbnails for recorded video.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thumbnailConfiguration")]
		public CreateRecordingConfigurationPostBodyThumbnailConfiguration ThumbnailConfiguration { get; set; }
	}
	
	public class CreateRecordingConfigurationPostBodyDestinationConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="s3")]
		public S3DestinationConfiguration S3 { get; set; }
	}
	
	public class CreateRecordingConfigurationPostBodyRenditionConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="renditionSelection")]
		public RenditionConfigurationRenditionSelection RenditionSelection { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="renditions")]
		public RenditionConfigurationRendition[] Renditions { get; set; }
	}
	
	public class CreateRecordingConfigurationPostBodyThumbnailConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="recordingMode")]
		public RecordingMode RecordingMode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public RenditionConfigurationRendition Resolution { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="storage")]
		public ThumbnailConfigurationStorage[] Storage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="targetIntervalSeconds")]
		public System.Nullable<System.Int32> TargetIntervalSeconds { get; set; }
	}
	
	public class CreateStreamKeyPostBody
	{
		
		/// <summary>
		/// ARN of the channel for which to create the stream key.
		/// Required
		/// Min length: 1
		/// Max length: 128
		/// Pattern: ^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")]
		public string ChannelArn { get; set; }
		
		/// <summary>
		/// Array of 1-50 maps, each of the form <code>string:string (key:value)</code>. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services Resources</a> for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public class DeleteChannelPostBody
	{
		
		/// <summary>
		/// ARN of the channel to be deleted.
		/// Required
		/// Min length: 1
		/// Max length: 128
		/// Pattern: ^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")]
		public string Arn { get; set; }
	}
	
	public class DeletePlaybackKeyPairPostBody
	{
		
		/// <summary>
		/// ARN of the key pair to be deleted.
		/// Required
		/// Min length: 1
		/// Max length: 128
		/// Pattern: ^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:playback-key/[a-zA-Z0-9-]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:playback-key/[a-zA-Z0-9-]+$")]
		public string Arn { get; set; }
	}
	
	public class DeleteRecordingConfigurationPostBody
	{
		
		/// <summary>
		/// ARN of the recording configuration to be deleted.
		/// Required
		/// Min length: 0
		/// Max length: 128
		/// Pattern: ^arn:aws:ivs:[a-z0-9-]+:[0-9]+:recording-configuration/[a-zA-Z0-9-]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws:ivs:[a-z0-9-]+:[0-9]+:recording-configuration/[a-zA-Z0-9-]+$")]
		public string Arn { get; set; }
	}
	
	public class DeleteStreamKeyPostBody
	{
		
		/// <summary>
		/// ARN of the stream key to be deleted.
		/// Required
		/// Min length: 1
		/// Max length: 128
		/// Pattern: ^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:stream-key/[a-zA-Z0-9-]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:stream-key/[a-zA-Z0-9-]+$")]
		public string Arn { get; set; }
	}
	
	public class GetChannelPostBody
	{
		
		/// <summary>
		/// ARN of the channel for which the configuration is to be retrieved.
		/// Required
		/// Min length: 1
		/// Max length: 128
		/// Pattern: ^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")]
		public string Arn { get; set; }
	}
	
	public class GetPlaybackKeyPairPostBody
	{
		
		/// <summary>
		/// ARN of the key pair to be returned.
		/// Required
		/// Min length: 1
		/// Max length: 128
		/// Pattern: ^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:playback-key/[a-zA-Z0-9-]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:playback-key/[a-zA-Z0-9-]+$")]
		public string Arn { get; set; }
	}
	
	public class GetRecordingConfigurationPostBody
	{
		
		/// <summary>
		/// ARN of the recording configuration to be retrieved.
		/// Required
		/// Min length: 0
		/// Max length: 128
		/// Pattern: ^arn:aws:ivs:[a-z0-9-]+:[0-9]+:recording-configuration/[a-zA-Z0-9-]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws:ivs:[a-z0-9-]+:[0-9]+:recording-configuration/[a-zA-Z0-9-]+$")]
		public string Arn { get; set; }
	}
	
	public class GetStreamPostBody
	{
		
		/// <summary>
		/// Channel ARN for stream to be accessed.
		/// Required
		/// Min length: 1
		/// Max length: 128
		/// Pattern: ^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")]
		public string ChannelArn { get; set; }
	}
	
	public class GetStreamKeyPostBody
	{
		
		/// <summary>
		/// ARN for the stream key to be retrieved.
		/// Required
		/// Min length: 1
		/// Max length: 128
		/// Pattern: ^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:stream-key/[a-zA-Z0-9-]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:stream-key/[a-zA-Z0-9-]+$")]
		public string Arn { get; set; }
	}
	
	public class GetStreamSessionPostBody
	{
		
		/// <summary>
		/// ARN of the channel resource
		/// Required
		/// Min length: 1
		/// Max length: 128
		/// Pattern: ^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")]
		public string ChannelArn { get; set; }
		
		/// <summary>
		/// Unique identifier for a live or previously live stream in the specified channel. If no <code>streamId</code> is provided, this returns the most recent stream session for the channel, if it exists.
		/// Min length: 26
		/// Max length: 26
		/// Pattern: ^st-[a-zA-Z0-9]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="streamId")]
		[System.ComponentModel.DataAnnotations.MinLength(26)]
		[System.ComponentModel.DataAnnotations.MaxLength(26)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^st-[a-zA-Z0-9]+$")]
		public string StreamId { get; set; }
	}
	
	public class ImportPlaybackKeyPairPostBody
	{
		
		/// <summary>
		/// Playback-key-pair name. The value does not need to be unique.
		/// Min length: 0
		/// Max length: 128
		/// Pattern: ^[a-zA-Z0-9-_]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9-_]*$")]
		public string Name { get; set; }
		
		/// <summary>
		/// The public portion of a customer-generated key pair.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="publicKeyMaterial")]
		public string PublicKeyMaterial { get; set; }
		
		/// <summary>
		/// Any tags provided with the request are added to the playback key pair tags. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services Resources</a> for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public class ListChannelsPostBody
	{
		
		/// <summary>
		/// Filters the channel list to match the specified name.
		/// Min length: 0
		/// Max length: 128
		/// Pattern: ^[a-zA-Z0-9-_]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filterByName")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9-_]*$")]
		public string FilterByName { get; set; }
		
		/// <summary>
		/// Filters the channel list to match the specified recording-configuration ARN.
		/// Min length: 0
		/// Max length: 128
		/// Pattern: ^$|^arn:aws:ivs:[a-z0-9-]+:[0-9]+:recording-configuration/[a-zA-Z0-9-]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filterByRecordingConfigurationArn")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^$|^arn:aws:ivs:[a-z0-9-]+:[0-9]+:recording-configuration/[a-zA-Z0-9-]+$")]
		public string FilterByRecordingConfigurationArn { get; set; }
		
		/// <summary>
		/// Maximum number of channels to return. Default: 100.
		/// Minimum: 1
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		[System.ComponentModel.DataAnnotations.Range(1, 100)]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		/// <summary>
		/// The first channel to retrieve. This is used for pagination; see the <code>nextToken</code> response field.
		/// Min length: 0
		/// Max length: 1024
		/// Pattern: ^[a-zA-Z0-9+/=_-]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(1024)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9+/=_-]*$")]
		public string NextToken { get; set; }
	}
	
	public class ListPlaybackKeyPairsPostBody
	{
		
		/// <summary>
		/// Maximum number of key pairs to return. Default: your service quota or 100, whichever is smaller.
		/// Minimum: 1
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		[System.ComponentModel.DataAnnotations.Range(1, 100)]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		/// <summary>
		/// The first key pair to retrieve. This is used for pagination; see the <code>nextToken</code> response field.
		/// Min length: 0
		/// Max length: 1024
		/// Pattern: ^[a-zA-Z0-9+/=_-]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(1024)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9+/=_-]*$")]
		public string NextToken { get; set; }
	}
	
	public class ListRecordingConfigurationsPostBody
	{
		
		/// <summary>
		/// Maximum number of recording configurations to return. Default: your service quota or 100, whichever is smaller. 
		/// Minimum: 1
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		[System.ComponentModel.DataAnnotations.Range(1, 100)]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		/// <summary>
		/// The first recording configuration to retrieve. This is used for pagination; see the <code>nextToken</code> response field.
		/// Min length: 0
		/// Max length: 1024
		/// Pattern: ^[a-zA-Z0-9+/=_-]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(1024)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9+/=_-]*$")]
		public string NextToken { get; set; }
	}
	
	public class ListStreamKeysPostBody
	{
		
		/// <summary>
		/// Channel ARN used to filter the list.
		/// Required
		/// Min length: 1
		/// Max length: 128
		/// Pattern: ^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")]
		public string ChannelArn { get; set; }
		
		/// <summary>
		/// Maximum number of streamKeys to return. Default: 1.
		/// Minimum: 1
		/// Maximum: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		[System.ComponentModel.DataAnnotations.Range(1, 50)]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		/// <summary>
		/// The first stream key to retrieve. This is used for pagination; see the <code>nextToken</code> response field.
		/// Min length: 0
		/// Max length: 1024
		/// Pattern: ^[a-zA-Z0-9+/=_-]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(1024)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9+/=_-]*$")]
		public string NextToken { get; set; }
	}
	
	public class ListStreamSessionsPostBody
	{
		
		/// <summary>
		/// Channel ARN used to filter the list.
		/// Required
		/// Min length: 1
		/// Max length: 128
		/// Pattern: ^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")]
		public string ChannelArn { get; set; }
		
		/// <summary>
		/// Maximum number of streams to return. Default: 100.
		/// Minimum: 1
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		[System.ComponentModel.DataAnnotations.Range(1, 100)]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		/// <summary>
		/// The first stream to retrieve. This is used for pagination; see the <code>nextToken</code> response field.
		/// Min length: 0
		/// Max length: 1024
		/// Pattern: ^[a-zA-Z0-9+/=_-]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(1024)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9+/=_-]*$")]
		public string NextToken { get; set; }
	}
	
	public class ListStreamsPostBody
	{
		
		/// <summary>
		/// Object specifying the stream attribute on which to filter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filterBy")]
		public ListStreamsPostBodyFilterBy FilterBy { get; set; }
		
		/// <summary>
		/// Maximum number of streams to return. Default: 100.
		/// Minimum: 1
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		[System.ComponentModel.DataAnnotations.Range(1, 100)]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		/// <summary>
		/// The first stream to retrieve. This is used for pagination; see the <code>nextToken</code> response field.
		/// Min length: 0
		/// Max length: 1024
		/// Pattern: ^[a-zA-Z0-9+/=_-]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(1024)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9+/=_-]*$")]
		public string NextToken { get; set; }
	}
	
	public class ListStreamsPostBodyFilterBy
	{
		
		[System.Runtime.Serialization.DataMember(Name="health")]
		public StreamHealth Health { get; set; }
	}
	
	public class TagResourcePostBody
	{
		
		/// <summary>
		/// Array of tags to be added or updated. Array of maps, each of the form <code>string:string (key:value)</code>. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services Resources</a> for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public class PutMetadataPostBody
	{
		
		/// <summary>
		/// ARN of the channel into which metadata is inserted. This channel must have an active stream.
		/// Required
		/// Min length: 1
		/// Max length: 128
		/// Pattern: ^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")]
		public string ChannelArn { get; set; }
		
		/// <summary>
		/// Metadata to insert into the stream. Maximum: 1 KB per request.
		/// Required
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Metadata { get; set; }
	}
	
	public class StartViewerSessionRevocationPostBody
	{
		
		/// <summary>
		/// The ARN of the channel associated with the viewer session to revoke.
		/// Required
		/// Min length: 1
		/// Max length: 128
		/// Pattern: ^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")]
		public string ChannelArn { get; set; }
		
		/// <summary>
		/// The ID of the viewer associated with the viewer session to revoke. Do not use this field for personally identifying, confidential, or sensitive information.
		/// Required
		/// Min length: 1
		/// Max length: 40
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="viewerId")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(40)]
		public string ViewerId { get; set; }
		
		/// <summary>
		/// An optional filter on which versions of the viewer session to revoke. All versions less than or equal to the specified version will be revoked. Default: 0.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="viewerSessionVersionsLessThanOrEqualTo")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> ViewerSessionVersionsLessThanOrEqualTo { get; set; }
	}
	
	public class StopStreamPostBody
	{
		
		/// <summary>
		/// ARN of the channel for which the stream is to be stopped.
		/// Required
		/// Min length: 1
		/// Max length: 128
		/// Pattern: ^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channelArn")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")]
		public string ChannelArn { get; set; }
	}
	
	public class UpdateChannelPostBody
	{
		
		/// <summary>
		/// ARN of the channel to be updated.
		/// Required
		/// Min length: 1
		/// Max length: 128
		/// Pattern: ^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")]
		public string Arn { get; set; }
		
		/// <summary>
		/// Whether the channel is private (enabled for playback authorization).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorized")]
		public System.Nullable<System.Boolean> Authorized { get; set; }
		
		/// <summary>
		/// Whether the channel allows insecure RTMP ingest. Default: <code>false</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="insecureIngest")]
		public System.Nullable<System.Boolean> InsecureIngest { get; set; }
		
		/// <summary>
		/// Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. (Note: In the Amazon IVS console, <code>LOW</code> and <code>NORMAL</code> correspond to Ultra-low and Standard, respectively.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latencyMode")]
		public ChannelLatencyMode LatencyMode { get; set; }
		
		/// <summary>
		/// Channel name.
		/// Min length: 0
		/// Max length: 128
		/// Pattern: ^[a-zA-Z0-9-_]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9-_]*$")]
		public string Name { get; set; }
		
		/// <summary>
		/// Optional transcode preset for the channel. This is selectable only for <code>ADVANCED_HD</code> and <code>ADVANCED_SD</code> channel types. For those channel types, the default <code>preset</code> is <code>HIGHER_BANDWIDTH_DELIVERY</code>. For other channel types (<code>BASIC</code> and <code>STANDARD</code>), <code>preset</code> is the empty string (<code>""</code>).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preset")]
		public TranscodePreset Preset { get; set; }
		
		/// <summary>
		/// Recording-configuration ARN. If this is set to an empty string, recording is disabled. A value other than an empty string indicates that recording is enabled
		/// Min length: 0
		/// Max length: 128
		/// Pattern: ^$|^arn:aws:ivs:[a-z0-9-]+:[0-9]+:recording-configuration/[a-zA-Z0-9-]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recordingConfigurationArn")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^$|^arn:aws:ivs:[a-z0-9-]+:[0-9]+:recording-configuration/[a-zA-Z0-9-]+$")]
		public string RecordingConfigurationArn { get; set; }
		
		/// <summary>
		/// <p>Channel type, which determines the allowable resolution and bitrate. <i>If you exceed the allowable input resolution or bitrate, the stream probably will disconnect immediately.</i> Some types generate multiple qualities (renditions) from the original input; this automatically gives viewers the best experience for their devices and network conditions. Some types provide transcoded video; transcoding allows higher playback quality across a range of download speeds. Default: <code>STANDARD</code>. Valid values:</p> <ul> <li> <p> <code>BASIC</code>: Video is transmuxed: Amazon IVS delivers the original input quality to viewers. The viewer’s video-quality choice is limited to the original input. Input resolution can be up to 1080p and bitrate can be up to 1.5 Mbps for 480p and up to 3.5 Mbps for resolutions between 480p and 1080p. Original audio is passed through.</p> </li> <li> <p> <code>STANDARD</code>: Video is transcoded: multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Transcoding allows higher playback quality across a range of download speeds. Resolution can be up to 1080p and bitrate can be up to 8.5 Mbps. Audio is transcoded only for renditions 360p and below; above that, audio is passed through. This is the default when you create a channel.</p> </li> <li> <p> <code>ADVANCED_SD</code>: Video is transcoded; multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Input resolution can be up to 1080p and bitrate can be up to 8.5 Mbps; output is capped at SD quality (480p). You can select an optional transcode preset (see below). Audio for all renditions is transcoded, and an audio-only rendition is available.</p> </li> <li> <p> <code>ADVANCED_HD</code>: Video is transcoded; multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Input resolution can be up to 1080p and bitrate can be up to 8.5 Mbps; output is capped at HD quality (720p). You can select an optional transcode preset (see below). Audio for all renditions is transcoded, and an audio-only rendition is available.</p> </li> </ul> <p>Optional <i>transcode presets</i> (available for the <code>ADVANCED</code> types) allow you to trade off available download bandwidth and video quality, to optimize the viewing experience. There are two presets:</p> <ul> <li> <p> <i>Constrained bandwidth delivery</i> uses a lower bitrate for each quality level. Use it if you have low download bandwidth and/or simple video content (e.g., talking heads)</p> </li> <li> <p> <i>Higher bandwidth delivery</i> uses a higher bitrate for each quality level. Use it if you have high download bandwidth and/or complex video content (e.g., flashes and quick scene changes).</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ChannelType Type { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
