//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Account object
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Account
	{
		
		[System.Runtime.Serialization.DataMember(Name="active_promotions")]
		public Promotion[] Active_promotions { get; set; }
		
		/// <summary>
		/// The datetime of when the account was activated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active_since")]
		public System.Nullable<System.DateTimeOffset> Active_since { get; set; }
		
		/// <summary>
		/// First line of this Account's billing address.
		/// Max length: 64
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address_1")]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		public string Address_1 { get; set; }
		
		/// <summary>
		/// Second line of this Account's billing address.
		/// Max length: 64
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address_2")]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		public string Address_2 { get; set; }
		
		/// <summary>
		/// This Account's balance, in US dollars.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="balance")]
		public System.Nullable<System.Double> Balance { get; set; }
		
		/// <summary>
		/// This Account's current estimated invoice in US dollars. This is not your final invoice balance. Transfer charges are not included in the estimate.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="balance_uninvoiced")]
		public System.Nullable<System.Double> Balance_uninvoiced { get; set; }
		
		/// <summary>
		/// The source of service charges for this Account, as determined by its relationship with Akamai.
		///Accounts that are associated with Akamai-specific customers return a value of `akamai`.
		///All other Accounts return a value of `linode`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="billing_source")]
		public System.Nullable<AccountBilling_source> Billing_source { get; set; }
		
		/// <summary>
		/// A list of capabilities your account supports.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="capabilities")]
		public string[] Capabilities { get; set; }
		
		/// <summary>
		/// The city for this Account's billing address.
		/// Max length: 24
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="city")]
		[System.ComponentModel.DataAnnotations.MaxLength(24)]
		public string City { get; set; }
		
		/// <summary>
		/// The company name associated with this Account.
		/// Max length: 128
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="company")]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		public string Company { get; set; }
		
		/// <summary>
		/// The two-letter ISO 3166 country code of this Account's billing address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Credit Card information associated with this Account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="credit_card")]
		public AccountCredit_card Credit_card { get; set; }
		
		/// <summary>
		/// The email address of the person associated with this Account.
		/// Max length: 128
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		public string Email { get; set; }
		
		/// <summary>
		/// An external unique identifier for this account.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="euuid")]
		public string Euuid { get; set; }
		
		/// <summary>
		/// The first name of the person associated with this Account.
		/// Max length: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="first_name")]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string First_name { get; set; }
		
		/// <summary>
		/// The last name of the person associated with this Account.
		/// Max length: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_name")]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string Last_name { get; set; }
		
		/// <summary>
		/// The phone number associated with this Account.
		/// Max length: 32
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="phone")]
		[System.ComponentModel.DataAnnotations.MaxLength(32)]
		public string Phone { get; set; }
		
		/// <summary>
		/// If billing address is in the United States (US) or Canada (CA), only the two-letter ISO 3166 State or Province code are accepted. If entering a US military address, state abbreviations (AA, AE, AP) should be entered. If the address is outside the US or CA, this is the Province associated with the Account's billing address.
		///
		/// Max length: 24
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		[System.ComponentModel.DataAnnotations.MaxLength(24)]
		public string State { get; set; }
		
		/// <summary>
		/// The tax identification number associated with this Account, for tax calculations in some countries. If you do not live in a country that collects tax, this should be an empty string (`""`).
		///
		/// Max length: 25
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tax_id")]
		[System.ComponentModel.DataAnnotations.MaxLength(25)]
		public string Tax_id { get; set; }
		
		/// <summary>
		/// The zip code of this Account's billing address. The following restrictions apply:
		///
		///- May only consist of letters, numbers, spaces, and hyphens.
		///- Must not contain more than 9 letter or number characters.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zip")]
		public string Zip { get; set; }
	}
	
	/// <summary>
	/// Promotions generally
	///offer a set amount of credit that can be used toward your Linode
	///services, and the promotion expires after a specified date. As well,
	///a monthly cap on the promotional offer is set.
	///
	///Simply put, a promotion offers a certain amount of credit every
	///month, until either the expiration date is passed, or until the total
	///promotional credit is used, whichever comes first.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Promotion
	{
		
		/// <summary>
		/// The amount available to spend per month.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="credit_monthly_cap")]
		public string Credit_monthly_cap { get; set; }
		
		/// <summary>
		/// The total amount of credit left for this promotion.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="credit_remaining")]
		public string Credit_remaining { get; set; }
		
		/// <summary>
		/// A detailed description of this promotion.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// When this promotion's credits expire.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expire_dt")]
		public string Expire_dt { get; set; }
		
		/// <summary>
		/// The location of an image for this promotion.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image_url")]
		public string Image_url { get; set; }
		
		/// <summary>
		/// The service to which this promotion applies.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service_type")]
		public System.Nullable<PromotionService_type> Service_type { get; set; }
		
		/// <summary>
		/// Short details of this promotion.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="summary")]
		public string Summary { get; set; }
		
		/// <summary>
		/// The amount of credit left for this month for this promotion.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="this_month_credit_remaining")]
		public string This_month_credit_remaining { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PromotionService_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		backup = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		blockstorage = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		db_mysql = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ip_v4 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_disk = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_memory = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		longview = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		managed = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		nodebalancer = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		objectstorage = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		transfer_tx = 12,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AccountBilling_source
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		akamai = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode = 1,
	}
	
	public class AccountCredit_card
	{
		
		/// <summary>
		/// The expiration month and year of the credit card.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiry")]
		public string Expiry { get; set; }
		
		/// <summary>
		/// The last four digits of the credit card associated with this Account.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_four")]
		public string Last_four { get; set; }
	}
	
	/// <summary>
	/// Account Settings object
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AccountSettings
	{
		
		/// <summary>
		/// Account-wide backups default.  If `true`, all Linodes created will automatically be enrolled in the Backups service.  If `false`, Linodes will not be enrolled by default, but may still be enrolled on creation or later.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backups_enabled")]
		public System.Nullable<System.Boolean> Backups_enabled { get; set; }
		
		/// <summary>
		/// The Longview Pro tier you are currently subscribed to. The value must be a [Longview Subscription](/docs/api/longview/#longview-subscriptions-list) ID or `null` for Longview Free.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="longview_subscription")]
		public string Longview_subscription { get; set; }
		
		/// <summary>
		/// Our 24/7 incident response service. This robust, multi-homed monitoring system distributes monitoring checks to ensure that your servers remain online and available at all times. Linode Managed can monitor any service or software stack reachable over TCP or HTTP. Once you add a service to Linode Managed, we'll monitor it for connectivity, response, and total request time.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managed")]
		public System.Nullable<System.Boolean> Managed { get; set; }
		
		/// <summary>
		/// Enables network helper across all users by default for new Linodes and Linode Configs.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network_helper")]
		public System.Nullable<System.Boolean> Network_helper { get; set; }
		
		/// <summary>
		/// A string describing the status of this account's Object Storage service enrollment.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="object_storage")]
		public System.Nullable<AccountSettingsObject_storage> Object_storage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AccountSettingsObject_storage
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		suspended = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 2,
	}
	
	/// <summary>
	/// An application you have authorized access to your Account through OAuth.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AuthorizedApp
	{
		
		/// <summary>
		/// When this app was authorized.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// When the app's access to your account expires. If `null`, the app's access must be revoked manually.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiry")]
		public System.Nullable<System.DateTimeOffset> Expiry { get; set; }
		
		/// <summary>
		/// This authorization's ID, used for revoking access.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The name of the application you've authorized.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The OAuth scopes this app was authorized with.  This defines what parts of your Account the app is allowed to access.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scopes")]
		public string Scopes { get; set; }
		
		/// <summary>
		/// The URL at which this app's thumbnail may be accessed.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thumbnail_url")]
		public string Thumbnail_url { get; set; }
		
		/// <summary>
		/// The website where you can get more information about this app.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="website")]
		public string Website { get; set; }
	}
	
	/// <summary>
	/// An object representing a Backup or snapshot for a Linode with Backup service enabled.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Backup
	{
		
		/// <summary>
		/// Whether this Backup is available for restoration.
		///
		///Backups undergoing maintenance are not available for restoration.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="available")]
		public System.Nullable<System.Boolean> Available { get; set; }
		
		/// <summary>
		/// A list of the labels of the Configuration profiles that are part of the Backup.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configs")]
		public string[] Configs { get; set; }
		
		/// <summary>
		/// The date the Backup was taken.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// A list of the disks that are part of the Backup.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public BackupDisks[] BackupDisks { get; set; }
		
		/// <summary>
		/// The date the Backup completed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public System.Nullable<System.DateTimeOffset> Finished { get; set; }
		
		/// <summary>
		/// The unique ID of this Backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// A label for Backups that are of type `snapshot`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The current state of a specific Backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<BackupStatus> Status { get; set; }
		
		/// <summary>
		/// This indicates whether the Backup is an automatic Backup or manual snapshot taken by the User at a specific point in time.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<BackupType> Type { get; set; }
		
		/// <summary>
		/// The date the Backup was most recently updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
	}
	
	public class BackupDisks
	{
		
		[System.Runtime.Serialization.DataMember(Name="filesystem")]
		public Disk Filesystem { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Disk
	{
		
		/// <summary>
		/// When this Disk was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// The Disk filesystem can be one of:
		///
		///  * raw - No filesystem, just a raw binary stream.
		///  * swap - Linux swap area.
		///  * ext3 - The ext3 journaling filesystem for Linux.
		///  * ext4 - The ext4 journaling filesystem for Linux.
		///  * initrd - initrd (uncompressed initrd, ext2, max 32 MB).
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filesystem")]
		public System.Nullable<DiskFilesystem> Filesystem { get; set; }
		
		/// <summary>
		/// This Disk's ID which must be provided for all operations impacting this Disk.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The Disk's label is for display purposes only.
		///
		/// Min length: 1
		/// Max length: 48
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(48)]
		public string Label { get; set; }
		
		/// <summary>
		/// The size of the Disk in MB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		/// <summary>
		/// A brief description of this Disk's current state. This field may change without direct action from you, as a result of operations performed to the Disk or the Linode containing the Disk.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<DiskStatus> Status { get; set; }
		
		/// <summary>
		/// When this Disk was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DiskFilesystem
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		raw = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		swap = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ext3 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ext4 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		initrd = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DiskStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ready = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="not ready")]
		not_ready = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deleting = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum BackupStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		paused = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		running = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		needsPostProcessing = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		successful = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		userAborted = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum BackupType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		auto = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		snapshot = 1,
	}
	
	/// <summary>
	/// An object representing the credit card information you have on file with
	///Linode to make Payments against your Account.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreditCard
	{
		
		/// <summary>
		/// Your credit card number. No spaces or dashes allowed.
		/// Required
		/// Min length: 14
		/// Max length: 24
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="card_number")]
		[System.ComponentModel.DataAnnotations.MinLength(14)]
		[System.ComponentModel.DataAnnotations.MaxLength(24)]
		public string Card_number { get; set; }
		
		/// <summary>
		/// CVV (Card Verification Value) of the credit card, typically found on the back of the card.
		///
		/// Required
		/// Min length: 3
		/// Max length: 4
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cvv")]
		[System.ComponentModel.DataAnnotations.MinLength(3)]
		[System.ComponentModel.DataAnnotations.MaxLength(4)]
		public string Cvv { get; set; }
		
		/// <summary>
		/// A value from 1-12 representing the expiration month of your credit card.
		///
		///  * 1 = January
		///  * 2 = February
		///  * 3 = March
		///  * Etc.
		///
		/// Required
		/// Minimum: 1
		/// Maximum: 12
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="expiry_month")]
		[System.ComponentModel.DataAnnotations.Range(1, 12)]
		public int Expiry_month { get; set; }
		
		/// <summary>
		/// A four-digit integer representing the expiration year of
		///your credit card.
		///
		///The combination of `expiry_month` and `expiry_year`
		///must result in a month/year combination of the current month or in
		///the future. An expiration date set in the past is invalid.
		///
		/// Required
		/// Min length: 4
		/// Max length: 4
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="expiry_year")]
		[System.ComponentModel.DataAnnotations.MinLength(4)]
		[System.ComponentModel.DataAnnotations.MaxLength(4)]
		public int Expiry_year { get; set; }
	}
	
	/// <summary>
	/// Credit card information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreditCardData
	{
		
		/// <summary>
		/// The type of credit card.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="card_type")]
		public string Card_type { get; set; }
		
		/// <summary>
		/// The expiration month and year of the credit card.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiry")]
		public string Expiry { get; set; }
		
		/// <summary>
		/// The last four digits of the credit card number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_four")]
		public string Last_four { get; set; }
	}
	
	/// <summary>
	/// A general Managed Database instance object containing properties that are identical for all database types.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Database
	{
		
		/// <summary>
		/// A list of IP addresses that can access the Managed Database. Each item can be a single IP address or a range in CIDR format.
		///
		///By default, this is an empty array (`[]`), which blocks all connections (both public and private) to the Managed Database.
		///
		///If `0.0.0.0/0` is a value in this list, then all IP addresses can access the Managed Database.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_list")]
		public string[] Allow_list { get; set; }
		
		/// <summary>
		/// The number of Linode Instance nodes deployed to the Managed Database.
		///
		///Choosing 3 nodes creates a high availability cluster consisting of 1 primary node and 2 replica nodes.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cluster_size")]
		public System.Nullable<DatabaseCluster_size> Cluster_size { get; set; }
		
		/// <summary>
		/// When this Managed Database was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// Whether the Managed Databases is encrypted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encrypted")]
		public System.Nullable<System.Boolean> Encrypted { get; set; }
		
		/// <summary>
		/// The Managed Database engine type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="engine")]
		public System.Nullable<DatabaseEngine> Engine { get; set; }
		
		/// <summary>
		/// The primary and secondary hosts for the Managed Database. These are assigned after provisioning is complete.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosts")]
		public DatabaseHosts Hosts { get; set; }
		
		/// <summary>
		/// A unique ID that can be used to identify and reference the Managed Database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Append this to `https://api.linode.com` to run commands for the Managed Database.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instance_uri")]
		public string Instance_uri { get; set; }
		
		/// <summary>
		/// A unique, user-defined string referring to the Managed Database.
		/// Min length: 3
		/// Max length: 32
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(3)]
		[System.ComponentModel.DataAnnotations.MaxLength(32)]
		public string Label { get; set; }
		
		/// <summary>
		/// The [Region](/docs/api/regions/) ID for the Managed Database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The operating status of the Managed Database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<DatabaseStatus> Status { get; set; }
		
		/// <summary>
		/// The Linode Instance type used by the Managed Database for its nodes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// When this Managed Database was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
		
		/// <summary>
		/// Configuration settings for automated patch update maintenance for the Managed Database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updates")]
		public DatabaseUpdates Updates { get; set; }
		
		/// <summary>
		/// The Managed Database engine version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DatabaseCluster_size
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3 = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DatabaseEngine
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		mongodb = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		mysql = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		postgresql = 2,
	}
	
	public class DatabaseHosts
	{
		
		/// <summary>
		/// The primary host for the Managed Database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary")]
		public string Primary { get; set; }
		
		/// <summary>
		/// The secondary/private network host for the Managed Database.
		///
		///A private network host and a private IP can only be used to access a Database Cluster from Linodes in the same data center and will not incur transfer costs.
		///
		///**Note**: The secondary hostname is publicly viewable and accessible.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondary")]
		public string Secondary { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DatabaseStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		provisioning = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		suspending = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		suspended = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		resuming = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		restoring = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		degraded = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		updating = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		backing_up = 9,
	}
	
	public class DatabaseUpdates
	{
		
		/// <summary>
		/// The day to perform maintenance. 1=Monday, 2=Tuesday, etc.
		/// Minimum: 1
		/// Maximum: 7
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="day_of_week")]
		[System.ComponentModel.DataAnnotations.Range(1, 7)]
		public System.Nullable<System.Int32> Day_of_week { get; set; }
		
		/// <summary>
		/// The maximum maintenance window time in hours.
		/// Minimum: 1
		/// Maximum: 3
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		[System.ComponentModel.DataAnnotations.Range(1, 3)]
		public System.Nullable<System.Int32> Duration { get; set; }
		
		/// <summary>
		/// Whether maintenance occurs on a weekly or monthly basis.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="frequency")]
		public System.Nullable<DatabaseUpdatesFrequency> Frequency { get; set; }
		
		/// <summary>
		/// The hour to begin maintenance based in UTC time.
		/// Minimum: 0
		/// Maximum: 23
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hour_of_day")]
		[System.ComponentModel.DataAnnotations.Range(0, 23)]
		public System.Nullable<System.Int32> Hour_of_day { get; set; }
		
		/// <summary>
		/// The week of the month to perform `monthly` frequency updates. Defaults to `null`.
		///
		///* Required for `monthly` frequency updates.
		///
		///* Must be `null` for `weekly` frequency updates.
		///
		/// Minimum: 1
		/// Maximum: 4
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="week_of_month")]
		[System.ComponentModel.DataAnnotations.Range(1, 4)]
		public System.Nullable<System.Int32> Week_of_month { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DatabaseUpdatesFrequency
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		weekly = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		monthly = 1,
	}
	
	/// <summary>
	/// A database backup object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DatabaseBackup
	{
		
		/// <summary>
		/// A time value given in a combined date and time format that represents when the database backup was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// The ID of the database backup object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The database backup's label, for display purposes only.
		///
		///Must include only ASCII letters or numbers.
		///
		/// Max length: 30
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MaxLength(30)]
		public string Label { get; set; }
		
		/// <summary>
		/// The type of database backup, determined by how the backup was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<DatabaseBackupType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DatabaseBackupType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		snapshot = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		auto = 1,
	}
	
	/// <summary>
	/// Managed Database request object for snapshot backup.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DatabaseBackupSnapshot
	{
		
		/// <summary>
		/// The label for the Database snapshot backup.
		///
		///* Must include only ASCII letters or numbers.
		///* Must be unique among other backup labels for this Database.
		///
		/// Required
		/// Min length: 1
		/// Max length: 30
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(30)]
		public string Label { get; set; }
		
		/// <summary>
		/// The Database cluster target.
		///If the Database is a high availability cluster, choosing `secondary` creates a snapshot backup of a replica node.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public System.Nullable<DatabaseBackupSnapshotTarget> Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DatabaseBackupSnapshotTarget
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		primary = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		secondary = 1,
	}
	
	/// <summary>
	/// Managed Database object for database credentials.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DatabaseCredentials
	{
		
		/// <summary>
		/// The randomly-generated root password for the Managed Database instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// The root username for the Managed Database instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// Managed MongoDB Databases object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DatabaseMongoDB
	{
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_list")]
		public Database Allow_list { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cluster_size")]
		public Database Cluster_size { get; set; }
		
		/// <summary>
		/// The type of data compression for this Database.
		///
		///Snappy has a lower comparative compression ratio and resource consumption rate.
		///
		///Zlip has a higher comparative compression ratio and resource consumption rate.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="compression_type")]
		public System.Nullable<DatabaseMongoDBCompression_type> Compression_type { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public Database Created { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encrypted")]
		public Database Encrypted { get; set; }
		
		/// <summary>
		/// The Managed Database engine type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="engine")]
		public string Engine { get; set; }
		
		/// <summary>
		/// The primary and secondary hosts for the Managed Database. These are assigned after provisioning is complete.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosts")]
		public DatabaseMongoDBHosts Hosts { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public Database Id { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public Database Label { get; set; }
		
		/// <summary>
		/// An array of peer addresses for this Database.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peers")]
		public string[] Peers { get; set; }
		
		/// <summary>
		/// The access port for this Managed Database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public Database Region { get; set; }
		
		/// <summary>
		/// Label for configuring a MongoDB [replica set](https://www.mongodb.com/docs/manual/replication/). Choose the same label on multiple Databases to include them in the same replica set.
		///
		///If `null`, the Database is not included in any replica set.
		///
		/// Max length: 64
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replica_set")]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		public string Replica_set { get; set; }
		
		/// <summary>
		/// Whether to require SSL credentials to establish a connection to the Managed Database.
		///
		///Use the **Managed MongoDB Database Credentials View** ([GET /databases/mongodb/instances/{instanceId}/credentials](/docs/api/databases/#managed-mongodb-database-credentials-view)) command for access information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssl_connection")]
		public System.Nullable<System.Boolean> Ssl_connection { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Database Status { get; set; }
		
		/// <summary>
		/// The type of storage engine for this Database.
		///
		///**Note:** MMAPV1 is not available for MongoDB versions 4.0 and above.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storage_engine")]
		public System.Nullable<DatabaseMongoDBStorage_engine> Storage_engine { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Database Type { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public Database Updated { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updates")]
		public Database Updates { get; set; }
		
		/// <summary>
		/// The Managed Database engine version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DatabaseMongoDBCompression_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		snappy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zlip = 2,
	}
	
	public class DatabaseMongoDBHosts
	{
		
		/// <summary>
		/// The primary host for the Managed Database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary")]
		public string Primary { get; set; }
		
		/// <summary>
		/// The secondary/private network host for the Managed Database.
		///
		///A private network host and a private IP can only be used to access a Database Cluster from Linodes in the same data center and will not incur transfer costs.
		///
		///**Note**: The secondary hostname is publicly viewable and accessible.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondary")]
		public string Secondary { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DatabaseMongoDBStorage_engine
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		mmapv1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wiredtiger = 1,
	}
	
	/// <summary>
	/// Managed MongoDB Database request object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DatabaseMongoDBRequest
	{
		
		/// <summary>
		/// Managed MongoDB Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_list")]
		public DatabaseMongoDB Allow_list { get; set; }
		
		/// <summary>
		/// Managed MongoDB Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cluster_size")]
		public DatabaseMongoDB Cluster_size { get; set; }
		
		/// <summary>
		/// Managed MongoDB Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="compression_type")]
		public DatabaseMongoDB Compression_type { get; set; }
		
		/// <summary>
		/// Managed MongoDB Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encrypted")]
		public DatabaseMongoDB Encrypted { get; set; }
		
		/// <summary>
		/// The Managed Database engine in engine/version format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="engine")]
		public string Engine { get; set; }
		
		/// <summary>
		/// Managed MongoDB Databases object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public DatabaseMongoDB Label { get; set; }
		
		/// <summary>
		/// Managed MongoDB Databases object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region")]
		public DatabaseMongoDB Region { get; set; }
		
		/// <summary>
		/// Managed MongoDB Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replica_set")]
		public DatabaseMongoDB Replica_set { get; set; }
		
		/// <summary>
		/// Managed MongoDB Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssl_connection")]
		public DatabaseMongoDB Ssl_connection { get; set; }
		
		/// <summary>
		/// Managed MongoDB Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storage_engine")]
		public DatabaseMongoDB Storage_engine { get; set; }
		
		/// <summary>
		/// Managed MongoDB Databases object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public DatabaseMongoDB Type { get; set; }
	}
	
	/// <summary>
	/// Managed MySQL Databases object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DatabaseMySQL
	{
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_list")]
		public Database Allow_list { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cluster_size")]
		public Database Cluster_size { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public Database Created { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encrypted")]
		public Database Encrypted { get; set; }
		
		/// <summary>
		/// The Managed Database engine type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="engine")]
		public string Engine { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosts")]
		public Database Hosts { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public Database Id { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public Database Label { get; set; }
		
		/// <summary>
		/// The access port for this Managed Database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public Database Region { get; set; }
		
		/// <summary>
		/// The replication method used for the Managed Database.
		///
		///Defaults to `none` for a single cluster and `semi_synch` for a high availability cluster.
		///
		///Must be `none` for a single node cluster.
		///
		///Must be `asynch` or `semi_synch` for a high availability cluster.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replication_type")]
		public System.Nullable<DatabaseMySQLReplication_type> Replication_type { get; set; }
		
		/// <summary>
		/// Whether to require SSL credentials to establish a connection to the Managed Database.
		///
		///Use the **Managed MySQL Database Credentials View** ([GET /databases/mysql/instances/{instanceId}/credentials](/docs/api/databases/#managed-mysql-database-credentials-view)) command for access information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssl_connection")]
		public System.Nullable<System.Boolean> Ssl_connection { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Database Status { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Database Type { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public Database Updated { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updates")]
		public Database Updates { get; set; }
		
		/// <summary>
		/// The Managed Database engine version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DatabaseMySQLReplication_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		asynch = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		semi_synch = 2,
	}
	
	/// <summary>
	/// Managed MySQL Database request object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DatabaseMySQLRequest
	{
		
		/// <summary>
		/// Managed MySQL Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_list")]
		public DatabaseMySQL Allow_list { get; set; }
		
		/// <summary>
		/// Managed MySQL Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cluster_size")]
		public DatabaseMySQL Cluster_size { get; set; }
		
		/// <summary>
		/// Managed MySQL Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encrypted")]
		public DatabaseMySQL Encrypted { get; set; }
		
		/// <summary>
		/// The Managed Database engine in engine/version format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="engine")]
		public string Engine { get; set; }
		
		/// <summary>
		/// Managed MySQL Databases object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public DatabaseMySQL Label { get; set; }
		
		/// <summary>
		/// Managed MySQL Databases object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region")]
		public DatabaseMySQL Region { get; set; }
		
		/// <summary>
		/// Managed MySQL Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replication_type")]
		public DatabaseMySQL Replication_type { get; set; }
		
		/// <summary>
		/// Managed MySQL Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssl_connection")]
		public DatabaseMySQL Ssl_connection { get; set; }
		
		/// <summary>
		/// Managed MySQL Databases object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public DatabaseMySQL Type { get; set; }
	}
	
	/// <summary>
	/// Managed PostgreSQL Databases object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DatabasePostgreSQL
	{
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_list")]
		public Database Allow_list { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cluster_size")]
		public Database Cluster_size { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public Database Created { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encrypted")]
		public Database Encrypted { get; set; }
		
		/// <summary>
		/// The Managed Database engine type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="engine")]
		public string Engine { get; set; }
		
		/// <summary>
		/// The primary and secondary hosts for the Managed Database. These are assigned after provisioning is complete.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosts")]
		public DatabasePostgreSQLHosts Hosts { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public Database Id { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public Database Label { get; set; }
		
		/// <summary>
		/// The access port for this Managed Database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public Database Region { get; set; }
		
		/// <summary>
		/// The synchronization level of the replicating server.
		///
		///Must be `local` or `off` for the `asynch` replication type.
		///
		///Must be `on`, `remote_write`, or `remote_apply` for the `semi_synch` replication type.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replication_commit_type")]
		public System.Nullable<DatabasePostgreSQLReplication_commit_type> Replication_commit_type { get; set; }
		
		/// <summary>
		/// The replication method used for the Managed Database.
		///
		///Defaults to `none` for a single cluster and `semi_synch` for a high availability cluster.
		///
		///Must be `none` for a single node cluster.
		///
		///Must be `asynch` or `semi_synch` for a high availability cluster.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replication_type")]
		public DatabaseMySQLReplication_type Replication_type { get; set; }
		
		/// <summary>
		/// Whether to require SSL credentials to establish a connection to the Managed Database.
		///
		///Use the **Managed PostgreSQL Database Credentials View** ([GET /databases/postgresql/instances/{instanceId}/credentials](/docs/api/databases/#managed-postgresql-database-credentials-view)) command for access information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssl_connection")]
		public System.Nullable<System.Boolean> Ssl_connection { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Database Status { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Database Type { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public Database Updated { get; set; }
		
		/// <summary>
		/// A general Managed Database instance object containing properties that are identical for all database types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updates")]
		public Database Updates { get; set; }
		
		/// <summary>
		/// The Managed Database engine version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	public class DatabasePostgreSQLHosts
	{
		
		/// <summary>
		/// The primary host for the Managed Database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary")]
		public string Primary { get; set; }
		
		/// <summary>
		/// The secondary/private network host for the Managed Database.
		///
		///A private network host and a private IP can only be used to access a Database Cluster from Linodes in the same data center and will not incur transfer costs.
		///
		///**Note**: The secondary hostname is publicly viewable and accessible.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondary")]
		public string Secondary { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DatabasePostgreSQLReplication_commit_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		on = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		local = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		remote_write = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		remote_apply = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		off = 4,
	}
	
	/// <summary>
	/// Managed PostgreSQL Database request object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DatabasePostgreSQLRequest
	{
		
		/// <summary>
		/// Managed PostgreSQL Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_list")]
		public DatabasePostgreSQL Allow_list { get; set; }
		
		/// <summary>
		/// Managed PostgreSQL Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cluster_size")]
		public DatabasePostgreSQL Cluster_size { get; set; }
		
		/// <summary>
		/// Managed PostgreSQL Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encrypted")]
		public DatabasePostgreSQL Encrypted { get; set; }
		
		/// <summary>
		/// The Managed Database engine in engine/version format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="engine")]
		public string Engine { get; set; }
		
		/// <summary>
		/// Managed PostgreSQL Databases object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public DatabasePostgreSQL Label { get; set; }
		
		/// <summary>
		/// Managed PostgreSQL Databases object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region")]
		public DatabasePostgreSQL Region { get; set; }
		
		/// <summary>
		/// Managed PostgreSQL Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replication_commit_type")]
		public DatabasePostgreSQL Replication_commit_type { get; set; }
		
		/// <summary>
		/// Managed PostgreSQL Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replication_type")]
		public DatabasePostgreSQL Replication_type { get; set; }
		
		/// <summary>
		/// Managed PostgreSQL Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssl_connection")]
		public DatabasePostgreSQL Ssl_connection { get; set; }
		
		/// <summary>
		/// Managed PostgreSQL Databases object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public DatabasePostgreSQL Type { get; set; }
	}
	
	/// <summary>
	/// Managed Database SSL object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DatabaseSSL
	{
		
		/// <summary>
		/// The base64-encoded SSL CA certificate for the Managed Database instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ca_certificate")]
		public string Ca_certificate { get; set; }
	}
	
	/// <summary>
	/// Managed Database plan type object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DatabaseType
	{
		
		/// <summary>
		/// The compute class category.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="class")]
		public string Class { get; set; }
		
		/// <summary>
		/// Whether this Database plan type has been deprecated and is no longer available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public System.Nullable<System.Boolean> Deprecated { get; set; }
		
		/// <summary>
		/// The amount of disk space set aside for Databases of this plan type. The value is represented in megabytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disk")]
		public System.Nullable<System.Int32> Disk { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="engines")]
		public DatabaseTypeEngines Engines { get; set; }
		
		/// <summary>
		/// The ID representing the Managed Database node plan type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A human-readable string that describes each plan type. For display purposes only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The amount of RAM allocated to Database created of this plan type. The value is represented in megabytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memory")]
		public System.Nullable<System.Int32> Memory { get; set; }
		
		/// <summary>
		/// The integer of number CPUs allocated to databases of this plan type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vcpus")]
		public System.Nullable<System.Int32> Vcpus { get; set; }
	}
	
	public class DatabaseTypeEngines
	{
		
		/// <summary>
		/// Pricing details for MongoDB Managed Databases.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mongodb")]
		public DatabaseTypeEngine[] Mongodb { get; set; }
		
		/// <summary>
		/// Pricing details for MySQL Managed Databases.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mysql")]
		public DatabaseTypeEngine[] Mysql { get; set; }
		
		/// <summary>
		/// Pricing details for PostgreSQL Managed Databases.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postgresql")]
		public DatabaseTypeEngine[] Postgresql { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DatabaseTypeEngine
	{
		
		/// <summary>
		/// Cost in US dollars, broken down into hourly and monthly charges.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="price")]
		public DatabaseTypeEnginePrice Price { get; set; }
		
		/// <summary>
		/// The number of nodes for the Managed Database cluster for this subscription tier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quantity")]
		public System.Nullable<DatabaseTypeEngineQuantity> Quantity { get; set; }
	}
	
	public class DatabaseTypeEnginePrice
	{
		
		/// <summary>
		/// Cost (in US dollars) per hour for this subscription tier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hourly")]
		public System.Nullable<System.Double> Hourly { get; set; }
		
		/// <summary>
		/// Maximum cost (in US dollars) per month for this subscription tier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monthly")]
		public System.Nullable<System.Double> Monthly { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DatabaseTypeEngineQuantity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_3 = 3,
	}
	
	/// <summary>
	/// Device can be either a Disk or Volume identified by `disk_id` or `volume_id`. Only one type per slot allowed. Can be null.
	///Devices mapped from _sde_ through _sdh_ are unavailable in `fullvirt` virt_mode.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Device
	{
		
		/// <summary>
		/// The Disk ID, or `null` if a Volume is assigned to this slot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disk_id")]
		public System.Nullable<System.Int32> Disk_id { get; set; }
		
		/// <summary>
		/// The Volume ID, or `null` if a Disk is assigned to this slot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volume_id")]
		public System.Nullable<System.Int32> Volume_id { get; set; }
	}
	
	/// <summary>
	/// A dictionary of device disks to use as a device map in a Linode's configuration profile.
	///* An empty device disk dictionary or a dictionary with empty values for device slots is allowed.
	///* If no devices are specified, booting from this configuration will hold until a device exists that allows the boot process to start.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Devices
	{
		
		/// <summary>
		/// Device can be either a Disk or Volume identified by `disk_id` or `volume_id`. Only one type per slot allowed. Can be null.
		///Devices mapped from _sde_ through _sdh_ are unavailable in `fullvirt` virt_mode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sda")]
		public Device Sda { get; set; }
		
		/// <summary>
		/// Device can be either a Disk or Volume identified by `disk_id` or `volume_id`. Only one type per slot allowed. Can be null.
		///Devices mapped from _sde_ through _sdh_ are unavailable in `fullvirt` virt_mode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sdb")]
		public Device Sdb { get; set; }
		
		/// <summary>
		/// Device can be either a Disk or Volume identified by `disk_id` or `volume_id`. Only one type per slot allowed. Can be null.
		///Devices mapped from _sde_ through _sdh_ are unavailable in `fullvirt` virt_mode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sdc")]
		public Device Sdc { get; set; }
		
		/// <summary>
		/// Device can be either a Disk or Volume identified by `disk_id` or `volume_id`. Only one type per slot allowed. Can be null.
		///Devices mapped from _sde_ through _sdh_ are unavailable in `fullvirt` virt_mode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sdd")]
		public Device Sdd { get; set; }
		
		/// <summary>
		/// Device can be either a Disk or Volume identified by `disk_id` or `volume_id`. Only one type per slot allowed. Can be null.
		///Devices mapped from _sde_ through _sdh_ are unavailable in `fullvirt` virt_mode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sde")]
		public Device Sde { get; set; }
		
		/// <summary>
		/// Device can be either a Disk or Volume identified by `disk_id` or `volume_id`. Only one type per slot allowed. Can be null.
		///Devices mapped from _sde_ through _sdh_ are unavailable in `fullvirt` virt_mode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sdf")]
		public Device Sdf { get; set; }
		
		/// <summary>
		/// Device can be either a Disk or Volume identified by `disk_id` or `volume_id`. Only one type per slot allowed. Can be null.
		///Devices mapped from _sde_ through _sdh_ are unavailable in `fullvirt` virt_mode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sdg")]
		public Device Sdg { get; set; }
		
		/// <summary>
		/// Device can be either a Disk or Volume identified by `disk_id` or `volume_id`. Only one type per slot allowed. Can be null.
		///Devices mapped from _sde_ through _sdh_ are unavailable in `fullvirt` virt_mode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sdh")]
		public Device Sdh { get; set; }
	}
	
	/// <summary>
	/// Disk object request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DiskRequest
	{
		
		/// <summary>
		/// A list of public SSH keys that will be automatically appended
		///to the root user's `~/.ssh/authorized_keys` file when deploying from an Image.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorized_keys")]
		public string[] Authorized_keys { get; set; }
		
		/// <summary>
		/// A list of usernames. If the usernames have associated SSH keys, the keys will be appended to the root users `~/.ssh/authorized_keys` file automatically when deploying from an Image.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorized_users")]
		public string[] Authorized_users { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="filesystem")]
		public Disk Filesystem { get; set; }
		
		/// <summary>
		/// An Image ID to deploy the Linode Disk from.
		///
		///Access the Images List ([GET /images](/docs/api/images/#images-list)) endpoint with authentication to view
		///all available Images. Official Linode Images start with `linode/`, while your Account's Images start with `private/`. Creating
		///a disk from a Private Image requires `read_only` or `read_write` permissions for that Image. Access the User's
		///Grant Update ([PUT /account/users/{username}/grants](/docs/api/account/#users-grants-update)) endpoint to
		///adjust permissions for an Account Image.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public string Image { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="label")]
		public Disk Label { get; set; }
		
		/// <summary>
		/// This sets the root user's password on a newly-created Linode Disk when deploying from an Image.
		///
		///* **Required** when creating a Linode Disk from an Image, including when using a StackScript.
		///
		///* Must meet a password strength score requirement that is calculated internally by the API.
		///If the strength requirement is not met, you will receive a `Password does not meet strength requirement` error.
		///
		/// Min length: 7
		/// Max length: 128
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="root_pass")]
		[System.ComponentModel.DataAnnotations.MinLength(7)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		public string Root_pass { get; set; }
		
		/// <summary>
		/// The size of the Disk in MB.
		///
		///Images require a minimum size. Access the Image View ([GET /images/{imageID}](/docs/api/images/#image-view)) endpoint to view its size.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		/// <summary>
		/// This field is required only if the StackScript being deployed requires input data from the User for successful completion. See [User Defined Fields (UDFs)](/docs/guides/writing-scripts-for-use-with-linode-stackscripts-a-tutorial/#user-defined-fields-udfs) for more details.
		///
		///This field is required to be valid JSON.
		///
		///Total length cannot exceed 65,535 characters.
		///
		/// Max length: 65535
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stackscript_data")]
		[System.ComponentModel.DataAnnotations.MaxLength(65535)]
		public string Stackscript_data { get; set; }
		
		/// <summary>
		/// A StackScript ID that will cause the referenced StackScript to be run during
		///deployment of this Linode. A compatible `image` is required to use a
		///StackScript. To get a list of available StackScript and their permitted Images
		///see [/stackscripts](/docs/api/stackscripts/#stackscripts-list).
		///This field cannot be used when deploying from a Backup or a Private Image.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stackscript_id")]
		public System.Nullable<System.Int32> Stackscript_id { get; set; }
	}
	
	/// <summary>
	/// A domain zonefile in our DNS system.  You must own the domain name and tell your registrar to use Linode's nameservers in order for a domain in our system to be treated as authoritative.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Domain
	{
		
		/// <summary>
		/// The list of IPs that may perform a zone transfer for this Domain. The total combined length of all data within this array cannot exceed 1000 characters.
		///
		///**Note**: This is potentially dangerous, and should be set to an empty list unless you intend to use it.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="axfr_ips")]
		public string[] Axfr_ips { get; set; }
		
		/// <summary>
		/// A description for this Domain. This is for display purposes only.
		///
		/// Min length: 1
		/// Max length: 253
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(253)]
		public string Description { get; set; }
		
		/// <summary>
		/// The domain this Domain represents. Domain labels cannot be longer than 63 characters and must conform to [RFC1035](https://tools.ietf.org/html/rfc1035). Domains must be unique on Linode's platform, including across different Linode accounts; there cannot be two Domains representing the same domain.
		///
		/// Min length: 1
		/// Max length: 253
		/// Pattern: \A(\*\.)?([a-zA-Z0-9-_]{1,63}\.)+([a-zA-Z]{2,3}\.)?([a-zA-Z]{2,16}|xn--[a-zA-Z0-9]+)\Z
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domain")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(253)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"\A(\*\.)?([a-zA-Z0-9-_]{1,63}\.)+([a-zA-Z]{2,3}\.)?([a-zA-Z]{2,16}|xn--[a-zA-Z0-9]+)\Z")]
		public string Domain1 { get; set; }
		
		/// <summary>
		/// The amount of time in seconds that may pass before this Domain is no longer
		///authoritative.
		///
		///* Valid values are
		///0, 300, 3600, 7200, 14400, 28800, 57600, 86400, 172800, 345600, 604800, 1209600, and 2419200.
		///
		///* Any other value is rounded up to the nearest valid value.
		///
		///* A value of 0 is equivalent to the default value of 1209600.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expire_sec")]
		public System.Nullable<System.Int32> Expire_sec { get; set; }
		
		/// <summary>
		/// The group this Domain belongs to.  This is for display purposes only.
		///
		/// Min length: 1
		/// Max length: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string Group { get; set; }
		
		/// <summary>
		/// This Domain's unique ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The IP addresses representing the master DNS for this Domain. At least one value is required for `type` slave Domains. The total combined length of all data within this array cannot exceed 1000 characters.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="master_ips")]
		public string[] Master_ips { get; set; }
		
		/// <summary>
		/// The amount of time in seconds before this Domain should be refreshed.
		///
		///* Valid values are
		///0, 300, 3600, 7200, 14400, 28800, 57600, 86400, 172800, 345600, 604800, 1209600, and 2419200.
		///
		///* Any other value is rounded up to the nearest valid value.
		///
		///* A value of 0 is equivalent to the default value of 14400.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="refresh_sec")]
		public System.Nullable<System.Int32> Refresh_sec { get; set; }
		
		/// <summary>
		/// The interval, in seconds, at which a failed refresh should be retried.
		///
		///* Valid values are
		///0, 300, 3600, 7200, 14400, 28800, 57600, 86400, 172800, 345600, 604800, 1209600, and 2419200.
		///
		///* Any other value is rounded up to the nearest valid value.
		///
		///* A value of 0 is equivalent to the default value of 14400.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retry_sec")]
		public System.Nullable<System.Int32> Retry_sec { get; set; }
		
		/// <summary>
		/// Start of Authority email address. This is required for `type` master Domains.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="soa_email")]
		public string Soa_email { get; set; }
		
		/// <summary>
		/// Used to control whether this Domain is currently being rendered.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<DomainStatus> Status { get; set; }
		
		/// <summary>
		/// An array of tags applied to this object.  Tags are for organizational purposes only.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// "Time to Live" - the amount of time in seconds that this Domain's records may be cached by resolvers or other domain servers.
		///* Valid values are 0, 300, 3600, 7200, 14400, 28800, 57600, 86400, 172800, 345600, 604800, 1209600, and 2419200.
		///* Any other value is rounded up to the nearest valid value.
		///* A value of 0 is equivalent to the default value of 86400.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ttl_sec")]
		public System.Nullable<System.Int32> Ttl_sec { get; set; }
		
		/// <summary>
		/// Whether this Domain represents the authoritative source of information for the domain it describes ("master"), or whether it is a read-only copy of a master ("slave").
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<DomainType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DomainStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DomainType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		master = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		slave = 1,
	}
	
	/// <summary>
	/// A single record on a Domain.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DomainRecord
	{
		
		/// <summary>
		/// When this Domain Record was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// This Record's unique ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The name of this Record. For requests, this property's actual usage and whether it is required depends
		///on the type of record this represents:
		///
		///`A` and `AAAA`: The hostname or FQDN of the Record.
		///
		///`NS`: The subdomain, if any, to use with the Domain of the Record. Wildcard NS records (`*`) are not supported.
		///
		///`MX`: The mail subdomain. For example, `sub` for the address `user@sub.example.com` under the `example.com`
		///Domain. Must be an empty string (`""`) for a Null MX Record.
		///
		///`CNAME`: The hostname. Must be unique. Required.
		///
		///`TXT`: The hostname.
		///
		///`SRV`: Unused. Use the `service` property to set the service name for this record.
		///
		///`CAA`: The subdomain. Omit or enter an empty string (`""`) to apply to the entire Domain.
		///
		///`PTR`: See our guide on how to [Configure Your Linode for Reverse DNS
		///(rDNS)](/docs/guides/configure-rdns/).
		///
		/// Min length: 1
		/// Max length: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Name { get; set; }
		
		/// <summary>
		/// The port this Record points to. Only valid and required for SRV record requests.
		///
		/// Minimum: 0
		/// Maximum: 65535
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		[System.ComponentModel.DataAnnotations.Range(0, 65535)]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// The priority of the target host for this Record. Lower values are preferred. Only valid for
		///MX and SRV record requests. Required for SRV record requests.
		///
		///Defaults to `0` for MX record requests. Must be `0` for Null MX records.
		///
		/// Minimum: 0
		/// Maximum: 255
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		[System.ComponentModel.DataAnnotations.Range(0, 255)]
		public System.Nullable<System.Int32> Priority { get; set; }
		
		/// <summary>
		/// The protocol this Record's service communicates with. An underscore (`_`) is prepended automatically to the submitted value for this property. Only valid for SRV record requests.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public string Protocol { get; set; }
		
		/// <summary>
		/// The name of the service. An underscore (`_`) is prepended and a period (`.`) is appended automatically to the submitted value for this property. Only valid and required for SRV record requests.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service")]
		public string Service { get; set; }
		
		/// <summary>
		/// The tag portion of a CAA record. Only valid and required for CAA record requests.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public System.Nullable<DomainRecordTag> Tag { get; set; }
		
		/// <summary>
		/// The target for this Record. For requests, this property's actual usage and whether it is required depends
		///on the type of record this represents:
		///
		///`A` and `AAAA`: The IP address. Use `[remote_addr]` to submit the IPv4 address of the request. Required.
		///
		///`NS`: The name server. Must be a valid domain. Required.
		///
		///`MX`: The mail server. Must be a valid domain unless creating a Null MX Record. To create a
		///[Null MX Record](https://datatracker.ietf.org/doc/html/rfc7505), first
		///[remove](/docs/api/domains/#domain-record-delete) any additional MX records, create an MX record with empty strings
		///(`""`) for the `target` and `name`. If a Domain has a Null MX record, new MX records cannot be created. Required.
		///
		///`CNAME`: The alias. Must be a valid domain. Required.
		///
		///`TXT`: The value. Required.
		///
		///`SRV`: The target domain or subdomain. If a subdomain is entered, it is automatically used with the Domain.
		///To configure for a different domain, enter a valid FQDN. For example, the value `www` with a Domain for
		///`example.com` results in a target set to `www.example.com`, whereas the value `sample.com` results in a
		///target set to `sample.com`. Required.
		///
		///`CAA`: The value. For `issue` or `issuewild` tags, the domain of your certificate issuer. For the `iodef`
		///tag, a contact or submission URL (domain, http, https, or mailto). Requirements depend on the tag for this record:
		///  * `issue`: The domain of your certificate issuer. Must be a valid domain.
		///  * `issuewild`: The domain of your wildcard certificate issuer. Must be a valid domain and must not start with an asterisk (`*`).
		///  * `iodef`: Must be either (1) a valid domain, (2) a valid domain prepended with `http://` or `https://`, or (3) a valid email address prepended with `mailto:`.
		///
		///`PTR`: Required. See our guide on how to [Configure Your Linode for Reverse DNS
		///(rDNS)](/docs/guides/configure-rdns/).
		///
		///With the exception of A, AAAA, and CAA records, this field accepts a trailing period.
		///
		/// Max length: 65535
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		[System.ComponentModel.DataAnnotations.MaxLength(65535)]
		public string Target { get; set; }
		
		/// <summary>
		/// "Time to Live" - the amount of time in seconds that this Domain's records may be cached by resolvers or other domain servers. Valid values are 300, 3600, 7200, 14400, 28800, 57600, 86400, 172800, 345600, 604800, 1209600, and 2419200 - any other value will be rounded to the nearest valid value.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ttl_sec")]
		public System.Nullable<System.Int32> Ttl_sec { get; set; }
		
		/// <summary>
		/// The type of Record this is in the DNS system. For example, A records associate a domain name with an IPv4 address, and AAAA records associate a domain name with an IPv6 address. For more information, see the guides on [DNS Record Types](/docs/products/networking/dns-manager/guides/#dns-record-types).
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<DomainRecordType> Type { get; set; }
		
		/// <summary>
		/// When this Domain Record was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
		
		/// <summary>
		/// The relative weight of this Record used in the case of identical priority. Higher values are preferred. Only valid and required for SRV record requests.
		///
		/// Minimum: 0
		/// Maximum: 65535
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="weight")]
		[System.ComponentModel.DataAnnotations.Range(0, 65535)]
		public System.Nullable<System.Int32> Weight { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DomainRecordTag
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		issue = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		issuewild = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		iodef = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DomainRecordType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		A = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AAAA = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MX = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CNAME = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TXT = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SRV = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PTR = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CAA = 8,
	}
	
	/// <summary>
	/// An object representing an Entity Transfer.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class EntityTransfer
	{
		
		/// <summary>
		/// When this transfer was created.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// A collection of the entities to include in this transfer request, separated by type.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entities")]
		public EntityTransferEntities Entities { get; set; }
		
		/// <summary>
		/// When this transfer expires. Transfers will automatically expire 24 hours after creation.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiry")]
		public System.Nullable<System.DateTimeOffset> Expiry { get; set; }
		
		/// <summary>
		/// If the requesting account created this transfer.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_sender")]
		public System.Nullable<System.Boolean> Is_sender { get; set; }
		
		/// <summary>
		/// The status of the transfer request.
		///
		///`accepted`: The transfer has been accepted by another user and is currently in progress. Transfers can take up to 3 hours to complete.
		///
		///`cancelled`: The transfer has been cancelled by the sender.
		///
		///`completed`: The transfer has completed successfully.
		///
		///`failed`: The transfer has failed after initiation.
		///
		///`pending`: The transfer is ready to be accepted.
		///
		///`stale`: The transfer has exceeded its expiration date. It can no longer be accepted or cancelled.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<EntityTransferStatus> Status { get; set; }
		
		/// <summary>
		/// The token used to identify and accept or cancel this transfer.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
		
		/// <summary>
		/// When this transfer was last updated.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
	}
	
	public class EntityTransferEntities
	{
		
		/// <summary>
		/// An array containing the IDs of each of the Linodes included in this transfer.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linodes")]
		public int[] Linodes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum EntityTransferStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		accepted = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cancelled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		completed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stale = 5,
	}
	
	/// <summary>
	/// An object for describing a single error that occurred during the processing of a request.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ErrorObject
	{
		
		/// <summary>
		/// The field in the request that caused this error. This may be a path, separated by periods in the case of nested fields. In some cases this may come back as "null" if the error is not specific to any single element of the request.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="field")]
		public string Field { get; set; }
		
		/// <summary>
		/// What happened to cause this error. In most cases, this can be fixed immediately by changing the data you sent in the request, but in some cases you will be instructed to [open a Support Ticket](/docs/api/support/#support-ticket-open) or perform some other action before you can complete the request successfully.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
	}
	
	/// <summary>
	/// A collection of Event objects. An Event is an action taken against an entity related to your Account. For example, booting a Linode would create an Event.
	///The Events returned depends on your grants.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Event
	{
		
		/// <summary>
		/// The action that caused this Event. New actions may be added in the future.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="action")]
		public System.Nullable<EventAction> Action { get; set; }
		
		/// <summary>
		/// When this Event was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// The total duration in seconds that it takes for the Event to complete.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<System.Double> Duration { get; set; }
		
		/// <summary>
		/// Detailed information about the Event's entity, including ID, type, label, and URL used to access it.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entity")]
		public EventEntity Entity { get; set; }
		
		/// <summary>
		/// The unique ID of this Event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Provides additional information about the event. Additional information may include, but is not limited to, a more detailed representation of events which can help diagnose non-obvious failures.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// A percentage estimating the amount of time remaining for an Event.
		///Returns `null` for notification events.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percent_complete")]
		public System.Nullable<System.Int32> Percent_complete { get; set; }
		
		/// <summary>
		/// The rate of completion of the Event. Only some Events will return rate; for example, migration and resize Events.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rate")]
		public string Rate { get; set; }
		
		/// <summary>
		/// If this Event has been read.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="read")]
		public System.Nullable<System.Boolean> Read { get; set; }
		
		/// <summary>
		/// Detailed information about the Event's secondary entity, which provides additional information
		///for events such as, but not limited to, `linode_boot`, `linode_reboot`, `linode_create`, and `linode_clone` Event actions.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondary_entity")]
		public EventSecondary_entity Secondary_entity { get; set; }
		
		/// <summary>
		/// If this Event has been seen.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seen")]
		public System.Nullable<System.Boolean> Seen { get; set; }
		
		/// <summary>
		/// The current status of this Event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<EventStatus> Status { get; set; }
		
		/// <summary>
		/// The estimated time remaining until the completion of this Event. This value is only returned for some in-progress migration events. For all other in-progress events, the `percent_complete` attribute will indicate about how much more work is to be done.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time_remaining")]
		public string Time_remaining { get; set; }
		
		/// <summary>
		/// The username of the User who caused the Event.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum EventAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		account_update = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		account_settings_update = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		backups_enable = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		backups_cancel = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		backups_restore = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		community_question_reply = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		community_like = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		credit_card_updated = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disk_create = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disk_delete = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disk_update = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disk_duplicate = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disk_imagize = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disk_resize = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dns_record_create = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dns_record_delete = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dns_record_update = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dns_zone_create = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dns_zone_delete = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dns_zone_import = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dns_zone_update = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		entity_transfer_accept = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		entity_transfer_cancel = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		entity_transfer_create = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		entity_transfer_fail = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		entity_transfer_stale = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		firewall_create = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		firewall_delete = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		firewall_disable = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		firewall_enable = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		firewall_update = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		firewall_device_add = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		firewall_device_remove = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		host_reboot = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		image_delete = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		image_update = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		image_upload = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ipaddress_update = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		lassie_reboot = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		lish_boot = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_addip = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_boot = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_clone = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_create = 43,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_delete = 44,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_update = 45,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_deleteip = 46,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_migrate = 47,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_migrate_datacenter = 48,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_migrate_datacenter_create = 49,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_mutate = 50,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_mutate_create = 51,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_reboot = 52,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_rebuild = 53,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_resize = 54,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_resize_create = 55,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_shutdown = 56,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_snapshot = 57,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_config_create = 58,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_config_delete = 59,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode_config_update = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		lke_node_create = 61,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		longviewclient_create = 62,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		longviewclient_delete = 63,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		longviewclient_update = 64,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		managed_disabled = 65,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		managed_enabled = 66,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		managed_service_create = 67,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		managed_service_delete = 68,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		nodebalancer_create = 69,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		nodebalancer_delete = 70,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		nodebalancer_update = 71,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		nodebalancer_config_create = 72,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		nodebalancer_config_delete = 73,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		nodebalancer_config_update = 74,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		nodebalancer_node_create = 75,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		nodebalancer_node_delete = 76,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		nodebalancer_node_update = 77,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		oauth_client_create = 78,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		oauth_client_delete = 79,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		oauth_client_secret_reset = 80,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		oauth_client_update = 81,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		password_reset = 82,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		payment_method_add = 83,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		payment_submitted = 84,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		profile_update = 85,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stackscript_create = 86,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stackscript_delete = 87,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stackscript_update = 88,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stackscript_publicize = 89,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stackscript_revise = 90,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tag_create = 91,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tag_delete = 92,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tfa_disabled = 93,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tfa_enabled = 94,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ticket_attachment_upload = 95,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ticket_create = 96,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ticket_update = 97,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		token_create = 98,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		token_delete = 99,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		token_update = 100,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		user_create = 101,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		user_update = 102,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		user_delete = 103,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		user_ssh_key_add = 104,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		user_ssh_key_delete = 105,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		user_ssh_key_update = 106,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		vlan_attach = 107,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		vlan_detach = 108,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		volume_attach = 109,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		volume_clone = 110,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		volume_create = 111,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		volume_delete = 112,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		volume_update = 113,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		volume_detach = 114,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		volume_resize = 115,
	}
	
	public class EventEntity
	{
		
		/// <summary>
		/// The unique ID for an Event's entity.
		///
		///
		///Some Event entities do not have IDs associated with them, so they
		///will not be returned when filtering by ID. These Events include:
		///  * `account`
		///  * `profile`
		///
		///Entities for some Events are assigned the ID of the Linode they correspond to.
		///When filtering by ID for these Events, use the corresponding Linode's ID.
		///These Events include:
		///  * `disks`
		///  * `backups`
		///
		///
		///Tag Events use a tag's name for the entity ID field. When filtering by ID
		///for tag Events, supply the name of the tag.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The current label of this object. The label may reflect changes that occur with this Event.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The type of entity that is being referenced by the Event.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<EventEntityType> Type { get; set; }
		
		/// <summary>
		/// The URL where you can access the object this Event is for. If a relative URL, it is relative to the domain you retrieved the Event from.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum EventEntityType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		account = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		backups = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		community = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disks = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		domain = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		entity_transfer = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		firewall = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		image = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ipaddress = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		longview = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		managed_service = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		nodebalancer = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		oauth_client = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		profile = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stackscript = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tag = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ticket = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		token = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		user = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		user_ssh_key = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		volume = 21,
	}
	
	public class EventSecondary_entity
	{
		
		/// <summary>
		/// The ID of the object that is the secondary entity.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The label of this object.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The type of entity that is being referenced by the Event.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// The URL where you can access the object this Event is for. If a relative URL, it is relative to the domain you retrieved the Event from.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum EventStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		finished = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		notification = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		scheduled = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		started = 4,
	}
	
	/// <summary>
	/// A resource that controls incoming and outgoing network traffic to a Linode service. Only one Firewall can be attached to a Linode at any given time. [Create a Firewall Device](/docs/api/networking/#firewall-create) to assign a Firewall to a Linode service. Currently, Firewalls can only be assigned to Linode instances.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Firewall
	{
		
		/// <summary>
		/// When this Firewall was created.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// The Firewall's unique ID.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The Firewall's label, for display purposes only.
		///
		///Firewall labels have the following constraints:
		///
		///  * Must begin and end with an alphanumeric character.
		///  * May only consist of alphanumeric characters, dashes (`-`), underscores (`_`) or periods (`.`).
		///  * Cannot have two dashes (`--`), underscores (`__`) or periods (`..`) in a row.
		///  * Must be between 3 and 32 characters.
		///  * Must be unique.
		///
		/// Min length: 3
		/// Max length: 32
		/// Pattern: ^[a-zA-Z]((?!--|__|..)[a-zA-Z0-9-_.])+$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(3)]
		[System.ComponentModel.DataAnnotations.MaxLength(32)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z]((?!--|__|..)[a-zA-Z0-9-_.])+$")]
		public string Label { get; set; }
		
		/// <summary>
		/// The inbound and outbound access rules to apply to the Firewall.
		///
		///A Firewall may have up to 25 rules across its inbound and outbound rulesets.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public FirewallRules Rules { get; set; }
		
		/// <summary>
		/// The status of this Firewall.
		///
		///  * When a Firewall is first created its status is `enabled`.
		///  * Use the [Update Firewall](/docs/api/networking/#firewall-update) endpoint to set a Firewall's status to `enabled` or `disabled`.
		///  * Use the [Delete Firewall](/docs/api/networking/#firewall-delete) endpoint to delete a Firewall.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<FirewallStatus> Status { get; set; }
		
		/// <summary>
		/// An array of tags applied to this object. Tags are for organizational purposes only.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// When this Firewall was last updated.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
	}
	
	public class FirewallRules
	{
		
		/// <summary>
		/// The inbound rules for the firewall, as a JSON array.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inbound")]
		public FirewallRuleConfig[] Inbound { get; set; }
		
		/// <summary>
		/// The default behavior for inbound traffic. This setting can be overridden by [updating](/docs/api/networking/#firewall-rules-update) the `inbound.action` property of the Firewall Rule.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inbound_policy")]
		public FirewallRuleConfigAction Inbound_policy { get; set; }
		
		/// <summary>
		/// The outbound rules for the firewall, as a JSON array.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outbound")]
		public FirewallRuleConfig[] Outbound { get; set; }
		
		/// <summary>
		/// The default behavior for outbound traffic. This setting can be overridden by [updating](/docs/api/networking/#firewall-rules-update) the `outbound.action` property of the Firewall Rule.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outbound_policy")]
		public FirewallRuleConfigAction Outbound_policy { get; set; }
	}
	
	/// <summary>
	/// One of a Firewall's inbound or outbound access rules. The `ports` property can be used to allow traffic on a comma-separated list of different ports.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FirewallRuleConfig
	{
		
		/// <summary>
		/// Controls whether traffic is accepted or dropped by this rule. Overrides the Firewall's `inbound_policy` if this is an inbound rule, or the `outbound_policy` if this is an outbound rule.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="action")]
		public System.Nullable<FirewallRuleConfigAction> Action { get; set; }
		
		/// <summary>
		/// Allowed IPv4 or IPv6 addresses. A Rule can have up to 255 addresses or networks listed across its IPv4 and IPv6 arrays. A network and a single IP are treated as equivalent when accounting for this limit.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public FirewallRuleConfigAddresses Addresses { get; set; }
		
		/// <summary>
		/// Used to describe this rule. For display purposes only.
		///
		/// Min length: 1
		/// Max length: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Description { get; set; }
		
		/// <summary>
		/// Used to identify this rule. For display purposes only.
		///
		/// Min length: 3
		/// Max length: 32
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(3)]
		[System.ComponentModel.DataAnnotations.MaxLength(32)]
		public string Label { get; set; }
		
		/// <summary>
		/// A string representing the port or ports on which traffic will be allowed:
		///
		///- The string may be a single port, a range of ports, or a comma-separated list of single ports and port ranges. A space is permitted following each comma.
		///- A range of ports is inclusive of the start and end values for the range. The end value of the range must be greater than the start value.
		///- Ports must be within 1 and 65535, and may not contain any leading zeroes. For example, port "080" is not allowed.
		///- Ports may not be specified if a rule's protocol is `ICMP` or `IPENCAP`.
		///- At least one port must be specified if a rule's protocol is `TCP` or `UDP`.
		///- The ports string can have up to 15 *pieces*, where a single port is treated as one piece, and a port range is treated as two pieces. For example, the string "22-24, 80, 443" has four pieces.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ports")]
		public string Ports { get; set; }
		
		/// <summary>
		/// The type of network traffic to allow.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public System.Nullable<FirewallRuleConfigProtocol> Protocol { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum FirewallRuleConfigAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DROP = 1,
	}
	
	public class FirewallRuleConfigAddresses
	{
		
		/// <summary>
		/// A list of IPv4 addresses or networks. Must be in IP/mask format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public string[] Ipv4 { get; set; }
		
		/// <summary>
		/// A list of IPv6 addresses or networks. Must be in IP/mask format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public string[] Ipv6 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum FirewallRuleConfigProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TCP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UDP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ICMP = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IPENCAP = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum FirewallStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deleted = 2,
	}
	
	/// <summary>
	/// Associates a Firewall with a Linode service. A Firewall can be assigned to a single Linode service at a time. Additional disabled Firewalls can be assigned to a service, but they cannot be enabled if another active Firewall is already assigned to the same service.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FirewallDevices
	{
		
		/// <summary>
		/// When this Device was created.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// The Linode service that this Firewall has been applied to.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entity")]
		public FirewallDevicesEntity Entity { get; set; }
		
		/// <summary>
		/// The Device's unique ID
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// When this Device was last updated.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
	}
	
	public class FirewallDevicesEntity
	{
		
		/// <summary>
		/// The entity's ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The entity's label.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The entity's type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<FirewallDevicesEntityType> Type { get; set; }
		
		/// <summary>
		/// The URL you can use to access this entity.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum FirewallDevicesEntityType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		linode = 0,
	}
	
	/// <summary>
	/// Google Pay information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GooglePayData
	{
		
		/// <summary>
		/// The type of credit card.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="card_type")]
		public string Card_type { get; set; }
		
		/// <summary>
		/// The expiration month and year of the credit card.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiry")]
		public string Expiry { get; set; }
		
		/// <summary>
		/// The last four digits of the credit card number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_four")]
		public string Last_four { get; set; }
	}
	
	/// <summary>
	/// Represents the level of access a restricted User has to a specific resource on the Account.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Grant
	{
		
		/// <summary>
		/// The ID of the entity this grant applies to.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The current label of the entity this grant applies to, for display purposes.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The level of access this User has to this entity.  If null, this User has no access.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public System.Nullable<GrantPermissions> Permissions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GrantPermissions
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		read_only = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		read_write = 1,
	}
	
	/// <summary>
	/// A structure representing all grants a restricted User has on the Account. Not available for unrestricted users, as they have access to everything without grants. If retrieved from the `/profile/grants` endpoint, entities to which a User has no access will be omitted.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GrantsResponse
	{
		
		/// <summary>
		/// The grants this User has for each Database that is owned by this Account.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="database")]
		public Grant[] Database { get; set; }
		
		/// <summary>
		/// The grants this User has for each Domain that is owned by this Account.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public Grant[] Domain { get; set; }
		
		/// <summary>
		/// A structure containing the Account-level grants a User has.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="global")]
		public GrantsResponseGlobal Global { get; set; }
		
		/// <summary>
		/// The grants this User has for each Image that is owned by this Account.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public Grant[] Image { get; set; }
		
		/// <summary>
		/// The grants this User has for each Linode that is owned by this Account.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linode")]
		public Grant[] Linode { get; set; }
		
		/// <summary>
		/// The grants this User has for each Longview Client that is owned by this Account.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="longview")]
		public Grant[] Longview { get; set; }
		
		/// <summary>
		/// The grants this User has for each NodeBalancer that is owned by this Account.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodebalancer")]
		public Grant[] Nodebalancer { get; set; }
		
		/// <summary>
		/// The grants this User has for each StackScript that is owned by this Account.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stackscript")]
		public Grant[] Stackscript { get; set; }
		
		/// <summary>
		/// The grants this User has for each Block Storage Volume that is owned by this Account.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volume")]
		public Grant[] Volume { get; set; }
	}
	
	public class GrantsResponseGlobal
	{
		
		/// <summary>
		/// The level of access this User has to Account-level actions, like billing information. A restricted User will never be able to manage users.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="account_access")]
		public GrantPermissions Account_access { get; set; }
		
		/// <summary>
		/// if true, this User may add Managed Databases.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="add_databases")]
		public System.Nullable<System.Boolean> Add_databases { get; set; }
		
		/// <summary>
		/// If true, this User may add Domains.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="add_domains")]
		public System.Nullable<System.Boolean> Add_domains { get; set; }
		
		/// <summary>
		/// If true, this User may add Firewalls.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="add_firewalls")]
		public System.Nullable<System.Boolean> Add_firewalls { get; set; }
		
		/// <summary>
		/// If true, this User may add Images.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="add_images")]
		public System.Nullable<System.Boolean> Add_images { get; set; }
		
		/// <summary>
		/// If true, this User may create Linodes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="add_linodes")]
		public System.Nullable<System.Boolean> Add_linodes { get; set; }
		
		/// <summary>
		/// If true, this User may create Longview clients and view the current plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="add_longview")]
		public System.Nullable<System.Boolean> Add_longview { get; set; }
		
		/// <summary>
		/// If true, this User may add NodeBalancers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="add_nodebalancers")]
		public System.Nullable<System.Boolean> Add_nodebalancers { get; set; }
		
		/// <summary>
		/// If true, this User may add StackScripts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="add_stackscripts")]
		public System.Nullable<System.Boolean> Add_stackscripts { get; set; }
		
		/// <summary>
		/// If true, this User may add Volumes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="add_volumes")]
		public System.Nullable<System.Boolean> Add_volumes { get; set; }
		
		/// <summary>
		/// If true, this User may cancel the entire Account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cancel_account")]
		public System.Nullable<System.Boolean> Cancel_account { get; set; }
		
		/// <summary>
		/// If true, this User may manage the Account's Longview subscription.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="longview_subscription")]
		public System.Nullable<System.Boolean> Longview_subscription { get; set; }
	}
	
	/// <summary>
	/// An IP address that exists in Linode's system, either IPv4 or IPv6.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IPAddress
	{
		
		/// <summary>
		/// The IP address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The default gateway for this address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The ID of the Linode this address currently belongs to. For IPv4 addresses, this is by default the Linode that this address was assigned to on creation, and these addresses my be moved using the [/networking/ipv4/assign](/docs/api/networking/#ips-to-linodes-assign) endpoint. For SLAAC and link-local addresses, this value may not be changed.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linode_id")]
		public System.Nullable<System.Int32> Linode_id { get; set; }
		
		/// <summary>
		/// The number of bits set in the subnet mask.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public System.Nullable<System.Int32> Prefix { get; set; }
		
		/// <summary>
		/// Whether this is a public or private IP address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="public")]
		public System.Nullable<System.Boolean> Public { get; set; }
		
		/// <summary>
		/// The reverse DNS assigned to this address. For public IPv4 addresses, this will be set to a default value provided by Linode if not explicitly set.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rdns")]
		public string Rdns { get; set; }
		
		/// <summary>
		/// The Region this IP address resides in.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The mask that separates host bits from network bits for this address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet_mask")]
		public string Subnet_mask { get; set; }
		
		/// <summary>
		/// The type of address this is.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<IPAddressType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum IPAddressType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ipv4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ipv6 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ipv6/pool")]
		ipv6_pool = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ipv6/range")]
		ipv6_range = 3,
	}
	
	/// <summary>
	/// A private IPv4 address that exists in Linode's system.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IPAddressPrivate
	{
		
		/// <summary>
		/// The private IPv4 address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The default gateway for this address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The ID of the Linode this address currently belongs to.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linode_id")]
		public System.Nullable<System.Int32> Linode_id { get; set; }
		
		/// <summary>
		/// The number of bits set in the subnet mask.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public System.Nullable<System.Int32> Prefix { get; set; }
		
		/// <summary>
		/// Whether this is a public or private IP address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="public")]
		public System.Nullable<System.Boolean> Public { get; set; }
		
		/// <summary>
		/// The reverse DNS assigned to this address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rdns")]
		public string Rdns { get; set; }
		
		/// <summary>
		/// The Region this address resides in.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The mask that separates host bits from network bits for this address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet_mask")]
		public string Subnet_mask { get; set; }
		
		/// <summary>
		/// The type of address this is.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// A link-local IPv6 address that exists in Linode's system,.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IPAddressV6LinkLocal
	{
		
		/// <summary>
		/// The IPv6 link-local address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The default gateway for this address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The ID of the Linode this address currently belongs to.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linode_id")]
		public System.Nullable<System.Int32> Linode_id { get; set; }
		
		/// <summary>
		/// The network prefix.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public System.Nullable<System.Int32> Prefix { get; set; }
		
		/// <summary>
		/// Whether this is a public or private IP address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="public")]
		public System.Nullable<System.Boolean> Public { get; set; }
		
		/// <summary>
		/// The reverse DNS assigned to this address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rdns")]
		public string Rdns { get; set; }
		
		/// <summary>
		/// The Region this address resides in.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The subnet mask.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet_mask")]
		public string Subnet_mask { get; set; }
		
		/// <summary>
		/// The type of address this is.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// A SLAAC IPv6 address that exists in Linode's system.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IPAddressV6Slaac
	{
		
		/// <summary>
		/// The address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The default gateway for this address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// The ID of the Linode this address currently belongs to.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linode_id")]
		public System.Nullable<System.Int32> Linode_id { get; set; }
		
		/// <summary>
		/// The network prefix.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public System.Nullable<System.Int32> Prefix { get; set; }
		
		/// <summary>
		/// Whether this is a public or private IP address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="public")]
		public System.Nullable<System.Boolean> Public { get; set; }
		
		/// <summary>
		/// The reverse DNS assigned to this address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rdns")]
		public string Rdns { get; set; }
		
		/// <summary>
		/// The Region this address resides in.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The subnet mask.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet_mask")]
		public string Subnet_mask { get; set; }
		
		/// <summary>
		/// The type of address this is.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Request object for IP Addresses Assign (POST /networking/ips/assign).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IPAddressesAssignRequest
	{
		
		/// <summary>
		/// The list of assignments to make. You must have read_write access to all IPs being assigned and all Linodes being assigned to in order for the assignments to succeed.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignments")]
		public IPAddressesAssignRequestAssignments[] IPAddressesAssignRequestAssignments { get; set; }
		
		/// <summary>
		/// The ID of the Region in which these assignments are to take place. All IPs and Linodes must exist in this Region.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
	}
	
	public class IPAddressesAssignRequestAssignments
	{
		
		/// <summary>
		/// The IPv4 address or IPv6 range for this assignment.
		///* Must be an IPv4 address or an IPv6 range you can access in the Region specified.
		///* IPv6 ranges must include a prefix length of `/56` or `/64`, for example: `2001:db8:3c4d:15::/64`.
		///* Assignment of an IPv6 range to a Linode updates the route target of the range to the assigned Linode's SLAAC address.
		///* May be a public or private address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The ID of the Linode to assign this address to. The IP's previous Linode will lose this address, and must end up with at least one public address and no more than one private address once all assignments have been made.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linode_id")]
		public System.Nullable<System.Int32> Linode_id { get; set; }
	}
	
	/// <summary>
	/// A request object IP Addresses Share (POST /networking/ips/share)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IPAddressesShareRequest
	{
		
		/// <summary>
		/// A list of secondary Linode IPs to share with the primary Linode.
		///* Can include both IPv4 addresses and IPv6 ranges (omit /56 and /64 prefix lengths)
		///* Can include both private and public IPv4 addresses.
		///* You must have access to all of these addresses and they must be in the same Region as the primary Linode.
		///* Enter an empty array to remove all shared IP addresses.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ips")]
		public string[] Ips { get; set; }
		
		/// <summary>
		/// The ID of the primary Linode that the addresses will be shared with.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="linode_id")]
		public int Linode_id { get; set; }
	}
	
	/// <summary>
	/// An object representing an IPv6 pool.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IPv6Pool
	{
		
		/// <summary>
		/// The prefix length of the address, denoting how many addresses can be assigned from this pool calculated as 2 <sup>128-prefix</sup>.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public System.Nullable<System.Int32> Prefix { get; set; }
		
		/// <summary>
		/// The IPv6 range of addresses in this pool.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="range")]
		public string Range { get; set; }
		
		/// <summary>
		/// The region for this pool of IPv6 addresses.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The last address in this block of IPv6 addresses.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="route_target")]
		public string Route_target { get; set; }
	}
	
	/// <summary>
	/// An object representing an IPv6 range.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IPv6Range
	{
		
		/// <summary>
		/// The prefix length of the address, denoting how many addresses can be assigned from this range calculated as 2 <sup>128-prefix</sup>.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public System.Nullable<System.Int32> Prefix { get; set; }
		
		/// <summary>
		/// The IPv6 range of addresses in this pool.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="range")]
		public string Range { get; set; }
		
		/// <summary>
		/// The region for this range of IPv6 addresses.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The last address in this block of IPv6 addresses.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="route_target")]
		public string Route_target { get; set; }
	}
	
	/// <summary>
	/// An object representing an IPv6 range.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IPv6RangeBGP
	{
		
		/// <summary>
		/// Whether this IPv6 range is shared.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_bgp")]
		public System.Nullable<System.Boolean> Is_bgp { get; set; }
		
		/// <summary>
		/// A list of Linodes targeted by this IPv6 range. Includes Linodes with IP sharing.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linodes")]
		public int[] Linodes { get; set; }
		
		/// <summary>
		/// The prefix length of the address, denoting how many addresses can be assigned from this range calculated as 2 <sup>128-prefix</sup>.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public System.Nullable<System.Int32> Prefix { get; set; }
		
		/// <summary>
		/// The IPv6 range of addresses in this pool.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="range")]
		public string Range { get; set; }
		
		/// <summary>
		/// The region for this range of IPv6 addresses.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
	}
	
	/// <summary>
	/// Image object
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Image
	{
		
		/// <summary>
		/// When this Image was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// The name of the User who created this Image, or "linode" for public Images.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_by")]
		public string Created_by { get; set; }
		
		/// <summary>
		/// Whether or not this Image is deprecated. Will only be true for deprecated public Images.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public System.Nullable<System.Boolean> Deprecated { get; set; }
		
		/// <summary>
		/// A detailed description of this Image.
		/// Min length: 1
		/// Max length: 65000
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(65000)]
		public string Description { get; set; }
		
		/// <summary>
		/// The date of the public Image's planned end of life. `None` for private Images.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eol")]
		public System.Nullable<System.DateTimeOffset> Eol { get; set; }
		
		/// <summary>
		/// Only Images created automatically from a deleted Linode (type=automatic) will expire.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiry")]
		public System.Nullable<System.DateTimeOffset> Expiry { get; set; }
		
		/// <summary>
		/// The unique ID of this Image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// True if the Image is a public distribution image. False if Image is private Account-specific Image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_public")]
		public System.Nullable<System.Boolean> Is_public { get; set; }
		
		/// <summary>
		/// A short description of the Image.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The minimum size this Image needs to deploy. Size is in MB.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		/// <summary>
		/// The current status of this Image.
		///
		///Only Images in an "available" status can be deployed. Images in a "creating" status are being created from a Linode Disk, and will become "available" shortly. Images in a "pending_upload" status are waiting for data to be [uploaded](/docs/api/images/#image-upload), and become "available" after the upload and processing are complete.
		///
		///The "+order_by" and "+order" operators are not available for [filtering](/docs/api/#filtering-and-sorting) on this key.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<ImageStatus> Status { get; set; }
		
		/// <summary>
		/// How the Image was created.
		///
		///"Manual" Images can be created at any time.
		///
		///"Automatic" Images are created automatically from a deleted Linode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<ImageType> Type { get; set; }
		
		/// <summary>
		/// When this Image was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
		
		/// <summary>
		/// The upstream distribution vendor. `None` for private Images.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vendor")]
		public string Vendor { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ImageStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		creating = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending_upload = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		available = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ImageType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		manual = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		automatic = 1,
	}
	
	/// <summary>
	/// Account Invoice object
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Invoice
	{
		
		/// <summary>
		/// When this Invoice was generated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date")]
		public System.Nullable<System.DateTimeOffset> Date { get; set; }
		
		/// <summary>
		/// The Invoice's unique ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The Invoice's display label.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The amount of the Invoice before taxes in US Dollars.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subtotal")]
		public System.Nullable<System.Double> Subtotal { get; set; }
		
		/// <summary>
		/// The amount of tax levied on the Invoice in US Dollars.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tax")]
		public System.Nullable<System.Double> Tax { get; set; }
		
		/// <summary>
		/// The amount of tax broken down into subtotals by source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tax_summary")]
		public InvoiceTax_summary[] InvoiceTax_summary { get; set; }
		
		/// <summary>
		/// The amount of the Invoice after taxes in US Dollars.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Double> Total { get; set; }
	}
	
	public class InvoiceTax_summary
	{
		
		/// <summary>
		/// The source of this tax subtotal.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The amount of tax subtotal attributable to this source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tax")]
		public System.Nullable<System.Double> Tax { get; set; }
	}
	
	/// <summary>
	/// An InvoiceItem object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InvoiceItem
	{
		
		/// <summary>
		/// The price, in US dollars, of the Invoice Item. Equal to the unit price multiplied by quantity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="amount")]
		public System.Nullable<System.Double> Amount { get; set; }
		
		/// <summary>
		/// The date the Invoice Item started, based on month.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public System.Nullable<System.DateTimeOffset> From { get; set; }
		
		/// <summary>
		/// The Invoice Item's display label.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The quantity of this Item for the specified Invoice.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quantity")]
		public System.Nullable<System.Int32> Quantity { get; set; }
		
		/// <summary>
		/// The amount of tax levied on this Item in US Dollars.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tax")]
		public System.Nullable<System.Double> Tax { get; set; }
		
		/// <summary>
		/// The date the Invoice Item ended, based on month.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public System.Nullable<System.DateTimeOffset> To { get; set; }
		
		/// <summary>
		/// The price of this Item after taxes in US Dollars.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Double> Total { get; set; }
		
		/// <summary>
		/// The type of service, ether `hourly` or `misc`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<InvoiceItemType> Type { get; set; }
		
		/// <summary>
		/// The monthly service fee in US Dollars for this Item.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unit_price")]
		public string Unit_price { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum InvoiceItemType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hourly = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		misc = 1,
	}
	
	/// <summary>
	/// Linux kernel object
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Kernel
	{
		
		/// <summary>
		/// The architecture of this Kernel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="architecture")]
		public System.Nullable<KernelArchitecture> Architecture { get; set; }
		
		/// <summary>
		/// The date on which this Kernel was built.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="built")]
		public System.Nullable<System.DateTimeOffset> Built { get; set; }
		
		/// <summary>
		/// If this Kernel is marked as deprecated, this field has a value of true; otherwise, this field is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public System.Nullable<System.Boolean> Deprecated { get; set; }
		
		/// <summary>
		/// The unique ID of this Kernel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// If this Kernel is suitable for KVM Linodes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kvm")]
		public System.Nullable<System.Boolean> Kvm { get; set; }
		
		/// <summary>
		/// The friendly name of this Kernel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// If this Kernel is suitable for paravirtualized operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pvops")]
		public System.Nullable<System.Boolean> Pvops { get; set; }
		
		/// <summary>
		/// Linux Kernel version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
		
		/// <summary>
		/// If this Kernel is suitable for Xen Linodes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xen")]
		public System.Nullable<System.Boolean> Xen { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum KernelArchitecture
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		x86_64 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		i386 = 1,
	}
	
	/// <summary>
	/// A Kubernetes cluster.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LKECluster
	{
		
		/// <summary>
		/// Defines settings for the Kubernetes Control Plane. Allows for the enabling of High Availability (HA) for Control Plane Components. Enabling High Avaialability for LKE is an **irreversible** change.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="control_plane")]
		public LKEClusterControl_plane Control_plane { get; set; }
		
		/// <summary>
		/// When this Kubernetes cluster was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// This Kubernetes cluster's unique ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The desired Kubernetes version for this Kubernetes cluster in the format of &lt;major&gt;.&lt;minor&gt;, and the latest supported patch version will be deployed.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="k8s_version")]
		public string K8s_version { get; set; }
		
		/// <summary>
		/// This Kubernetes cluster's unique label for display purposes only.
		///Labels have the following constraints:
		///
		///  * UTF-8 characters will be returned by the API using escape
		///    sequences of their Unicode code points. For example, the
		///    Japanese character *か* is 3 bytes in UTF-8 (`0xE382AB`). Its
		///    Unicode code point is 2 bytes (`0x30AB`). APIv4 supports this
		///    character and the API will return it as the escape sequence
		///    using six 1 byte characters which represent 2 bytes of Unicode
		///    code point (`"\u30ab"`).
		///  * 4 byte UTF-8 characters are not supported.
		///  * If the label is entirely composed of UTF-8 characters, the API
		///    response will return the code points using up to 193 1 byte
		///    characters.
		///
		/// Min length: 1
		/// Max length: 32
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(32)]
		public string Label { get; set; }
		
		/// <summary>
		/// This Kubernetes cluster's location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// An array of tags applied to the Kubernetes cluster. Tags are for organizational purposes only.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// When this Kubernetes cluster was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
	}
	
	public class LKEClusterControl_plane
	{
		
		/// <summary>
		/// Defines whether High Availability is enabled for the Control Plane Components of the cluster. Defaults to `false`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="high_availability")]
		public System.Nullable<System.Boolean> High_availability { get; set; }
	}
	
	/// <summary>
	/// The set of Node Pools which are members of the Kubernetes cluster. Node Pools consist of a Linode type, the number of Linodes to deploy of that type, and additional status information.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LKENodePool
	{
		
		/// <summary>
		/// When enabled, the number of nodes autoscales within the defined minimum and maximum values.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoscaler")]
		public LKENodePoolAutoscaler Autoscaler { get; set; }
		
		/// <summary>
		/// The number of nodes in the Node Pool.
		/// Minimum: 1
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		[System.ComponentModel.DataAnnotations.Range(1, 100)]
		public System.Nullable<System.Int32> Count { get; set; }
		
		/// <summary>
		/// This Node Pool's custom disk layout.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public LKENodePoolDisks[] LKENodePoolDisks { get; set; }
		
		/// <summary>
		/// This Node Pool's unique ID.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Status information for the Nodes which are members of this Node Pool. If a Linode has not been provisioned for a given Node slot, the instance_id will be returned as null.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodes")]
		public LKENodeStatus[] Nodes { get; set; }
		
		/// <summary>
		/// An array of tags applied to this object. Tags are for organizational purposes only.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// The Linode Type for all of the nodes in the Node Pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class LKENodePoolAutoscaler
	{
		
		/// <summary>
		/// Whether autoscaling is enabled for this Node Pool. Defaults to `false`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The maximum number of nodes to autoscale to. Defaults to the Node Pool's `count`.
		/// Minimum: 1
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="max")]
		[System.ComponentModel.DataAnnotations.Range(1, 100)]
		public System.Nullable<System.Int32> Max { get; set; }
		
		/// <summary>
		/// The minimum number of nodes to autoscale to. Defaults to the Node Pool's `count`.
		/// Minimum: 1
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="min")]
		[System.ComponentModel.DataAnnotations.Range(1, 100)]
		public System.Nullable<System.Int32> Min { get; set; }
	}
	
	public class LKENodePoolDisks
	{
		
		/// <summary>
		/// The size of this custom disk partition in MB.
		///
		///  * The size of this disk partition must not exceed the capacity of the node's plan type.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		/// <summary>
		/// This custom disk partition's filesystem type.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<LKENodePoolDisksType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LKENodePoolDisksType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		raw = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ext4 = 1,
	}
	
	/// <summary>
	/// Status information for a Node which is a member of a Kubernetes cluster.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LKENodeStatus
	{
		
		/// <summary>
		/// The Node's ID.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The Linode's ID. When no Linode is currently provisioned for this Node, this will be null.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instance_id")]
		public string Instance_id { get; set; }
		
		/// <summary>
		/// The Node's status as it pertains to being a Kubernetes node.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<LKENodeStatusStatus> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LKENodeStatusStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ready = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		not_ready = 1,
	}
	
	/// <summary>
	/// Specifies a collection of Linodes which will be members of a Kubernetes cluster.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LKENodePoolRequestBody
	{
		
		/// <summary>
		/// When enabled, the number of nodes autoscales within the defined minimum and maximum values.
		///
		///When making a request, `max` and `min` require each other.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoscaler")]
		public LKENodePoolRequestBodyAutoscaler Autoscaler { get; set; }
		
		/// <summary>
		/// The set of Node Pools which are members of the Kubernetes cluster. Node Pools consist of a Linode type, the number of Linodes to deploy of that type, and additional status information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public LKENodePool Count { get; set; }
		
		/// <summary>
		/// **Note**: This field should be omitted except for special use cases. The disks specified here are
		///partitions in *addition* to the primary partition and reduce the size of the primary partition,
		///which can lead to stability problems for the Node.
		///
		///This Node Pool's custom disk layout. Each item in this array will create a new disk
		///partition for each node in this Node Pool.
		///
		///  * The custom disk layout is applied to each node in this Node Pool.
		///  * The maximum number of custom disk partitions that can be configured is 7.
		///  * Once the requested disk paritions are allocated, the remaining disk space is allocated to the node's boot disk.
		///  * A Node Pool's custom disk layout is immutable over the lifetime of the Node Pool.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public LKENodePool[] Disks { get; set; }
		
		/// <summary>
		/// The set of Node Pools which are members of the Kubernetes cluster. Node Pools consist of a Linode type, the number of Linodes to deploy of that type, and additional status information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public LKENodePool Tags { get; set; }
		
		/// <summary>
		/// The set of Node Pools which are members of the Kubernetes cluster. Node Pools consist of a Linode type, the number of Linodes to deploy of that type, and additional status information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public LKENodePool Type { get; set; }
	}
	
	public class LKENodePoolRequestBodyAutoscaler
	{
		
		/// <summary>
		/// Whether autoscaling is enabled for this Node Pool. Defaults to `false`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The maximum number of nodes to autoscale to. Defaults to the Node Pool's `count`. Defaults to the value provided by the `count` field.
		///
		/// Minimum: 1
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="max")]
		[System.ComponentModel.DataAnnotations.Range(1, 100)]
		public System.Nullable<System.Int32> Max { get; set; }
		
		/// <summary>
		/// The minimum number of nodes to autoscale to. Defaults to the Node Pool's `count`.
		/// Minimum: 1
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="min")]
		[System.ComponentModel.DataAnnotations.Range(1, 100)]
		public System.Nullable<System.Int32> Min { get; set; }
	}
	
	/// <summary>
	/// LKE versions
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LKEVersion
	{
		
		/// <summary>
		/// A Kubernetes version number available for deployment to a Kubernetes cluster in the format of &lt;major&gt;.&lt;minor&gt;, and the latest supported patch version.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Linode
	{
		
		[System.Runtime.Serialization.DataMember(Name="alerts")]
		public LinodeAlerts Alerts { get; set; }
		
		/// <summary>
		/// Information about this Linode's backups status. For information about available backups, see [/linode/instances/{linodeId}/backups](/docs/api/linode-instances/#backups-list).
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backups")]
		public LinodeBackups Backups { get; set; }
		
		/// <summary>
		/// When this Linode was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// A deprecated property denoting a group label for this Linode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public string Group { get; set; }
		
		/// <summary>
		/// The Linode's host machine, as a UUID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host_uuid")]
		public string Host_uuid { get; set; }
		
		/// <summary>
		/// The virtualization software powering this Linode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hypervisor")]
		public System.Nullable<LinodeHypervisor> Hypervisor { get; set; }
		
		/// <summary>
		/// This Linode's ID which must be provided for all operations impacting this Linode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="image")]
		public DiskRequest Image { get; set; }
		
		/// <summary>
		/// This Linode's IPv4 Addresses. Each Linode is assigned a single public IPv4 address
		///upon creation, and may get a single private IPv4 address if needed. You may need to
		///[open a support ticket](/docs/api/support/#support-ticket-open)
		///to get additional IPv4 addresses.
		///
		///IPv4 addresses may be reassigned between your Linodes, or shared with other Linodes.
		///See the [/networking](/docs/api/networking/) endpoints for details.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public string[] Ipv4 { get; set; }
		
		/// <summary>
		/// This Linode's IPv6 SLAAC address. This address is specific to a Linode, and may not be shared. If the Linode has not been assigned an IPv6 address, the return value will be `null`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public string Ipv6 { get; set; }
		
		/// <summary>
		/// The Linode's label is for display purposes only. If no label is provided for a Linode,
		///a default will be assigned.
		///
		///Linode labels have the following constraints:
		///
		///  * Must begin and end with an alphanumeric character.
		///  * May only consist of alphanumeric characters, dashes (`-`), underscores (`_`) or periods (`.`).
		///  * Cannot have two dashes (`--`), underscores (`__`) or periods (`..`) in a row.
		///
		/// Min length: 3
		/// Max length: 64
		/// Pattern: ^[a-zA-Z]((?!--|__|..)[a-zA-Z0-9-_.])+$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(3)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z]((?!--|__|..)[a-zA-Z0-9-_.])+$")]
		public string Label { get; set; }
		
		/// <summary>
		/// This is the [Region](/docs/api/regions/#regions-list) where the Linode was deployed. A Linode's region can only be changed by initiating a [cross data center migration](/docs/api/linode-instances/#dc-migrationpending-host-migration-initiate).
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// Information about the resources available to this Linode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="specs")]
		public LinodeSpecs Specs { get; set; }
		
		/// <summary>
		/// A brief description of this Linode's current state. This field may change without direct action from you. For example, when a Linode goes into maintenance mode its status will display "stopped".
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<LinodeStatus> Status { get; set; }
		
		/// <summary>
		/// An array of tags applied to this object.  Tags are for organizational purposes only.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// This is the [Linode Type](/docs/api/linode-types/#types-list) that this Linode was deployed with.
		///To change a Linode's Type, use [POST /linode/instances/{linodeId}/resize](/docs/api/linode-instances/#linode-resize).
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// When this Linode was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
		
		/// <summary>
		/// The watchdog, named Lassie, is a Shutdown Watchdog that monitors your Linode and will reboot it if it powers off unexpectedly. It works by issuing a boot job when your Linode powers off without a shutdown job being responsible.
		///To prevent a loop, Lassie will give up if there have been more than 5 boot jobs issued within 15 minutes.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="watchdog_enabled")]
		public System.Nullable<System.Boolean> Watchdog_enabled { get; set; }
	}
	
	public class LinodeAlerts
	{
		
		/// <summary>
		/// The percentage of CPU usage required to trigger an alert.
		///If the average CPU usage over two hours exceeds this value, we'll send you an alert.
		///Your Linode's total CPU capacity is represented as 100%, multiplied by its number of
		///cores.
		///
		///For example, a two core Linode's CPU capacity is represented as 200%. If you want
		///to be alerted at 90% of a two core Linode's CPU capacity, set the alert value to `180`.
		///
		///The default value is 90% multiplied by the number of cores.
		///
		///If the value is set to `0` (zero), the alert is disabled.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpu")]
		public System.Nullable<System.Int32> Cpu { get; set; }
		
		/// <summary>
		/// The amount of disk IO operation per second required to trigger an alert. If the average disk IO over two hours exceeds this value, we'll send you an alert. If set to `0` (zero), this alert is disabled.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="io")]
		public System.Nullable<System.Int32> Io { get; set; }
		
		/// <summary>
		/// The amount of incoming traffic, in Mbit/s, required to trigger an alert. If the average incoming traffic over two hours exceeds this value, we'll send you an alert. If this is set to `0` (zero), the alert is disabled.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network_in")]
		public System.Nullable<System.Int32> Network_in { get; set; }
		
		/// <summary>
		/// The amount of outbound traffic, in Mbit/s, required to trigger an alert. If the average outbound traffic over two hours exceeds this value, we'll send you an alert. If this is set to `0` (zero), the alert is disabled.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network_out")]
		public System.Nullable<System.Int32> Network_out { get; set; }
		
		/// <summary>
		/// The percentage of network transfer that may be used before an alert is triggered. When this value is exceeded, we'll alert you. If this is set to `0` (zero), the alert is disabled.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transfer_quota")]
		public System.Nullable<System.Int32> Transfer_quota { get; set; }
	}
	
	public class LinodeBackups
	{
		
		/// <summary>
		/// Whether Backups for this Linode are available for restoration.
		///
		///Backups undergoing maintenance are not available for restoration.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="available")]
		public System.Nullable<System.Boolean> Available { get; set; }
		
		/// <summary>
		/// If this Linode has the Backup service enabled. To enable backups, see [POST /linode/instances/{linodeId}/backups/enable](/docs/api/linode-instances/#backups-enable).
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The last successful backup date. 'null' if there was no previous backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_successful")]
		public System.Nullable<System.DateTimeOffset> Last_successful { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public LinodeBackupsSchedule Schedule { get; set; }
	}
	
	public class LinodeBackupsSchedule
	{
		
		/// <summary>
		/// The day of the week that your Linode's weekly Backup is taken.
		///If not set manually, a day will be chosen for you. Backups
		///are taken every day, but backups taken on this day are
		///preferred when selecting backups to retain for a longer period.
		///
		///
		///If not set manually, then when backups are initially enabled, this
		///may come back as `Scheduling` until the `day` is automatically selected.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="day")]
		public System.Nullable<LinodeBackupsScheduleDay> Day { get; set; }
		
		/// <summary>
		/// The window in which your backups will be taken, in UTC. A
		///backups window is a two-hour span of time in which the backup
		///may occur.
		///
		///
		///For example, `W10` indicates that your backups should be
		///taken between 10:00 and 12:00. If you do not choose a backup
		///window, one will be selected for you automatically.
		///
		///
		///If not set manually, when backups are initially enabled this
		///may come back as `Scheduling` until the `window` is automatically selected.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="window")]
		public System.Nullable<LinodeBackupsScheduleWindow> Window { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LinodeBackupsScheduleDay
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Scheduling = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Sunday = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Monday = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Tuesday = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Wednesday = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Thursday = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Friday = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Saturday = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LinodeBackupsScheduleWindow
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Scheduling = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		W0 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		W2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		W4 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		W6 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		W8 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		W10 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		W12 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		W14 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		W16 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		W18 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		W20 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		W22 = 12,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LinodeHypervisor
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		kvm = 0,
	}
	
	public class LinodeSpecs
	{
		
		/// <summary>
		/// The amount of storage space, in MB, this Linode has access to. A typical Linode will divide this space between a primary disk with an `image` deployed to it, and a swap disk, usually 512 MB. This is the default configuration created when deploying a Linode with an `image` through [POST /linode/instances](/docs/api/linode-instances/#linode-create). While this configuration is suitable for 99% of use cases, if you need finer control over your Linode's disks, see the [/linode/instances/{linodeId}/disks](/docs/api/linode-instances/#disks-list) endpoints.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disk")]
		public System.Nullable<System.Int32> Disk { get; set; }
		
		/// <summary>
		/// The number of gpus this Linode has access to.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gpus")]
		public System.Nullable<System.Int32> Gpus { get; set; }
		
		/// <summary>
		/// The amount of RAM, in MB, this Linode has access to.
		///
		///Typically, a Linode boots with all of its available RAM, but this can be configured in a Config profile. See the [/linode/instances/{linodeId}/configs](/docs/api/linode-instances/#configuration-profiles-list) endpoints and the LinodeConfig object for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memory")]
		public System.Nullable<System.Int32> Memory { get; set; }
		
		/// <summary>
		/// The amount of network transfer this Linode is allotted each month.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transfer")]
		public System.Nullable<System.Int32> Transfer { get; set; }
		
		/// <summary>
		/// The number of vcpus this Linode has access to.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vcpus")]
		public System.Nullable<System.Int32> Vcpus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LinodeStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		running = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		offline = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		booting = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rebooting = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		shutting_down = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		provisioning = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deleting = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		migrating = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rebuilding = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cloning = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		restoring = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stopped = 11,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LinodeConfig
	{
		
		/// <summary>
		/// Optional field for arbitrary User comments on this Config.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comments")]
		public string Comments { get; set; }
		
		/// <summary>
		/// A dictionary of device disks to use as a device map in a Linode's configuration profile.
		///* An empty device disk dictionary or a dictionary with empty values for device slots is allowed.
		///* If no devices are specified, booting from this configuration will hold until a device exists that allows the boot process to start.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="devices")]
		public Devices Devices { get; set; }
		
		/// <summary>
		/// Helpers enabled when booting to this Linode Config.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helpers")]
		public LinodeConfigHelpers Helpers { get; set; }
		
		/// <summary>
		/// The ID of this Config.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// An array of Network Interfaces to add to this Linode's Configuration Profile.
		///
		///Up to three interface objects can be entered in this array. The position in the array determines the interface to which the settings apply:
		///
		///- First/0:  eth0
		///- Second/1: eth1
		///- Third/2:  eth2
		///
		///When updating a Linode's interfaces, *each interface must be redefined*. An empty interfaces array results in a default public interface configuration only.
		///
		///If no public interface is configured, public IP addresses are still assigned to the Linode but will not be usable without manual configuration.
		///
		///**Note:** Changes to Linode interface configurations can be enabled by rebooting the Linode.
		///
		///**Note:** Only Next Generation Network (NGN) data centers support VLANs. Use the Regions ([/regions](/docs/api/regions/)) endpoint to view the capabilities of data center regions.
		///If a VLAN is attached to your Linode and you attempt to migrate or clone it to a non-NGN data center,
		///the migration or cloning will not initiate. If a Linode cannot be migrated because of an incompatibility,
		///you will be prompted to select a different data center or contact support.
		///
		///**Note:** See the [VLANs Overview](/docs/products/networking/vlans/#technical-specifications) guide to view additional specifications and limitations.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaces")]
		public LinodeConfigInterface[] Interfaces { get; set; }
		
		/// <summary>
		/// A Kernel ID to boot a Linode with. Defaults to "linode/latest-64bit".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kernel")]
		public string Kernel { get; set; }
		
		/// <summary>
		/// The Config's label is for display purposes only.
		///
		/// Min length: 1
		/// Max length: 48
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(48)]
		public string Label { get; set; }
		
		/// <summary>
		/// Defaults to the total RAM of the Linode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memory_limit")]
		public System.Nullable<System.Int32> Memory_limit { get; set; }
		
		/// <summary>
		/// The root device to boot.
		///* If no value or an invalid value is provided, root device will default to `/dev/sda`.
		///* If the device specified at the root device location is not mounted, the Linode will not boot until a device is mounted.
		///
		/// Pattern: a-z, A-Z, 0-9, /, _, -
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="root_device")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"a-z, A-Z, 0-9, /, _, -")]
		public string Root_device { get; set; }
		
		/// <summary>
		/// Defines the state of your Linode after booting. Defaults to `default`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="run_level")]
		public System.Nullable<LinodeConfigRun_level> Run_level { get; set; }
		
		/// <summary>
		/// Controls the virtualization mode. Defaults to `paravirt`.
		///* `paravirt` is suitable for most cases. Linodes running in paravirt mode
		///  share some qualities with the host, ultimately making it run faster since
		///  there is less transition between it and the host.
		///* `fullvirt` affords more customization, but is slower because 100% of the VM
		///  is virtualized.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virt_mode")]
		public System.Nullable<LinodeConfigVirt_mode> Virt_mode { get; set; }
	}
	
	public class LinodeConfigHelpers
	{
		
		/// <summary>
		/// Populates the /dev directory early during boot without udev.  Defaults to false.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="devtmpfs_automount")]
		public System.Nullable<System.Boolean> Devtmpfs_automount { get; set; }
		
		/// <summary>
		/// Helps maintain correct inittab/upstart console device.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="distro")]
		public System.Nullable<System.Boolean> Distro { get; set; }
		
		/// <summary>
		/// Creates a modules dependency file for the Kernel you run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="modules_dep")]
		public System.Nullable<System.Boolean> Modules_dep { get; set; }
		
		/// <summary>
		/// Automatically configures static networking.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public System.Nullable<System.Boolean> Network { get; set; }
		
		/// <summary>
		/// Disables updatedb cron job to avoid disk thrashing.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updatedb_disabled")]
		public System.Nullable<System.Boolean> Updatedb_disabled { get; set; }
	}
	
	/// <summary>
	/// The Network Interface to apply to this Linode's configuration profile.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LinodeConfigInterface
	{
		
		/// <summary>
		/// This Network Interface's private IP address in Classless Inter-Domain Routing (CIDR) notation.
		///
		///Only used for `vlan` purpose interfaces. Must be an empty string or `null` for `public` purpose interfaces.
		///
		///The Linode is configured to use this address for the associated interface upon reboot if Network Helper is enabled. If Network Helper is disabled, the address can be enabled with [manual static IP configuration](/docs/guides/manual-network-configuration/).
		///
		///Must be unique among the Linode's interfaces.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipam_address")]
		public string Ipam_address { get; set; }
		
		/// <summary>
		/// The name of this interface.
		///
		///Required for `vlan` purpose interfaces. Must be an empty string or `null` for `public` purpose interfaces.
		///
		///If the VLAN label is new, a VLAN is created. Up to 10 VLANs can be created in each data center region. To view your active VLANs, use the [VLANs List](/docs/api/networking/#vlans-list) endpoint.
		///
		///May only consist of ASCII letters, numbers, and dashes (`-`).
		///
		///Must be unique among the Linode's interfaces.
		///
		/// Min length: 1
		/// Max length: 64
		/// Pattern: /[a-z0-9-]+/
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"/[a-z0-9-]+/")]
		public string Label { get; set; }
		
		/// <summary>
		/// The type of interface.
		///
		///* `public`
		///  * Only one `public` interface per Linode can be defined.
		///  * The Linode's default public IPv4 address is assigned to the `public` interface.
		///  * A Linode must have a public interface in the first/eth0 position to be reachable via the public internet upon boot without additional system configuration. If no `public` interface is configured, the Linode is not directly reachable via the public internet. In this case, access can only be established via LISH or other Linodes connected to the same VLAN.
		///
		///* `vlan`
		///  * Configuring a `vlan` purpose interface attaches this Linode to the VLAN with the specified `label`.
		///  * The Linode is configured to use the specified `ipam_address`, if any.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="purpose")]
		public System.Nullable<LinodeConfigInterfacePurpose> Purpose { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LinodeConfigInterfacePurpose
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public")]
		_public = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		vlan = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LinodeConfigRun_level
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default")]
		_default = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		single = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		binbash = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LinodeConfigVirt_mode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		paravirt = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		fullvirt = 1,
	}
	
	/// <summary>
	/// Common properties for creating and rebuilding Linodes.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LinodeRequest
	{
		
		/// <summary>
		/// Disk object request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorized_keys")]
		public DiskRequest Authorized_keys { get; set; }
		
		/// <summary>
		/// Disk object request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorized_users")]
		public DiskRequest Authorized_users { get; set; }
		
		/// <summary>
		/// This field defaults to `true` if the Linode is created with an Image or from a Backup.
		///If it is deployed from an Image or a Backup and you wish it to remain `offline` after deployment, set this to `false`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="booted")]
		public System.Nullable<System.Boolean> Booted { get; set; }
		
		/// <summary>
		/// Disk object request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public DiskRequest Image { get; set; }
		
		/// <summary>
		/// Disk object request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="root_pass")]
		public DiskRequest Root_pass { get; set; }
		
		/// <summary>
		/// Disk object request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stackscript_data")]
		public DiskRequest Stackscript_data { get; set; }
		
		/// <summary>
		/// Disk object request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stackscript_id")]
		public DiskRequest Stackscript_id { get; set; }
	}
	
	/// <summary>
	/// CPU, IO, IPv4, and IPv6 statistics. Graph data, if available, is in "[timestamp, reading]" array format. Timestamp is a UNIX timestamp in EST.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LinodeStats
	{
		
		/// <summary>
		/// Percentage of CPU used.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpu")]
		public string[] Cpu { get; set; }
		
		/// <summary>
		/// Input/Output statistics.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="io")]
		public LinodeStatsIo Io { get; set; }
		
		/// <summary>
		/// IPv4 statistics.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="netv4")]
		public LinodeStatsNetv4 Netv4 { get; set; }
		
		/// <summary>
		/// IPv6 statistics.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="netv6")]
		public LinodeStatsNetv6 Netv6 { get; set; }
		
		/// <summary>
		/// The title for this data set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class LinodeStatsIo
	{
		
		/// <summary>
		/// Block/s written.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="io")]
		public string[] Io { get; set; }
		
		/// <summary>
		/// Block/s written.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="swap")]
		public string[] Swap { get; set; }
	}
	
	public class LinodeStatsNetv4
	{
		
		/// <summary>
		/// Input stats for IPv4, measured in bits/s (bits/second).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="in")]
		public string[] In { get; set; }
		
		/// <summary>
		/// Output stats for IPv4, measured in bits/s (bits/second).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="out")]
		public string[] Out { get; set; }
		
		/// <summary>
		/// Private IPv4 input statistics, measured in bits/s (bits/second).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="private_in")]
		public string[] Private_in { get; set; }
		
		/// <summary>
		/// Private IPv4 output statistics, measured in bits/s (bits/second).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="private_out")]
		public string[] Private_out { get; set; }
	}
	
	public class LinodeStatsNetv6
	{
		
		/// <summary>
		/// Input stats for IPv6, measured in bits/s (bits/second).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="in")]
		public string[] In { get; set; }
		
		/// <summary>
		/// Output stats for IPv6, measured in bits/s (bits/second).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="out")]
		public string[] Out { get; set; }
		
		/// <summary>
		/// Private IPv6 input statistics, measured in bits/s (bits/second).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="private_in")]
		public string[] Private_in { get; set; }
		
		/// <summary>
		/// Private IPv6 output statistics, measured in bits/s (bits/second).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="private_out")]
		public string[] Private_out { get; set; }
	}
	
	/// <summary>
	/// Returns collection of Linode types, including pricing and specifications for each type. These are used when [creating](/docs/api/linode-instances/#linode-create) or [resizing](/docs/api/linode-instances/#linode-resize) Linodes.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LinodeType
	{
		
		/// <summary>
		/// A list of optional add-on services for Linodes and their associated costs.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addons")]
		public LinodeTypeAddons Addons { get; set; }
		
		/// <summary>
		/// The class of the Linode Type. We currently offer five classes of Linodes:
		///
		///  * nanode - Nanode instances are good for low-duty workloads,
		///    where performance isn't critical. **Note:** As of June 16th, 2020, Nanodes became
		///    1 GB Linodes in the Cloud Manager, however, the API, the CLI, and billing will
		///    continue to refer to these instances as Nanodes.
		///  * standard - Standard Shared instances are good for medium-duty workloads and
		///    are a good mix of performance, resources, and price. **Note:** As of June 16th, 2020,
		///    Standard Linodes in the Cloud Manager became Shared Linodes, however, the API, the CLI, and
		///    billing will continue to refer to these instances as Standard Linodes.
		///  * dedicated - Dedicated CPU instances are good for full-duty workloads
		///    where consistent performance is important.
		///  * gpu - Linodes with dedicated NVIDIA Quadro &reg; RTX 6000 GPUs accelerate highly
		///    specialized applications such as machine learning, AI, and video transcoding.
		///  * highmem - High Memory instances favor RAM over other resources, and can be
		///    good for memory hungry use cases like caching and in-memory databases.
		///    All High Memory plans contain dedicated CPU cores.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="class")]
		public System.Nullable<LinodeTypeClass> Class { get; set; }
		
		/// <summary>
		/// The Disk size, in MB, of the Linode Type.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disk")]
		public System.Nullable<System.Int32> Disk { get; set; }
		
		/// <summary>
		/// The number of GPUs this Linode Type offers.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gpus")]
		public System.Nullable<System.Int32> Gpus { get; set; }
		
		/// <summary>
		/// The ID representing the Linode Type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The Linode Type's label is for display purposes only.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// Amount of RAM included in this Linode Type.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memory")]
		public System.Nullable<System.Int32> Memory { get; set; }
		
		/// <summary>
		/// The Mbits outbound bandwidth allocation.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network_out")]
		public System.Nullable<System.Int32> Network_out { get; set; }
		
		/// <summary>
		/// Cost in US dollars, broken down into hourly and monthly charges.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="price")]
		public LinodeTypePrice Price { get; set; }
		
		/// <summary>
		/// The Linode Type that a [mutate](/docs/api/linode-instances/#linode-upgrade) will upgrade to for a Linode of this type.  If "null", a Linode of this type may not mutate.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="successor")]
		public string Successor { get; set; }
		
		/// <summary>
		/// The monthly outbound transfer amount, in MB.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transfer")]
		public System.Nullable<System.Int32> Transfer { get; set; }
		
		/// <summary>
		/// The number of VCPU cores this Linode Type offers.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vcpus")]
		public System.Nullable<System.Int32> Vcpus { get; set; }
	}
	
	public class LinodeTypeAddons
	{
		
		/// <summary>
		/// Information about the optional Backup service offered for Linodes.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backups")]
		public LinodeTypeAddonsBackups Backups { get; set; }
	}
	
	public class LinodeTypeAddonsBackups
	{
		
		/// <summary>
		/// Cost of enabling Backups for this Linode Type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="price")]
		public LinodeTypeAddonsBackupsPrice Price { get; set; }
	}
	
	public class LinodeTypeAddonsBackupsPrice
	{
		
		/// <summary>
		/// The cost (in US dollars) per hour to add Backups service.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hourly")]
		public System.Nullable<System.Double> Hourly { get; set; }
		
		/// <summary>
		/// The cost (in US dollars) per month to add Backups service.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monthly")]
		public System.Nullable<System.Double> Monthly { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LinodeTypeClass
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		nanode = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		standard = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dedicated = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		gpu = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		highmem = 4,
	}
	
	public class LinodeTypePrice
	{
		
		/// <summary>
		/// Cost (in US dollars) per hour.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hourly")]
		public System.Nullable<System.Double> Hourly { get; set; }
		
		/// <summary>
		/// Cost (in US dollars) per month.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monthly")]
		public System.Nullable<System.Double> Monthly { get; set; }
	}
	
	/// <summary>
	/// An object representing a previous successful login for a User.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Login
	{
		
		/// <summary>
		/// When the login was initiated.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="datetime")]
		public System.Nullable<System.DateTimeOffset> Datetime { get; set; }
		
		/// <summary>
		/// The unique ID of this login object.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The remote IP address that requested the login.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// True if the User that attempted the login was a restricted User, false otherwise.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restricted")]
		public System.Nullable<System.Boolean> Restricted { get; set; }
		
		/// <summary>
		/// Whether the login attempt succeeded or failed.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<LoginStatus> Status { get; set; }
		
		/// <summary>
		/// The username of the User that attempted the login.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LoginStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		successful = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 1,
	}
	
	/// <summary>
	/// A LongviewClient is a single monitor set up to track statistics about one of your servers.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LongviewClient
	{
		
		/// <summary>
		/// The API key for this Client, used when configuring the Longview
		///Client application on your Linode.
		///
		///Returns as `[REDACTED]` if you do not have read-write access to this client.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="api_key")]
		public string Api_key { get; set; }
		
		/// <summary>
		/// The apps this Client is monitoring on your Linode. This is configured when you install the Longview Client application, and is present here for information purposes only.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apps")]
		public LongviewClientApps Apps { get; set; }
		
		/// <summary>
		/// When this Longview Client was created.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// This Client's unique ID.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The install code for this Client, used when configuring the Longview
		///Client application on your Linode.
		///
		///Returns as `[REDACTED]` if you do not have read-write access to this client.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="install_code")]
		public string Install_code { get; set; }
		
		/// <summary>
		/// This Client's unique label. This is for display purposes only.
		///
		/// Min length: 3
		/// Max length: 32
		/// Pattern: [a-zA-Z0-9-_]{3,32}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(3)]
		[System.ComponentModel.DataAnnotations.MaxLength(32)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-zA-Z0-9-_]{3,32}")]
		public string Label { get; set; }
		
		/// <summary>
		/// When this Longview Client was last updated.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
	}
	
	public class LongviewClientApps
	{
		
		/// <summary>
		/// If True, the Apache Longview Client module is monitoring Apache on your server.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apache")]
		public System.Nullable<System.Boolean> Apache { get; set; }
		
		/// <summary>
		/// If True, the MySQL Longview Client modules is monitoring MySQL on your server.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mysql")]
		public System.Nullable<System.Boolean> Mysql { get; set; }
		
		/// <summary>
		/// If True, the Nginx Longview Client module is monitoring Nginx on your server.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nginx")]
		public System.Nullable<System.Boolean> Nginx { get; set; }
	}
	
	/// <summary>
	/// Longview Plan object.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LongviewPlan
	{
		
		/// <summary>
		/// The subscription ID for a particular Longview plan. A value of `null` corresponds to Longview Free.
		///
		///You can send a request to the [List Longview Subscriptions](/docs/api/longview/#longview-subscriptions-list) endpoint to receive the details of each plan.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="longview_subscription")]
		public System.Nullable<LongviewPlanLongview_subscription> Longview_subscription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LongviewPlanLongview_subscription
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="longview-3")]
		longviewMinus3 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="longview-10")]
		longviewMinus10 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="longview-40")]
		longviewMinus40 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="longview-100")]
		longviewMinus100 = 3,
	}
	
	/// <summary>
	/// A Longview Subscription represents a tier of Longview service you can subscribe to.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LongviewSubscription
	{
		
		/// <summary>
		/// The number of Longview Clients that may be created with this Subscription tier.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clients_included")]
		public System.Nullable<System.Int32> Clients_included { get; set; }
		
		/// <summary>
		/// The unique ID of this Subscription tier.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<LongviewSubscriptionId> Id { get; set; }
		
		/// <summary>
		/// A display name for this Subscription tier.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// Pricing information about this Subscription tier.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="price")]
		public LongviewSubscriptionPrice Price { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LongviewSubscriptionId
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="longview-3")]
		longviewMinus3 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="longview-10")]
		longviewMinus10 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="longview-40")]
		longviewMinus40 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="longview-100")]
		longviewMinus100 = 3,
	}
	
	public class LongviewSubscriptionPrice
	{
		
		/// <summary>
		/// The hourly price, in US dollars, for this Subscription tier.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hourly")]
		public System.Nullable<System.Double> Hourly { get; set; }
		
		/// <summary>
		/// The maximum monthly price in US Dollars for this Subscription tier. You will never be charged more than this amount per month for this subscription.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monthly")]
		public System.Nullable<System.Double> Monthly { get; set; }
	}
	
	/// <summary>
	/// Information about maintenance affecting an entity.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Maintenance
	{
		
		/// <summary>
		/// The entity being affected by maintenance.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entity")]
		public MaintenanceEntity Entity { get; set; }
		
		/// <summary>
		/// The reason maintenance is being performed.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
		
		/// <summary>
		/// The maintenance status.
		///
		///Maintenance progresses in the following sequence: pending, started, then completed.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<MaintenanceStatus> Status { get; set; }
		
		/// <summary>
		/// The type of maintenance.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<MaintenanceType> Type { get; set; }
		
		/// <summary>
		/// When the maintenance will begin.
		///
		///[Filterable](/docs/api/#filtering-and-sorting) with the following parameters:
		///
		///* A single value in date-time string format ("%Y-%m-%dT%H:%M:%S"), which returns only matches to that value.
		///
		///* A dictionary containing pairs of inequality operator string keys ("+or", "+gt", "+gte", "+lt", "+lte",
		///or "+neq") and single date-time string format values ("%Y-%m-%dT%H:%M:%S"). "+or" accepts an array of values that
		///may consist of single date-time strings or dictionaries of inequality operator pairs.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="when")]
		public System.Nullable<System.DateTimeOffset> When { get; set; }
	}
	
	public class MaintenanceEntity
	{
		
		/// <summary>
		/// The id of the entity being affected by maintenance.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Double> Id { get; set; }
		
		/// <summary>
		/// The label of the entity being affected by maintenance.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The type of entity.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// The API endpoint prefix to use in combination with the entity id to find specific information about the entity.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum MaintenanceStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		completed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		started = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum MaintenanceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		reboot = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cold_migration = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		live_migration = 2,
	}
	
	/// <summary>
	/// Information about someone Linode's special forces may contact in case an issue is detected with a manager service.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ManagedContact
	{
		
		/// <summary>
		/// The address to email this Contact to alert them of issues.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// A grouping for this Contact. This is for display purposes only.
		///
		/// Min length: 2
		/// Max length: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string Group { get; set; }
		
		/// <summary>
		/// This Contact's unique ID.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The name of this Contact.
		///
		/// Min length: 2
		/// Max length: 64
		/// Pattern: [a-zA-Z0-9-_ ]{2,64}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-zA-Z0-9-_ ]{2,64}")]
		public string Name { get; set; }
		
		/// <summary>
		/// Information about how to reach this Contact by phone.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="phone")]
		public ManagedContactPhone Phone { get; set; }
		
		/// <summary>
		/// When this Contact was last updated.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
	}
	
	public class ManagedContactPhone
	{
		
		/// <summary>
		/// This Contact's primary phone number.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary")]
		public string Primary { get; set; }
		
		/// <summary>
		/// This Contact's secondary phone number.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondary")]
		public string Secondary { get; set; }
	}
	
	/// <summary>
	/// A securely-stored Credential that allows Linode's special forces to access a Managed server to respond to Issues.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ManagedCredential
	{
		
		/// <summary>
		/// This Credential's unique ID.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The unique label for this Credential. This is for display purposes only.
		///
		/// Min length: 2
		/// Max length: 75
		/// Pattern: [a-zA-Z0-9-_ \.]{2,75}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		[System.ComponentModel.DataAnnotations.MaxLength(75)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-zA-Z0-9-_ \.]{2,75}")]
		public string Label { get; set; }
		
		/// <summary>
		/// The date this Credential was last decrypted by a member of Linode special forces.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_decrypted")]
		public System.Nullable<System.DateTimeOffset> Last_decrypted { get; set; }
	}
	
	/// <summary>
	/// An Issue that was detected with a service Linode is managing.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ManagedIssue
	{
		
		/// <summary>
		/// When this Issue was created. Issues are created in response to issues detected with Managed Services, so this is also when the Issue was detected.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// The ticket this Managed Issue opened.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entity")]
		public ManagedIssueEntity Entity { get; set; }
		
		/// <summary>
		/// This Issue's unique ID.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// An array of Managed Service IDs that were affected by this Issue.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="services")]
		public int[] Services { get; set; }
	}
	
	public class ManagedIssueEntity
	{
		
		/// <summary>
		/// This ticket's ID
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The summary for this Ticket.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The type of entity this is. In this case, it is always a Ticket.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<ManagedIssueEntityType> Type { get; set; }
		
		/// <summary>
		/// The relative URL where you can access this Ticket.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ManagedIssueEntityType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ticket = 0,
	}
	
	/// <summary>
	/// Settings for a specific Linode related to Managed Services. There is one ManagedLinodeSettings object for each Linode on your Account.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ManagedLinodeSettings
	{
		
		/// <summary>
		/// The group of the Linode these Settings are for. This is for display purposes only.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public string Group { get; set; }
		
		/// <summary>
		/// The ID of the Linode these Settings are for.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The label of the Linode these Settings are for.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The SSH settings for this Linode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssh")]
		public ManagedLinodeSettingsSsh Ssh { get; set; }
	}
	
	public class ManagedLinodeSettingsSsh
	{
		
		/// <summary>
		/// If true, Linode special forces may access this Linode over ssh to respond to Issues.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="access")]
		public System.Nullable<System.Boolean> Access { get; set; }
		
		/// <summary>
		/// The IP Linode special forces should use to access this Linode
		///when responding to an Issue.
		///
		///By default, any of a Linode's IP addresses can be used for incident response access.
		///
		/// </summary>
		[System.ComponentModel.DefaultValue("any")]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; } = "any";
		
		/// <summary>
		/// The port Linode special forces should use to access this Linode
		///over ssh to respond to an Issue.
		///
		///The default `null` value corresponds to port 22.
		///
		/// Minimum: 1
		/// Maximum: 65535
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		[System.ComponentModel.DataAnnotations.Range(1, 65535)]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// The specific user, if any, Linode's special forces should use when accessing this
		///Linode to respond to an issue.
		///
		///The default `null` value corresponds to the root user.
		///
		/// Min length: 0
		/// Max length: 32
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(32)]
		public string User { get; set; }
	}
	
	/// <summary>
	/// A service that Linode is monitoring as part of your Managed services. If issues are detected with this service, a ManagedIssue will be opened and, optionally, Linode special forces will attempt to resolve the Issue.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ManagedService
	{
		
		/// <summary>
		/// The URL at which this Service is monitored.
		///
		///URL parameters such as `?no-cache=1` are preserved.
		///
		///URL fragments/anchors such as `#monitor` are **not** preserved.
		///
		/// Min length: 3
		/// Max length: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		[System.ComponentModel.DataAnnotations.MinLength(3)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Address { get; set; }
		
		/// <summary>
		/// What to expect to find in the response body for the Service to be considered up.
		///
		/// Min length: 0
		/// Max length: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Body { get; set; }
		
		/// <summary>
		/// The group of ManagedContacts who should be notified or consulted with when an Issue is detected.
		///
		/// Min length: 0
		/// Max length: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="consultation_group")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string Consultation_group { get; set; }
		
		/// <summary>
		/// When this Managed Service was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// An array of ManagedCredential IDs that should be used when attempting to resolve issues with this Service.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="credentials")]
		public int[] Credentials { get; set; }
		
		/// <summary>
		/// This Service's unique ID.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The label for this Service. This is for display purposes only.
		///
		/// Min length: 3
		/// Max length: 64
		/// Pattern: [a-zA-Z0-9-_ \.]{3,64}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(3)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-zA-Z0-9-_ \.]{3,64}")]
		public string Label { get; set; }
		
		/// <summary>
		/// Any information relevant to the Service that Linode special forces should know when attempting to resolve Issues.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// The Region in which this Service is located. This is required if address is a private IP, and may not be set otherwise.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// How this Service is monitored.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service_type")]
		public System.Nullable<ManagedServiceService_type> Service_type { get; set; }
		
		/// <summary>
		/// The current status of this Service.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<ManagedServiceStatus> Status { get; set; }
		
		/// <summary>
		/// How long to wait, in seconds, for a response before considering the Service to be down.
		///
		/// Minimum: 1
		/// Maximum: 255
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		[System.ComponentModel.DataAnnotations.Range(1, 255)]
		public System.Nullable<System.Int32> Timeout { get; set; }
		
		/// <summary>
		/// When this Managed Service was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ManagedServiceService_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		url = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tcp = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ManagedServiceStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ok = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		problem = 3,
	}
	
	/// <summary>
	/// Linode's load balancing solution.  Can handle multiple ports, SSL termination, and any number of backends.  NodeBalancer ports are configured with NodeBalancer Configs, and each config is given one or more NodeBalancer Node that accepts traffic.  The traffic should be routed to the  NodeBalancer's ip address, the NodeBalancer will handle routing individual requests to backends.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NodeBalancer
	{
		
		/// <summary>
		/// Throttle connections per second.  Set to 0 (zero) to disable throttling.
		///
		/// Minimum: 0
		/// Maximum: 20
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="client_conn_throttle")]
		[System.ComponentModel.DataAnnotations.Range(0, 20)]
		public System.Nullable<System.Int32> Client_conn_throttle { get; set; }
		
		/// <summary>
		/// When this NodeBalancer was created.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// This NodeBalancer's hostname, beginning with its IP address and ending with _.ip.linodeusercontent.com_.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// This NodeBalancer's unique ID.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// This NodeBalancer's public IPv4 address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public string Ipv4 { get; set; }
		
		/// <summary>
		/// This NodeBalancer's public IPv6 address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public string Ipv6 { get; set; }
		
		/// <summary>
		/// This NodeBalancer's label. These must be unique on your Account.
		///
		/// Min length: 3
		/// Max length: 32
		/// Pattern: [a-zA-Z0-9-_]{3,32}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(3)]
		[System.ComponentModel.DataAnnotations.MaxLength(32)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-zA-Z0-9-_]{3,32}")]
		public string Label { get; set; }
		
		/// <summary>
		/// The Region where this NodeBalancer is located. NodeBalancers only support backends in the same Region.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// An array of Tags applied to this object.  Tags are for organizational purposes only.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// Information about the amount of transfer this NodeBalancer has had so far this month.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transfer")]
		public NodeBalancerTransfer Transfer { get; set; }
		
		/// <summary>
		/// When this NodeBalancer was last updated.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
	}
	
	public class NodeBalancerTransfer
	{
		
		/// <summary>
		/// The total outbound transfer, in MB, used for this NodeBalancer this month.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="in")]
		public System.Nullable<System.Double> In { get; set; }
		
		/// <summary>
		/// The total inbound transfer, in MB, used for this NodeBalancer this month.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="out")]
		public System.Nullable<System.Double> Out { get; set; }
		
		/// <summary>
		/// The total transfer, in MB, used by this NodeBalancer this month.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Double> Total { get; set; }
	}
	
	/// <summary>
	/// A NodeBalancer config represents the configuration of this NodeBalancer on a single port.  For example, a NodeBalancer Config on port 80 would typically represent how this NodeBalancer response to HTTP requests.
	///
	///NodeBalancer configs have a list of backends, called "nodes," that they forward requests between based on their configuration.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NodeBalancerConfig
	{
		
		/// <summary>
		/// What algorithm this NodeBalancer should use for routing traffic to backends.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="algorithm")]
		public System.Nullable<NodeBalancerConfigAlgorithm> Algorithm { get; set; }
		
		/// <summary>
		/// The type of check to perform against backends to ensure they are serving requests. This is used to determine if backends are up or down.
		///* If `none` no check is performed.
		///* `connection` requires only a connection to the backend to succeed.
		///* `http` and `http_body` rely on the backend serving HTTP, and that
		///  the response returned matches what is expected.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="check")]
		public System.Nullable<NodeBalancerConfigCheck> Check { get; set; }
		
		/// <summary>
		/// How many times to attempt a check before considering a backend to be down.
		///
		/// Minimum: 1
		/// Maximum: 30
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="check_attempts")]
		[System.ComponentModel.DataAnnotations.Range(1, 30)]
		public System.Nullable<System.Int32> Check_attempts { get; set; }
		
		/// <summary>
		/// This value must be present in the response body of the check in order for it to pass. If this value is not present in the response body of a check request, the backend is considered to be down.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="check_body")]
		public string Check_body { get; set; }
		
		/// <summary>
		/// How often, in seconds, to check that backends are up and serving requests.
		///
		///Must be greater than `check_timeout`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="check_interval")]
		public System.Nullable<System.Int32> Check_interval { get; set; }
		
		/// <summary>
		/// If true, any response from this backend with a `5xx` status code will be enough for it to be considered unhealthy and taken out of rotation.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="check_passive")]
		public System.Nullable<System.Boolean> Check_passive { get; set; }
		
		/// <summary>
		/// The URL path to check on each backend. If the backend does not respond to this request it is considered to be down.
		///
		/// Pattern: ^[a-zA-Z0-9\/\-%?&=.]*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="check_path")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9\/\-%?&=.]*$")]
		public string Check_path { get; set; }
		
		/// <summary>
		/// How long, in seconds, to wait for a check attempt before considering it failed.
		///
		///Must be less than `check_interval`.
		///
		/// Minimum: 1
		/// Maximum: 30
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="check_timeout")]
		[System.ComponentModel.DataAnnotations.Range(1, 30)]
		public System.Nullable<System.Int32> Check_timeout { get; set; }
		
		/// <summary>
		/// What ciphers to use for SSL connections served by this NodeBalancer.
		///
		///* `legacy` is considered insecure and should only be used if necessary.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cipher_suite")]
		public System.Nullable<NodeBalancerConfigCipher_suite> Cipher_suite { get; set; }
		
		/// <summary>
		/// This config's unique ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The ID for the NodeBalancer this config belongs to.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodebalancer_id")]
		public System.Nullable<System.Int32> Nodebalancer_id { get; set; }
		
		/// <summary>
		/// A structure containing information about the health of the backends for this port.  This information is updated periodically as checks are performed against backends.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodes_status")]
		public NodeBalancerConfigNodes_status Nodes_status { get; set; }
		
		/// <summary>
		/// The port this Config is for. These values must be unique across configs on a single NodeBalancer (you can't have two configs for port 80, for example).  While some ports imply some protocols, no enforcement is done and you may configure your NodeBalancer however is useful to you. For example, while port 443 is generally used for HTTPS, you do not need SSL configured to have a NodeBalancer listening on port 443.
		///
		/// Minimum: 1
		/// Maximum: 65535
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		[System.ComponentModel.DataAnnotations.Range(1, 65535)]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// The protocol this port is configured to serve.
		///
		///* The `http` and `tcp` protocols do not support `ssl_cert` and `ssl_key`.
		///
		///* The `https` protocol is mutually required with `ssl_cert` and `ssl_key`.
		///
		///Review our guide on [Available Protocols](/docs/products/networking/nodebalancers/guides/protocols/) for information on protocol features.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public System.Nullable<NodeBalancerConfigProtocol> Protocol { get; set; }
		
		/// <summary>
		/// ProxyProtocol is a TCP extension that sends initial TCP connection information such as source/destination IPs and ports to backend devices. This information would be lost otherwise. Backend devices must be configured to work with ProxyProtocol if enabled.
		///
		///* If ommited, or set to `none`, the NodeBalancer doesn't send any auxilary data over TCP connections. This is the default.
		///* If set to `v1`, the human-readable header format (Version 1) is used. Requires `tcp` protocol.
		///* If set to `v2`, the binary header format (Version 2) is used. Requires `tcp` protocol.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="proxy_protocol")]
		public System.Nullable<NodeBalancerConfigProxy_protocol> Proxy_protocol { get; set; }
		
		/// <summary>
		/// The PEM-formatted public SSL certificate (or the combined PEM-formatted SSL
		///certificate and Certificate Authority chain) that should be served on this
		///NodeBalancerConfig's port.
		///
		///Line breaks must be represented as "\n" in the string for requests (but not when using the Linode CLI).
		///
		///[Diffie-Hellman Parameters](/docs/products/networking/nodebalancers/guides/ssl-termination/#diffie-hellman-parameters) can be included in this value to enable forward secrecy.
		///
		///The contents of this field will not be shown in any responses that display
		///the NodeBalancerConfig. Instead, `<REDACTED>` will be printed where the field
		///appears.
		///
		///The read-only `ssl_commonname` and `ssl_fingerprint` fields in a NodeBalancerConfig
		///response are automatically derived from your certificate. Please refer to these fields to
		///verify that the appropriate certificate was assigned to your NodeBalancerConfig.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssl_cert")]
		public string Ssl_cert { get; set; }
		
		/// <summary>
		/// The read-only common name automatically derived from the SSL certificate assigned to this NodeBalancerConfig. Please refer to this field to verify that the appropriate certificate is assigned to your NodeBalancerConfig.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssl_commonname")]
		public string Ssl_commonname { get; set; }
		
		/// <summary>
		/// The read-only SHA1-encoded fingerprint automatically derived from the SSL certificate assigned to this NodeBalancerConfig. Please refer to this field to verify that the appropriate certificate is assigned to your NodeBalancerConfig.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssl_fingerprint")]
		public string Ssl_fingerprint { get; set; }
		
		/// <summary>
		/// The PEM-formatted private key for the SSL certificate set in the `ssl_cert` field.
		///
		///Line breaks must be represented as "\n" in the string for requests (but not when using the Linode CLI).
		///
		///The contents of this field will not be shown in any responses that display
		///the NodeBalancerConfig. Instead, `<REDACTED>` will be printed where the field
		///appears.
		///
		///The read-only `ssl_commonname` and `ssl_fingerprint` fields in a NodeBalancerConfig
		///response are automatically derived from your certificate. Please refer to these fields to
		///verify that the appropriate certificate was assigned to your NodeBalancerConfig.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssl_key")]
		public string Ssl_key { get; set; }
		
		/// <summary>
		/// Controls how session stickiness is handled on this port.
		///* If set to `none` connections will always be assigned a backend based on the algorithm configured.
		///* If set to `table` sessions from the same remote address will be routed to the same
		///  backend.
		///
		///* For HTTP or HTTPS clients, `http_cookie` allows sessions to be
		///  routed to the same backend based on a cookie set by the NodeBalancer.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stickiness")]
		public System.Nullable<NodeBalancerConfigStickiness> Stickiness { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum NodeBalancerConfigAlgorithm
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		roundrobin = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		leastconn = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		source = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum NodeBalancerConfigCheck
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		connection = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		http = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		http_body = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum NodeBalancerConfigCipher_suite
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		recommended = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		legacy = 1,
	}
	
	public class NodeBalancerConfigNodes_status
	{
		
		/// <summary>
		/// The number of backends considered to be "DOWN" and unhealthy.  These are not in rotation, and not serving requests.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="down")]
		public System.Nullable<System.Int32> Down { get; set; }
		
		/// <summary>
		/// The number of backends considered to be "UP" and healthy, and that are serving requests.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="up")]
		public System.Nullable<System.Int32> Up { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum NodeBalancerConfigProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		http = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		https = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tcp = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum NodeBalancerConfigProxy_protocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		v1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		v2 = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum NodeBalancerConfigStickiness
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		table = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		http_cookie = 2,
	}
	
	/// <summary>
	/// A NodeBalancerNode represents a single backend serving requests for a single port of a NodeBalancer.  Nodes are specific to NodeBalancer Configs, and serve traffic over their private IP.  If the same Linode is serving traffic for more than one port on the same NodeBalancer, one NodeBalancer Node is required for each config (port) it should serve requests on.  For example, if you have four backends, and each should response to both HTTP and HTTPS requests, you will need two NodeBalancerConfigs (port 80 and port 443) and four backends each - one for each of the Linodes serving requests for that port.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NodeBalancerNode
	{
		
		/// <summary>
		/// The private IP Address where this backend can be reached. This _must_ be a private IP address.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// The NodeBalancer Config ID that this Node belongs to.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="config_id")]
		public System.Nullable<System.Int32> Config_id { get; set; }
		
		/// <summary>
		/// This node's unique ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The label for this node.  This is for display purposes only.
		///
		/// Min length: 3
		/// Max length: 32
		/// Pattern: [a-zA-Z0-9-_.]{3,32}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(3)]
		[System.ComponentModel.DataAnnotations.MaxLength(32)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-zA-Z0-9-_.]{3,32}")]
		public string Label { get; set; }
		
		/// <summary>
		/// The mode this NodeBalancer should use when sending traffic to this backend.
		///* If set to `accept` this backend is accepting traffic.
		///* If set to `reject` this backend will not receive traffic.
		///* If set to `drain` this backend will not receive _new_ traffic, but connections already
		///  pinned to it will continue to be routed to it.
		///
		///* If set to `backup`, this backend will only receive traffic if all `accept` nodes
		///  are down.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public System.Nullable<NodeBalancerNodeMode> Mode { get; set; }
		
		/// <summary>
		/// The NodeBalancer ID that this Node belongs to.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodebalancer_id")]
		public System.Nullable<System.Int32> Nodebalancer_id { get; set; }
		
		/// <summary>
		/// The current status of this node, based on the configured checks of its NodeBalancer Config.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<NodeBalancerNodeStatus> Status { get; set; }
		
		/// <summary>
		/// Used when picking a backend to serve a request and is not pinned to a single backend yet.  Nodes with a higher weight will receive more traffic.
		///
		/// Minimum: 1
		/// Maximum: 255
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="weight")]
		[System.ComponentModel.DataAnnotations.Range(1, 255)]
		public System.Nullable<System.Int32> Weight { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum NodeBalancerNodeMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		accept = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		reject = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		drain = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		backup = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum NodeBalancerNodeStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOWN = 2,
	}
	
	/// <summary>
	/// Stats for this NodeBalancer.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NodeBalancerStats
	{
		
		/// <summary>
		/// The data returned about this NodeBalancers.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NodeBalancerStatsData Data { get; set; }
		
		/// <summary>
		/// The title for the statistics generated in this response.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class NodeBalancerStatsData
	{
		
		/// <summary>
		/// An array of key/value pairs representing unix timestamp and reading for connections to this NodeBalancer.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connections")]
		public double[] Connections { get; set; }
		
		/// <summary>
		/// Traffic statistics for this NodeBalancer.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="traffic")]
		public NodeBalancerStatsDataTraffic Traffic { get; set; }
	}
	
	public class NodeBalancerStatsDataTraffic
	{
		
		/// <summary>
		/// An array of key/value pairs representing unix timestamp and reading for inbound traffic.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="in")]
		public double[] In { get; set; }
		
		/// <summary>
		/// An array of key/value pairs representing unix timestamp and reading for outbound traffic.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="out")]
		public double[] Out { get; set; }
	}
	
	/// <summary>
	/// An important, often time-sensitive item related to your Account.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Notification
	{
		
		/// <summary>
		/// A full description of this Notification, in markdown format.  Not all Notifications include bodies.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Detailed information about the Notification.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entity")]
		public NotificationEntity Entity { get; set; }
		
		/// <summary>
		/// A short description of this Notification.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// A human-readable description of the Notification.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// The severity of this Notification.  This field can be used to decide how prominently to display the Notification, what color to make the display text, etc.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="severity")]
		public System.Nullable<NotificationSeverity> Severity { get; set; }
		
		/// <summary>
		/// The type of Notification this is.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<NotificationType> Type { get; set; }
		
		/// <summary>
		/// If this Notification has a duration, this will be the ending time for the Event/action. For example, if there is scheduled maintenance for one of our systems, `until` would be set to the end of the maintenance window.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="until")]
		public System.Nullable<System.DateTimeOffset> Until { get; set; }
		
		/// <summary>
		/// If this Notification is of an Event that will happen at a fixed, future time, this is when the named action will be taken. For example, if a Linode is to be migrated in response to a Security Advisory, this field will contain the approximate time the Linode will be taken offline for migration.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="when")]
		public System.Nullable<System.DateTimeOffset> When { get; set; }
	}
	
	public class NotificationEntity
	{
		
		/// <summary>
		/// The unique ID of the Notification's entity, based on the entity type.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The current label for this Notification's entity.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The type of entity this is related to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// The URL where you can access the object this Notification is for. If a relative URL, it is relative to the domain you retrieved the Notification from.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum NotificationSeverity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		minor = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		major = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		critical = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum NotificationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		migration_scheduled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		migration_imminent = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		migration_pending = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		reboot_scheduled = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		outage = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		payment_due = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ticket_important = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ticket_abuse = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		notice = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		maintenance = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		promotion = 10,
	}
	
	/// <summary>
	/// A third-party application registered to Linode that users may log into with their Linode account through our authentication server at <a target="_top" href="https://login.linode.com">https://login.linode.com</a>.  Using an OAuth Client, a third-party developer may be given access to some, or all, of a User's account for the purposes of their application.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OAuthClient
	{
		
		/// <summary>
		/// The OAuth Client ID.  This is used to identify the client, and is a publicly-known value (it is not a secret).
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of this application.  This will be presented to users when they are asked to grant it access to their Account.
		///
		/// Min length: 1
		/// Max length: 512
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(512)]
		public string Label { get; set; }
		
		/// <summary>
		/// If this is a public or private OAuth Client.  Public clients have a slightly different authentication workflow than private clients.  See the <a target="_top" href="https://oauth.net/2/">OAuth spec</a> for more details.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="public")]
		public System.Nullable<System.Boolean> Public { get; set; }
		
		/// <summary>
		/// The location a successful log in from <a target="_top" href="https://login.linode.com">https://login.linode.com</a> should be redirected to for this client.  The receiver of this redirect should be ready to accept an OAuth exchange code and finish the OAuth exchange.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirect_uri")]
		public string Redirect_uri { get; set; }
		
		/// <summary>
		/// The OAuth Client secret, used in the OAuth exchange.  This is returned as `<REDACTED>` except when an OAuth Client is created or its secret is reset.  This is a secret, and should not be shared or disclosed publicly.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		/// <summary>
		/// The status of this application.  `active` by default.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<OAuthClientStatus> Status { get; set; }
		
		/// <summary>
		/// The URL where this client's thumbnail may be viewed, or `null` if this client does not have a thumbnail set.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thumbnail_url")]
		public string Thumbnail_url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum OAuthClientStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		suspended = 2,
	}
	
	/// <summary>
	/// An Object Storage Bucket. This should be accessed primarily through the S3 API; [click here for more information](https://docs.ceph.com/en/latest/radosgw/s3/#api).
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ObjectStorageBucket
	{
		
		/// <summary>
		/// The ID of the Object Storage Cluster this bucket is in.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cluster")]
		public string Cluster { get; set; }
		
		/// <summary>
		/// When this bucket was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// The hostname where this bucket can be accessed. This hostname can be accessed through a browser if the bucket is made public.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// The name of this bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The number of objects stored in this bucket.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objects")]
		public System.Nullable<System.Int32> Objects { get; set; }
		
		/// <summary>
		/// The size of the bucket in bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
	}
	
	/// <summary>
	/// An Object Storage Cluster
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ObjectStorageCluster
	{
		
		/// <summary>
		/// The base URL for this cluster, used for connecting with third-party clients.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// The unique ID for this cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The region where this cluster is located.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The base URL for this cluster used when hosting static sites.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="static_site_domain")]
		public string Static_site_domain { get; set; }
		
		/// <summary>
		/// This cluster's status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<ObjectStorageClusterStatus> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ObjectStorageClusterStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		available = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unavailable = 1,
	}
	
	/// <summary>
	/// A keypair used to communicate with the Object Storage S3 API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ObjectStorageKey
	{
		
		/// <summary>
		/// This keypair's access key. This is not secret.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="access_key")]
		public string Access_key { get; set; }
		
		/// <summary>
		/// Defines this key as a Limited Access Key. Limited Access Keys restrict this Object Storage key's access to only the bucket(s) declared in this array and define their bucket-level permissions.
		///
		///
		///  Limited Access Keys can:
		///
		///  * [list all buckets](/docs/api/object-storage/#object-storage-buckets-list) available on this Account, but cannot perform any actions on a bucket unless it has access to the bucket.
		///
		///
		///  * [create new buckets](/docs/api/object-storage/#object-storage-bucket-create), but do not have any access to the buckets it creates, unless explicitly given access to them.
		///
		///
		///  **Note:** You can create an Object Storage Limited Access Key without access to any buckets.
		///  This is achieved by sending a request with an empty `bucket_access` array.
		///
		///
		///  **Note:** If this field is omitted, a regular unlimited access key is issued.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bucket_access")]
		public ObjectStorageKeyBucket_access[] ObjectStorageKeyBucket_access { get; set; }
		
		/// <summary>
		/// This keypair's unique ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The label given to this key. For display purposes only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// Whether or not this key is a limited access key. Will return `false` if this key grants full access to all buckets on the user's account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limited")]
		public System.Nullable<System.Boolean> Limited { get; set; }
		
		/// <summary>
		/// This keypair's secret key. Only returned on key creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secret_key")]
		public string Secret_key { get; set; }
	}
	
	public class ObjectStorageKeyBucket_access
	{
		
		/// <summary>
		/// The unique label of the bucket to which the key will grant limited access.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bucket_name")]
		public string Bucket_name { get; set; }
		
		/// <summary>
		/// The Object Storage cluster where a bucket to which the key is granting access is hosted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cluster")]
		public string Cluster { get; set; }
		
		/// <summary>
		/// This Limited Access Key's permissions for the selected bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public System.Nullable<ObjectStorageKeyBucket_accessPermissions> Permissions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ObjectStorageKeyBucket_accessPermissions
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		read_write = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		read_only = 1,
	}
	
	/// <summary>
	/// An Object in Object Storage, or a "prefix" that contains one or more objects when a `delimiter` is used.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ObjectStorageObject
	{
		
		/// <summary>
		/// An MD-5 hash of the object. `null` if this object represents a prefix.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// Designates if there is another page of bucket objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_truncated")]
		public System.Nullable<System.Boolean> Is_truncated { get; set; }
		
		/// <summary>
		/// The date and time this object was last modified. `null` if this object represents a prefix.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_modified")]
		public System.Nullable<System.DateTimeOffset> Last_modified { get; set; }
		
		/// <summary>
		/// The name of this object or prefix.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Returns the value you should pass to the `marker` query parameter to get the next page of objects. If there is no next page, `null` will be returned.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="next_marker")]
		public string Next_marker { get; set; }
		
		/// <summary>
		/// The owner of this object, as a UUID. `null` if this object represents a prefix.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public string Owner { get; set; }
		
		/// <summary>
		/// The size of this object, in bytes. `null` if this object represents a prefix.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
	}
	
	/// <summary>
	/// Upload a TLS/SSL certificate and private key to be served when you visit your Object Storage bucket via HTTPS.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ObjectStorageSSL
	{
		
		/// <summary>
		/// Your Base64 encoded and PEM formatted SSL certificate.
		///
		///Line breaks must be represented as "\n" in the string for requests (but not when using the Linode CLI)
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificate")]
		public string Certificate { get; set; }
		
		/// <summary>
		/// The private key associated with this TLS/SSL certificate.
		///
		///Line breaks must be represented as "\n" in the string for requests (but not when using the Linode CLI)
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private_key")]
		public string Private_key { get; set; }
	}
	
	/// <summary>
	/// If this Object Storage bucket has a corresponding TLS/SSL Certificate.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ObjectStorageSSLResponse
	{
		
		/// <summary>
		/// A boolean indicating if this Bucket has a corresponding TLS/SSL certificate that was uploaded by an Account user.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssl")]
		public System.Nullable<System.Boolean> Ssl { get; set; }
	}
	
	/// <summary>
	/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PaginationEnvelope
	{
		
		/// <summary>
		/// The current [page](/docs/api/#pagination).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public System.Nullable<System.Int32> Page { get; set; }
		
		/// <summary>
		/// The total number of [pages](/docs/api/#pagination).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public System.Nullable<System.Int32> Pages { get; set; }
		
		/// <summary>
		/// The total number of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public System.Nullable<System.Int32> Results { get; set; }
	}
	
	/// <summary>
	/// An object representing the staging of a Payment via PayPal.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PayPal
	{
		
		/// <summary>
		/// The URL to have PayPal redirect to when Payment is cancelled.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cancel_url")]
		public string Cancel_url { get; set; }
		
		/// <summary>
		/// The URL to have PayPal redirect to when Payment is approved.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="redirect_url")]
		public string Redirect_url { get; set; }
		
		/// <summary>
		/// The payment amount in USD. Minimum accepted value of $5 USD. Maximum accepted value of $500 USD or credit card payment limit; whichever value is highest. PayPal's maximum transaction limit is $10,000 USD.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="usd")]
		public string Usd { get; set; }
	}
	
	/// <summary>
	/// PayPal information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PayPalData
	{
		
		/// <summary>
		/// The email address associated with your PayPal account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// PayPal Merchant ID associated with your PayPal account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="paypal_id")]
		public string Paypal_id { get; set; }
	}
	
	/// <summary>
	/// An object representing an execution of Payment to PayPal to capture the funds and credit your Linode Account.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PayPalExecute
	{
		
		/// <summary>
		/// The PayerID returned by PayPal during the transaction authorization process.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="payer_id")]
		public string Payer_id { get; set; }
		
		/// <summary>
		/// The PaymentID returned from [POST /account/payments/paypal](/docs/api/account/#paypal-payment-stage) that has been approved with PayPal.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="payment_id")]
		public string Payment_id { get; set; }
	}
	
	/// <summary>
	/// Payment object response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Payment
	{
		
		/// <summary>
		/// When the Payment was made.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date")]
		public System.Nullable<System.DateTimeOffset> Date { get; set; }
		
		/// <summary>
		/// The unique ID of the Payment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The amount, in US dollars, of the Payment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usd")]
		public System.Nullable<System.Int32> Usd { get; set; }
	}
	
	/// <summary>
	/// Payment Method Response Object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PaymentMethod
	{
		
		/// <summary>
		/// When the Payment Method was added to the Account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public CreditCardData Data { get; set; }
		
		/// <summary>
		/// The unique ID of this Payment Method.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Whether this Payment Method is the default method for automatically processing service charges.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_default")]
		public System.Nullable<System.Boolean> Is_default { get; set; }
		
		/// <summary>
		/// The type of Payment Method.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<PaymentMethodType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PaymentMethodType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		credit_card = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		google_pay = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		paypal = 2,
	}
	
	/// <summary>
	/// Payment object request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PaymentRequest
	{
		
		/// <summary>
		/// CVV (Card Verification Value) of the credit card to be used for the Payment. Required if paying by credit card.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cvv")]
		public string Cvv { get; set; }
		
		/// <summary>
		/// The ID of the Payment Method to apply to the Payment.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payment_method_id")]
		public System.Nullable<System.Int32> Payment_method_id { get; set; }
		
		/// <summary>
		/// The amount in US Dollars of the Payment.
		///
		///* Can begin with or without `$`.
		///* Commas (`,`) are not accepted.
		///* Must end with a decimal expression, such as `.00` or `.99`.
		///* Minimum: `$5.00` or the Account balance, whichever is lower.
		///* Maximum: `$2000.00` or the Account balance up to `$50000.00`, whichever is greater.
		///
		/// Required
		/// Pattern: ^\$?\d+\.\d{2}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="usd")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^\$?\d+\.\d{2}$")]
		public string Usd { get; set; }
	}
	
	/// <summary>
	/// A Personal Access Token is a token generated manually to access the API without going through an OAuth login.  Personal Access Tokens can have scopes just like OAuth tokens do, and are commonly used to give access to command-line tools like the Linode CLI, or when writing your own integrations.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PersonalAccessToken
	{
		
		/// <summary>
		/// The date and time this token was created.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// When this token will expire.  Personal Access Tokens cannot be renewed, so after this time the token will be completely unusable and a new token will need to be generated.  Tokens may be created with "null" as their expiry and will never expire unless revoked.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiry")]
		public System.Nullable<System.DateTimeOffset> Expiry { get; set; }
		
		/// <summary>
		/// This token's unique ID, which can be used to revoke it.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// This token's label.  This is for display purposes only, but can be used to more easily track what you're using each token for.
		///
		/// Min length: 1
		/// Max length: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Label { get; set; }
		
		/// <summary>
		/// The scopes this token was created with. These define what parts of the Account the token can be used to access. Many command-line tools, such as the <a target="_top" href="https://github.com/linode/linode-cli">Linode CLI</a>, require tokens with access to `*`. Tokens with more restrictive scopes are generally more secure.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scopes")]
		public string Scopes { get; set; }
		
		/// <summary>
		/// The token used to access the API.  When the token is created, the full token is returned here.  Otherwise, only the first 16 characters are returned.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
	}
	
	/// <summary>
	/// A Profile represents your User in our system. This is where you can change information about your User. This information is available to any OAuth Client regardless of requested scopes, and can be used to populate User information in third-party applications.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Profile
	{
		
		/// <summary>
		/// This account's Cloud Manager authentication type. Authentication types are chosen through
		///Cloud Manager and authorized when logging into your account. These authentication types are either
		///the user's password (in conjunction with their username), or the name of their
		///indentity provider such as GitHub. For example, if a user:
		///
		///- Has never used Third-Party Authentication, their authentication type will be `password`.
		///- Is using Third-Party Authentication, their authentication type will be the name of their Identity Provider (eg. `github`).
		///- Has used Third-Party Authentication and has since revoked it, their authentication type will be `password`.
		///
		///
		///**Note:** This functionality may not yet be available in Cloud Manager.
		///See the [Cloud Manager Changelog](/changelog/cloud-manager/) for the latest updates.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authentication_type")]
		public System.Nullable<ProfileAuthentication_type> Authentication_type { get; set; }
		
		/// <summary>
		/// The list of SSH Keys authorized to use Lish for your User. This value is ignored if `lish_auth_method` is "disabled."
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorized_keys")]
		public string[] Authorized_keys { get; set; }
		
		/// <summary>
		/// Your email address.  This address will be used for communication with Linode as necessary.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// If true, you will receive email notifications about account activity.  If false, you may still receive business-critical communications through email.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email_notifications")]
		public System.Nullable<System.Boolean> Email_notifications { get; set; }
		
		/// <summary>
		/// If true, logins for your User will only be allowed from whitelisted IPs. This setting is currently deprecated, and cannot be enabled.
		///
		///If you disable this setting, you will not be able to re-enable it.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip_whitelist_enabled")]
		public System.Nullable<System.Boolean> Ip_whitelist_enabled { get; set; }
		
		/// <summary>
		/// The authentication methods that are allowed when connecting to [the Linode Shell (Lish)](/docs/guides/lish/).
		///* `keys_only` is the most secure if you intend to use Lish.
		///* `disabled` is recommended if you do not intend to use Lish at all.
		///* If this account's Cloud Manager authentication type is set to a Third-Party Authentication method, `password_keys` cannot be used as your Lish authentication method. To view this account's Cloud Manager `authentication_type` field, send a request to the [View Profile](/docs/api/profile/#profile-view) endpoint.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lish_auth_method")]
		public System.Nullable<ProfileLish_auth_method> Lish_auth_method { get; set; }
		
		/// <summary>
		/// Information about your status in our referral program.
		///
		///This information becomes accessible after this Profile's Account has established at least $25.00 USD of total payments.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="referrals")]
		public ProfileReferrals Referrals { get; set; }
		
		/// <summary>
		/// If true, your User has restrictions on what can be accessed on your Account. To get details on what entities/actions you can access/perform, see [/profile/grants](/docs/api/profile/#grants-list).
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restricted")]
		public System.Nullable<System.Boolean> Restricted { get; set; }
		
		/// <summary>
		/// The timezone you prefer to see times in. This is not used by the API directly. It is provided for the benefit of clients such as the Linode Cloud Manager and other clients built on the API. All times returned by the API are in UTC.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timezone")]
		public string Timezone { get; set; }
		
		/// <summary>
		/// If true, logins from untrusted computers will require Two Factor Authentication.  See [/profile/tfa-enable](/docs/api/profile/#two-factor-secret-create) to enable Two Factor Authentication.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="two_factor_auth")]
		public System.Nullable<System.Boolean> Two_factor_auth { get; set; }
		
		/// <summary>
		/// Your unique ID in our system. This value will never change, and can safely be used to identify your User.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uid")]
		public System.Nullable<System.Int32> Uid { get; set; }
		
		/// <summary>
		/// Your username, used for logging in to our system.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
		
		/// <summary>
		/// The phone number verified for this Profile with the **Phone Number Verify** ([POST /profile/phone-number/verify](/docs/api/profile/#phone-number-verify)) command.
		///
		///`null` if this Profile has no verified phone number.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="verified_phone_number")]
		public string Verified_phone_number { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProfileAuthentication_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		password = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		github = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProfileLish_auth_method
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		password_keys = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		keys_only = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 2,
	}
	
	public class ProfileReferrals
	{
		
		/// <summary>
		/// Your referral code.  If others use this when signing up for Linode, you will receive account credit.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// The number of completed signups with your referral code.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completed")]
		public System.Nullable<System.Int32> Completed { get; set; }
		
		/// <summary>
		/// The amount of account credit in US Dollars issued to you through the referral program.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="credit")]
		public System.Nullable<System.Int32> Credit { get; set; }
		
		/// <summary>
		/// The number of pending signups with your referral code.  You will not receive credit for these signups until they are completed.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pending")]
		public System.Nullable<System.Int32> Pending { get; set; }
		
		/// <summary>
		/// The number of users who have signed up with your referral code.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
		
		/// <summary>
		/// Your referral url, used to direct others to sign up for Linode with your referral code.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// An area where Linode services are available.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Region
	{
		
		/// <summary>
		/// A list of capabilities of this region.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="capabilities")]
		public string[] Capabilities { get; set; }
		
		/// <summary>
		/// The country where this Region resides.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// The unique ID of this Region.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Detailed location information for this Region, including city, state or region, and country.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resolvers")]
		public RegionResolvers Resolvers { get; set; }
		
		/// <summary>
		/// This region's current operational status.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<RegionStatus> Status { get; set; }
	}
	
	public class RegionResolvers
	{
		
		/// <summary>
		/// The IPv4 addresses for this region's DNS resolvers, separated by commas.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public string Ipv4 { get; set; }
		
		/// <summary>
		/// The IPv6 addresses for this region's DNS resolvers, separated by commas.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public string Ipv6 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RegionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ok = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		outage = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RescueDevices
	{
		
		/// <summary>
		/// Device can be either a Disk or Volume identified by `disk_id` or `volume_id`. Only one type per slot allowed. Can be null.
		///Devices mapped from _sde_ through _sdh_ are unavailable in `fullvirt` virt_mode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sda")]
		public Device Sda { get; set; }
		
		/// <summary>
		/// Device can be either a Disk or Volume identified by `disk_id` or `volume_id`. Only one type per slot allowed. Can be null.
		///Devices mapped from _sde_ through _sdh_ are unavailable in `fullvirt` virt_mode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sdb")]
		public Device Sdb { get; set; }
		
		/// <summary>
		/// Device can be either a Disk or Volume identified by `disk_id` or `volume_id`. Only one type per slot allowed. Can be null.
		///Devices mapped from _sde_ through _sdh_ are unavailable in `fullvirt` virt_mode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sdc")]
		public Device Sdc { get; set; }
		
		/// <summary>
		/// Device can be either a Disk or Volume identified by `disk_id` or `volume_id`. Only one type per slot allowed. Can be null.
		///Devices mapped from _sde_ through _sdh_ are unavailable in `fullvirt` virt_mode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sdd")]
		public Device Sdd { get; set; }
		
		/// <summary>
		/// Device can be either a Disk or Volume identified by `disk_id` or `volume_id`. Only one type per slot allowed. Can be null.
		///Devices mapped from _sde_ through _sdh_ are unavailable in `fullvirt` virt_mode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sde")]
		public Device Sde { get; set; }
		
		/// <summary>
		/// Device can be either a Disk or Volume identified by `disk_id` or `volume_id`. Only one type per slot allowed. Can be null.
		///Devices mapped from _sde_ through _sdh_ are unavailable in `fullvirt` virt_mode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sdf")]
		public Device Sdf { get; set; }
		
		/// <summary>
		/// Device can be either a Disk or Volume identified by `disk_id` or `volume_id`. Only one type per slot allowed. Can be null.
		///Devices mapped from _sde_ through _sdh_ are unavailable in `fullvirt` virt_mode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sdg")]
		public Device Sdg { get; set; }
	}
	
	/// <summary>
	/// A credential object for authenticating a User's secure shell connection to a Linode.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SSHKey
	{
		
		/// <summary>
		/// The date this key was added.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// The unique identifier of an SSH Key object.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// A label for the SSH Key.
		///
		/// Min length: 0
		/// Max length: 64
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		public string Label { get; set; }
		
		/// <summary>
		/// The public SSH Key, which is used to authenticate to the root user of the Linodes you deploy.
		///
		///Accepted formats:
		///* ssh-dss
		///* ssh-rsa
		///* ecdsa-sha2-nistp
		///* ssh-ed25519
		///* sk-ecdsa-sha2-nistp256 (Akamai-specific)
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssh_key")]
		public string Ssh_key { get; set; }
	}
	
	/// <summary>
	/// Single security question and response object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SecurityQuestion
	{
		
		/// <summary>
		/// The ID representing the security question.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The security question.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="question")]
		public string Question { get; set; }
		
		/// <summary>
		/// The security question response.
		///
		/// Min length: 3
		/// Max length: 17
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		[System.ComponentModel.DataAnnotations.MinLength(3)]
		[System.ComponentModel.DataAnnotations.MaxLength(17)]
		public string Response { get; set; }
	}
	
	/// <summary>
	/// Security questions and responses object for GET operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SecurityQuestionsGet
	{
		
		[System.Runtime.Serialization.DataMember(Name="security_questions")]
		public SecurityQuestionsGetSecurity_questions[] SecurityQuestionsGetSecurity_questions { get; set; }
	}
	
	public class SecurityQuestionsGetSecurity_questions
	{
		
		/// <summary>
		/// Single security question and response object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public SecurityQuestion Id { get; set; }
		
		/// <summary>
		/// Single security question and response object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="question")]
		public SecurityQuestion Question { get; set; }
		
		/// <summary>
		/// Single security question and response object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public SecurityQuestion Response { get; set; }
	}
	
	/// <summary>
	/// Security questions and responses object for POST operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SecurityQuestionsPost
	{
		
		[System.Runtime.Serialization.DataMember(Name="security_questions")]
		public SecurityQuestionsPostSecurity_questions[] SecurityQuestionsPostSecurity_questions { get; set; }
	}
	
	public class SecurityQuestionsPostSecurity_questions
	{
		
		/// <summary>
		/// Single security question and response object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="question_id")]
		public SecurityQuestion Question_id { get; set; }
		
		/// <summary>
		/// Single security question and response object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public SecurityQuestion Response { get; set; }
		
		/// <summary>
		/// Single security question and response object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="security_question")]
		public SecurityQuestion Security_question { get; set; }
	}
	
	/// <summary>
	/// An object representing a Service Transfer.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ServiceTransfer
	{
		
		/// <summary>
		/// When this transfer was created.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// A collection of the services to include in this transfer request, separated by type.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entities")]
		public ServiceTransferEntities Entities { get; set; }
		
		/// <summary>
		/// When this transfer expires. Transfers will automatically expire 24 hours after creation.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiry")]
		public System.Nullable<System.DateTimeOffset> Expiry { get; set; }
		
		/// <summary>
		/// If the requesting account created this transfer.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_sender")]
		public System.Nullable<System.Boolean> Is_sender { get; set; }
		
		/// <summary>
		/// The status of the transfer request.
		///
		///`accepted`: The transfer has been accepted by another user and is currently in progress.
		///Transfers can take up to 3 hours to complete.
		///
		///`cancelled`: The transfer has been cancelled by the sender.
		///
		///`completed`: The transfer has completed successfully.
		///
		///`failed`: The transfer has failed after initiation.
		///
		///`pending`: The transfer is ready to be accepted.
		///
		///`stale`: The transfer has exceeded its expiration date. It can no longer be accepted or
		///cancelled.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public EntityTransferStatus Status { get; set; }
		
		/// <summary>
		/// The token used to identify and accept or cancel this transfer.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
		
		/// <summary>
		/// When this transfer was last updated.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
	}
	
	public class ServiceTransferEntities
	{
		
		/// <summary>
		/// An array containing the IDs of each of the Linodes included in this transfer.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linodes")]
		public int[] Linodes { get; set; }
	}
	
	/// <summary>
	/// A StackScript enables you to quickly deploy a fully-configured application in an automated manner.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StackScript
	{
		
		/// <summary>
		/// The date this StackScript was created.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// Count of currently active, deployed Linodes created from this StackScript.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deployments_active")]
		public System.Nullable<System.Int32> Deployments_active { get; set; }
		
		/// <summary>
		/// The total number of times this StackScript has been deployed.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deployments_total")]
		public System.Nullable<System.Int32> Deployments_total { get; set; }
		
		/// <summary>
		/// A description for the StackScript.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The unique ID of this StackScript.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// An array of Image IDs. These are the Images that can be deployed with this StackScript.
		///
		///`any/all` indicates that all available Images, including private Images, are accepted.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="images")]
		public string[] Images { get; set; }
		
		/// <summary>
		/// This determines whether other users can use your StackScript. **Once a StackScript is made public, it cannot be made private.**
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is_public")]
		public System.Nullable<System.Boolean> Is_public { get; set; }
		
		/// <summary>
		/// The StackScript's label is for display purposes only.
		///
		/// Min length: 3
		/// Max length: 128
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(3)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		public string Label { get; set; }
		
		/// <summary>
		/// Returns `true` if this StackScript is owned by the account of the user making the request, and the user
		///making the request is unrestricted or has access to this StackScript.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mine")]
		public System.Nullable<System.Boolean> Mine { get; set; }
		
		/// <summary>
		/// This field allows you to add notes for the set of revisions made to this StackScript.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rev_note")]
		public string Rev_note { get; set; }
		
		/// <summary>
		/// The script to execute when provisioning a new Linode with this StackScript.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="script")]
		public string Script { get; set; }
		
		/// <summary>
		/// The date this StackScript was last updated.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
		
		/// <summary>
		/// This is a list of fields defined with a special syntax inside this StackScript that allow for supplying customized parameters during deployment. See [Declare User-Defined Fields (UDFs)](/docs/products/tools/stackscripts/guides/write-a-custom-script/#declare-user-defined-fields-udfs) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user_defined_fields")]
		public UserDefinedField[] User_defined_fields { get; set; }
		
		/// <summary>
		/// The Gravatar ID for the User who created the StackScript.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user_gravatar_id")]
		public string User_gravatar_id { get; set; }
		
		/// <summary>
		/// The User who created the StackScript.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// A custom field defined by the User with a special syntax within a StackScript. Derived from the contents of the script.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UserDefinedField
	{
		
		/// <summary>
		/// The default value.  If not specified, this value will be used.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="default")]
		public string Default { get; set; }
		
		/// <summary>
		/// An example value for the field.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="example")]
		public string Example { get; set; }
		
		/// <summary>
		/// A human-readable label for the field that will serve as the input prompt for entering the value during deployment.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// A list of acceptable values for the field in any quantity, combination or order.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="manyOf")]
		public string ManyOf { get; set; }
		
		/// <summary>
		/// The name of the field.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A list of acceptable single values for the field.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oneOf")]
		public string OneOf { get; set; }
	}
	
	/// <summary>
	/// A stat data point.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StatsData
	{
		
		/// <summary>
		/// A stats graph data point.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="x")]
		public System.Nullable<System.Int32> X { get; set; }
		
		/// <summary>
		/// A stats graph data point.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="y")]
		public System.Nullable<System.Int32> Y { get; set; }
	}
	
	/// <summary>
	/// A collection of graph data returned for managed stats.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StatsDataAvailable
	{
		
		/// <summary>
		/// CPU usage stats from the last 24 hours.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpu")]
		public StatsData[] Cpu { get; set; }
		
		/// <summary>
		/// Disk usage stats from the last 24 hours.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disk")]
		public StatsData[] Disk { get; set; }
		
		/// <summary>
		/// Inbound network traffic stats from the last 24 hours.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="net_in")]
		public StatsData[] Net_in { get; set; }
		
		/// <summary>
		/// Outbound network traffic stats from the last 24 hours.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="net_out")]
		public StatsData[] Net_out { get; set; }
		
		/// <summary>
		/// Swap usage stats from the last 24 hours.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="swap")]
		public StatsData[] Swap { get; set; }
	}
	
	/// <summary>
	/// A Support Ticket opened on your Account.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SupportTicket
	{
		
		/// <summary>
		/// A list of filenames representing attached files associated with this Ticket.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="attachments")]
		public string[] Attachments { get; set; }
		
		/// <summary>
		/// Whether the Support Ticket may be closed.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="closable")]
		public System.Nullable<System.Boolean> Closable { get; set; }
		
		/// <summary>
		/// The date and time this Ticket was closed.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="closed")]
		public System.Nullable<System.DateTimeOffset> Closed { get; set; }
		
		/// <summary>
		/// The full details of the issue or question.
		///
		/// Min length: 1
		/// Max length: 65000
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(65000)]
		public string Description { get; set; }
		
		/// <summary>
		/// The entity this Ticket was opened for.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entity")]
		public SupportTicketEntity Entity { get; set; }
		
		/// <summary>
		/// The Gravatar ID of the User who opened this Ticket.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		/// <summary>
		/// The ID of the Support Ticket.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The date and time this Ticket was created.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="opened")]
		public System.Nullable<System.DateTimeOffset> Opened { get; set; }
		
		/// <summary>
		/// The User who opened this Ticket.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="opened_by")]
		public string Opened_by { get; set; }
		
		/// <summary>
		/// The current status of this Ticket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<SupportTicketStatus> Status { get; set; }
		
		/// <summary>
		/// The summary or title for this Ticket.
		///
		/// Min length: 1
		/// Max length: 64
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="summary")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		public string Summary { get; set; }
		
		/// <summary>
		/// The date and time this Ticket was last updated.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
		
		/// <summary>
		/// The User who last updated this Ticket.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_by")]
		public string Updated_by { get; set; }
	}
	
	public class SupportTicketEntity
	{
		
		/// <summary>
		/// The unique ID for this Ticket's entity.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The current label of this entity.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The type of entity this is related to.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// The URL where you can access the object this event is for. If a relative URL, it is relative to the domain you retrieved the entity from.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SupportTicketStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		closed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="new")]
		_new = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		open = 2,
	}
	
	/// <summary>
	/// An object representing a reply to a Support Ticket.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SupportTicketReply
	{
		
		/// <summary>
		/// The date and time this Ticket reply was created.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// The User who submitted this reply.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_by")]
		public string Created_by { get; set; }
		
		/// <summary>
		/// The body of this Support Ticket reply.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// If set to true, this reply came from a Linode employee.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from_linode")]
		public System.Nullable<System.Boolean> From_linode { get; set; }
		
		/// <summary>
		/// The Gravatar ID of the User who created this reply.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gravatar_id")]
		public string Gravatar_id { get; set; }
		
		/// <summary>
		/// The unique ID of this Support Ticket reply.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
	}
	
	/// <summary>
	/// An object representing a created Support Ticket - a question or issue and request for help from the Linode support team.
	///Only one of the ID attributes (`linode_id`, `domain_id`, etc.) can be set on a single Support Ticket.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SupportTicketRequest
	{
		
		/// <summary>
		/// The ID of the Managed Database this ticket is regarding, if relevant.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="database_id")]
		public System.Nullable<System.Int32> Database_id { get; set; }
		
		/// <summary>
		/// The full details of the issue or question.
		///
		/// Required
		/// Min length: 1
		/// Max length: 65000
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(65000)]
		public string Description { get; set; }
		
		/// <summary>
		/// The ID of the Domain this ticket is regarding, if relevant.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domain_id")]
		public System.Nullable<System.Int32> Domain_id { get; set; }
		
		/// <summary>
		/// The ID of the Firewall this ticket is regarding, if relevant.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewall_id")]
		public System.Nullable<System.Int32> Firewall_id { get; set; }
		
		/// <summary>
		/// The ID of the Linode this ticket is regarding, if relevant.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linode_id")]
		public System.Nullable<System.Int32> Linode_id { get; set; }
		
		/// <summary>
		/// The ID of the Kubernetes cluster this ticket is regarding, if relevant.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lkecluster_id")]
		public System.Nullable<System.Int32> Lkecluster_id { get; set; }
		
		/// <summary>
		/// The ID of the Longview client this ticket is regarding, if relevant.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="longviewclient_id")]
		public System.Nullable<System.Int32> Longviewclient_id { get; set; }
		
		/// <summary>
		/// Designates if this ticket is related to a [Managed service](https://www.linode.com/products/managed/). If `true`, the following constraints will apply:
		///* No ID attributes (i.e. `linode_id`, `domain_id`, etc.) should be provided with this request.
		///* Your account must have a [Managed service enabled](/docs/api/managed/#managed-service-enable).
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managed_issue")]
		public System.Nullable<System.Boolean> Managed_issue { get; set; }
		
		/// <summary>
		/// The ID of the NodeBalancer this ticket is regarding, if relevant.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodebalancer_id")]
		public System.Nullable<System.Int32> Nodebalancer_id { get; set; }
		
		/// <summary>
		/// The [Region](/docs/api/regions/) ID for the associated VLAN this ticket is regarding.
		///
		///Only allowed when submitting a VLAN ticket.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The summary or title for this SupportTicket.
		///
		/// Required
		/// Min length: 1
		/// Max length: 64
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="summary")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		public string Summary { get; set; }
		
		/// <summary>
		/// The label of the VLAN this ticket is regarding, if relevant. To view your VLANs, use the VLANs List ([GET /networking/vlans](/docs/api/networking/#vlans-list)) endpoint.
		///
		///Requires a specified `region` to identify the VLAN.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlan")]
		public string Vlan { get; set; }
		
		/// <summary>
		/// The ID of the Volume this ticket is regarding, if relevant.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volume_id")]
		public System.Nullable<System.Int32> Volume_id { get; set; }
	}
	
	/// <summary>
	/// A tag that has been applied to an object on your Account. Tags are currently for organizational purposes only.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Tag
	{
		
		/// <summary>
		/// A Label used for organization of objects on your Account.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
	}
	
	/// <summary>
	/// An object representing your network utilization for the current month, in Gigabytes.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Transfer
	{
		
		/// <summary>
		/// The amount of your transfer pool that is billable this billing cycle.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="billable")]
		public System.Nullable<System.Int32> Billable { get; set; }
		
		/// <summary>
		/// The amount of network usage allowed this billing cycle.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quota")]
		public System.Nullable<System.Int32> Quota { get; set; }
		
		/// <summary>
		/// The amount of network usage you have used this billing cycle.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="used")]
		public System.Nullable<System.Int32> Used { get; set; }
	}
	
	/// <summary>
	/// A trusted device object represents an active Remember Me session with <a target="_top" href="https://login.linode.com">login.linode.com</a>.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TrustedDevice
	{
		
		/// <summary>
		/// When this Remember Me session was started.  This corresponds to the time of login with the "Remember Me" box checked.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// When this TrustedDevice session expires.  Sessions typically last 30 days.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiry")]
		public System.Nullable<System.DateTimeOffset> Expiry { get; set; }
		
		/// <summary>
		/// The unique ID for this TrustedDevice
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The last time this TrustedDevice was successfully used to authenticate to <a target="_top" href="https://login.linode.com">login.linode.com</a>.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_authenticated")]
		public System.Nullable<System.DateTimeOffset> Last_authenticated { get; set; }
		
		/// <summary>
		/// The last IP Address to successfully authenticate with this TrustedDevice.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_remote_addr")]
		public string Last_remote_addr { get; set; }
		
		/// <summary>
		/// The User Agent of the browser that created this TrustedDevice session.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user_agent")]
		public string User_agent { get; set; }
	}
	
	/// <summary>
	/// A User on your Account. Unrestricted users can log in and access information about your Account, while restricted users may only access entities or perform actions they've been granted access to.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class User
	{
		
		/// <summary>
		/// The email address for the User. Linode sends emails to this address for account management communications. May be used for other communications as configured.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// If true, the User must be granted access to perform actions or access entities on this Account. See User Grants View ([GET /account/users/{username}/grants](/docs/api/account/#users-grants-view)) for details on how to configure grants for a restricted User.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restricted")]
		public System.Nullable<System.Boolean> Restricted { get; set; }
		
		/// <summary>
		/// A list of SSH Key labels added by this User.
		///
		///Users can add keys with the SSH Key Add ([POST /profile/sshkeys](/docs/api/profile/#ssh-key-add)) command.
		///
		///These keys are deployed when this User is included in the `authorized_users`
		///field of the following requests:
		///- Linode Create ([POST /linode/instances](/docs/api/linode-instances/#linode-create))
		///- Linode Rebuild ([POST /linode/instances/{linodeId}/rebuild](/docs/api/linode-instances/#linode-rebuild))
		///- Disk Create ([POST /linode/instances/{linodeId}/disks](/docs/api/linode-instances/#disk-create))
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssh_keys")]
		public string[] Ssh_keys { get; set; }
		
		/// <summary>
		/// A boolean value indicating if the User has Two Factor Authentication (TFA) enabled. See the Create Two Factor Secret ([POST /profile/tfa-enable](/docs/api/profile/#two-factor-secret-create)) endpoint to enable TFA.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tfa_enabled")]
		public System.Nullable<System.Boolean> Tfa_enabled { get; set; }
		
		/// <summary>
		/// The User's username. This is used for logging in, and may also be displayed alongside actions the User performs (for example, in Events or public StackScripts).
		///
		/// Min length: 3
		/// Max length: 32
		/// Pattern: ^[a-zA-Z0-9]((?![_-]{2,})[a-zA-Z0-9-_])+[a-zA-Z0-9]$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		[System.ComponentModel.DataAnnotations.MinLength(3)]
		[System.ComponentModel.DataAnnotations.MaxLength(32)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9]((?![_-]{2,})[a-zA-Z0-9-_])+[a-zA-Z0-9]$")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// A virtual local area network (VLAN) associated with your Account.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Vlans
	{
		
		/// <summary>
		/// The date this VLAN was created.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// The name of this VLAN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// An array of Linode IDs attached to this VLAN.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linodes")]
		public int[] Linodes { get; set; }
		
		/// <summary>
		/// This VLAN's data center region.
		///
		///**Note:** Currently, a VLAN can only be assigned to a Linode
		///within the same data center region.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
	}
	
	/// <summary>
	/// A Block Storage Volume associated with your Account.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Volume
	{
		
		/// <summary>
		/// When this Volume was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// The full filesystem path for the Volume based on the Volume's label. Path is /dev/disk/by-id/scsi-0Linode_Volume_ + Volume label.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filesystem_path")]
		public string Filesystem_path { get; set; }
		
		/// <summary>
		/// The storage type of this Volume.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hardware_type")]
		public System.Nullable<VolumeHardware_type> Hardware_type { get; set; }
		
		/// <summary>
		/// The unique ID of this Volume.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The Volume's label is for display purposes only.
		///
		/// Min length: 1
		/// Max length: 32
		/// Pattern: ^[a-zA-Z]((?!--|__)[a-zA-Z0-9-_])+$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(32)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z]((?!--|__)[a-zA-Z0-9-_])+$")]
		public string Label { get; set; }
		
		/// <summary>
		/// If a Volume is attached to a specific Linode, the ID of that Linode will be displayed here.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linode_id")]
		public System.Nullable<System.Int32> Linode_id { get; set; }
		
		/// <summary>
		/// If a Volume is attached to a specific Linode, the label of that Linode will be displayed here.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linode_label")]
		public string Linode_label { get; set; }
		
		/// <summary>
		/// An area where Linode services are available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public Region Region { get; set; }
		
		/// <summary>
		/// The Volume's size, in GiB.
		///
		/// Maximum: 10240
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		[System.ComponentModel.DataAnnotations.Range(System.Int32.MinValue, 10240)]
		public System.Nullable<System.Int32> Size { get; set; }
		
		/// <summary>
		/// The current status of the volume.  Can be one of:
		///
		///  * `creating` - the Volume is being created and is not yet available
		///    for use.
		///  * `active` - the Volume is online and available for use.
		///  * `resizing` - the Volume is in the process of upgrading
		///    its current capacity.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<VolumeStatus> Status { get; set; }
		
		/// <summary>
		/// An array of Tags applied to this object.  Tags are for organizational purposes only.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// When this Volume was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public System.Nullable<System.DateTimeOffset> Updated { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum VolumeHardware_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hdd = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		nvme = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum VolumeStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		creating = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		resizing = 2,
	}
	
	/// <summary>
	/// An object for describing a single warning associated with a response.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WarningObject
	{
		
		/// <summary>
		/// Specific information related to the warning.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string Details { get; set; }
		
		/// <summary>
		/// The general warning message.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Account View
		/// Returns the contact and billing information related to your Account.
		/// 
		/// GetAccount account
		/// </summary>
		/// <returns>Returns a single Account object.</returns>
		public async Task<Account> GetAccountAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Account>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Account Update
		/// Updates contact and billing information related to your Account.
		/// 
		/// UpdateAccount account
		/// </summary>
		/// <param name="requestBody">Update contact and billing information.
		///
		///Account properties that are excluded from a request remain unchanged.
		///
		///When updating an Account's `country` to "US", an error is returned if the Account's `zip` is not a valid US zip code.
		///</param>
		/// <returns>The updated Account.</returns>
		public async Task<Account> UpdateAccountAsync(Account requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Account>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Account Cancel
		/// Cancels an active Linode account. This action will cause Linode to attempt to charge the credit card on file for the remaining balance. An error will occur if Linode fails to charge the credit card on file. Restricted users will not be able to cancel an account.
		/// 
		/// CancelAccount account/cancel
		/// </summary>
		/// <param name="requestBody">Supply a comment stating the reason that you are cancelling your account.
		///</param>
		/// <returns>Account cancelled</returns>
		public async Task<CancelAccountReturn> CancelAccountAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/cancel";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<CancelAccountReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Credit Card Add/Edit
		/// **DEPRECATED**. Please use Payment Method Add ([POST /account/payment-methods](/docs/api/account/#payment-method-add)).
		/// 
		/// Adds a credit card Payment Method to your account and sets it as the default method.
		/// 
		/// CreateCreditCard account/credit-card
		/// </summary>
		/// <param name="requestBody">Update the credit card information associated with your Account.</param>
		/// <returns>Credit Card updated.</returns>
		public async Task<string> CreateCreditCardAsync(CreditCard requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/credit-card";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Entity Transfers List
		/// **DEPRECATED**. Please use [Service Transfers List](/docs/api/account/#service-transfers-list).
		/// 
		/// GetEntityTransfers account/entity-transfers
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated list of Entity Transfer objects containing the details of all transfers that have been created and accepted by this account.
		///</returns>
		public async Task<PaginationEnvelope> GetEntityTransfersAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/entity-transfers?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<PaginationEnvelope>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Entity Transfer Create
		/// **DEPRECATED**. Please use [Service Transfer Create](/docs/api/account/#service-transfer-create).
		/// 
		/// CreateEntityTransfer account/entity-transfers
		/// </summary>
		/// <param name="requestBody">The entities to include in this transfer request.</param>
		/// <returns>Returns an Entity Transfer object for the request.
		///</returns>
		public async Task<EntityTransfer> CreateEntityTransferAsync(CreateEntityTransferPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/entity-transfers";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<EntityTransfer>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Entity Transfer Cancel
		/// **DEPRECATED**. Please use [Service Transfer Cancel](/docs/api/account/#service-transfer-cancel).
		/// 
		/// DeleteEntityTransfer account/entity-transfers/{token}
		/// </summary>
		/// <returns>Entity Transfer cancelled.
		///</returns>
		public async Task<string> DeleteEntityTransferAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/entity-transfers/{token}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Entity Transfer View
		/// **DEPRECATED**. Please use [Service Transfer View](/docs/api/account/#service-transfer-view).
		/// 
		/// GetEntityTransfer account/entity-transfers/{token}
		/// </summary>
		/// <returns>Returns an Entity Transfer object containing the details of the transfer for the specified token.
		///</returns>
		public async Task<EntityTransfer> GetEntityTransferAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/entity-transfers/{token}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<EntityTransfer>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Entity Transfer Accept
		/// **DEPRECATED**. Please use [Service Transfer Accept](/docs/api/account/#service-transfer-accept).
		/// 
		/// AcceptEntityTransfer account/entity-transfers/{token}/accept
		/// </summary>
		/// <returns>Entity Transfer accepted.
		///</returns>
		public async Task<string> AcceptEntityTransferAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/entity-transfers/{token}/accept";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Events List
		/// Returns a collection of Event objects representing actions taken on your Account from the last 90 days. The Events returned depend on your grants.
		/// 
		/// GetEvents account/events
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated lists of Event objects from the last 90 days.
		///</returns>
		public async Task<GetEventsReturn> GetEventsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/events?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetEventsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Event View
		/// Returns a single Event object.
		/// 
		/// GetEvent account/events/{eventId}
		/// </summary>
		/// <returns>An Event object</returns>
		public async Task<Event> GetEventAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/events/{eventId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Event>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Event Mark as Read
		/// Marks a single Event as read.
		/// EventRead account/events/{eventId}/read
		/// </summary>
		/// <returns>Event read.</returns>
		public async Task<string> EventReadAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/events/{eventId}/read";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Event Mark as Seen
		/// Marks all Events up to and including this Event by ID as seen.
		/// 
		/// EventSeen account/events/{eventId}/seen
		/// </summary>
		/// <returns>Events seen.</returns>
		public async Task<string> EventSeenAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/events/{eventId}/seen";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Invoices List
		/// Returns a paginated list of Invoices against your Account.
		/// 
		/// GetInvoices account/invoices
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated list of Invoice objects.</returns>
		public async Task<GetInvoicesReturn> GetInvoicesAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/invoices?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetInvoicesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Invoice View
		/// Returns a single Invoice object.
		/// GetInvoice account/invoices/{invoiceId}
		/// </summary>
		/// <returns>An Invoice object</returns>
		public async Task<Invoice> GetInvoiceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/invoices/{invoiceId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Invoice>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Invoice Items List
		/// Returns a paginated list of Invoice items.
		/// GetInvoiceItems account/invoices/{invoiceId}/items
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A paginated list of InvoiceItem objects</returns>
		public async Task<GetInvoiceItemsReturn> GetInvoiceItemsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/invoices/{invoiceId}/items?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetInvoiceItemsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// User Logins List All
		/// Returns a collection of successful logins for all users on the account during the last 90 days. This command can only be accessed by the unrestricted users of an account.
		/// 
		/// GetAccountLogins account/logins
		/// </summary>
		/// <returns>A collection of successful logins for all users on the account during the last 90 days.
		///</returns>
		public async Task<GetAccountLoginsReturn> GetAccountLoginsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/logins";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetAccountLoginsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Login View
		/// Returns a Login object that displays information about a successful login. The logins that can be viewed can be for any user on the account, and are not limited to only the logins of the user that is accessing this API endpoint. This command can only be accessed by the unrestricted users of the account.
		/// 
		/// GetAccountLogin account/logins/{loginId}
		/// </summary>
		/// <returns>The requested login object.</returns>
		public async Task<Login> GetAccountLoginAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/logins/{loginId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Login>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Maintenance List
		/// Returns a collection of Maintenance objects for any entity a user has permissions to view. Cancelled Maintenance objects are not returned.
		/// 
		/// Currently, Linodes are the only entities available for viewing.
		/// 
		/// GetMaintenance account/maintenance
		/// </summary>
		/// <returns>Returns a paginated list of Maintenance objects.</returns>
		public async Task<GetMaintenanceReturn> GetMaintenanceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/maintenance";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetMaintenanceReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Notifications List
		/// Returns a collection of Notification objects representing important, often time-sensitive items related to your Account.
		/// You cannot interact directly with Notifications, and a Notification will disappear when the circumstances causing it have been resolved. For example, if you have an important Ticket open, you must respond to the Ticket to dismiss the Notification.
		/// 
		/// GetNotifications account/notifications
		/// </summary>
		/// <returns>Returns a paginated list of Notification objects.</returns>
		public async Task<GetNotificationsReturn> GetNotificationsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/notifications";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNotificationsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// OAuth Clients List
		/// Returns a paginated list of OAuth Clients registered to your Account.  OAuth Clients allow users to log into applications you write or host using their Linode Account, and may allow them to grant some level of access to their Linodes or other entities to your application.
		/// 
		/// GetClients account/oauth-clients
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A paginated list of OAuth Clients.</returns>
		public async Task<GetClientsReturn> GetClientsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/oauth-clients?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetClientsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// OAuth Client Create
		/// Creates an OAuth Client, which can be used to allow users (using their Linode account) to log in to your own application, and optionally grant your application some amount of access to their Linodes or other entities.
		/// 
		/// CreateClient account/oauth-clients
		/// </summary>
		/// <param name="requestBody">Information about the OAuth Client to create.</param>
		/// <returns>Client created successfully.</returns>
		public async Task<OAuthClient> CreateClientAsync(OAuthClient requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/oauth-clients";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<OAuthClient>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// OAuth Client Delete
		/// Deletes an OAuth Client registered with Linode. The Client ID and Client secret will no longer be accepted by <a target="_top" href="https://login.linode.com">https://login.linode.com</a>, and all tokens issued to this client will be invalidated (meaning that if your application was using a token, it will no longer work).
		/// 
		/// DeleteClient account/oauth-clients/{clientId}
		/// </summary>
		/// <returns>Client deleted successfully.</returns>
		public async Task<string> DeleteClientAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/oauth-clients/{clientId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// OAuth Client View
		/// Returns information about a single OAuth client.
		/// 
		/// GetClient account/oauth-clients/{clientId}
		/// </summary>
		/// <returns>Information about the requested client.</returns>
		public async Task<OAuthClient> GetClientAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/oauth-clients/{clientId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<OAuthClient>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// OAuth Client Update
		/// Update information about an OAuth Client on your Account. This can be especially useful to update the `redirect_uri` of your client in the event that the callback url changed in your application.
		/// 
		/// UpdateClient account/oauth-clients/{clientId}
		/// </summary>
		/// <param name="requestBody">The fields to update.</param>
		/// <returns>Client updated successfully.</returns>
		public async Task<OAuthClient> UpdateClientAsync(OAuthClient requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/oauth-clients/{clientId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<OAuthClient>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// OAuth Client Secret Reset
		/// Resets the OAuth Client secret for a client you own, and returns the OAuth Client with the plaintext secret. This secret is not supposed to be publicly known or disclosed anywhere. This can be used to generate a new secret in case the one you have has been leaked, or to get a new secret if you lost the original. The old secret is expired immediately, and logins to your client with the old secret will fail.
		/// 
		/// ResetClientSecret account/oauth-clients/{clientId}/reset-secret
		/// </summary>
		/// <returns>Client secret reset successfully.</returns>
		public async Task<OAuthClient> ResetClientSecretAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/oauth-clients/{clientId}/reset-secret";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<OAuthClient>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// OAuth Client Thumbnail View
		/// Returns the thumbnail for this OAuth Client.  This is a publicly-viewable endpoint, and can be accessed without authentication.
		/// 
		/// GetClientThumbnail account/oauth-clients/{clientId}/thumbnail
		/// </summary>
		/// <returns>The client's thumbnail.</returns>
		public async Task GetClientThumbnailAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/oauth-clients/{clientId}/thumbnail";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Payment Methods List
		/// Returns a paginated list of Payment Methods for this Account.
		/// 
		/// GetPaymentMethods account/payment-methods
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated list of Payment Method objects.</returns>
		public async Task<GetPaymentMethodsReturn> GetPaymentMethodsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/payment-methods?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetPaymentMethodsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Payment Method Add
		/// Adds a Payment Method to your Account with the option to set it as the default method.
		/// 
		/// * Adding a default Payment Method removes the default status from any other Payment Method.
		/// 
		/// * An Account can have up to 6 active Payment Methods.
		/// 
		/// * Up to 60 Payment Methods can be added each day.
		/// 
		/// * Prior to adding a Payment Method, ensure that your billing address information is up-to-date
		/// with a valid `zip` by using the Account Update ([PUT /account](/docs/api/account/#account-update)) endpoint.
		/// 
		/// * A `payment_method_add` event is generated when a payment is successfully submitted.
		/// 
		/// CreatePaymentMethod account/payment-methods
		/// </summary>
		/// <param name="requestBody">The details of the Payment Method to add.</param>
		/// <returns>Payment Method added.</returns>
		public async Task<string> CreatePaymentMethodAsync(CreatePaymentMethodPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/payment-methods";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Payment Method Delete
		/// Deactivate the specified Payment Method.
		/// 
		/// The default Payment Method can not be deleted. To add a new default Payment Method, access the Payment Method
		/// Add ([POST /account/payment-methods](/docs/api/account/#payment-method-add)) endpoint. To designate an existing
		/// Payment Method as the default method, access the Payment Method Make Default
		/// ([POST /account/payment-methods/{paymentMethodId}/make-default](/docs/api/account/#payment-method-make-default))
		/// endpoint.
		/// 
		/// DeletePaymentMethod account/payment-methods/{paymentMethodId}
		/// </summary>
		/// <returns>Payment Method deactivated.</returns>
		public async Task<string> DeletePaymentMethodAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/payment-methods/{paymentMethodId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Payment Method View
		/// View the details of the specified Payment Method.
		/// 
		/// GetPaymentMethod account/payment-methods/{paymentMethodId}
		/// </summary>
		/// <returns>Returns a Payment Method Object.</returns>
		public async Task<PaymentMethod> GetPaymentMethodAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/payment-methods/{paymentMethodId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<PaymentMethod>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Payment Method Make Default
		/// Make the specified Payment Method the default method for automatically processing payments.
		/// 
		/// Removes the default status from any other Payment Method.
		/// 
		/// MakePaymentMethodDefault account/payment-methods/{paymentMethodId}/make-default
		/// </summary>
		/// <returns>Payment Method successfully set as the default method.</returns>
		public async Task<string> MakePaymentMethodDefaultAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/payment-methods/{paymentMethodId}/make-default";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Payments List
		/// Returns a paginated list of Payments made on this Account.
		/// 
		/// GetPayments account/payments
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated list of Payment objects.</returns>
		public async Task<GetPaymentsReturn> GetPaymentsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/payments?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetPaymentsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Payment Make
		/// Makes a Payment to your Account.
		/// 
		/// * The requested amount is charged to the default Payment Method if no `payment_method_id` is specified.
		/// 
		/// * A `payment_submitted` event is generated when a payment is successfully submitted.
		/// 
		/// CreatePayment account/payments
		/// </summary>
		/// <param name="requestBody">Information about the Payment you are making.</param>
		/// <returns>Payment submitted successfully.</returns>
		public async Task<Payment> CreatePaymentAsync(PaymentRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/payments";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Payment>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// PayPal Payment Stage
		/// **Note**: This endpoint is disabled and no longer accessible. PayPal can be designated as a Payment Method for automated payments using the Cloud Manager. See [Manage Payment Methods](/docs/products/platform/billing/guides/payment-methods/).
		/// 
		/// CreatePayPalPayment account/payments/paypal
		/// </summary>
		/// <param name="requestBody">The amount of the Payment to submit via PayPal.
		///</param>
		/// <returns>PayPal Payment staged.</returns>
		public async Task<CreatePayPalPaymentReturn> CreatePayPalPaymentAsync(PayPal requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/payments/paypal";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<CreatePayPalPaymentReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Staged/Approved PayPal Payment Execute
		/// **Note**: This endpoint is disabled and no longer accessible. PayPal can be designated as a Payment Method for automated payments using the Cloud Manager. See [Manage Payment Methods](/docs/products/platform/billing/guides/payment-methods/).
		/// 
		/// ExecutePayPalPayment account/payments/paypal/execute
		/// </summary>
		/// <param name="requestBody">The details of the Payment to execute.
		///</param>
		/// <returns>PayPal Payment executed.</returns>
		public async Task<string> ExecutePayPalPaymentAsync(PayPalExecute requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/payments/paypal/execute";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Payment View
		/// Returns information about a specific Payment.
		/// 
		/// GetPayment account/payments/{paymentId}
		/// </summary>
		/// <returns>A Payment object.</returns>
		public async Task<Payment> GetPaymentAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/payments/{paymentId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Payment>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Promo Credit Add
		/// Adds an expiring Promo Credit to your account.
		/// 
		/// The following restrictions apply:
		/// 
		/// * Your account must be less than 90 days old.
		/// * There must not be an existing Promo Credit already on your account.
		/// * The requesting User must be unrestricted. Use the User Update
		/// ([PUT /account/users/{username}](/docs/api/account/#user-update)) to change a User's restricted status.
		/// * The `promo_code` must be valid and unexpired.
		/// 
		/// CreatePromoCredit account/promo-codes
		/// </summary>
		/// <param name="requestBody">Enter a Promo Code to add its associated credit to your Account.</param>
		/// <returns>Promo Credit successfully added.
		///</returns>
		public async Task<Promotion> CreatePromoCreditAsync(CreatePromoCreditPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/promo-codes";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Promotion>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Service Transfers List
		/// Returns a collection of all created and accepted Service Transfers for this account, regardless of the user that created or accepted the transfer.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// GetServiceTransfers account/service-transfers
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated list of Service Transfer objects containing the details of all transfers that have been created and accepted by this account.
		///</returns>
		public async Task<GetServiceTransfersReturn> GetServiceTransfersAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/service-transfers?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetServiceTransfersReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Service Transfer Create
		/// Creates a transfer request for the specified services. A request can contain any of the specified service types
		/// and any number of each service type. At this time, only Linodes can be transferred.
		/// 
		/// When created successfully, a confirmation email is sent to the account that created this transfer containing a
		/// transfer token and instructions on completing the transfer.
		/// 
		/// When a transfer is [accepted](/docs/api/account/#service-transfer-accept), the requested services are moved to
		/// the receiving account. Linode services will not experience interruptions due to the transfer process. Backups
		/// for Linodes are transferred as well.
		/// 
		/// DNS records that are associated with requested services will not be transferred or updated. Please ensure that
		/// associated DNS records have been updated or communicated to the recipient prior to the transfer.
		/// 
		/// A transfer can take up to three hours to complete once accepted. When a transfer is
		/// completed, billing for transferred services ends for the sending account and begins for the receiving account.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// There are several conditions that must be met in order to successfully create a transfer request:
		/// 
		/// 1. The account creating the transfer must not have a past due balance or active Terms of Service violation.
		/// 
		/// 1. The service must be owned by the account that is creating the transfer.
		/// 
		/// 1. The service must not be assigned to another Service Transfer that is pending or that has been accepted and is
		/// incomplete.
		/// 
		/// 1. Linodes must not:
		/// 
		/// * be assigned to a NodeBalancer, Firewall, VLAN, or Managed Service.
		/// 
		/// * have any attached Block Storage Volumes.
		/// 
		/// * have any shared IP addresses.
		/// 
		/// * have any assigned /56, /64, or /116 IPv6 ranges.
		/// 
		/// CreateServiceTransfer account/service-transfers
		/// </summary>
		/// <param name="requestBody">The services to include in this transfer request.</param>
		/// <returns>Returns a Service Transfer object for the request.
		///</returns>
		public async Task<ServiceTransfer> CreateServiceTransferAsync(CreateServiceTransferPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/service-transfers";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ServiceTransfer>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Service Transfer Cancel
		/// Cancels the Service Transfer for the provided token. Once cancelled, a transfer cannot be accepted or otherwise
		/// acted on in any way. If cancelled in error, the transfer must be
		/// [created](/docs/api/account/#service-transfer-create) again.
		/// 
		/// When cancelled, an email notification for the cancellation is sent to the account that created
		/// this transfer. Transfers can not be cancelled if they are expired or have been accepted.
		/// 
		/// This command can only be accessed by the unrestricted users of the account that created this transfer.
		/// 
		/// DeleteServiceTransfer account/service-transfers/{token}
		/// </summary>
		/// <returns>Service Transfer cancelled.
		///</returns>
		public async Task<string> DeleteServiceTransferAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/service-transfers/{token}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Service Transfer View
		/// Returns the details of the Service Transfer for the provided token.
		/// 
		/// While a transfer is pending, any unrestricted user *of any account* can access this command. After a
		/// transfer has been accepted, it can only be viewed by unrestricted users of the accounts that created and
		/// accepted the transfer. If cancelled or expired, only unrestricted users of the account that created the
		/// transfer can view it.
		/// 
		/// GetServiceTransfer account/service-transfers/{token}
		/// </summary>
		/// <returns>Returns a Service Transfer object containing the details of the transfer for the specified token.
		///</returns>
		public async Task<ServiceTransfer> GetServiceTransferAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/service-transfers/{token}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ServiceTransfer>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Service Transfer Accept
		/// Accept a Service Transfer for the provided token to receive the services included in the transfer to your
		/// account. At this time, only Linodes can be transferred.
		/// 
		/// When accepted, email confirmations are sent to the accounts that created and accepted the transfer. A transfer
		/// can take up to three hours to complete once accepted. Once a transfer is completed, billing for transferred
		/// services ends for the sending account and begins for the receiving account.
		/// 
		/// This command can only be accessed by the unrestricted users of the account that receives the transfer. Users
		/// of the same account that created a transfer cannot accept the transfer.
		/// 
		/// There are several conditions that must be met in order to accept a transfer request:
		/// 
		/// 1. Only transfers with a `pending` status can be accepted.
		/// 
		/// 1. The account accepting the transfer must have a registered payment method and must not have a past due
		/// balance or other account limitations for the services to be transferred.
		/// 
		/// 1. Both the account that created the transfer and the account that is accepting the transfer must not have any
		/// active Terms of Service violations.
		/// 
		/// 1. The service must still be owned by the account that created the transfer.
		/// 
		/// 1. Linodes must not:
		/// 
		/// * be assigned to a NodeBalancer, Firewall, VLAN, or Managed Service.
		/// 
		/// * have any attached Block Storage Volumes.
		/// 
		/// * have any shared IP addresses.
		/// 
		/// * have any assigned /56, /64, or /116 IPv6 ranges.
		/// 
		/// Any and all of the above conditions must be cured and maintained by the relevant account prior to the
		/// transfer's expiration to allow the transfer to be accepted by the receiving account.
		/// 
		/// AcceptServiceTransfer account/service-transfers/{token}/accept
		/// </summary>
		/// <returns>Service Transfer accepted.
		///</returns>
		public async Task<string> AcceptServiceTransferAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/service-transfers/{token}/accept";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Account Settings View
		/// Returns information related to your Account settings: Managed service subscription, Longview subscription, and network helper.
		/// 
		/// GetAccountSettings account/settings
		/// </summary>
		/// <returns>Returns a single Account settings object.</returns>
		public async Task<AccountSettings> GetAccountSettingsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AccountSettings>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Account Settings Update
		/// Updates your Account settings.
		/// 
		/// To update your Longview subscription plan, send a request to [Update Longview Plan](/docs/api/longview/#longview-plan-update).
		/// 
		/// UpdateAccountSettings account/settings
		/// </summary>
		/// <param name="requestBody">Update Account settings information.</param>
		/// <returns>The updated Account settings.</returns>
		public async Task<AccountSettings> UpdateAccountSettingsAsync(AccountSettings requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/settings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AccountSettings>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linode Managed Enable
		/// Enables Linode Managed for the entire account and sends a welcome email to the account's associated email address. Linode Managed can monitor any service or software stack reachable over TCP or HTTP. See our [Linode Managed guide](/docs/guides/linode-managed/) to learn more.
		/// 
		/// EnableAccountManaged account/settings/managed-enable
		/// </summary>
		/// <returns>Managed services enabled for account.</returns>
		public async Task<string> EnableAccountManagedAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/settings/managed-enable";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Network Utilization View
		/// Returns a Transfer object showing your network utilization, in GB, for the current month.
		/// 
		/// GetTransfer account/transfer
		/// </summary>
		/// <returns>Returns a single Transfer object.</returns>
		public async Task<Transfer> GetTransferAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/transfer";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Transfer>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Users List
		/// Returns a paginated list of Users on your Account.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// Users may access all or part of your Account based on their restricted status and grants.  An unrestricted User may access everything on the account, whereas restricted User may only access entities or perform actions they've been given specific grants to.
		/// 
		/// GetUsers account/users
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A paginated list of Users.</returns>
		public async Task<GetUsersReturn> GetUsersAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/users?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetUsersReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// User Create
		/// Creates a User on your Account. Once created, a confirmation message containing
		/// password creation and login instructions is sent to the User's email address.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// The User's account access is determined by whether or not they are restricted,
		/// and what grants they have been given.
		/// 
		/// CreateUser account/users
		/// </summary>
		/// <param name="requestBody">Information about the User to create.</param>
		/// <returns>New User created successfully.</returns>
		public async Task<User> CreateUserAsync(User requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/users";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<User>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// User Delete
		/// Deletes a User. The deleted User will be immediately logged out and
		/// may no longer log in or perform any actions. All of the User's Grants
		/// will be removed.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// DeleteUser account/users/{username}
		/// </summary>
		/// <returns>User deleted successfully.</returns>
		public async Task<string> DeleteUserAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/users/{username}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// User View
		/// Returns information about a single User on your Account.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// GetUser account/users/{username}
		/// </summary>
		/// <returns>The requested User object</returns>
		public async Task<User> GetUserAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/users/{username}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<User>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// User Update
		/// Update information about a User on your Account. This can be used to
		/// change the restricted status of a User. When making a User restricted,
		/// no grants will be configured by default and you must then set up grants
		/// in order for the User to access anything on the Account.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// UpdateUser account/users/{username}
		/// </summary>
		/// <param name="requestBody">The information to update.</param>
		/// <returns>User updated successfully.</returns>
		public async Task<User> UpdateUserAsync(User requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/users/{username}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<User>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// User's Grants View
		/// Returns the full grants structure for the specified account User
		/// (other than the account owner, see below for details). This includes all entities
		/// on the Account alongside the level of access this User has to each of them.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// The current authenticated User, including the account owner, may view their
		/// own grants at the [/profile/grants](/docs/api/profile/#grants-list)
		/// endpoint, but will not see entities that they do not have access to.
		/// 
		/// GetUserGrants account/users/{username}/grants
		/// </summary>
		/// <returns>The User's grants.</returns>
		public async Task<GrantsResponse> GetUserGrantsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/users/{username}/grants";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GrantsResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// User's Grants Update
		/// Update the grants a User has. This can be used to give a User access
		/// to new entities or actions, or take access away.  You do not need to
		/// include the grant for every entity on the Account in this request; any
		/// that are not included will remain unchanged.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// UpdateUserGrants account/users/{username}/grants
		/// </summary>
		/// <param name="requestBody">The grants to update. Omitted grants will be left unchanged.</param>
		/// <returns>Grants updated successfully.</returns>
		public async Task<GrantsResponse> UpdateUserGrantsAsync(GrantsResponse requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account/users/{username}/grants";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GrantsResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Database Engines List
		/// Display all available Managed Database engine types and versions. Engine IDs are used when creating new Managed Databases.
		/// 
		/// GetDatabasesEngines databases/engines
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated list of all available Managed Database engines and versions.</returns>
		public async Task<PaginationEnvelope> GetDatabasesEnginesAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/engines?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<PaginationEnvelope>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Database Engine View
		/// Display information for a single Managed Database engine type and version.
		/// 
		/// GetDatabasesEngine databases/engines/{engineId}
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns information for a single Managed Database engine type and version.</returns>
		public async Task<DatabaseEngine> GetDatabasesEngineAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/engines/{engineId}?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DatabaseEngine>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Databases List All
		/// Display all Managed Databases that are accessible by your User, regardless of engine type.
		/// 
		/// For more detailed information on a particular Database instance, make a request to its `instance_uri`.
		/// 
		/// GetDatabasesInstances databases/instances
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated list of all accessible Managed Databases on your Account.</returns>
		public async Task<PaginationEnvelope> GetDatabasesInstancesAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/instances?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<PaginationEnvelope>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MongoDB Databases List
		/// Display all accessible Managed MongoDB Databases.
		/// 
		/// **Note**: New MongoDB Databases cannot currently be created.
		/// 
		/// GetDatabasesMongoDBInstances databases/mongodb/instances
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated list of all accessible Managed MongoDB Databases on your Account.</returns>
		public async Task<PaginationEnvelope> GetDatabasesMongoDBInstancesAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mongodb/instances?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<PaginationEnvelope>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MongoDB Database Delete
		/// Remove a Managed MongoDB Database from your Account.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// The Database must have an `active`, `failed`, or `degraded` status to perform this command.
		/// 
		/// Only unrestricted Users can access this command, and have access regardless of the acting token's OAuth scopes.
		/// 
		/// **Note**: New MongoDB Databases cannot currently be created.
		/// 
		/// DeleteDatabasesMongoDBInstance databases/mongodb/instances/{instanceId}
		/// </summary>
		/// <returns>Managed MongoDB Database successfully deleted.</returns>
		public async Task<string> DeleteDatabasesMongoDBInstanceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mongodb/instances/{instanceId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MongoDB Database View
		/// Display information for a single, accessible Managed MongoDB Database.
		/// 
		/// **Note**: New MongoDB Databases cannot currently be created.
		/// 
		/// GetDatabasesMongoDBInstance databases/mongodb/instances/{instanceId}
		/// </summary>
		/// <returns>Returns information for a single Managed MongoDB Database.</returns>
		public async Task<DatabaseMongoDB> GetDatabasesMongoDBInstanceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mongodb/instances/{instanceId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DatabaseMongoDB>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MongoDB Database Update
		/// Update a Managed MongoDB Database.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// The Database must have an `active` status to perform this command.
		/// 
		/// Updating addresses in the `allow_list` overwrites any existing addresses.
		/// 
		/// * IP addresses and ranges on this list can access the Managed Database. All other sources are blocked.
		/// 
		/// * If `0.0.0.0/0` is a value in this list, then all IP addresses can access the Managed Database.
		/// 
		/// * Entering an empty array (`[]`) blocks all connections (both public and private) to the Managed Database.
		/// 
		/// * **Note**: Updates to the `allow_list` may take a short period of time to complete, making this command inappropriate for rapid successive updates to this property.
		/// 
		/// All Managed Databases include automatic patch updates, which apply security patches and updates to the underlying operating system of the Managed MongoDB Database. The maintenance window for these updates is configured with the Managed Database's `updates` property.
		/// 
		/// * If your database cluster is configured with a single node, you will experience downtime during this maintenance window when any updates occur. It's recommended that you adjust this window to match a time that will be the least disruptive for your application and users. You may also want to consider upgrading to a high availability plan to avoid any downtime due to maintenance.
		/// 
		/// * **The database software is not updated automatically.** To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then migrate your databases from the original Managed Database cluster to the new one.
		/// 
		/// **Note**: New MongoDB Databases cannot currently be created.
		/// 
		/// PutDatabasesMongoDBInstance databases/mongodb/instances/{instanceId}
		/// </summary>
		/// <param name="requestBody">Updated information for the Managed MongoDB Database.</param>
		/// <returns>Managed Database updated successfully.</returns>
		public async Task<DatabaseMongoDB> PutDatabasesMongoDBInstanceAsync(PutDatabasesMongoDBInstancePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mongodb/instances/{instanceId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DatabaseMongoDB>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MongoDB Database Backups List
		/// Display all backups for an accessible Managed MongoDB Database.
		/// 
		/// The Database must not be provisioning to perform this command.
		/// 
		/// Database `auto` type backups are created every 24 hours at 0:00 UTC. Each `auto` backup is retained for 7 days.
		/// 
		/// Database `snapshot` type backups are created by accessing the **Managed MongoDB Database Backup Snapshot Create** ([POST /databases/mongodb/instances/{instanceId}/backups](/docs/api/databases/#managed-mongodb-database-backup-snapshot-create)) command.
		/// 
		/// **Note**: New MongoDB Databases cannot currently be created.
		/// 
		/// GetDatabasesMongoDBInstanceBackups databases/mongodb/instances/{instanceId}/backups
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated list of backups for the Managed MongoDB Database.</returns>
		public async Task<PaginationEnvelope> GetDatabasesMongoDBInstanceBackupsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mongodb/instances/{instanceId}/backups?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<PaginationEnvelope>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MongoDB Database Backup Snapshot Create
		/// Creates a snapshot backup of a Managed MongoDB Database.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// Up to 3 snapshot backups for each Database can be stored at a time. If 3 snapshots have been created for a Database, one must be deleted before another can be made.
		/// 
		/// Backups generated by this command have the type `snapshot`. Snapshot backups may take several minutes to complete, after which they will be accessible to view or restore.
		/// 
		/// The Database must have an `active` status to perform this command. If another backup is in progress, it must complete before a new backup can be initiated.
		/// 
		/// **Note**: New MongoDB Databases cannot currently be created.
		/// 
		/// PostDatabasesMongoDBInstanceBackup databases/mongodb/instances/{instanceId}/backups
		/// </summary>
		/// <param name="requestBody">Information about the snapshot backup to create.</param>
		/// <returns>Database snapshot backup request successful.</returns>
		public async Task<string> PostDatabasesMongoDBInstanceBackupAsync(DatabaseBackupSnapshot requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mongodb/instances/{instanceId}/backups";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MongoDB Database Backup Delete
		/// Delete a single backup for an accessible Managed MongoDB Database.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// The Database must not be provisioning to perform this command.
		/// 
		/// **Note**: New MongoDB Databases cannot currently be created.
		/// 
		/// DeleteDatabaseMongoDBInstanceBackup databases/mongodb/instances/{instanceId}/backups/{backupId}
		/// </summary>
		/// <returns>Request to delete Database backup successful.</returns>
		public async Task<string> DeleteDatabaseMongoDBInstanceBackupAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mongodb/instances/{instanceId}/backups/{backupId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MongoDB Database Backup View
		/// Display information for a single backup for an accessible Managed MongoDB Database.
		/// 
		/// The Database must not be provisioning to perform this command.
		/// 
		/// **Note**: New MongoDB Databases cannot currently be created.
		/// 
		/// GetDatabasesMongoDBInstanceBackup databases/mongodb/instances/{instanceId}/backups/{backupId}
		/// </summary>
		/// <returns>Returns a single backup for the Managed MongoDB Database.</returns>
		public async Task<DatabaseBackup> GetDatabasesMongoDBInstanceBackupAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mongodb/instances/{instanceId}/backups/{backupId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DatabaseBackup>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MongoDB Database Backup Restore
		/// Restore a backup to a Managed MongoDB Database on your Account.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// The Database must have an `active` status to perform this command.
		/// 
		/// **Note**: Restoring from a backup will erase all existing data on the database instance and replace it with backup data.
		/// 
		/// **Note**: Currently, restoring a backup after resetting Managed Database credentials results in a failed cluster. Please contact Customer Support if this occurs.
		/// 
		/// **Note**: New MongoDB Databases cannot currently be created.
		/// 
		/// PostDatabasesMongoDBInstanceBackupRestore databases/mongodb/instances/{instanceId}/backups/{backupId}/restore
		/// </summary>
		/// <returns>Request to restore backup successful.</returns>
		public async Task<string> PostDatabasesMongoDBInstanceBackupRestoreAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mongodb/instances/{instanceId}/backups/{backupId}/restore";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MongoDB Database Credentials View
		/// Display the root username and password for an accessible Managed MongoDB Database.
		/// 
		/// The Database must have an `active` status to perform this command.
		/// 
		/// **Note**: New MongoDB Databases cannot currently be created.
		/// 
		/// GetDatabasesMongoDBInstanceCredentials databases/mongodb/instances/{instanceId}/credentials
		/// </summary>
		/// <returns>Managed Database root username and password.</returns>
		public async Task<DatabaseCredentials> GetDatabasesMongoDBInstanceCredentialsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mongodb/instances/{instanceId}/credentials";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DatabaseCredentials>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MongoDB Database Credentials Reset
		/// Reset the root password for a Managed MongoDB Database.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// A new root password is randomly generated and accessible with the **Managed MongoDB Database Credentials View** ([GET /databases/mongodb/instances/{instanceId}/credentials](/docs/api/databases/#managed-mongodb-database-credentials-view)) command.
		/// 
		/// Only unrestricted Users can access this command, and have access regardless of the acting token's OAuth scopes.
		/// 
		/// **Note**: Note that it may take several seconds for credentials to reset.
		/// 
		/// **Note**: New MongoDB Databases cannot currently be created.
		/// 
		/// PostDatabasesMongoDBInstanceCredentialsReset databases/mongodb/instances/{instanceId}/credentials/reset
		/// </summary>
		/// <returns>Managed Database instance credentials successfully reset.</returns>
		public async Task<string> PostDatabasesMongoDBInstanceCredentialsResetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mongodb/instances/{instanceId}/credentials/reset";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MongoDB Database Patch
		/// Apply security patches and updates to the underlying operating system of the Managed MongoDB Database. This function runs during regular maintenance windows, which are configurable with the **Managed MongoDB Database Update** ([PUT /databases/mongodb/instances/{instanceId}](/docs/api/databases/#managed-mongodb-database-update)) command.
		/// Requires `read_write` access to the Database.
		/// 
		/// The Database must have an `active` status to perform this command.
		/// 
		/// **Note**:
		/// 
		/// * If your database cluster is configured with a single node, you will experience downtime during this maintenance. Consider upgrading to a high availability plan to avoid any downtime due to maintenance.
		/// 
		/// * **The database software is not updated automatically.** To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then migrate your databases from the original Managed Database cluster to the new one.
		/// 
		/// **Note**: New MongoDB Databases cannot currently be created.
		/// 
		/// PostDatabasesMongoDBInstancePatch databases/mongodb/instances/{instanceId}/patch
		/// </summary>
		/// <returns>Managed Database instance patch request successful.</returns>
		public async Task<string> PostDatabasesMongoDBInstancePatchAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mongodb/instances/{instanceId}/patch";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MongoDB Database SSL Certificate View
		/// Display the SSL CA certificate for an accessible Managed MongoDB Database.
		/// 
		/// The Database must have an `active` status to perform this command.
		/// 
		/// **Note**: New MongoDB Databases cannot currently be created.
		/// 
		/// GetDatabasesMongoDBInstanceSSL databases/mongodb/instances/{instanceId}/ssl
		/// </summary>
		/// <returns>Returns the SSL CA certificate of a single Managed MongoDB Database.</returns>
		public async Task<DatabaseSSL> GetDatabasesMongoDBInstanceSSLAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mongodb/instances/{instanceId}/ssl";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DatabaseSSL>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MySQL Databases List
		/// Display all accessible Managed MySQL Databases.
		/// 
		/// GetDatabasesMySQLInstances databases/mysql/instances
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated list of all accessible Managed MySQL Databases on your Account.</returns>
		public async Task<PaginationEnvelope> GetDatabasesMySQLInstancesAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mysql/instances?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<PaginationEnvelope>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MySQL Database Create
		/// Provision a Managed MySQL Database.
		/// 
		/// Restricted Users must have the `add_databases` grant to use this command.
		/// 
		/// New instances can take approximately 15 to 30 minutes to provision.
		/// 
		/// The `allow_list` is used to control access to the Managed Database.
		/// 
		/// * IP addresses and ranges in this list can access the Managed Database. All other sources are blocked.
		/// 
		/// * If `0.0.0.0/0` is a value in this list, then all IP addresses can access the Managed Database.
		/// 
		/// * Entering an empty array (`[]`) blocks all connections (both public and private) to the Managed Database.
		/// 
		/// All Managed Databases include automatic, daily backups. Up to seven backups are automatically stored for each Managed Database, providing restore points for each day of the past week.
		/// 
		/// All Managed Databases include automatic patch updates, which apply security patches and updates to the underlying operating system of the Managed MySQL Database during configurable maintenance windows.
		/// 
		/// * If your database cluster is configured with a single node, you will experience downtime during this maintenance window when any updates occur. It's recommended that you adjust this window to match a time that will be the least disruptive for your application and users. You may also want to consider upgrading to a high availability plan to avoid any downtime due to maintenance.
		/// 
		/// * **The database software is not updated automatically.** To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then [migrate your databases](/docs/products/databases/managed-databases/guides/migrate-mysql/) from the original Managed Database cluster to the new one.
		/// 
		/// * To modify update the maintenance window for a Database, use the **Managed MySQL Database Update** ([PUT /databases/mysql/instances/{instanceId}](/docs/api/databases/#managed-mysql-database-update)) command.
		/// 
		/// PostDatabasesMySQLInstances databases/mysql/instances
		/// </summary>
		/// <param name="requestBody">Information about the Managed MySQL Database you are creating.</param>
		/// <returns>A new Managed MySQL Database is provisioning.</returns>
		public async Task<DatabaseMySQL> PostDatabasesMySQLInstancesAsync(DatabaseMySQLRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mysql/instances";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DatabaseMySQL>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MySQL Database Delete
		/// Remove a Managed MySQL Database from your Account.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// The Database must have an `active`, `failed`, or `degraded` status to perform this command.
		/// 
		/// Only unrestricted Users can access this command, and have access regardless of the acting token's OAuth scopes.
		/// 
		/// DeleteDatabasesMySQLInstance databases/mysql/instances/{instanceId}
		/// </summary>
		/// <returns>Managed MySQL Database successfully deleted.</returns>
		public async Task<string> DeleteDatabasesMySQLInstanceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mysql/instances/{instanceId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MySQL Database View
		/// Display information for a single, accessible Managed MySQL Database.
		/// 
		/// GetDatabasesMySQLInstance databases/mysql/instances/{instanceId}
		/// </summary>
		/// <returns>Returns information for a single Managed MySQL Database.</returns>
		public async Task<DatabaseMySQL> GetDatabasesMySQLInstanceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mysql/instances/{instanceId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DatabaseMySQL>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MySQL Database Update
		/// Update a Managed MySQL Database.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// The Database must have an `active` status to perform this command.
		/// 
		/// Updating addresses in the `allow_list` overwrites any existing addresses.
		/// 
		/// * IP addresses and ranges in this list can access the Managed Database. All other sources are blocked.
		/// 
		/// * If `0.0.0.0/0` is a value in this list, then all IP addresses can access the Managed Database.
		/// 
		/// * Entering an empty array (`[]`) blocks all connections (both public and private) to the Managed Database.
		/// 
		/// * **Note**: Updates to the `allow_list` may take a short period of time to complete, making this command inappropriate for rapid successive updates to this property.
		/// 
		/// All Managed Databases include automatic patch updates, which apply security patches and updates to the underlying operating system of the Managed MySQL Database. The maintenance window for these updates is configured with the Managed Database's `updates` property.
		/// 
		/// * If your database cluster is configured with a single node, you will experience downtime during this maintenance window when any updates occur. It's recommended that you adjust this window to match a time that will be the least disruptive for your application and users. You may also want to consider upgrading to a high availability plan to avoid any downtime due to maintenance.
		/// 
		/// * **The database software is not updated automatically.** To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then [migrate your databases](/docs/products/databases/managed-databases/guides/migrate-mysql/) from the original Managed Database cluster to the new one.
		/// 
		/// PutDatabasesMySQLInstance databases/mysql/instances/{instanceId}
		/// </summary>
		/// <param name="requestBody">Updated information for the Managed MySQL Database.</param>
		/// <returns>Managed Database updated successfully.</returns>
		public async Task<DatabaseMySQL> PutDatabasesMySQLInstanceAsync(PutDatabasesMySQLInstancePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mysql/instances/{instanceId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DatabaseMySQL>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MySQL Database Backups List
		/// Display all backups for an accessible Managed MySQL Database.
		/// 
		/// The Database must not be provisioning to perform this command.
		/// 
		/// Database `auto` type backups are created every 24 hours at 0:00 UTC. Each `auto` backup is retained for 7 days.
		/// 
		/// Database `snapshot` type backups are created by accessing the **Managed MySQL Database Backup Snapshot Create** ([POST /databases/mysql/instances/{instanceId}/backups](/docs/api/databases/#managed-mysql-database-backup-snapshot-create)) command.
		/// 
		/// GetDatabasesMySQLInstanceBackups databases/mysql/instances/{instanceId}/backups
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated list of backups for the Managed MySQL Database.</returns>
		public async Task<PaginationEnvelope> GetDatabasesMySQLInstanceBackupsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mysql/instances/{instanceId}/backups?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<PaginationEnvelope>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MySQL Database Backup Snapshot Create
		/// Creates a snapshot backup of a Managed MySQL Database.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// Up to 3 snapshot backups for each Database can be stored at a time. If 3 snapshots have been created for a Database, one must be deleted before another can be made.
		/// 
		/// Backups generated by this command have the type `snapshot`. Snapshot backups may take several minutes to complete, after which they will be accessible to view or restore.
		/// 
		/// The Database must have an `active` status to perform this command. If another backup is in progress, it must complete before a new backup can be initiated.
		/// 
		/// PostDatabasesMySQLInstanceBackup databases/mysql/instances/{instanceId}/backups
		/// </summary>
		/// <param name="requestBody">Information about the snapshot backup to create.</param>
		/// <returns>Database snapshot backup request successful.</returns>
		public async Task<string> PostDatabasesMySQLInstanceBackupAsync(DatabaseBackupSnapshot requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mysql/instances/{instanceId}/backups";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MySQL Database Backup Delete
		/// Delete a single backup for an accessible Managed MySQL Database.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// The Database must not be provisioning to perform this command.
		/// 
		/// DeleteDatabaseMySQLInstanceBackup databases/mysql/instances/{instanceId}/backups/{backupId}
		/// </summary>
		/// <returns>Request to delete Database backup successful.</returns>
		public async Task<string> DeleteDatabaseMySQLInstanceBackupAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mysql/instances/{instanceId}/backups/{backupId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MySQL Database Backup View
		/// Display information for a single backup for an accessible Managed MySQL Database.
		/// 
		/// The Database must not be provisioning to perform this command.
		/// 
		/// GetDatabasesMySQLInstanceBackup databases/mysql/instances/{instanceId}/backups/{backupId}
		/// </summary>
		/// <returns>Returns a single backup for the Managed MySQL Database.</returns>
		public async Task<DatabaseBackup> GetDatabasesMySQLInstanceBackupAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mysql/instances/{instanceId}/backups/{backupId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DatabaseBackup>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MySQL Database Backup Restore
		/// Restore a backup to a Managed MySQL Database on your Account.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// The Database must have an `active` status to perform this command.
		/// 
		/// **Note**: Restoring from a backup will erase all existing data on the database instance and replace it with backup data.
		/// 
		/// **Note**: Currently, restoring a backup after resetting Managed Database credentials results in a failed cluster. Please contact Customer Support if this occurs.
		/// 
		/// PostDatabasesMySQLInstanceBackupRestore databases/mysql/instances/{instanceId}/backups/{backupId}/restore
		/// </summary>
		/// <returns>Request to restore backup successful.</returns>
		public async Task<string> PostDatabasesMySQLInstanceBackupRestoreAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mysql/instances/{instanceId}/backups/{backupId}/restore";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MySQL Database Credentials View
		/// Display the root username and password for an accessible Managed MySQL Database.
		/// 
		/// The Database must have an `active` status to perform this command.
		/// 
		/// GetDatabasesMySQLInstanceCredentials databases/mysql/instances/{instanceId}/credentials
		/// </summary>
		/// <returns>Managed Database root username and password.</returns>
		public async Task<DatabaseCredentials> GetDatabasesMySQLInstanceCredentialsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mysql/instances/{instanceId}/credentials";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DatabaseCredentials>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MySQL Database Credentials Reset
		/// Reset the root password for a Managed MySQL Database.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// A new root password is randomly generated and accessible with the **Managed MySQL Database Credentials View** ([GET /databases/mysql/instances/{instanceId}/credentials](/docs/api/databases/#managed-mysql-database-credentials-view)) command.
		/// 
		/// Only unrestricted Users can access this command, and have access regardless of the acting token's OAuth scopes.
		/// 
		/// **Note**: Note that it may take several seconds for credentials to reset.
		/// 
		/// PostDatabasesMySQLInstanceCredentialsReset databases/mysql/instances/{instanceId}/credentials/reset
		/// </summary>
		/// <returns>Managed Database instance credentials successfully reset.</returns>
		public async Task<string> PostDatabasesMySQLInstanceCredentialsResetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mysql/instances/{instanceId}/credentials/reset";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MySQL Database Patch
		/// Apply security patches and updates to the underlying operating system of the Managed MySQL Database. This function runs during regular maintenance windows, which are configurable with the **Managed MySQL Database Update** ([PUT /databases/mysql/instances/{instanceId}](/docs/api/databases/#managed-mysql-database-update)) command.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// The Database must have an `active` status to perform this command.
		/// 
		/// **Note**
		/// 
		/// * If your database cluster is configured with a single node, you will experience downtime during this maintenance. Consider upgrading to a high availability plan to avoid any downtime due to maintenance.
		/// 
		/// * **The database software is not updated automatically.** To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then [migrate your databases](/docs/products/databases/managed-databases/guides/migrate-mysql/) from the original Managed Database cluster to the new one.
		/// 
		/// PostDatabasesMySQLInstancePatch databases/mysql/instances/{instanceId}/patch
		/// </summary>
		/// <returns>Managed Database instance patch request successful.</returns>
		public async Task<string> PostDatabasesMySQLInstancePatchAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mysql/instances/{instanceId}/patch";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed MySQL Database SSL Certificate View
		/// Display the SSL CA certificate for an accessible Managed MySQL Database.
		/// 
		/// The Database must have an `active` status to perform this command.
		/// 
		/// GetDatabasesMySQLInstanceSSL databases/mysql/instances/{instanceId}/ssl
		/// </summary>
		/// <returns>Returns the SSL CA certificate of a single Managed MySQL Database.</returns>
		public async Task<DatabaseSSL> GetDatabasesMySQLInstanceSSLAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/mysql/instances/{instanceId}/ssl";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DatabaseSSL>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed PostgreSQL Databases List
		/// Display all accessible Managed PostgreSQL Databases.
		/// 
		/// GetDatabasesPostgreSQLInstances databases/postgresql/instances
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated list of all accessible Managed PostgreSQL Databases on your Account.</returns>
		public async Task<PaginationEnvelope> GetDatabasesPostgreSQLInstancesAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/postgresql/instances?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<PaginationEnvelope>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed PostgreSQL Database Create
		/// Provision a Managed PostgreSQL Database.
		/// 
		/// Restricted Users must have the `add_databases` grant to use this command.
		/// 
		/// New instances can take approximately 15 to 30 minutes to provision.
		/// 
		/// The `allow_list` is used to control access to the Managed Database.
		/// 
		/// * IP addresses and ranges in this list can access the Managed Database. All other sources are blocked.
		/// 
		/// * If `0.0.0.0/0` is a value in this list, then all IP addresses can access the Managed Database.
		/// 
		/// * Entering an empty array (`[]`) blocks all connections (both public and private) to the Managed Database.
		/// 
		/// All Managed Databases include automatic, daily backups. Up to seven backups are automatically stored for each Managed Database, providing restore points for each day of the past week.
		/// 
		/// All Managed Databases include automatic patch updates, which apply security patches and updates to the underlying operating system of the Managed PostgreSQL Database during configurable maintenance windows.
		/// 
		/// * If your database cluster is configured with a single node, you will experience downtime during this maintenance window when any updates occur. It's recommended that you adjust this window to match a time that will be the least disruptive for your application and users. You may also want to consider upgrading to a high availability plan to avoid any downtime due to maintenance.
		/// 
		/// * **The database software is not updated automatically.** To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then migrate your databases from the original Managed Database cluster to the new one.
		/// 
		/// * To modify update the maintenance window for a Database, use the **Managed PostgreSQL Database Update** ([PUT /databases/postgresql/instances/{instanceId}](/docs/api/databases/#managed-postgresql-database-update)) command.
		/// 
		/// PostDatabasesPostgreSQLInstances databases/postgresql/instances
		/// </summary>
		/// <param name="requestBody">Information about the Managed PostgreSQL Database you are creating.</param>
		/// <returns>A new Managed PostgreSQL Database is provisioning.</returns>
		public async Task<DatabasePostgreSQL> PostDatabasesPostgreSQLInstancesAsync(DatabasePostgreSQLRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/postgresql/instances";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DatabasePostgreSQL>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed PostgreSQL Database Delete
		/// Remove a Managed PostgreSQL Database from your Account.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// The Database must have an `active`, `failed`, or `degraded` status to perform this command.
		/// 
		/// Only unrestricted Users can access this command, and have access regardless of the acting token's OAuth scopes.
		/// 
		/// DeleteDatabasesPostgreSQLInstance databases/postgresql/instances/{instanceId}
		/// </summary>
		/// <returns>Managed PostgreSQL Database successfully deleted.</returns>
		public async Task<string> DeleteDatabasesPostgreSQLInstanceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/postgresql/instances/{instanceId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed PostgreSQL Database View
		/// Display information for a single, accessible Managed PostgreSQL Database.
		/// 
		/// GetDatabasesPostgreSQLInstance databases/postgresql/instances/{instanceId}
		/// </summary>
		/// <returns>Returns information for a single Managed PostgreSQL Database.</returns>
		public async Task<DatabasePostgreSQL> GetDatabasesPostgreSQLInstanceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/postgresql/instances/{instanceId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DatabasePostgreSQL>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed PostgreSQL Database Update
		/// Update a Managed PostgreSQL Database.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// The Database must have an `active` status to perform this command.
		/// 
		/// Updating addresses in the `allow_list` overwrites any existing addresses.
		/// 
		/// * IP addresses and ranges in this list can access the Managed Database. All other sources are blocked.
		/// 
		/// * If `0.0.0.0/0` is a value in this list, then all IP addresses can access the Managed Database.
		/// 
		/// * Entering an empty array (`[]`) blocks all connections (both public and private) to the Managed Database.
		/// 
		/// * **Note**: Updates to the `allow_list` may take a short period of time to complete, making this command inappropriate for rapid successive updates to this property.
		/// 
		/// All Managed Databases include automatic patch updates, which apply security patches and updates to the underlying operating system of the Managed PostgreSQL Database. The maintenance window for these updates is configured with the Managed Database's `updates` property.
		/// 
		/// * If your database cluster is configured with a single node, you will experience downtime during this maintenance window when any updates occur. It's recommended that you adjust this window to match a time that will be the least disruptive for your application and users. You may also want to consider upgrading to a high availability plan to avoid any downtime due to maintenance.
		/// 
		/// * **The database software is not updated automatically.** To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then migrate your databases from the original Managed Database cluster to the new one.
		/// 
		/// PutDatabasesPostgreSQLInstance databases/postgresql/instances/{instanceId}
		/// </summary>
		/// <param name="requestBody">Updated information for the Managed PostgreSQL Database.</param>
		/// <returns>Managed Database updated successfully.</returns>
		public async Task<DatabasePostgreSQL> PutDatabasesPostgreSQLInstanceAsync(PutDatabasesPostgreSQLInstancePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/postgresql/instances/{instanceId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DatabasePostgreSQL>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed PostgreSQL Database Backups List
		/// Display all backups for an accessible Managed PostgreSQL Database.
		/// 
		/// The Database must not be provisioning to perform this command.
		/// 
		/// Database `auto` type backups are created every 24 hours at 0:00 UTC. Each `auto` backup is retained for 7 days.
		/// 
		/// Database `snapshot` type backups are created by accessing the **Managed PostgreSQL Database Backup Snapshot Create** ([POST /databases/postgresql/instances/{instanceId}/backups](/docs/api/databases/#managed-postgresql-database-backup-snapshot-create)) command.
		/// 
		/// GetDatabasesPostgreSQLInstanceBackups databases/postgresql/instances/{instanceId}/backups
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated list of backups for the Managed PostgreSQL Database.</returns>
		public async Task<PaginationEnvelope> GetDatabasesPostgreSQLInstanceBackupsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/postgresql/instances/{instanceId}/backups?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<PaginationEnvelope>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed PostgreSQL Database Backup Snapshot Create
		/// Creates a snapshot backup of a Managed PostgreSQL Database.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// Up to 3 snapshot backups for each Database can be stored at a time. If 3 snapshots have been created for a Database, one must be deleted before another can be made.
		/// 
		/// Backups generated by this command have the type `snapshot`. Snapshot backups may take several minutes to complete, after which they will be accessible to view or restore.
		/// 
		/// The Database must have an `active` status to perform this command. If another backup is in progress, it must complete before a new backup can be initiated.
		/// 
		/// PostDatabasesPostgreSQLInstanceBackup databases/postgresql/instances/{instanceId}/backups
		/// </summary>
		/// <param name="requestBody">Information about the snapshot backup to create.</param>
		/// <returns>Database snapshot backup request successful.</returns>
		public async Task<string> PostDatabasesPostgreSQLInstanceBackupAsync(DatabaseBackupSnapshot requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/postgresql/instances/{instanceId}/backups";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed PostgreSQL Database Backup Delete
		/// Delete a single backup for an accessible Managed PostgreSQL Database.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// The Database must not be provisioning to perform this command.
		/// 
		/// DeleteDatabasePostgreSQLInstanceBackup databases/postgresql/instances/{instanceId}/backups/{backupId}
		/// </summary>
		/// <returns>Request to delete Database backup successful.</returns>
		public async Task<string> DeleteDatabasePostgreSQLInstanceBackupAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/postgresql/instances/{instanceId}/backups/{backupId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed PostgreSQL Database Backup View
		/// Display information for a single backup for an accessible Managed PostgreSQL Database.
		/// 
		/// The Database must not be provisioning to perform this command.
		/// 
		/// GetDatabasesPostgreSQLInstanceBackup databases/postgresql/instances/{instanceId}/backups/{backupId}
		/// </summary>
		/// <returns>Returns a single backup for the Managed PostgreSQL Database.</returns>
		public async Task<DatabaseBackup> GetDatabasesPostgreSQLInstanceBackupAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/postgresql/instances/{instanceId}/backups/{backupId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DatabaseBackup>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed PostgreSQL Database Backup Restore
		/// Restore a backup to a Managed PostgreSQL Database on your Account.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// The Database must have an `active` status to perform this command.
		/// 
		/// **Note**: Restoring from a backup will erase all existing data on the database instance and replace it with backup data.
		/// 
		/// **Note**: Currently, restoring a backup after resetting Managed Database credentials results in a failed cluster. Please contact Customer Support if this occurs.
		/// 
		/// PostDatabasesPostgreSQLInstanceBackupRestore databases/postgresql/instances/{instanceId}/backups/{backupId}/restore
		/// </summary>
		/// <returns>Request to restore backup successful.</returns>
		public async Task<string> PostDatabasesPostgreSQLInstanceBackupRestoreAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/postgresql/instances/{instanceId}/backups/{backupId}/restore";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed PostgreSQL Database Credentials View
		/// Display the root username and password for an accessible Managed PostgreSQL Database.
		/// 
		/// The Database must have an `active` status to perform this command.
		/// 
		/// GetDatabasesPostgreSQLInstanceCredentials databases/postgresql/instances/{instanceId}/credentials
		/// </summary>
		/// <returns>Managed Database root username and password.</returns>
		public async Task<DatabaseCredentials> GetDatabasesPostgreSQLInstanceCredentialsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/postgresql/instances/{instanceId}/credentials";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DatabaseCredentials>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed PostgreSQL Database Credentials Reset
		/// Reset the root password for a Managed PostgreSQL Database.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// A new root password is randomly generated and accessible with the **Managed PostgreSQL Database Credentials View** ([GET /databases/postgresql/instances/{instanceId}/credentials](/docs/api/databases/#managed-postgresql-database-credentials-view)) command.
		/// 
		/// Only unrestricted Users can access this command, and have access regardless of the acting token's OAuth scopes.
		/// 
		/// **Note**: Note that it may take several seconds for credentials to reset.
		/// 
		/// PostDatabasesPostgreSQLInstanceCredentialsReset databases/postgresql/instances/{instanceId}/credentials/reset
		/// </summary>
		/// <returns>Managed Database instance credentials successfully reset.</returns>
		public async Task<string> PostDatabasesPostgreSQLInstanceCredentialsResetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/postgresql/instances/{instanceId}/credentials/reset";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed PostgreSQL Database Patch
		/// Apply security patches and updates to the underlying operating system of the Managed PostgreSQL Database. This function runs during regular maintenance windows, which are configurable with the **Managed PostgreSQL Database Update** ([PUT /databases/postgresql/instances/{instanceId}](/docs/api/databases/#managed-postgresql-database-update)) command.
		/// 
		/// Requires `read_write` access to the Database.
		/// 
		/// The Database must have an `active` status to perform this command.
		/// 
		/// **Note**
		/// 
		/// * If your database cluster is configured with a single node, you will experience downtime during this maintenance. Consider upgrading to a high availability plan to avoid any downtime due to maintenance.
		/// 
		/// * **The database software is not updated automatically.** To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then migrate your databases from the original Managed Database cluster to the new one.
		/// 
		/// PostDatabasesPostgreSQLInstancePatch databases/postgresql/instances/{instanceId}/patch
		/// </summary>
		/// <returns>Managed Database instance patch request successful.</returns>
		public async Task<string> PostDatabasesPostgreSQLInstancePatchAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/postgresql/instances/{instanceId}/patch";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed PostgreSQL Database SSL Certificate View
		/// Display the SSL CA certificate for an accessible Managed PostgreSQL Database.
		/// 
		/// The Database must have an `active` status to perform this command.
		/// 
		/// GetDatabasesPostgreSQLInstanceSSL databases/postgresql/instances/{instanceId}/ssl
		/// </summary>
		/// <returns>Returns the SSL CA certificate of a single Managed PostgreSQL Database.</returns>
		public async Task<DatabaseSSL> GetDatabasesPostgreSQLInstanceSSLAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/postgresql/instances/{instanceId}/ssl";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DatabaseSSL>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Database Types List
		/// Display all Managed Database node types. The type and number of nodes determine the resources and price of a Managed Database instance.
		/// 
		/// Each Managed Database can have one node type. In the case of a high availabilty Database, all nodes are provisioned according to the chosen type.
		/// 
		/// GetDatabasesTypes databases/types
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated list of all Managed Database types.</returns>
		public async Task<PaginationEnvelope> GetDatabasesTypesAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/types?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<PaginationEnvelope>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Database Type View
		/// Display the details of a single Managed Database type. The type and number of nodes determine the resources and price of a Managed Database instance.
		/// 
		/// GetDatabasesType databases/types/{typeId}
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a single Managed Database type.</returns>
		public async Task<DatabaseType> GetDatabasesTypeAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "databases/types/{typeId}?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DatabaseType>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Domains List
		/// This is a collection of Domains that you have registered in Linode's DNS Manager.  Linode is not a registrar, and in order for these to work you must own the domains and point your registrar at Linode's nameservers.
		/// 
		/// GetDomains domains
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A paginated list of Domains you have registered.</returns>
		public async Task<GetDomainsReturn> GetDomainsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domains?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetDomainsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Domain Create
		/// Adds a new Domain to Linode's DNS Manager. Linode is not a registrar, and you must own the domain before adding it here. Be sure to point your registrar to Linode's nameservers so that the records hosted here are used.
		/// 
		/// CreateDomain domains
		/// </summary>
		/// <param name="requestBody">Information about the domain you are registering.</param>
		/// <returns>Domain added successfully.
		///</returns>
		public async Task<Domain> CreateDomainAsync(Domain requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domains";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Domain>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Domain Import
		/// Imports a domain zone from a remote nameserver.
		/// Your nameserver must allow zone transfers (AXFR) from the following IPs:
		/// 
		/// - 96.126.114.97
		/// - 96.126.114.98
		/// - 2600:3c00::5e
		/// - 2600:3c00::5f
		/// 
		/// ImportDomain domains/import
		/// </summary>
		/// <param name="requestBody">Information about the Domain to import.</param>
		/// <returns>A single Domain in Linode's DNS Manager.
		///</returns>
		public async Task<Domain> ImportDomainAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domains/import";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Domain>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Domain Delete
		/// Deletes a Domain from Linode's DNS Manager. The Domain will be removed from Linode's nameservers shortly after this operation completes. This also deletes all associated Domain Records.
		/// 
		/// DeleteDomain domains/{domainId}
		/// </summary>
		/// <returns>Domain deleted successfully.</returns>
		public async Task<string> DeleteDomainAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domains/{domainId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Domain View
		/// This is a single Domain that you have registered in Linode's DNS Manager. Linode is not a registrar, and in order for this Domain record to work you must own the domain and point your registrar at Linode's nameservers.
		/// 
		/// GetDomain domains/{domainId}
		/// </summary>
		/// <returns>A single Domain in Linode's DNS Manager.
		///</returns>
		public async Task<Domain> GetDomainAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domains/{domainId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Domain>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Domain Update
		/// Update information about a Domain in Linode's DNS Manager.
		/// 
		/// UpdateDomain domains/{domainId}
		/// </summary>
		/// <param name="requestBody">The Domain information to update.</param>
		/// <returns>Domain update successful.</returns>
		public async Task<Domain> UpdateDomainAsync(Domain requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domains/{domainId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Domain>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Domain Clone
		/// Clones a Domain and all associated DNS records from a Domain that is registered in Linode's DNS manager.
		/// 
		/// CloneDomain domains/{domainId}/clone
		/// </summary>
		/// <param name="requestBody">Information about the Domain to clone.</param>
		/// <returns>A new Domain in Linode's DNS Manager, based on a cloned Domain.
		///</returns>
		public async Task<Domain> CloneDomainAsync(CloneDomainPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domains/{domainId}/clone";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Domain>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Domain Records List
		/// Returns a paginated list of Records configured on a Domain in Linode's
		/// DNS Manager.
		/// 
		/// GetDomainRecords domains/{domainId}/records
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A list of Domain Records.</returns>
		public async Task<GetDomainRecordsReturn> GetDomainRecordsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domains/{domainId}/records?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetDomainRecordsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Domain Record Create
		/// Adds a new Domain Record to the zonefile this Domain represents.
		/// 
		/// Each domain can have up to 12,000 active records.
		/// 
		/// CreateDomainRecord domains/{domainId}/records
		/// </summary>
		/// <param name="requestBody">Information about the new Record to add.
		///</param>
		/// <returns>Domain Record created successfully.</returns>
		public async Task<DomainRecord> CreateDomainRecordAsync(DomainRecord requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domains/{domainId}/records";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DomainRecord>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Domain Record Delete
		/// Deletes a Record on this Domain.
		/// 
		/// DeleteDomainRecord domains/{domainId}/records/{recordId}
		/// </summary>
		/// <returns>Record deleted successfully.</returns>
		public async Task<string> DeleteDomainRecordAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domains/{domainId}/records/{recordId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Domain Record View
		/// View a single Record on this Domain.
		/// 
		/// GetDomainRecord domains/{domainId}/records/{recordId}
		/// </summary>
		/// <returns>A Domain Record object.</returns>
		public async Task<DomainRecord> GetDomainRecordAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domains/{domainId}/records/{recordId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DomainRecord>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Domain Record Update
		/// Updates a single Record on this Domain.
		/// 
		/// UpdateDomainRecord domains/{domainId}/records/{recordId}
		/// </summary>
		/// <param name="requestBody">The values to change.</param>
		/// <returns>Domain Record updated.</returns>
		public async Task<DomainRecord> UpdateDomainRecordAsync(UpdateDomainRecordPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domains/{domainId}/records/{recordId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DomainRecord>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Domain Zone File View
		/// Returns the zone file for the last rendered zone for the specified domain.
		/// 
		/// GetDomainZone domains/{domainId}/zone-file
		/// </summary>
		/// <returns>An array containing the lines of the domain zone file.
		///</returns>
		public async Task<object> GetDomainZoneAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domains/{domainId}/zone-file";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<object>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Images List
		/// Returns a paginated list of Images.
		/// 
		/// * **Public** Images have IDs that begin with "linode/". These distribution images are generally available to
		/// all users.
		/// 
		/// * **Private** Images have IDs that begin with "private/". These Images are Account-specific and only
		/// accessible to Users with appropriate [Grants](/docs/api/account/#users-grants-view).
		/// 
		/// * To view only public Images, call this endpoint with or without authentication. To view private Images as well, call this endpoint with authentication.
		/// 
		/// GetImages images
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A paginated list of Images.</returns>
		public async Task<GetImagesReturn> GetImagesAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetImagesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Image Create
		/// Captures a private gold-master Image from a Linode Disk.
		/// 
		/// CreateImage images
		/// </summary>
		/// <param name="requestBody">Information about the Image to create.</param>
		/// <returns>New private Image created successfully.</returns>
		public async Task<Image> CreateImageAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Image>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Image Upload
		/// Initiates an Image upload.
		/// 
		/// This endpoint creates a new private Image object and returns it along
		/// with the URL to which image data can be uploaded.
		/// 
		/// - Image data must be uploaded within 24 hours of creation or the
		/// upload will be cancelled and the image deleted.
		/// 
		/// - Image uploads should be made as an HTTP PUT request to the URL returned in the `upload_to`
		/// response parameter, with a `Content-type: application/octet-stream` header included in the
		/// request. For example:
		/// 
		/// curl -v \
		/// -H "Content-Type: application/octet-stream" \
		/// --upload-file example.img.gz \
		/// $UPLOAD_URL \
		/// --progress-bar \
		/// --output /dev/null
		/// 
		/// - Uploaded image data should be compressed in gzip (`.gz`) format. The uncompressed disk should be in raw
		/// disk image (`.img`) format. A maximum compressed file size of 5GB is supported for upload at this time.
		/// 
		/// **Note:** To initiate and complete an Image upload in a single step, see our guide on how to [Upload an Image](/docs/products/tools/images/guides/upload-an-image/) using Cloud Manager or the Linode CLI `image-upload` plugin.
		/// 
		/// ImagesPost images/upload
		/// </summary>
		/// <param name="requestBody">The uploaded Image details.</param>
		/// <returns>Image Upload object including the upload URL and Image object.</returns>
		public async Task<ImagesPostReturn> ImagesPostAsync(ImagesPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/upload";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ImagesPostReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Image Delete
		/// Deletes a private Image you have permission to `read_write`.
		/// 
		/// 
		/// **Deleting an Image is a destructive action and cannot be undone.**
		/// 
		/// DeleteImage images/{imageId}
		/// </summary>
		/// <returns>Delete successful</returns>
		public async Task<string> DeleteImageAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/{imageId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Image View
		/// Get information about a single Image.
		/// 
		/// * **Public** Images have IDs that begin with "linode/". These distribution images are generally available to
		/// all users.
		/// 
		/// * **Private** Images have IDs that begin with "private/". These Images are Account-specific and only
		/// accessible to Users with appropriate [Grants](/docs/api/account/#users-grants-view).
		/// 
		/// * To view a public Image, call this endpoint with or without authentication. To view a private Image, call this endpoint with authentication.
		/// 
		/// GetImage images/{imageId}
		/// </summary>
		/// <returns>A single Image object.</returns>
		public async Task<Image> GetImageAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/{imageId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Image>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Image Update
		/// Updates a private Image that you have permission to `read_write`.
		/// 
		/// UpdateImage images/{imageId}
		/// </summary>
		/// <param name="requestBody">The fields to update.
		///</param>
		/// <returns>The updated image.</returns>
		public async Task<Image> UpdateImageAsync(Image requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/{imageId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Image>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linodes List
		/// Returns a paginated list of Linodes you have permission to view.
		/// 
		/// GetLinodeInstances linode/instances
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns an array of all Linodes on your Account.</returns>
		public async Task<GetLinodeInstancesReturn> GetLinodeInstancesAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetLinodeInstancesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linode Create
		/// Creates a Linode Instance on your Account. In order for this
		/// request to complete successfully, your User must have the `add_linodes` grant. Creating a
		/// new Linode will incur a charge on your Account.
		/// 
		/// Linodes can be created using one of the available Types. See
		/// Types List ([GET /linode/types](/docs/api/linode-types/#types-list)) to get more
		/// information about each Type's specs and cost.
		/// 
		/// Linodes can be created in any one of our available Regions, which are accessible from the
		/// Regions List ([GET /regions](/docs/api/regions/#regions-list)) endpoint.
		/// 
		/// In an effort to fight spam, Linode restricts outbound connections on ports 25, 465, and 587
		/// on all Linodes for new accounts created after November 5th, 2019. For more information,
		/// see [Sending Email on Linode](/docs/guides/running-a-mail-server/#sending-email-on-linode).
		/// 
		/// Linodes can be created in a number of ways:
		/// 
		/// * Using a Linode Public Image distribution or a Private Image you created based on another Linode.
		/// * Access the Images List ([GET /images](/docs/api/images/#images-list)) endpoint with authentication to view
		/// all available Images.
		/// * The Linode will be `running` after it completes `provisioning`.
		/// * A default config with two Disks, one being a 512 swap disk, is created.
		/// * `swap_size` can be used to customize the swap disk size.
		/// * Requires a `root_pass` be supplied to use for the root User's Account.
		/// * It is recommended to supply SSH keys for the root User using the `authorized_keys` field.
		/// * You may also supply a list of usernames via the `authorized_users` field.
		/// * These users must have an SSH Key associated with your Profile first. See SSH Key Add ([POST /profile/sshkeys](/docs/api/profile/#ssh-key-add)) for more information.
		/// 
		/// * Using a StackScript.
		/// * See StackScripts List ([GET /linode/stackscripts](/docs/api/stackscripts/#stackscripts-list)) for
		/// a list of available StackScripts.
		/// * The Linode will be `running` after it completes `provisioning`.
		/// * Requires a compatible Image to be supplied.
		/// * See StackScript View ([GET /linode/stackscript/{stackscriptId}](/docs/api/stackscripts/#stackscript-view)) for compatible Images.
		/// * Requires a `root_pass` be supplied to use for the root User's Account.
		/// * It is recommended to supply SSH keys for the root User using the `authorized_keys` field.
		/// * You may also supply a list of usernames via the `authorized_users` field.
		/// * These users must have an SSH Key associated with your Profile first. See SSH Key Add ([POST /profile/sshkeys](/docs/api/profile/#ssh-key-add)) for more information.
		/// 
		/// * Using one of your other Linode's backups.
		/// * You must create a Linode large enough to accommodate the Backup's size.
		/// * The Disks and Config will match that of the Linode that was backed up.
		/// * The `root_pass` will match that of the Linode that was backed up.
		/// 
		/// * Attached to a private VLAN.
		/// * Review the `interfaces` property of the [Request Body Schema](/docs/api/linode-instances/#linode-create__request-body-schema) for details.
		/// * For more information, see our guide on [Getting Started with VLANs](/docs/products/networking/vlans/get-started/).
		/// 
		/// * Create an empty Linode.
		/// * The Linode will remain `offline` and must be manually started.
		/// * See Linode Boot ([POST /linode/instances/{linodeId}/boot](/docs/api/linode-instances/#linode-boot)).
		/// * Disks and Configs must be created manually.
		/// * This is only recommended for advanced use cases.
		/// 
		/// **Important**: You must be an unrestricted User in order to add or modify
		/// tags on Linodes.
		/// 
		/// CreateLinodeInstance linode/instances
		/// </summary>
		/// <param name="requestBody">The requested initial state of a new Linode.</param>
		/// <returns>A new Linode is being created.
		///</returns>
		public async Task<Linode> CreateLinodeInstanceAsync(string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Linode>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linode Delete
		/// Deletes a Linode you have permission to `read_write`.
		/// 
		/// **Deleting a Linode is a destructive action and cannot be undone.**
		/// 
		/// Additionally, deleting a Linode:
		/// 
		/// * Gives up any IP addresses the Linode was assigned.
		/// * Deletes all Disks, Backups, Configs, etc.
		/// * Stops billing for the Linode and its associated services. You will be billed for time used
		/// within the billing period the Linode was active.
		/// 
		/// Linodes that are in the process of [cloning](/docs/api/linode-instances/#linode-clone) or [backup restoration](/docs/api/linode-instances/#backup-restore) cannot be deleted.
		/// 
		/// DeleteLinodeInstance linode/instances/{linodeId}
		/// </summary>
		/// <returns>Delete successful</returns>
		public async Task<string> DeleteLinodeInstanceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linode View
		/// Get a specific Linode by ID.
		/// GetLinodeInstance linode/instances/{linodeId}
		/// </summary>
		/// <returns>Returns a single Linode object.</returns>
		public async Task<Linode> GetLinodeInstanceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Linode>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linode Update
		/// Updates a Linode that you have permission to `read_write`.
		/// 
		/// **Important**: You must be an unrestricted User in order to add or modify tags on Linodes.
		/// 
		/// UpdateLinodeInstance linode/instances/{linodeId}
		/// </summary>
		/// <param name="requestBody">Any field that is not marked as `readOnly` may be updated. Fields that are marked `readOnly` will be ignored. If any updated field fails to pass validation, the Linode will not be updated.
		///</param>
		/// <returns>The updated Linode.</returns>
		public async Task<Linode> UpdateLinodeInstanceAsync(Linode requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Linode>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Backups List
		/// Returns information about this Linode's available backups.
		/// 
		/// GetBackups linode/instances/{linodeId}/backups
		/// </summary>
		/// <returns>A collection of the specified Linode's available backups.</returns>
		public async Task<GetBackupsReturn> GetBackupsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/backups";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetBackupsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Snapshot Create
		/// Creates a snapshot Backup of a Linode.
		/// 
		/// **Important:** If you already have a snapshot of this Linode, this is a destructive
		/// action. The previous snapshot will be deleted.
		/// 
		/// CreateSnapshot linode/instances/{linodeId}/backups
		/// </summary>
		/// <returns>Snapshot request successful.</returns>
		public async Task<Backup> CreateSnapshotAsync(CreateSnapshotPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/backups";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Backup>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Backups Cancel
		/// Cancels the Backup service on the given Linode. Deletes all of this Linode's existing backups forever.
		/// 
		/// CancelBackups linode/instances/{linodeId}/backups/cancel
		/// </summary>
		/// <returns>Backup service was cancelled for the specified Linode.</returns>
		public async Task<string> CancelBackupsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/backups/cancel";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Backups Enable
		/// Enables backups for the specified Linode.
		/// 
		/// EnableBackups linode/instances/{linodeId}/backups/enable
		/// </summary>
		/// <returns>Backup service was enabled.</returns>
		public async Task<string> EnableBackupsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/backups/enable";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Backup View
		/// Returns information about a Backup.
		/// 
		/// GetBackup linode/instances/{linodeId}/backups/{backupId}
		/// </summary>
		/// <returns>A single Backup.</returns>
		public async Task<Backup> GetBackupAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/backups/{backupId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Backup>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Backup Restore
		/// Restores a Linode's Backup to the specified Linode.
		/// 
		/// RestoreBackup linode/instances/{linodeId}/backups/{backupId}/restore
		/// </summary>
		/// <param name="requestBody">Parameters to provide when restoring the Backup.</param>
		/// <returns>Restore from Backup was initiated.</returns>
		public async Task<string> RestoreBackupAsync(RestoreBackupPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/backups/{backupId}/restore";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linode Boot
		/// Boots a Linode you have permission to modify. If no parameters are given, a Config profile
		/// will be chosen for this boot based on the following criteria:
		/// 
		/// * If there is only one Config profile for this Linode, it will be used.
		/// * If there is more than one Config profile, the last booted config will be used.
		/// * If there is more than one Config profile and none were the last to be booted (because the
		/// Linode was never booted or the last booted config was deleted) an error will be returned.
		/// 
		/// BootLinodeInstance linode/instances/{linodeId}/boot
		/// </summary>
		/// <param name="requestBody">Optional configuration to boot into (see above).</param>
		/// <returns>Boot started.</returns>
		public async Task<string> BootLinodeInstanceAsync(BootLinodeInstancePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/boot";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linode Clone
		/// You can clone your Linode's existing Disks or Configuration profiles to
		/// another Linode on your Account. In order for this request to complete
		/// successfully, your User must have the `add_linodes` grant. Cloning to a
		/// new Linode will incur a charge on your Account.
		/// 
		/// If cloning to an existing Linode, any actions currently running or
		/// queued must be completed first before you can clone to it.
		/// 
		/// Up to five clone operations from any given source Linode can be run concurrently.
		/// If more concurrent clones are attempted, an HTTP 400 error will be
		/// returned by this endpoint.
		/// 
		/// Any [tags](/docs/api/tags/#tags-list) existing on the source Linode will be cloned to the target Linode.
		/// 
		/// CloneLinodeInstance linode/instances/{linodeId}/clone
		/// </summary>
		/// <param name="requestBody">The requested state your Linode will be cloned into.</param>
		/// <returns>Clone started.</returns>
		public async Task<Linode> CloneLinodeInstanceAsync(CloneLinodeInstancePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/clone";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Linode>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Configuration Profiles List
		/// Lists Configuration profiles associated with a Linode.
		/// 
		/// GetLinodeConfigs linode/instances/{linodeId}/configs
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns an array of Configuration profiles associated with this Linode.
		///</returns>
		public async Task<GetLinodeConfigsReturn> GetLinodeConfigsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/configs?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetLinodeConfigsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Configuration Profile Create
		/// Adds a new Configuration profile to a Linode.
		/// 
		/// AddLinodeConfig linode/instances/{linodeId}/configs
		/// </summary>
		/// <param name="requestBody">The parameters to set when creating the Configuration profile.
		///This determines which kernel, devices, how much memory, etc. a Linode boots with.
		///</param>
		/// <returns>A Configuration profile was created.
		///</returns>
		public async Task<LinodeConfig> AddLinodeConfigAsync(LinodeConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/configs";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LinodeConfig>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Configuration Profile Delete
		/// Deletes the specified Configuration profile from the specified Linode.
		/// 
		/// DeleteLinodeConfig linode/instances/{linodeId}/configs/{configId}
		/// </summary>
		/// <returns>Configuration profile successfully deleted.
		///</returns>
		public async Task<string> DeleteLinodeConfigAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/configs/{configId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Configuration Profile View
		/// Returns information about a specific Configuration profile.
		/// 
		/// GetLinodeConfig linode/instances/{linodeId}/configs/{configId}
		/// </summary>
		/// <returns>A Configuration profile object.</returns>
		public async Task<LinodeConfig> GetLinodeConfigAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/configs/{configId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LinodeConfig>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Configuration Profile Update
		/// Updates a Configuration profile.
		/// 
		/// UpdateLinodeConfig linode/instances/{linodeId}/configs/{configId}
		/// </summary>
		/// <param name="requestBody">The Configuration profile parameters to modify.</param>
		/// <returns>Configuration profile successfully updated.</returns>
		public async Task<LinodeConfig> UpdateLinodeConfigAsync(LinodeConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/configs/{configId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LinodeConfig>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Disks List
		/// View Disk information for Disks associated with this Linode.
		/// 
		/// GetLinodeDisks linode/instances/{linodeId}/disks
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated list of disks associated with this Linode.</returns>
		public async Task<GetLinodeDisksReturn> GetLinodeDisksAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/disks?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetLinodeDisksReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Disk Create
		/// Adds a new Disk to a Linode.
		/// 
		/// * You can optionally create a Disk from an Image or an Empty Disk if no Image is provided with a request.
		/// 
		/// * When creating an Empty Disk, providing a `label` is required.
		/// 
		/// * If no `label` is provided, an `image` is required instead.
		/// 
		/// * When creating a Disk from an Image, `root_pass` is required.
		/// 
		/// * The default filesystem for new Disks is `ext4`. If creating a Disk from an Image, the filesystem
		/// of the Image is used unless otherwise specified.
		/// 
		/// * When deploying a StackScript on a Disk:
		/// * See StackScripts List ([GET /linode/stackscripts](/docs/api/stackscripts/#stackscripts-list)) for
		/// a list of available StackScripts.
		/// * Requires a compatible Image to be supplied.
		/// * See StackScript View ([GET /linode/stackscript/{stackscriptId}](/docs/api/stackscripts/#stackscript-view)) for compatible Images.
		/// * It is recommended to supply SSH keys for the root User using the `authorized_keys` field.
		/// * You may also supply a list of usernames via the `authorized_users` field.
		/// * These users must have an SSH Key associated with their Profiles first. See SSH Key Add ([POST /profile/sshkeys](/docs/api/profile/#ssh-key-add)) for more information.
		/// 
		/// AddLinodeDisk linode/instances/{linodeId}/disks
		/// </summary>
		/// <param name="requestBody">The parameters to set when creating the Disk.
		///</param>
		/// <returns>Disk created.</returns>
		public async Task<Disk> AddLinodeDiskAsync(DiskRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/disks";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Disk>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Disk Delete
		/// Deletes a Disk you have permission to `read_write`.
		/// 
		/// **Deleting a Disk is a destructive action and cannot be undone.**
		/// 
		/// DeleteDisk linode/instances/{linodeId}/disks/{diskId}
		/// </summary>
		/// <returns>Delete successful</returns>
		public async Task<string> DeleteDiskAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/disks/{diskId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Disk View
		/// View Disk information for a Disk associated with this Linode.
		/// 
		/// GetLinodeDisk linode/instances/{linodeId}/disks/{diskId}
		/// </summary>
		/// <returns>Returns a single Disk object.</returns>
		public async Task<Disk> GetLinodeDiskAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/disks/{diskId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Disk>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Disk Update
		/// Updates a Disk that you have permission to `read_write`.
		/// 
		/// UpdateDisk linode/instances/{linodeId}/disks/{diskId}
		/// </summary>
		/// <param name="requestBody">Updates the parameters of a single Disk.
		///</param>
		/// <returns>The updated Disk.</returns>
		public async Task<Disk> UpdateDiskAsync(Disk requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/disks/{diskId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Disk>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Disk Clone
		/// Copies a disk, byte-for-byte, into a new Disk belonging to the same Linode. The Linode must have enough storage space available to accept a new Disk of the same size as this one or this operation will fail.
		/// 
		/// CloneLinodeDisk linode/instances/{linodeId}/disks/{diskId}/clone
		/// </summary>
		/// <returns>Disk clone initiated.</returns>
		public async Task<Disk> CloneLinodeDiskAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/disks/{diskId}/clone";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Disk>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Disk Root Password Reset
		/// Resets the password of a Disk you have permission to `read_write`.
		/// 
		/// ResetDiskPassword linode/instances/{linodeId}/disks/{diskId}/password
		/// </summary>
		/// <param name="requestBody">The new password.</param>
		/// <returns>Returns a single Disk object.</returns>
		public async Task<string> ResetDiskPasswordAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/disks/{diskId}/password";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Disk Resize
		/// Resizes a Disk you have permission to `read_write`.
		/// 
		/// The Disk must not be in use. If the Disk is in use, the request will
		/// succeed but the resize will ultimately fail. For a request to succeed,
		/// the Linode must be shut down prior to resizing the Disk, or the Disk
		/// must not be assigned to the Linode's active Configuration Profile.
		/// 
		/// If you are resizing the Disk to a smaller size, it cannot be made smaller
		/// than what is required by the total size of the files current on the Disk.
		/// 
		/// ResizeDisk linode/instances/{linodeId}/disks/{diskId}/resize
		/// </summary>
		/// <param name="requestBody">The new size of the Disk.</param>
		/// <returns>Resize started.</returns>
		public async Task<string> ResizeDiskAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/disks/{diskId}/resize";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Firewalls List
		/// View Firewall information for Firewalls associated with this Linode.
		/// 
		/// GetLinodeFirewalls linode/instances/{linodeId}/firewalls
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated list of Firewalls associated with this Linode.</returns>
		public async Task<GetLinodeFirewallsReturn> GetLinodeFirewallsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/firewalls?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetLinodeFirewallsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Networking Information List
		/// Returns networking information for a single Linode.
		/// 
		/// GetLinodeIPs linode/instances/{linodeId}/ips
		/// </summary>
		/// <returns>Requested Linode's networking configuration.</returns>
		public async Task<object> GetLinodeIPsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/ips";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<object>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// IPv4 Address Allocate
		/// Allocates a public or private IPv4 address to a Linode. Public IP Addresses, after the one included with each Linode, incur an additional monthly charge. If you need an additional public IP Address you must request one - please [open a support ticket](/docs/api/support/#support-ticket-open). You may not add more than one private IPv4 address to a single Linode.
		/// 
		/// AddLinodeIP linode/instances/{linodeId}/ips
		/// </summary>
		/// <param name="requestBody">Information about the address you are creating.</param>
		/// <returns>IP address was successfully allocated.</returns>
		public async Task<IPAddress> AddLinodeIPAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/ips";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<IPAddress>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// IPv4 Address Delete
		/// Deletes a public or private IPv4 address associated with this Linode. This will fail if it is the Linode's last remaining public IPv4 address.
		/// 
		/// RemoveLinodeIP linode/instances/{linodeId}/ips/{address}
		/// </summary>
		/// <returns>IP address successfully removed.</returns>
		public async Task<string> RemoveLinodeIPAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/ips/{address}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// IP Address View
		/// View information about the specified IP address associated with the specified Linode.
		/// 
		/// GetLinodeIP linode/instances/{linodeId}/ips/{address}
		/// </summary>
		/// <returns>A single IP address.</returns>
		public async Task<IPAddress> GetLinodeIPAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/ips/{address}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<IPAddress>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// IP Address Update
		/// Updates a the reverse DNS (RDNS) for a particular IP Address associated with this Linode.
		/// 
		/// Setting the RDNS to `null` for a public IPv4 address, resets it to the default "ip.linodeusercontent.com" RDNS value.
		/// 
		/// UpdateLinodeIP linode/instances/{linodeId}/ips/{address}
		/// </summary>
		/// <param name="requestBody">The information to update for the IP address.</param>
		/// <returns>The updated IP address record.</returns>
		public async Task<IPAddress> UpdateLinodeIPAsync(UpdateLinodeIPPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/ips/{address}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<IPAddress>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// DC Migration/Pending Host Migration Initiate
		/// Initiate a pending host migration that has been scheduled by Linode or initiate a cross data center (DC) migration.  A list of pending migrations, if any, can be accessed from [GET /account/notifications](/docs/api/account/#notifications-list). When the migration begins, your Linode will be shutdown if not already off. If the migration initiated the shutdown, it will reboot the Linode when completed.
		/// 
		/// To initiate a cross DC migration, you must pass a `region` parameter to the request body specifying the target data center region. You can view a list of all available regions and their feature capabilities from [GET /regions](/docs/api/regions/#regions-list). If your Linode has a DC migration already queued or you have initiated a previously scheduled migration, you will not be able to initiate a DC migration until it has completed.
		/// 
		/// **Note:** Next Generation Network (NGN) data centers do not support IPv6 `/116` pools or IP Failover. If you have these features enabled on your Linode and attempt to migrate to an NGN data center, the migration will not initiate. If a Linode cannot be migrated because of an incompatibility, you will be prompted to select a different data center or contact support.
		/// 
		/// MigrateLinodeInstance linode/instances/{linodeId}/migrate
		/// </summary>
		/// <returns>Scheduled migration started</returns>
		public async Task<string> MigrateLinodeInstanceAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/migrate";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linode Upgrade
		/// Linodes created with now-deprecated Types are entitled to a free upgrade to the next generation. A mutating Linode will be allocated any new resources the upgraded Type provides, and will be subsequently restarted if it was currently running.
		/// If any actions are currently running or queued, those actions must be completed first before you can initiate a mutate.
		/// 
		/// MutateLinodeInstance linode/instances/{linodeId}/mutate
		/// </summary>
		/// <param name="requestBody">Whether to automatically resize disks or not.</param>
		/// <returns>Mutate started.</returns>
		public async Task<string> MutateLinodeInstanceAsync(MutateLinodeInstancePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/mutate";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linode NodeBalancers View
		/// Returns a list of NodeBalancers that are assigned to this Linode and readable by the requesting User.
		/// 
		/// Read permission to a NodeBalancer can be given to a User by accessing the User's Grants Update
		/// ([PUT /account/users/{username}/grants](/docs/api/account/#users-grants-update)) endpoint.
		/// 
		/// GetLinodeNodeBalancers linode/instances/{linodeId}/nodebalancers
		/// </summary>
		/// <returns>Returns a paginated list of NodeBalancers.</returns>
		public async Task<GetLinodeNodeBalancersReturn> GetLinodeNodeBalancersAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/nodebalancers";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetLinodeNodeBalancersReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linode Root Password Reset
		/// Resets the root password for this Linode.
		/// * Your Linode must be [shut down](/docs/api/linode-instances/#linode-shut-down) for a password reset to complete.
		/// * If your Linode has more than one disk (not counting its swap disk), use the [Reset Disk Root Password](/docs/api/linode-instances/#disk-root-password-reset) endpoint to update a specific disk's root password.
		/// * A `password_reset` event is generated when a root password reset is successful.
		/// 
		/// ResetLinodePassword linode/instances/{linodeId}/password
		/// </summary>
		/// <param name="requestBody">This Linode's new root password.</param>
		/// <returns>Password Reset.</returns>
		public async Task<string> ResetLinodePasswordAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/password";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linode Reboot
		/// Reboots a Linode you have permission to modify. If any actions are currently running or queued, those actions must be completed first before you can initiate a reboot.
		/// 
		/// RebootLinodeInstance linode/instances/{linodeId}/reboot
		/// </summary>
		/// <param name="requestBody">Optional reboot parameters.</param>
		/// <returns>Reboot started.</returns>
		public async Task<string> RebootLinodeInstanceAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/reboot";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linode Rebuild
		/// Rebuilds a Linode you have the `read_write` permission to modify.
		/// A rebuild will first shut down the Linode, delete all disks and configs on the Linode, and then deploy a new `image` to the Linode with the given attributes. Additionally:
		/// 
		/// * Requires an `image` be supplied.
		/// * Requires a `root_pass` be supplied to use for the root User's Account.
		/// * It is recommended to supply SSH keys for the root User using the
		/// `authorized_keys` field.
		/// 
		/// RebuildLinodeInstance linode/instances/{linodeId}/rebuild
		/// </summary>
		/// <param name="requestBody">The requested state your Linode will be rebuilt into.</param>
		/// <returns>Rebuild started.</returns>
		public async Task<Linode> RebuildLinodeInstanceAsync(string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/rebuild";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Linode>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linode Boot into Rescue Mode
		/// Rescue Mode is a safe environment for performing many system recovery and disk management tasks. Rescue Mode is based on the Finnix recovery distribution, a self-contained and bootable Linux distribution. You can also use Rescue Mode for tasks other than disaster recovery, such as formatting disks to use different filesystems, copying data between disks, and downloading files from a disk via SSH and SFTP.
		/// * Note that "sdh" is reserved and unavailable during rescue.
		/// 
		/// RescueLinodeInstance linode/instances/{linodeId}/rescue
		/// </summary>
		/// <param name="requestBody">Optional object of devices to be mounted.</param>
		/// <returns>Rescue started.</returns>
		public async Task<string> RescueLinodeInstanceAsync(RescueLinodeInstancePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/rescue";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linode Resize
		/// Resizes a Linode you have the `read_write` permission to a different Type. If any actions are currently running or queued, those actions must be completed first before you can initiate a resize. Additionally, the following criteria must be met in order to resize a Linode:
		/// 
		/// * The Linode must not have a pending migration.
		/// * Your Account cannot have an outstanding balance.
		/// * The Linode must not have more disk allocation than the new Type allows.
		/// * In that situation, you must first delete or resize the disk to be smaller.
		/// 
		/// ResizeLinodeInstance linode/instances/{linodeId}/resize
		/// </summary>
		/// <param name="requestBody">The Type your current Linode will resize to, and whether to attempt to automatically resize the Linode's disks.
		///</param>
		/// <returns>Resize started.</returns>
		public async Task<string> ResizeLinodeInstanceAsync(ResizeLinodeInstancePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/resize";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linode Shut Down
		/// Shuts down a Linode you have permission to modify. If any actions are currently running or queued, those actions must be completed first before you can initiate a shutdown.
		/// 
		/// ShutdownLinodeInstance linode/instances/{linodeId}/shutdown
		/// </summary>
		/// <returns>Shutdown started.</returns>
		public async Task<string> ShutdownLinodeInstanceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/shutdown";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linode Statistics View
		/// Returns CPU, IO, IPv4, and IPv6 statistics for your Linode for the past 24 hours.
		/// 
		/// GetLinodeStats linode/instances/{linodeId}/stats
		/// </summary>
		/// <returns>The Linode's stats for the past 24 hours.</returns>
		public async Task<LinodeStats> GetLinodeStatsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/stats";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LinodeStats>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Statistics View (year/month)
		/// Returns statistics for a specific month. The year/month values must be either a date in the past, or the current month. If the current month, statistics will be retrieved for the past 30 days.
		/// 
		/// GetLinodeStatsByYearMonth linode/instances/{linodeId}/stats/{year}/{month}
		/// </summary>
		/// <returns>The Linode's statistics for the requested period.</returns>
		public async Task<LinodeStats> GetLinodeStatsByYearMonthAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/stats/{year}/{month}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LinodeStats>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Network Transfer View
		/// Returns a Linode's network transfer pool statistics for the current month.
		/// 
		/// GetLinodeTransfer linode/instances/{linodeId}/transfer
		/// </summary>
		/// <returns>A collection of the specified Linode's network transfer statistics.</returns>
		public async Task<object> GetLinodeTransferAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/transfer";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<object>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Network Transfer View (year/month)
		/// Returns a Linode's network transfer statistics for a specific month. The year/month values must be either a date in the past, or the current month.
		/// 
		/// GetLinodeTransferByYearMonth linode/instances/{linodeId}/transfer/{year}/{month}
		/// </summary>
		/// <returns>A collection of the specified Linode's network transfer statistics for the requested month.
		///</returns>
		public async Task<object> GetLinodeTransferByYearMonthAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/transfer/{year}/{month}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<object>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linode's Volumes List
		/// View Block Storage Volumes attached to this Linode.
		/// 
		/// GetLinodeVolumes linode/instances/{linodeId}/volumes
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns an array of Block Storage Volumes attached to this Linode.
		///</returns>
		public async Task<GetLinodeVolumesReturn> GetLinodeVolumesAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/instances/{linodeId}/volumes?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetLinodeVolumesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Kernels List
		/// Lists available Kernels.
		/// 
		/// GetKernels linode/kernels
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns an array of Kernels.</returns>
		public async Task<GetKernelsReturn> GetKernelsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/kernels?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetKernelsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Kernel View
		/// Returns information about a single Kernel.
		/// 
		/// GetKernel linode/kernels/{kernelId}
		/// </summary>
		/// <returns>A single Kernel object.</returns>
		public async Task<Kernel> GetKernelAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/kernels/{kernelId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Kernel>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// StackScripts List
		/// If the request is not authenticated, only public StackScripts are returned.
		/// 
		/// For more information on StackScripts, please read our [StackScripts documentation](/docs/products/tools/stackscripts/).
		/// 
		/// GetStackScripts linode/stackscripts
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A list of StackScripts available to the User, including private StackScripts owned by the User if the request is authenticated.
		///</returns>
		public async Task<GetStackScriptsReturn> GetStackScriptsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/stackscripts?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetStackScriptsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// StackScript Create
		/// Creates a StackScript in your Account.
		/// 
		/// AddStackScript linode/stackscripts
		/// </summary>
		/// <param name="requestBody">The properties to set for the new StackScript.</param>
		/// <returns>StackScript successfully created.</returns>
		public async Task<StackScript> AddStackScriptAsync(StackScript requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/stackscripts";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<StackScript>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// StackScript Delete
		/// Deletes a private StackScript you have permission to `read_write`. You cannot delete a public StackScript.
		/// 
		/// DeleteStackScript linode/stackscripts/{stackscriptId}
		/// </summary>
		/// <returns>StackScript was deleted.</returns>
		public async Task<string> DeleteStackScriptAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/stackscripts/{stackscriptId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// StackScript View
		/// Returns all of the information about a specified StackScript, including the contents of the script.
		/// 
		/// GetStackScript linode/stackscripts/{stackscriptId}
		/// </summary>
		/// <returns>A single StackScript.</returns>
		public async Task<StackScript> GetStackScriptAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/stackscripts/{stackscriptId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<StackScript>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// StackScript Update
		/// Updates a StackScript.
		/// 
		/// **Once a StackScript is made public, it cannot be made private.**
		/// 
		/// UpdateStackScript linode/stackscripts/{stackscriptId}
		/// </summary>
		/// <param name="requestBody">The fields to update.</param>
		/// <returns>StackScript was successfully modified.</returns>
		public async Task<StackScript> UpdateStackScriptAsync(StackScript requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/stackscripts/{stackscriptId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<StackScript>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Types List
		/// Returns collection of Linode Types, including pricing and specifications for each Type. These are used when [creating](/docs/api/linode-instances/#linode-create) or [resizing](/docs/api/linode-instances/#linode-resize) Linodes.
		/// 
		/// GetLinodeTypes linode/types
		/// </summary>
		/// <returns>A collection of Linode Types.</returns>
		public async Task<GetLinodeTypesReturn> GetLinodeTypesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/types";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetLinodeTypesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Type View
		/// Returns information about a specific Linode Type, including pricing and specifications. This is used when [creating](/docs/api/linode-instances/#linode-create) or [resizing](/docs/api/linode-instances/#linode-resize) Linodes.
		/// 
		/// GetLinodeType linode/types/{typeId}
		/// </summary>
		/// <returns>A single Linode Type.</returns>
		public async Task<LinodeType> GetLinodeTypeAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "linode/types/{typeId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LinodeType>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Kubernetes Clusters List
		/// Lists current Kubernetes clusters available on your account.
		/// 
		/// GetLKEClusters lke/clusters
		/// </summary>
		/// <returns>Returns an array of all Kubernetes clusters on your Account.</returns>
		public async Task<GetLKEClustersReturn> GetLKEClustersAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetLKEClustersReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Kubernetes Cluster Create
		/// Creates a Kubernetes cluster. The Kubernetes cluster will be created
		/// asynchronously. You can use the events system to determine when the
		/// Kubernetes cluster is ready to use. Please note that it often takes 2-5 minutes before the
		/// [Kubernetes API server endpoint](/docs/api/linode-kubernetes-engine-lke/#kubernetes-api-endpoints-list) and
		/// the [Kubeconfig file](/docs/api/linode-kubernetes-engine-lke/#kubeconfig-view) for the new cluster
		/// are ready.
		/// 
		/// CreateLKECluster lke/clusters
		/// </summary>
		/// <param name="requestBody">Configuration for the Kubernetes cluster</param>
		/// <returns>Kubernetes cluster creation has started.</returns>
		public async Task<LKECluster> CreateLKEClusterAsync(CreateLKEClusterPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LKECluster>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Kubernetes Cluster Delete
		/// Deletes a Cluster you have permission to `read_write`.
		/// 
		/// **Deleting a Cluster is a destructive action and cannot be undone.**
		/// 
		/// Deleting a Cluster:
		/// - Deletes all Linodes in all pools within this Kubernetes cluster
		/// - Deletes all supporting Kubernetes services for this Kubernetes
		/// cluster (API server, etcd, etc)
		/// - Deletes all NodeBalancers created by this Kubernetes cluster
		/// - Does not delete any of the volumes created by this Kubernetes
		/// cluster
		/// 
		/// DeleteLKECluster lke/clusters/{clusterId}
		/// </summary>
		/// <returns>Delete successful</returns>
		public async Task<string> DeleteLKEClusterAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters/{clusterId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Kubernetes Cluster View
		/// Get a specific Cluster by ID.
		/// 
		/// GetLKECluster lke/clusters/{clusterId}
		/// </summary>
		/// <returns>Returns a single Kubernetes cluster.</returns>
		public async Task<LKECluster> GetLKEClusterAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters/{clusterId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LKECluster>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Kubernetes Cluster Update
		/// Updates a Kubernetes cluster.
		/// 
		/// PutLKECluster lke/clusters/{clusterId}
		/// </summary>
		/// <param name="requestBody">The fields to update the Kubernetes cluster.</param>
		/// <returns>Returns a single Kubernetes cluster.</returns>
		public async Task<object> PutLKEClusterAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters/{clusterId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<object>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Kubernetes API Endpoints List
		/// List the Kubernetes API server endpoints for this cluster. Please note that it often takes 2-5 minutes before the endpoint is ready after first [creating a new cluster](/docs/api/linode-kubernetes-engine-lke/#kubernetes-cluster-create).
		/// 
		/// GetLKEClusterAPIEndpoints lke/clusters/{clusterId}/api-endpoints
		/// </summary>
		/// <returns>Returns the Kubernetes API server endpoints for this cluster.</returns>
		public async Task<GetLKEClusterAPIEndpointsReturn> GetLKEClusterAPIEndpointsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters/{clusterId}/api-endpoints";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetLKEClusterAPIEndpointsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Kubernetes Cluster Dashboard URL View
		/// Get a [Kubernetes Dashboard](https://github.com/kubernetes/dashboard) access URL for this Cluster, which enables performance of administrative tasks through a web interface.
		/// 
		/// Dashboards are installed for Clusters by default.
		/// 
		/// To access the Cluster Dashboard login prompt, enter the URL in a web browser. Select either **Token** or **Kubeconfig** authentication, then select **Sign in**.
		/// 
		/// For additional guidance on using the Cluster Dashboard, see the [Navigating the Cluster Dashboard](/docs/guides/using-the-kubernetes-dashboard-on-lke/#navigating-the-cluster-dashboard) section of our guide on [Using the Kubernetes Dashboard on LKE](/docs/guides/using-the-kubernetes-dashboard-on-lke/).
		/// 
		/// GetLKEClusterDashboard lke/clusters/{clusterId}/dashboard
		/// </summary>
		/// <returns>Returns a Kubernetes Cluster Dashboard URL.</returns>
		public async Task<GetLKEClusterDashboardReturn> GetLKEClusterDashboardAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters/{clusterId}/dashboard";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetLKEClusterDashboardReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Kubeconfig Delete
		/// Delete and regenerate the Kubeconfig file for a Cluster.
		/// 
		/// DeleteLKEClusterKubeconfig lke/clusters/{clusterId}/kubeconfig
		/// </summary>
		/// <returns>Kubeconfig file deleted and regenerated successfully.</returns>
		public async Task<string> DeleteLKEClusterKubeconfigAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters/{clusterId}/kubeconfig";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Kubeconfig View
		/// Get the Kubeconfig file for a Cluster. Please note that it often takes 2-5 minutes before
		/// the Kubeconfig file is ready after first [creating a new cluster](/docs/api/linode-kubernetes-engine-lke/#kubernetes-cluster-create).
		/// 
		/// GetLKEClusterKubeconfig lke/clusters/{clusterId}/kubeconfig
		/// </summary>
		/// <returns>Returns the Base64-encoded Kubeconfig file for this Kubernetes cluster.</returns>
		public async Task<GetLKEClusterKubeconfigReturn> GetLKEClusterKubeconfigAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters/{clusterId}/kubeconfig";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetLKEClusterKubeconfigReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Node Delete
		/// Deletes a specific Node from a Node Pool.
		/// 
		/// **Deleting a Node is a destructive action and cannot be undone.**
		/// 
		/// Deleting a Node will reduce the size of the Node Pool it belongs to.
		/// 
		/// DeleteLKEClusterNode lke/clusters/{clusterId}/nodes/{nodeId}
		/// </summary>
		/// <returns>Delete successful</returns>
		public async Task<string> DeleteLKEClusterNodeAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters/{clusterId}/nodes/{nodeId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Node View
		/// Returns the values for a specified node object.
		/// 
		/// GetLKEClusterNode lke/clusters/{clusterId}/nodes/{nodeId}
		/// </summary>
		/// <returns>Returns the values of a node object in the form that it appears currently in the node pool array.</returns>
		public async Task<GetLKEClusterNodeReturn> GetLKEClusterNodeAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters/{clusterId}/nodes/{nodeId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetLKEClusterNodeReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Node Recycle
		/// Recycles an individual Node in the designated Kubernetes Cluster. The Node will be deleted
		/// and replaced with a new Linode, which may take a few minutes. Replacement Nodes are
		/// installed with the latest available patch for the Cluster's Kubernetes Version.
		/// 
		/// **Any local storage on deleted Linodes (such as "hostPath" and "emptyDir" volumes, or "local" PersistentVolumes) will be erased.**
		/// 
		/// PostLKEClusterNodeRecycle lke/clusters/{clusterId}/nodes/{nodeId}/recycle
		/// </summary>
		/// <returns>Recycle request succeeded and is in progress.</returns>
		public async Task<string> PostLKEClusterNodeRecycleAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters/{clusterId}/nodes/{nodeId}/recycle";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Node Pools List
		/// Returns all active Node Pools on a Kubernetes cluster.
		/// 
		/// GetLKEClusterPools lke/clusters/{clusterId}/pools
		/// </summary>
		/// <returns>Returns an array of all Pools in this Kubernetes cluster.</returns>
		public async Task<GetLKEClusterPoolsReturn> GetLKEClusterPoolsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters/{clusterId}/pools";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetLKEClusterPoolsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Node Pool Create
		/// Creates a new Node Pool for the designated Kubernetes cluster.
		/// 
		/// PostLKEClusterPools lke/clusters/{clusterId}/pools
		/// </summary>
		/// <param name="requestBody">Configuration for the Node Pool</param>
		/// <returns>Node Pool has been created.</returns>
		public async Task<LKENodePool> PostLKEClusterPoolsAsync(string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters/{clusterId}/pools";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LKENodePool>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Node Pool Delete
		/// Delete a specific Node Pool from a Kubernetes cluster.
		/// 
		/// **Deleting a Node Pool is a destructive action and cannot be undone.**
		/// 
		/// Deleting a Node Pool will delete all Linodes within that Pool.
		/// 
		/// DeleteLKENodePool lke/clusters/{clusterId}/pools/{poolId}
		/// </summary>
		/// <returns>Delete successful</returns>
		public async Task<string> DeleteLKENodePoolAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters/{clusterId}/pools/{poolId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Node Pool View
		/// Get a specific Node Pool by ID.
		/// 
		/// GetLKENodePool lke/clusters/{clusterId}/pools/{poolId}
		/// </summary>
		/// <returns>Returns the requested Node Pool.</returns>
		public async Task<LKENodePool> GetLKENodePoolAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters/{clusterId}/pools/{poolId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LKENodePool>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Node Pool Update
		/// Updates a Node Pool's count and autoscaler configuration.
		/// 
		/// Linodes will be created or deleted to match changes to the Node Pool's count.
		/// 
		/// **Any local storage on deleted Linodes (such as "hostPath" and "emptyDir" volumes, or "local" PersistentVolumes) will be erased.**
		/// 
		/// PutLKENodePool lke/clusters/{clusterId}/pools/{poolId}
		/// </summary>
		/// <param name="requestBody">The fields to update</param>
		/// <returns>Node Pool was successfully modified.</returns>
		public async Task<LKENodePool> PutLKENodePoolAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters/{clusterId}/pools/{poolId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LKENodePool>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Node Pool Recycle
		/// Recycles a Node Pool for the designated Kubernetes Cluster. All Linodes within the Node Pool will be deleted
		/// and replaced with new Linodes on a rolling basis, which may take several minutes. Replacement Nodes are
		/// installed with the latest available patch for the Cluster's Kubernetes Version.
		/// 
		/// **Any local storage on deleted Linodes (such as "hostPath" and "emptyDir" volumes, or "local" PersistentVolumes) will be erased.**
		/// 
		/// PostLKEClusterPoolRecycle lke/clusters/{clusterId}/pools/{poolId}/recycle
		/// </summary>
		/// <returns>Recycle request succeeded and is in progress.</returns>
		public async Task<string> PostLKEClusterPoolRecycleAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters/{clusterId}/pools/{poolId}/recycle";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Cluster Nodes Recycle
		/// Recycles all nodes in all pools of a designated Kubernetes Cluster. All Linodes within the Cluster will be deleted
		/// and replaced with new Linodes on a rolling basis, which may take several minutes. Replacement Nodes are
		/// installed with the latest available [patch version](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/release/versioning.md#kubernetes-release-versioning) for the Cluster's current Kubernetes minor release.
		/// 
		/// **Any local storage on deleted Linodes (such as "hostPath" and "emptyDir" volumes, or "local" PersistentVolumes) will be erased.**
		/// 
		/// PostLKEClusterRecycle lke/clusters/{clusterId}/recycle
		/// </summary>
		/// <returns>Recycle request succeeded and is in progress.</returns>
		public async Task<string> PostLKEClusterRecycleAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters/{clusterId}/recycle";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Kubernetes Cluster Regenerate
		/// Regenerate the Kubeconfig file and/or the service account token for a Cluster.
		/// 
		/// This is a helper command that allows performing both the [Kubeconfig Delete](#kubeconfig-delete) and the [Service Token Delete](#service-token-delete) actions with a single request.
		/// 
		/// When using this command, at least one of `kubeconfig` or `servicetoken` is required.
		/// 
		/// **Note**: When regenerating a service account token, the Cluster's control plane components and Linode CSI drivers are also restarted and configured with the new token. High Availability Clusters should not experience any disruption, while standard Clusters may experience brief control plane downtime while components are restarted.
		/// 
		/// PostLKEClusterRegenerate lke/clusters/{clusterId}/regenerate
		/// </summary>
		/// <param name="requestBody">The Kubernetes Cluster Regenerate request object.</param>
		/// <returns>Regenerate request successful.</returns>
		public async Task<string> PostLKEClusterRegenerateAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters/{clusterId}/regenerate";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Service Token Delete
		/// Delete and regenerate the service account token for a Cluster.
		/// 
		/// **Note**: When regenerating a service account token, the Cluster's control plane components and Linode CSI drivers are also restarted and configured with the new token. High Availability Clusters should not experience any disruption, while standard Clusters may experience brief control plane downtime while components are restarted.
		/// 
		/// PostLKECServiceTokenDelete lke/clusters/{clusterId}/servicetoken
		/// </summary>
		/// <returns>Service token deleted and regenerated successfully.</returns>
		public async Task<string> PostLKECServiceTokenDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/clusters/{clusterId}/servicetoken";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Kubernetes Versions List
		/// List the Kubernetes versions available for deployment to a Kubernetes cluster.
		/// 
		/// GetLKEVersions lke/versions
		/// </summary>
		/// <returns>Returns a list of Kubernetes versions available for deployment to a Kubernetes cluster.
		///</returns>
		public async Task<GetLKEVersionsReturn> GetLKEVersionsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/versions";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetLKEVersionsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Kubernetes Version View
		/// View a Kubernetes version available for deployment to a Kubernetes cluster.
		/// 
		/// GetLKEVersion lke/versions/{version}
		/// </summary>
		/// <returns>Returns a Kubernetes version object that is available for deployment to a Kubernetes cluster.
		///</returns>
		public async Task<LKEVersion> GetLKEVersionAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lke/versions/{version}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LKEVersion>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Longview Clients List
		/// Returns a paginated list of Longview Clients you have access to. Longview Client is used to monitor stats on your Linode with the help of the Longview Client application.
		/// 
		/// GetLongviewClients longview/clients
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A paginated list of Longview Clients.</returns>
		public async Task<GetLongviewClientsReturn> GetLongviewClientsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "longview/clients?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetLongviewClientsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Longview Client Create
		/// Creates a Longview Client.  This Client will not begin monitoring the status of your server until you configure the Longview Client application on your Linode using the returning `install_code` and `api_key`.
		/// 
		/// CreateLongviewClient longview/clients
		/// </summary>
		/// <param name="requestBody">Information about the LongviewClient to create.</param>
		/// <returns>Longview Client created successfully.</returns>
		public async Task<LongviewClient> CreateLongviewClientAsync(LongviewClient requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "longview/clients";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LongviewClient>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Longview Client Delete
		/// Deletes a Longview Client from your Account.
		/// 
		/// **All information stored for this client will be lost.**
		/// 
		/// This _does not_ uninstall the Longview Client application for your Linode - you must do that manually.
		/// 
		/// DeleteLongviewClient longview/clients/{clientId}
		/// </summary>
		/// <returns>Longview Client deleted successfully.</returns>
		public async Task<string> DeleteLongviewClientAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "longview/clients/{clientId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Longview Client View
		/// Returns a single Longview Client you can access.
		/// 
		/// GetLongviewClient longview/clients/{clientId}
		/// </summary>
		/// <returns>The requested Longview Client.</returns>
		public async Task<LongviewClient> GetLongviewClientAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "longview/clients/{clientId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LongviewClient>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Longview Client Update
		/// Updates a Longview Client.  This cannot update how it monitors your server; use the Longview Client application on your Linode for monitoring configuration.
		/// 
		/// UpdateLongviewClient longview/clients/{clientId}
		/// </summary>
		/// <param name="requestBody">The fields to update.</param>
		/// <returns>Longview Client updated successfully.</returns>
		public async Task<LongviewClient> UpdateLongviewClientAsync(LongviewClient requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "longview/clients/{clientId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LongviewClient>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Longview Plan View
		/// Get the details of your current Longview plan. This returns a `LongviewSubscription` object for your current Longview Pro plan, or an empty set `{}` if your current plan is Longview Free.
		/// 
		/// You must have at least one of the following `global` [User Grants](/docs/api/account/#users-grants-view) in order to access this endpoint:
		/// 
		/// - `"account_access": read_write`
		/// - `"account_access": read_only`
		/// - `"longview_subscription": true`
		/// - `"add_longview": true`
		/// 
		/// 
		/// To update your subscription plan, send a request to [Update Longview Plan](/docs/api/longview/#longview-plan-update).
		/// 
		/// GetLongviewPlan longview/plan
		/// </summary>
		/// <returns>The Longview plan details for this account.</returns>
		public async Task<LongviewSubscription> GetLongviewPlanAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "longview/plan";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LongviewSubscription>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Longview Plan Update
		/// Update your Longview plan to that of the given subcription ID. This returns a `LongviewSubscription` object for the updated Longview Pro plan, or an empty set `{}` if the updated plan is Longview Free.
		/// 
		/// You must have `"longview_subscription": true` configured as a `global` [User Grant](/docs/api/account/#users-grants-view) in order to access this endpoint.
		/// 
		/// You can send a request to the [List Longview Subscriptions](/docs/api/longview/#longview-subscriptions-list) endpoint to receive the details, including `id`'s, of each plan.
		/// 
		/// UpdateLongviewPlan longview/plan
		/// </summary>
		/// <param name="requestBody">Update your Longview subscription plan.</param>
		/// <returns>The updated Longview plan details for this account.</returns>
		public async Task<LongviewSubscription> UpdateLongviewPlanAsync(LongviewPlan requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "longview/plan";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LongviewSubscription>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Longview Subscriptions List
		/// Returns a paginated list of available Longview Subscriptions. This is a public endpoint and requires no authentication.
		/// 
		/// GetLongviewSubscriptions longview/subscriptions
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A paginated list of Longview Subscriptions.</returns>
		public async Task<GetLongviewSubscriptionsReturn> GetLongviewSubscriptionsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "longview/subscriptions?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetLongviewSubscriptionsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Longview Subscription View
		/// Get the Longview plan details as a single `LongviewSubscription` object for the provided subscription ID. This is a public endpoint and requires no authentication.
		/// 
		/// GetLongviewSubscription longview/subscriptions/{subscriptionId}
		/// </summary>
		/// <returns>The requested Longview Subscription details.</returns>
		public async Task<LongviewSubscription> GetLongviewSubscriptionAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "longview/subscriptions/{subscriptionId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LongviewSubscription>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Contacts List
		/// Returns a paginated list of Managed Contacts on your Account.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// GetManagedContacts managed/contacts
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A paginated list of ManagedContacts</returns>
		public async Task<GetManagedContactsReturn> GetManagedContactsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/contacts?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetManagedContactsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Contact Create
		/// Creates a Managed Contact.  A Managed Contact is someone Linode
		/// special forces can contact in the course of attempting to resolve an issue
		/// with a Managed Service.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// CreateManagedContact managed/contacts
		/// </summary>
		/// <param name="requestBody">Information about the contact to create.</param>
		/// <returns>Contact created.</returns>
		public async Task<ManagedContact> CreateManagedContactAsync(ManagedContact requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/contacts";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ManagedContact>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Contact Delete
		/// Deletes a Managed Contact.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// DeleteManagedContact managed/contacts/{contactId}
		/// </summary>
		/// <returns>Contact deleted successfully.</returns>
		public async Task<string> DeleteManagedContactAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/contacts/{contactId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Contact View
		/// Returns a single Managed Contact.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// GetManagedContact managed/contacts/{contactId}
		/// </summary>
		/// <returns>The requested Managed Contact.</returns>
		public async Task<ManagedContact> GetManagedContactAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/contacts/{contactId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ManagedContact>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Contact Update
		/// Updates information about a Managed Contact.
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// UpdateManagedContact managed/contacts/{contactId}
		/// </summary>
		/// <param name="requestBody">The fields to update.</param>
		/// <returns>Contact updated successfully.</returns>
		public async Task<ManagedContact> UpdateManagedContactAsync(ManagedContact requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/contacts/{contactId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ManagedContact>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Credentials List
		/// Returns a paginated list of Managed Credentials on your Account.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// GetManagedCredentials managed/credentials
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A paginated list of ManagedCredentials</returns>
		public async Task<GetManagedCredentialsReturn> GetManagedCredentialsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/credentials?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetManagedCredentialsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Credential Create
		/// Creates a Managed Credential. A Managed Credential is stored securely
		/// to allow Linode special forces to access your Managed Services and resolve
		/// issues.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// CreateManagedCredential managed/credentials
		/// </summary>
		/// <param name="requestBody">Information about the Credential to create.</param>
		/// <returns>Credential created.</returns>
		public async Task<ManagedCredential> CreateManagedCredentialAsync(ManagedCredential requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/credentials";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ManagedCredential>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed SSH Key View
		/// Returns the unique SSH public key assigned to your Linode account's
		/// Managed service. If you [add this public key](/docs/guides/linode-managed/#adding-the-public-key) to a Linode on your account,
		/// Linode special forces will be able to log in to the Linode with this key
		/// when attempting to resolve issues.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// ViewManagedSSHKey managed/credentials/sshkey
		/// </summary>
		/// <returns>The requested Managed SSH public key.</returns>
		public async Task<ViewManagedSSHKeyReturn> ViewManagedSSHKeyAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/credentials/sshkey";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ViewManagedSSHKeyReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Credential View
		/// Returns a single Managed Credential.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// GetManagedCredential managed/credentials/{credentialId}
		/// </summary>
		/// <returns>The requested Managed Credential.</returns>
		public async Task<ManagedCredential> GetManagedCredentialAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/credentials/{credentialId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ManagedCredential>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Credential Update
		/// Updates the label of a Managed Credential. This endpoint does not update the username and password for a Managed Credential. To do this, use the Managed Credential Username and Password Update ([POST /managed/credentials/{credentialId}/update](/docs/api/managed/#managed-credential-username-and-password-update)) endpoint instead.
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// UpdateManagedCredential managed/credentials/{credentialId}
		/// </summary>
		/// <param name="requestBody">The fields to update.</param>
		/// <returns>Credential updated successfully.</returns>
		public async Task<ManagedCredential> UpdateManagedCredentialAsync(ManagedCredential requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/credentials/{credentialId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ManagedCredential>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Credential Delete
		/// Deletes a Managed Credential.  Linode special forces will no longer
		/// have access to this Credential when attempting to resolve issues.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// DeleteManagedCredential managed/credentials/{credentialId}/revoke
		/// </summary>
		/// <returns>Credential deleted successfully.</returns>
		public async Task<string> DeleteManagedCredentialAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/credentials/{credentialId}/revoke";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Credential Username and Password Update
		/// Updates the username and password for a Managed Credential.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// UpdateManagedCredentialUsernamePassword managed/credentials/{credentialId}/update
		/// </summary>
		/// <param name="requestBody">The new username and password to assign to the Managed Credential.
		///</param>
		/// <returns>Credential username and password updated.</returns>
		public async Task<string> UpdateManagedCredentialUsernamePasswordAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/credentials/{credentialId}/update";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Issues List
		/// Returns a paginated list of recent and ongoing issues detected on your
		/// Managed Services.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// GetManagedIssues managed/issues
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A paginated list of open or ongoing Managed Issues.
		///</returns>
		public async Task<GetManagedIssuesReturn> GetManagedIssuesAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/issues?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetManagedIssuesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Issue View
		/// Returns a single Issue that is impacting or did impact one of your
		/// Managed Services.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// GetManagedIssue managed/issues/{issueId}
		/// </summary>
		/// <returns>The requested issue.</returns>
		public async Task<ManagedIssue> GetManagedIssueAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/issues/{issueId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ManagedIssue>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Linode Settings List
		/// Returns a paginated list of Managed Settings for your Linodes. There will
		/// be one entry per Linode on your Account.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// GetManagedLinodeSettings managed/linode-settings
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A paginated list of Managed settings for your Linodes.
		///</returns>
		public async Task<GetManagedLinodeSettingsReturn> GetManagedLinodeSettingsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/linode-settings?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetManagedLinodeSettingsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linode's Managed Settings View
		/// Returns a single Linode's Managed settings.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// GetManagedLinodeSetting managed/linode-settings/{linodeId}
		/// </summary>
		/// <returns>The requested Linode's Managed settings.</returns>
		public async Task<ManagedLinodeSettings> GetManagedLinodeSettingAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/linode-settings/{linodeId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ManagedLinodeSettings>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linode's Managed Settings Update
		/// Updates a single Linode's Managed settings.
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// UpdateManagedLinodeSetting managed/linode-settings/{linodeId}
		/// </summary>
		/// <param name="requestBody">The settings to update.</param>
		/// <returns>Settings updated successfully.</returns>
		public async Task<ManagedLinodeSettings> UpdateManagedLinodeSettingAsync(ManagedLinodeSettings requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/linode-settings/{linodeId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ManagedLinodeSettings>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Services List
		/// Returns a paginated list of Managed Services on your Account. These
		/// are the services Linode Managed is monitoring and will report and attempt
		/// to resolve issues with.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// GetManagedServices managed/services
		/// </summary>
		/// <returns>A paginated list of Managed Services</returns>
		public async Task<GetManagedServicesReturn> GetManagedServicesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/services";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetManagedServicesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Service Create
		/// Creates a Managed Service. Linode Managed will begin monitoring this
		/// service and reporting and attempting to resolve any Issues.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// CreateManagedService managed/services
		/// </summary>
		/// <param name="requestBody">Information about the service to monitor.</param>
		/// <returns>Service created.</returns>
		public async Task<ManagedService> CreateManagedServiceAsync(ManagedService requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/services";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ManagedService>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Service Delete
		/// Deletes a Managed Service.  This service will no longer be monitored by
		/// Linode Managed.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// DeleteManagedService managed/services/{serviceId}
		/// </summary>
		/// <returns>Service deleted successfully.</returns>
		public async Task<string> DeleteManagedServiceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/services/{serviceId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Service View
		/// Returns information about a single Managed Service on your Account.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// GetManagedService managed/services/{serviceId}
		/// </summary>
		/// <returns>The requested Managed Service.</returns>
		public async Task<ManagedService> GetManagedServiceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/services/{serviceId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ManagedService>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Service Update
		/// Updates information about a Managed Service.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// UpdateManagedService managed/services/{serviceId}
		/// </summary>
		/// <param name="requestBody">The fields to update.</param>
		/// <returns>Service updated successfully.</returns>
		public async Task<ManagedService> UpdateManagedServiceAsync(ManagedService requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/services/{serviceId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ManagedService>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Service Disable
		/// Temporarily disables monitoring of a Managed Service.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// DisableManagedService managed/services/{serviceId}/disable
		/// </summary>
		/// <returns>Service disabled.</returns>
		public async Task<ManagedService> DisableManagedServiceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/services/{serviceId}/disable";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ManagedService>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Service Enable
		/// Enables monitoring of a Managed Service.
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// EnableManagedService managed/services/{serviceId}/enable
		/// </summary>
		/// <returns>Service enabled.</returns>
		public async Task<ManagedService> EnableManagedServiceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/services/{serviceId}/enable";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ManagedService>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Managed Stats List
		/// Returns a list of Managed Stats on your Account in the form of x and y data points.
		/// You can use these data points to plot your own graph visualizations. These stats
		/// reflect the last 24 hours of combined usage across all managed Linodes on your account
		/// giving you a high-level snapshot of data for the following:
		/// 
		/// 
		/// * cpu
		/// * disk
		/// * swap
		/// * network in
		/// * network out
		/// 
		/// This command can only be accessed by the unrestricted users of an account.
		/// 
		/// GetManagedStats managed/stats
		/// </summary>
		/// <returns>A list of Managed Stats from the last 24 hours.</returns>
		public async Task<GetManagedStatsReturn> GetManagedStatsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "managed/stats";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetManagedStatsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Firewalls List
		/// Returns a paginated list of accessible Firewalls.
		/// 
		/// GetFirewalls networking/firewalls
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns an array of Firewalls.</returns>
		public async Task<GetFirewallsReturn> GetFirewallsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/firewalls?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetFirewallsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Firewall Create
		/// Creates a Firewall to filter network traffic.
		/// 
		/// * Use the `rules` property to create inbound and outbound access rules.
		/// 
		/// * Use the `devices` property to assign the Firewall to a service and apply its Rules to the device. Requires `read_write` [User's Grants](/docs/api/account/#users-grants-view) to the device.
		/// Currently, Firewalls can only be assigned to Linode instances.
		/// 
		/// * A Firewall can be assigned to multiple Linode instances at a time.
		/// 
		/// * A Linode instance can have one active, assigned Firewall at a time.
		/// Additional disabled Firewalls can be assigned to a service, but they cannot be enabled if another active Firewall is already assigned to the same service.
		/// 
		/// * A `firewall_create` Event is generated when this endpoint returns successfully.
		/// 
		/// CreateFirewalls networking/firewalls
		/// </summary>
		/// <param name="requestBody">Creates a Firewall object that can be applied to a Linode service to filter the service's network traffic.</param>
		/// <returns>Returns information about the created Firewall.</returns>
		public async Task<Firewall> CreateFirewallsAsync(Firewall requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/firewalls";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Firewall>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Firewall Delete
		/// Delete a Firewall resource by its ID. This will remove all of the Firewall's Rules
		/// from any Linode services that the Firewall was assigned to.
		/// 
		/// A `firewall_delete` Event is generated when this endpoint returns successfully.
		/// 
		/// DeleteFirewall networking/firewalls/{firewallId}
		/// </summary>
		/// <returns>Delete Successful.</returns>
		public async Task<string> DeleteFirewallAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/firewalls/{firewallId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Firewall View
		/// Get a specific Firewall resource by its ID. The Firewall's Devices will not be
		/// returned in the response. Instead, use the
		/// [List Firewall Devices](/docs/api/networking/#firewall-devices-list)
		/// endpoint to review them.
		/// 
		/// GetFirewall networking/firewalls/{firewallId}
		/// </summary>
		/// <returns>Returns information about this Firewall.</returns>
		public async Task<Firewall> GetFirewallAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/firewalls/{firewallId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Firewall>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Firewall Update
		/// Updates information for a Firewall. Some parts of a Firewall's configuration cannot
		/// be manipulated by this endpoint:
		/// 
		/// - A Firewall's Devices cannot be set with this endpoint. Instead, use the
		/// [Create Firewall Device](/docs/api/networking/#firewall-device-create)
		/// and [Delete Firewall Device](/docs/api/networking/#firewall-device-delete)
		/// endpoints to assign and remove this Firewall from Linode services.
		/// 
		/// - A Firewall's Rules cannot be changed with this endpoint. Instead, use the
		/// [Update Firewall Rules](/docs/api/networking/#firewall-rules-update)
		/// endpoint to update your Rules.
		/// 
		/// - A Firewall's status can be set to `enabled` or `disabled` by this endpoint, but it cannot be
		/// set to `deleted`. Instead, use the
		/// [Delete Firewall](/docs/api/networking/#firewall-delete)
		/// endpoint to delete a Firewall.
		/// 
		/// If a Firewall's status is changed with this endpoint, a corresponding `firewall_enable` or
		/// `firewall_disable` Event will be generated.
		/// 
		/// UpdateFirewall networking/firewalls/{firewallId}
		/// </summary>
		/// <param name="requestBody">The Firewall information to update.</param>
		/// <returns>Firewall updated successfully.</returns>
		public async Task<Firewall> UpdateFirewallAsync(UpdateFirewallPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/firewalls/{firewallId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Firewall>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Firewall Devices List
		/// Returns a paginated list of a Firewall's Devices. A Firewall Device assigns a
		/// Firewall to a Linode service (referred to as the Device's `entity`). Currently,
		/// only Devices with an entity of type `linode` are accepted.
		/// 
		/// GetFirewallDevices networking/firewalls/{firewallId}/devices
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A paginated list of Firewall Devices</returns>
		public async Task<GetFirewallDevicesReturn> GetFirewallDevicesAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/firewalls/{firewallId}/devices?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetFirewallDevicesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Firewall Device Create
		/// Creates a Firewall Device, which assigns a Firewall to a service (referred to
		/// as the Device's `entity`) and applies the Firewall's Rules to the device.
		/// 
		/// * Currently, only Devices with an entity of type `linode` are accepted.
		/// 
		/// * A Firewall can be assigned to multiple Linode instances at a time.
		/// 
		/// * A Linode instance can have one active, assigned Firewall at a time.
		/// Additional disabled Firewalls can be assigned to a service, but they cannot be enabled if another active Firewall is already assigned to the same service.
		/// 
		/// * A `firewall_device_add` Event is generated when the Firewall Device is added successfully.
		/// 
		/// CreateFirewallDevice networking/firewalls/{firewallId}/devices
		/// </summary>
		/// <returns>Returns information about the created Firewall Device.</returns>
		public async Task<FirewallDevices> CreateFirewallDeviceAsync(string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/firewalls/{firewallId}/devices";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<FirewallDevices>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Firewall Device Delete
		/// Removes a Firewall Device, which removes a Firewall from the Linode service it was
		/// assigned to by the Device. This will remove all of the Firewall's Rules from the Linode
		/// service. If any other Firewalls have been assigned to the Linode service, then those Rules
		/// will remain in effect.
		/// 
		/// A `firewall_device_remove` Event is generated when the Firewall Device is removed successfully.
		/// 
		/// DeleteFirewallDevice networking/firewalls/{firewallId}/devices/{deviceId}
		/// </summary>
		/// <returns>Delete Successful.</returns>
		public async Task<string> DeleteFirewallDeviceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/firewalls/{firewallId}/devices/{deviceId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Firewall Device View
		/// Returns information for a Firewall Device, which assigns a Firewall
		/// to a Linode service (referred to as the Device's `entity`). Currently,
		/// only Devices with an entity of type `linode` are accepted.
		/// 
		/// GetFirewallDevice networking/firewalls/{firewallId}/devices/{deviceId}
		/// </summary>
		/// <returns>The requested Firewall Device.</returns>
		public async Task<FirewallDevices> GetFirewallDeviceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/firewalls/{firewallId}/devices/{deviceId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<FirewallDevices>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Firewall Rules List
		/// Returns the inbound and outbound Rules for a Firewall.
		/// 
		/// GetFirewallRules networking/firewalls/{firewallId}/rules
		/// </summary>
		/// <returns>The requested Firewall Rules.</returns>
		public async Task<Firewall> GetFirewallRulesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/firewalls/{firewallId}/rules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Firewall>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Firewall Rules Update
		/// Updates the inbound and outbound Rules for a Firewall.
		/// 
		/// **Note:** This command replaces all of a Firewall's `inbound` and/or `outbound` rulesets with the values specified in your request.
		/// 
		/// UpdateFirewallRules networking/firewalls/{firewallId}/rules
		/// </summary>
		/// <param name="requestBody">The Firewall Rules information to update.</param>
		/// <returns>Firewall Rules updated successfully.</returns>
		public async Task<Firewall> UpdateFirewallRulesAsync(Firewall requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/firewalls/{firewallId}/rules";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Firewall>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// IP Addresses List
		/// Returns a paginated list of IP Addresses on your Account, excluding private addresses.
		/// 
		/// GetIPs networking/ips
		/// </summary>
		/// <returns>A paginated list of IP Addresses.</returns>
		public async Task<GetIPsReturn> GetIPsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/ips";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetIPsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// IP Address Allocate
		/// Allocates a new IPv4 Address on your Account. The Linode must be configured to support additional addresses - please [open a support ticket](/docs/api/support/#support-ticket-open) requesting additional addresses before attempting allocation.
		/// 
		/// AllocateIP networking/ips
		/// </summary>
		/// <param name="requestBody">Information about the address you are creating.</param>
		/// <returns>IP Address allocated successfully.</returns>
		public async Task<IPAddress> AllocateIPAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/ips";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<IPAddress>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// IP Addresses Assign
		/// Assign multiple IPv4 addresses and/or IPv6 ranges to multiple Linodes in one Region. This allows swapping, shuffling, or otherwise reorganizing IPs to your Linodes.
		/// 
		/// The following restrictions apply:
		/// * All Linodes involved must have at least one public IPv4 address after assignment.
		/// * Linodes may have no more than one assigned private IPv4 address.
		/// * Linodes may have no more than one assigned IPv6 range.
		/// 
		/// [Open a Support Ticket](/docs/api/support/#support-ticket-open) to request additional IPv4 addresses or IPv6 ranges beyond standard account limits.
		/// 
		/// **Note**: Removing an IP address that has been set as a Managed Linode's `ssh.ip` causes the Managed Linode's SSH access settings to reset to their default values. To view and configure Managed Linode SSH settings, use the following commands:
		/// * **Linode's Managed Settings View** ([GET /managed/linode-settings/{linodeId}](/docs/api/managed/#linodes-managed-settings-view))
		/// * **Linode's Managed Settings Update** ([PUT /managed/linode-settings/{linodeId}](/docs/api/managed/#linodes-managed-settings-update))
		/// 
		/// AssignIPs networking/ips/assign
		/// </summary>
		/// <param name="requestBody">Information about what IPv4 address or IPv6 range to assign, and to which Linode.
		///</param>
		/// <returns>All assignments completed successfully.</returns>
		public async Task<string> AssignIPsAsync(IPAddressesAssignRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/ips/assign";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// IP Addresses Share
		/// Configure shared IPs.
		/// 
		/// IP sharing allows IP address reassignment (also referred to as IP failover) from one Linode to another if the primary Linode becomes unresponsive. This means that requests to the primary Linode's IP address can be automatically rerouted to secondary Linodes at the configured shared IP addresses.
		/// 
		/// IP failover requires configuration of a failover service (such as [Keepalived](/docs/guides/ip-failover-keepalived)) within the internal system of the primary Linode.
		/// 
		/// ShareIPs networking/ips/share
		/// </summary>
		/// <param name="requestBody">Information about what IPs to share with which Linode.</param>
		/// <returns>IP Address sharing successful.</returns>
		public async Task<string> ShareIPsAsync(IPAddressesShareRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/ips/share";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// IP Address View
		/// Returns information about a single IP Address on your Account.
		/// 
		/// GetIP networking/ips/{address}
		/// </summary>
		/// <returns>The requested IP Address.</returns>
		public async Task<IPAddress> GetIPAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/ips/{address}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<IPAddress>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// IP Address RDNS Update
		/// Sets RDNS on an IP Address. Forward DNS must already be set up for reverse DNS to be applied. If you set the RDNS to `null` for public IPv4 addresses, it will be reset to the default _ip.linodeusercontent.com_ RDNS value.
		/// 
		/// UpdateIP networking/ips/{address}
		/// </summary>
		/// <param name="requestBody">The information to update.</param>
		/// <returns>RDNS set successfully</returns>
		public async Task<IPAddress> UpdateIPAsync(UpdateIPPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/ips/{address}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<IPAddress>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Linodes Assign IPv4s
		/// This command is equivalent to **IP Addresses Assign** ([POST /networking/ips/assign](#ip-addresses-assign)).
		/// 
		/// Assign multiple IPv4 addresses and/or IPv6 ranges to multiple Linodes in one Region. This allows swapping, shuffling, or otherwise reorganizing IPs to your Linodes.
		/// 
		/// The following restrictions apply:
		/// * All Linodes involved must have at least one public IPv4 address after assignment.
		/// * Linodes may have no more than one assigned private IPv4 address.
		/// * Linodes may have no more than one assigned IPv6 range.
		/// 
		/// [Open a Support Ticket](/docs/api/support/#support-ticket-open) to request additional IPv4 addresses or IPv6 ranges beyond standard account limits.
		/// 
		/// **Note**: Removing an IP address that has been set as a Managed Linode's `ssh.ip` causes the Managed Linode's SSH access settings to reset to their default values. To view and configure Managed Linode SSH settings, use the following commands:
		/// * **Linode's Managed Settings View** ([GET /managed/linode-settings/{linodeId}](/docs/api/managed/#linodes-managed-settings-view))
		/// * **Linode's Managed Settings Update** ([PUT /managed/linode-settings/{linodeId}](/docs/api/managed/#linodes-managed-settings-update))
		/// 
		/// AssignIPv4s networking/ipv4/assign
		/// </summary>
		/// <param name="requestBody">Information about what IPv4 address to assign, and to which Linode.
		///</param>
		/// <returns>All assignments completed successfully.</returns>
		public async Task<string> AssignIPv4sAsync(IPAddressesAssignRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/ipv4/assign";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// IPv4 Sharing Configure
		/// This command is equivalent to **IP Addresses Share** ([POST /networking/ips/share](#ip-addresses-share)).
		/// 
		/// Configure shared IPs.
		/// 
		/// IP sharing allows IP address reassignment (also referred to as IP failover) from one Linode to another if the primary Linode becomes unresponsive. This means that requests to the primary Linode's IP address can be automatically rerouted to secondary Linodes at the configured shared IP addresses.
		/// 
		/// IP failover requires configuration of a failover service (such as [Keepalived](/docs/guides/ip-failover-keepalived)) within the internal system of the primary Linode.
		/// 
		/// ShareIPv4s networking/ipv4/share
		/// </summary>
		/// <param name="requestBody">Information about what IPs to share with which Linode.</param>
		/// <returns>Sharing configured successfully.</returns>
		public async Task<string> ShareIPv4sAsync(IPAddressesShareRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/ipv4/share";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// IPv6 Pools List
		/// Displays the IPv6 pools on your Account. A pool of IPv6 addresses are routed to all of your Linodes in a single [Region](/docs/api/regions/#regions-list). Any Linode on your Account may bring up any address in this pool at any time, with no external configuration required.
		/// 
		/// GetIPv6Pools networking/ipv6/pools
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>The IPv6 pools on your Account.</returns>
		public async Task<GetIPv6PoolsReturn> GetIPv6PoolsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/ipv6/pools?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetIPv6PoolsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// IPv6 Ranges List
		/// Displays the IPv6 ranges on your Account.
		/// 
		/// 
		/// * An IPv6 range is a `/64` or `/54` block of IPv6 addresses routed to a single Linode in a given [Region](/docs/api/regions/#regions-list).
		/// 
		/// * Your Linode is responsible for routing individual addresses in the range, or handling traffic for all the addresses in the range.
		/// 
		/// * Access the IPv6 Range Create ([POST /networking/ipv6/ranges](/docs/api/networking/#ipv6-range-create)) endpoint to add a `/64` or `/56` block of IPv6 addresses to your account.
		/// 
		/// GetIPv6Ranges networking/ipv6/ranges
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>The IPv6 ranges on your Account.</returns>
		public async Task<GetIPv6RangesReturn> GetIPv6RangesAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/ipv6/ranges?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetIPv6RangesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// IPv6 Range Create
		/// Creates an IPv6 Range and assigns it based on the provided Linode or route target IPv6 SLAAC address. See the `ipv6` property when accessing the Linode View ([GET /linode/instances/{linodeId}](/docs/api/linode-instances/#linode-view)) endpoint to view a Linode's IPv6 SLAAC address.
		/// * Either `linode_id` or `route_target` is required in a request.
		/// * `linode_id` and `route_target` are mutually exclusive. Submitting values for both properties in a request results in an error.
		/// * Upon a successful request, an IPv6 range is created in the [Region](/docs/api/regions/#regions-list) that corresponds to the provided `linode_id` or `route_target`.
		/// * Your Linode is responsible for routing individual addresses in the range, or handling traffic for all the addresses in the range.
		/// * Access the IP Addresses Assign ([POST /networking/ips/assign](/docs/api/networking/#ip-addresses-assign)) endpoint to re-assign IPv6 Ranges to your Linodes.
		/// 
		/// **Note**: The following restrictions apply:
		/// * A Linode can only have one IPv6 range targeting its SLAAC address.
		/// * An account can only have one IPv6 range in each [Region](/docs/api/regions/#regions-list).
		/// * [Open a Support Ticket](/docs/api/support/#support-ticket-open) to request expansion of these restrictions.
		/// 
		/// PostIPv6Range networking/ipv6/ranges
		/// </summary>
		/// <param name="requestBody">Information about the IPv6 range to create.
		///</param>
		/// <returns>IPv6 range created successfully.</returns>
		public async Task<PostIPv6RangeReturn> PostIPv6RangeAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/ipv6/ranges";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<PostIPv6RangeReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// IPv6 Range Delete
		/// Removes this IPv6 range from your account and disconnects the range from any assigned Linodes.
		/// 
		/// **Note:** Shared IPv6 ranges cannot be deleted at this time. Please contact Customer Support for assistance.
		/// 
		/// DeleteIPv6Range networking/ipv6/ranges/{range}
		/// </summary>
		/// <returns>IPv6 Range deleted.</returns>
		public async Task<string> DeleteIPv6RangeAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/ipv6/ranges/{range}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// IPv6 Range View
		/// View IPv6 range information.
		/// 
		/// GetIPv6Range networking/ipv6/ranges/{range}
		/// </summary>
		/// <returns>Returns IPv6 range information.</returns>
		public async Task<IPv6RangeBGP> GetIPv6RangeAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/ipv6/ranges/{range}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<IPv6RangeBGP>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// VLANs List
		/// Returns a list of all Virtual Local Area Networks (VLANs) on your Account. VLANs provide
		/// a mechanism for secure communication between two or more Linodes that are assigned to the
		/// same VLAN and are both within the same Layer 2 broadcast domain.
		/// 
		/// VLANs are created and attached to Linodes by using the `interfaces` property for the following endpoints:
		/// 
		/// - Linode Create ([POST /linode/instances](/docs/api/linode-instances/#linode-create))
		/// - Configuration Profile Create ([POST /linode/instances/{linodeId}/configs](/docs/api/linode-instances/#configuration-profile-create))
		/// - Configuration Profile Update ([PUT /linode/instances/{linodeId}/configs/{configId}](/docs/api/linode-instances/#configuration-profile-update))
		/// 
		/// There are several ways to detach a VLAN from a Linode:
		/// 
		/// - [Update](/docs/api/linode-instances/#configuration-profile-update) the active Configuration Profile to remove the VLAN interface, then [reboot](/docs/api/linode-instances/#linode-reboot) the Linode.
		/// - [Create](/docs/api/linode-instances/#configuration-profile-create) a new Configuration Profile without the VLAN interface, then [reboot](/docs/api/linode-instances/#linode-reboot) the Linode into the new Configuration Profile.
		/// - [Delete](/docs/api/linode-instances/#linode-delete) the Linode.
		/// 
		/// **Note:** Only Next Generation Network (NGN) data centers support VLANs. Use the Regions ([/regions](/docs/api/regions/)) endpoint to view the capabilities of data center regions.
		/// If a VLAN is attached to your Linode and you attempt to migrate or clone it to a non-NGN data center,
		/// the migration or cloning will not initiate. If a Linode cannot be migrated because of an incompatibility,
		/// you will be prompted to select a different data center or contact support.
		/// 
		/// **Note:** See the [VLANs Overview](/docs/products/networking/vlans/#technical-specifications) to view additional specifications and limitations.
		/// 
		/// GetVLANs networking/vlans
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>The VLANs available on this Account.</returns>
		public async Task<GetVLANsReturn> GetVLANsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networking/vlans?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetVLANsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// NodeBalancers List
		/// Returns a paginated list of NodeBalancers you have access to.
		/// 
		/// GetNodeBalancers nodebalancers
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A paginated list of NodeBalancers.</returns>
		public async Task<GetNodeBalancersReturn> GetNodeBalancersAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nodebalancers?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNodeBalancersReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// NodeBalancer Create
		/// Creates a NodeBalancer in the requested Region.
		/// 
		/// NodeBalancers require a port Config with at least one backend Node to start serving requests.
		/// 
		/// When using the Linode CLI to create a NodeBalancer, first create a NodeBalancer without any Configs. Then, create Configs and Nodes for that NodeBalancer with the respective [Config Create](/docs/api/nodebalancers/#config-create) and [Node Create](/docs/api/nodebalancers/#node-create) commands.
		/// 
		/// CreateNodeBalancer nodebalancers
		/// </summary>
		/// <param name="requestBody">Information about the NodeBalancer to create.</param>
		/// <returns>NodeBalancer created successfully.</returns>
		public async Task<NodeBalancer> CreateNodeBalancerAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nodebalancers";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<NodeBalancer>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// NodeBalancer Delete
		/// Deletes a NodeBalancer.
		/// 
		/// **This is a destructive action and cannot be undone.**
		/// 
		/// Deleting a NodeBalancer will also delete all associated Configs and Nodes, although the backend servers represented by the Nodes will not be changed or removed. Deleting a NodeBalancer will cause you to lose access to the IP Addresses assigned to this NodeBalancer.
		/// 
		/// DeleteNodeBalancer nodebalancers/{nodeBalancerId}
		/// </summary>
		/// <returns>NodeBalancer deleted successfully.</returns>
		public async Task<string> DeleteNodeBalancerAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nodebalancers/{nodeBalancerId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// NodeBalancer View
		/// Returns a single NodeBalancer you can access.
		/// 
		/// GetNodeBalancer nodebalancers/{nodeBalancerId}
		/// </summary>
		/// <returns>The requested NodeBalancer object.</returns>
		public async Task<NodeBalancer> GetNodeBalancerAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nodebalancers/{nodeBalancerId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<NodeBalancer>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// NodeBalancer Update
		/// Updates information about a NodeBalancer you can access.
		/// 
		/// UpdateNodeBalancer nodebalancers/{nodeBalancerId}
		/// </summary>
		/// <param name="requestBody">The information to update.</param>
		/// <returns>NodeBalancer updated successfully.</returns>
		public async Task<NodeBalancer> UpdateNodeBalancerAsync(NodeBalancer requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nodebalancers/{nodeBalancerId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<NodeBalancer>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Configs List
		/// Returns a paginated list of NodeBalancer Configs associated with this NodeBalancer. NodeBalancer Configs represent individual ports that this NodeBalancer will accept traffic on, one Config per port.
		/// 
		/// For example, if you wanted to accept standard HTTP traffic, you would need a Config listening on port 80.
		/// 
		/// GetNodeBalancerConfigs nodebalancers/{nodeBalancerId}/configs
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A paginted list of NodeBalancer Configs</returns>
		public async Task<GetNodeBalancerConfigsReturn> GetNodeBalancerConfigsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nodebalancers/{nodeBalancerId}/configs?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNodeBalancerConfigsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Config Create
		/// Creates a NodeBalancer Config, which allows the NodeBalancer to accept traffic on a new port. You will need to add NodeBalancer Nodes to the new Config before it can actually serve requests.
		/// 
		/// CreateNodeBalancerConfig nodebalancers/{nodeBalancerId}/configs
		/// </summary>
		/// <param name="requestBody">Information about the port to configure.</param>
		/// <returns>Config created successfully.</returns>
		public async Task<NodeBalancerConfig> CreateNodeBalancerConfigAsync(NodeBalancerConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nodebalancers/{nodeBalancerId}/configs";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<NodeBalancerConfig>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Config Delete
		/// Deletes the Config for a port of this NodeBalancer.
		/// 
		/// **This cannot be undone.**
		/// 
		/// Once completed, this NodeBalancer will no longer respond to requests on the given port. This also deletes all associated NodeBalancerNodes, but the Linodes they were routing traffic to will be unchanged and will not be removed.
		/// 
		/// DeleteNodeBalancerConfig nodebalancers/{nodeBalancerId}/configs/{configId}
		/// </summary>
		/// <returns>NodeBalancer Config deleted successfully.</returns>
		public async Task<string> DeleteNodeBalancerConfigAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nodebalancers/{nodeBalancerId}/configs/{configId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Config View
		/// Returns configuration information for a single port of this NodeBalancer.
		/// 
		/// GetNodeBalancerConfig nodebalancers/{nodeBalancerId}/configs/{configId}
		/// </summary>
		/// <returns>The requested NodeBalancer config.</returns>
		public async Task<NodeBalancerConfig> GetNodeBalancerConfigAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nodebalancers/{nodeBalancerId}/configs/{configId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<NodeBalancerConfig>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Config Update
		/// Updates the configuration for a single port on a NodeBalancer.
		/// 
		/// UpdateNodeBalancerConfig nodebalancers/{nodeBalancerId}/configs/{configId}
		/// </summary>
		/// <param name="requestBody">The fields to update.</param>
		/// <returns>Config updated successfully.</returns>
		public async Task<NodeBalancerConfig> UpdateNodeBalancerConfigAsync(NodeBalancerConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nodebalancers/{nodeBalancerId}/configs/{configId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<NodeBalancerConfig>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Nodes List
		/// Returns a paginated list of NodeBalancer nodes associated with this Config. These are the backends that will be sent traffic for this port.
		/// 
		/// GetNodeBalancerConfigNodes nodebalancers/{nodeBalancerId}/configs/{configId}/nodes
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A paginated list of NodeBalancer nodes.</returns>
		public async Task<GetNodeBalancerConfigNodesReturn> GetNodeBalancerConfigNodesAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nodebalancers/{nodeBalancerId}/configs/{configId}/nodes?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetNodeBalancerConfigNodesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Node Create
		/// Creates a NodeBalancer Node, a backend that can accept traffic for this NodeBalancer Config. Nodes are routed requests on the configured port based on their status.
		/// 
		/// CreateNodeBalancerNode nodebalancers/{nodeBalancerId}/configs/{configId}/nodes
		/// </summary>
		/// <param name="requestBody">Information about the Node to create.</param>
		/// <returns>Node created successfully.</returns>
		public async Task<NodeBalancerNode> CreateNodeBalancerNodeAsync(NodeBalancerNode requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nodebalancers/{nodeBalancerId}/configs/{configId}/nodes";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<NodeBalancerNode>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Node Delete
		/// Deletes a Node from this Config. This backend will no longer receive traffic for the configured port of this NodeBalancer.
		/// 
		/// This does not change or remove the Linode whose address was used in the creation of this Node.
		/// 
		/// DeleteNodeBalancerConfigNode nodebalancers/{nodeBalancerId}/configs/{configId}/nodes/{nodeId}
		/// </summary>
		/// <returns>Node deleted successfully.</returns>
		public async Task<string> DeleteNodeBalancerConfigNodeAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nodebalancers/{nodeBalancerId}/configs/{configId}/nodes/{nodeId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Node View
		/// Returns information about a single Node, a backend for this NodeBalancer's configured port.
		/// 
		/// GetNodeBalancerNode nodebalancers/{nodeBalancerId}/configs/{configId}/nodes/{nodeId}
		/// </summary>
		/// <returns>A paginated list of NodeBalancer nodes.</returns>
		public async Task<NodeBalancerNode> GetNodeBalancerNodeAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nodebalancers/{nodeBalancerId}/configs/{configId}/nodes/{nodeId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<NodeBalancerNode>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Node Update
		/// Updates information about a Node, a backend for this NodeBalancer's configured port.
		/// 
		/// UpdateNodeBalancerNode nodebalancers/{nodeBalancerId}/configs/{configId}/nodes/{nodeId}
		/// </summary>
		/// <param name="requestBody">The fields to update.</param>
		/// <returns>Node updated successfully.</returns>
		public async Task<NodeBalancerNode> UpdateNodeBalancerNodeAsync(NodeBalancerNode requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nodebalancers/{nodeBalancerId}/configs/{configId}/nodes/{nodeId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<NodeBalancerNode>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Config Rebuild
		/// Rebuilds a NodeBalancer Config and its Nodes that you have permission to modify.
		/// 
		/// Use this command to update a NodeBalancer's Config and Nodes with a single request.
		/// 
		/// RebuildNodeBalancerConfig nodebalancers/{nodeBalancerId}/configs/{configId}/rebuild
		/// </summary>
		/// <param name="requestBody">Information about the NodeBalancer Config to rebuild.
		///</param>
		/// <returns>NodeBalancer created successfully.</returns>
		public async Task<NodeBalancerConfig> RebuildNodeBalancerConfigAsync(NodeBalancerConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nodebalancers/{nodeBalancerId}/configs/{configId}/rebuild";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<NodeBalancerConfig>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// NodeBalancer Statistics View
		/// Returns detailed statistics about the requested NodeBalancer.
		/// 
		/// NodeBalancersGet nodebalancers/{nodeBalancerId}/stats
		/// </summary>
		/// <returns>The requested stats.</returns>
		public async Task<NodeBalancerStats> NodeBalancersGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nodebalancers/{nodeBalancerId}/stats";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<NodeBalancerStats>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage Buckets List
		/// Returns a paginated list of all Object Storage Buckets that you own.
		/// 
		/// 
		/// This endpoint is available for convenience. It is recommended that instead you
		/// use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/serviceops/#list-buckets) directly.
		/// 
		/// GetObjectStorageBuckets object-storage/buckets
		/// </summary>
		/// <returns>A paginated list of buckets you own.</returns>
		public async Task<GetObjectStorageBucketsReturn> GetObjectStorageBucketsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/buckets";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetObjectStorageBucketsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage Bucket Create
		/// Creates an Object Storage Bucket in the specified cluster.
		/// 
		/// Accounts with negative balances cannot access this command.
		/// 
		/// If the bucket already exists and is owned by you, this endpoint returns a `200` response with that bucket as if it had just been created.
		/// 
		/// This endpoint is available for convenience. It is recommended that instead you use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/bucketops/#put-bucket) directly.
		/// 
		/// CreateObjectStorageBucket object-storage/buckets
		/// </summary>
		/// <param name="requestBody">Information about the bucket you want to create.
		///</param>
		/// <returns>The bucket created successfully.</returns>
		public async Task<ObjectStorageBucket> CreateObjectStorageBucketAsync(CreateObjectStorageBucketPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/buckets";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ObjectStorageBucket>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage Buckets in Cluster List
		/// Returns a list of Buckets in this cluster belonging to this Account.
		/// 
		/// 
		/// This endpoint is available for convenience. It is recommended that instead you
		/// use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/bucketops/#get-bucket) directly.
		/// 
		/// GetObjectStorageBucketinCluster object-storage/buckets/{clusterId}
		/// </summary>
		/// <returns>A paginated list of buckets you own in this cluster.</returns>
		public async Task<GetObjectStorageBucketinClusterReturn> GetObjectStorageBucketinClusterAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/buckets/{clusterId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetObjectStorageBucketinClusterReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage Bucket Remove
		/// Removes a single bucket.
		/// 
		/// Bucket objects must be removed prior to removing the bucket. While buckets containing objects _may_ be
		/// deleted using the [s3cmd command-line tool](/docs/products/storage/object-storage/guides/s3cmd/#delete-a-bucket), such operations
		/// can fail if the bucket contains too many objects. The recommended
		/// way to empty large buckets is to use the [S3 API to configure lifecycle policies](https://docs.ceph.com/en/latest/radosgw/bucketpolicy/#) that
		/// remove all objects, then delete the bucket.
		/// 
		/// This endpoint is available for convenience. It is recommended that instead you
		/// use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/bucketops/#delete-bucket) directly.
		/// 
		/// DeleteObjectStorageBucket object-storage/buckets/{clusterId}/{bucket}
		/// </summary>
		/// <returns>Bucket deleted successfully.</returns>
		public async Task<string> DeleteObjectStorageBucketAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/buckets/{clusterId}/{bucket}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage Bucket View
		/// Returns a single Object Storage Bucket.
		/// 
		/// 
		/// This endpoint is available for convenience. It is recommended that instead you
		/// use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/bucketops/#get-bucket) directly.
		/// 
		/// GetObjectStorageBucket object-storage/buckets/{clusterId}/{bucket}
		/// </summary>
		/// <returns>The requested bucket.</returns>
		public async Task<ObjectStorageBucket> GetObjectStorageBucketAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/buckets/{clusterId}/{bucket}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ObjectStorageBucket>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage Bucket Access Modify
		/// Allows changing basic Cross-origin Resource Sharing (CORS) and Access Control Level (ACL) settings.
		/// Only allows enabling/disabling CORS for all origins, and/or setting canned ACLs.
		/// 
		/// 
		/// For more fine-grained control of both systems, please use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/bucketops/#put-bucket-acl) directly.
		/// 
		/// ModifyObjectStorageBucketAccess object-storage/buckets/{clusterId}/{bucket}/access
		/// </summary>
		/// <param name="requestBody">The changes to make to the bucket's access controls.</param>
		/// <returns>Access controls updated.</returns>
		public async Task<string> ModifyObjectStorageBucketAccessAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/buckets/{clusterId}/{bucket}/access";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage Bucket Access Update
		/// Allows changing basic Cross-origin Resource Sharing (CORS) and Access Control Level (ACL) settings.
		/// Only allows enabling/disabling CORS for all origins, and/or setting canned ACLs.
		/// 
		/// 
		/// For more fine-grained control of both systems, please use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/bucketops/#put-bucket-acl) directly.
		/// 
		/// UpdateObjectStorageBucketAccess object-storage/buckets/{clusterId}/{bucket}/access
		/// </summary>
		/// <param name="requestBody">The changes to make to the bucket's access controls.</param>
		/// <returns>Access controls updated.</returns>
		public async Task<string> UpdateObjectStorageBucketAccessAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/buckets/{clusterId}/{bucket}/access";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage Object ACL Config View
		/// View an Object's configured Access Control List (ACL) in this Object Storage bucket.
		/// ACLs define who can access your buckets and objects and specify the level of access
		/// granted to those users.
		/// 
		/// 
		/// This endpoint is available for convenience. It is recommended that instead you
		/// use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/objectops/#get-object-acl) directly.
		/// 
		/// ViewObjectStorageBucketACL object-storage/buckets/{clusterId}/{bucket}/object-acl
		/// </summary>
		/// <param name="name">The `name` of the object for which to retrieve its Access Control List (ACL). Use the [Object Storage Bucket Contents List](/docs/api/object-storage/#object-storage-bucket-contents-list) endpoint to access all object names in a bucket.
		///</param>
		/// <returns>The Object's canned ACL and policy.</returns>
		public async Task<ViewObjectStorageBucketACLReturn> ViewObjectStorageBucketACLAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/buckets/{clusterId}/{bucket}/object-acl?name=" + (name==null? "" : System.Uri.EscapeDataString(name));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ViewObjectStorageBucketACLReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage Object ACL Config Update
		/// Update an Object's configured Access Control List (ACL) in this Object Storage bucket.
		/// ACLs define who can access your buckets and objects and specify the level of access
		/// granted to those users.
		/// 
		/// 
		/// This endpoint is available for convenience. It is recommended that instead you
		/// use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/objectops/#set-object-acl) directly.
		/// 
		/// UpdateObjectStorageBucketACL object-storage/buckets/{clusterId}/{bucket}/object-acl
		/// </summary>
		/// <param name="requestBody">The changes to make to this Object's access controls.</param>
		/// <returns>The Object's canned ACL and policy.</returns>
		public async Task<UpdateObjectStorageBucketACLReturn> UpdateObjectStorageBucketACLAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/buckets/{clusterId}/{bucket}/object-acl";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<UpdateObjectStorageBucketACLReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage Bucket Contents List
		/// Returns the contents of a bucket. The contents are paginated using a `marker`,
		/// which is the name of the last object on the previous page.  Objects may
		/// be filtered by `prefix` and `delimiter` as well; see Query Parameters for more
		/// information.
		/// 
		/// 
		/// This endpoint is available for convenience. It is recommended that instead you
		/// use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/objectops/#get-object) directly.
		/// 
		/// GetObjectStorageBucketContent object-storage/buckets/{clusterId}/{bucket}/object-list
		/// </summary>
		/// <param name="marker">The "marker" for this request, which can be used to paginate through large buckets. Its value should be the value of the `next_marker` property returned with the last page. Listing bucket contents *does not* support arbitrary page access. See the `next_marker` property in the responses section for more details.
		///</param>
		/// <param name="delimiter">The delimiter for object names; if given, object names will be returned up to the first occurrence of this character. This is most commonly used with the `/` character to allow bucket transversal in a manner similar to a filesystem, however any delimiter may be used. Use in conjunction with `prefix` to see object names past the first occurrence of the delimiter.
		///</param>
		/// <param name="prefix">Filters objects returned to only those whose name start with the given prefix. Commonly used in conjunction with `delimiter` to allow transversal of bucket contents in a manner similar to a filesystem.
		///</param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>One page of the requested bucket's contents.</returns>
		public async Task<object> GetObjectStorageBucketContentAsync(string marker, string delimiter, string prefix, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/buckets/{clusterId}/{bucket}/object-list?marker=" + (marker==null? "" : System.Uri.EscapeDataString(marker))+"&delimiter=" + (delimiter==null? "" : System.Uri.EscapeDataString(delimiter))+"&prefix=" + (prefix==null? "" : System.Uri.EscapeDataString(prefix))+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<object>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage Object URL Create
		/// Creates a pre-signed URL to access a single Object in a bucket. This
		/// can be used to share objects, and also to create/delete objects by using
		/// the appropriate HTTP method in your request body's `method` parameter.
		/// 
		/// 
		/// This endpoint is available for convenience. It is recommended that instead you
		/// use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/)
		/// directly.
		/// 
		/// CreateObjectStorageObjectURL object-storage/buckets/{clusterId}/{bucket}/object-url
		/// </summary>
		/// <param name="requestBody">Information about the request to sign.</param>
		/// <returns>The URL with which to access your object.</returns>
		public async Task<object> CreateObjectStorageObjectURLAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/buckets/{clusterId}/{bucket}/object-url";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<object>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage TLS/SSL Cert Delete
		/// Deletes this Object Storage bucket's user uploaded TLS/SSL certificate and private key.
		/// 
		/// DeleteObjectStorageSSL object-storage/buckets/{clusterId}/{bucket}/ssl
		/// </summary>
		/// <returns>Deletes this Object Storage bucket's user uploaded TLS/SSL certificate and private key.</returns>
		public async Task<string> DeleteObjectStorageSSLAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/buckets/{clusterId}/{bucket}/ssl";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage TLS/SSL Cert View
		/// Returns a boolean value indicating if this bucket has a corresponding TLS/SSL certificate that was
		/// uploaded by an Account user.
		/// 
		/// GetObjectStorageSSL object-storage/buckets/{clusterId}/{bucket}/ssl
		/// </summary>
		/// <returns>Returns a boolean value indicating if this bucket has a corresponding TLS/SSL certificate that was uploaded by an Account user.
		///</returns>
		public async Task<ObjectStorageSSLResponse> GetObjectStorageSSLAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/buckets/{clusterId}/{bucket}/ssl";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ObjectStorageSSLResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage TLS/SSL Cert Upload
		/// Upload a TLS/SSL certificate and private key to be served when you visit your Object Storage bucket via HTTPS.
		/// Your TLS/SSL certificate and private key are stored encrypted at rest.
		/// 
		/// 
		/// To replace an expired certificate, [delete your current certificate](/docs/api/object-storage/#object-storage-tlsssl-cert-delete)
		/// and upload a new one.
		/// 
		/// CreateObjectStorageSSL object-storage/buckets/{clusterId}/{bucket}/ssl
		/// </summary>
		/// <param name="requestBody">Upload this TLS/SSL certificate with its corresponding secret key.</param>
		/// <returns>Returns whether this bucket has a corresponding TLS/SSL certificate that was uploaded by a user.</returns>
		public async Task<ObjectStorageSSLResponse> CreateObjectStorageSSLAsync(ObjectStorageSSL requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/buckets/{clusterId}/{bucket}/ssl";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ObjectStorageSSLResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage Cancel
		/// Cancel Object Storage on an Account.
		/// 
		/// **Warning**: Removes all buckets and their contents from your Account. This data is irretrievable once removed.
		/// 
		/// CancelObjectStorage object-storage/cancel
		/// </summary>
		/// <returns>Object Storage cancellation successful.</returns>
		public async Task<string> CancelObjectStorageAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/cancel";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Clusters List
		/// Returns a paginated list of Object Storage Clusters that are available for
		/// use.  Users can connect to the clusters with third party clients to create buckets
		/// and upload objects.
		/// 
		/// GetObjectStorageClusters object-storage/clusters
		/// </summary>
		/// <returns>A paginated list of available clusters.</returns>
		public async Task<GetObjectStorageClustersReturn> GetObjectStorageClustersAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/clusters";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetObjectStorageClustersReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Cluster View
		/// Returns a single Object Storage Cluster.
		/// 
		/// GetObjectStorageCluster object-storage/clusters/{clusterId}
		/// </summary>
		/// <returns>The requested Cluster</returns>
		public async Task<ObjectStorageCluster> GetObjectStorageClusterAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/clusters/{clusterId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ObjectStorageCluster>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage Keys List
		/// Returns a paginated list of Object Storage Keys for authenticating to
		/// the Object Storage S3 API.
		/// 
		/// GetObjectStorageKeys object-storage/keys
		/// </summary>
		/// <returns>A paginated list of Object Storage Keys</returns>
		public async Task<GetObjectStorageKeysReturn> GetObjectStorageKeysAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/keys";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetObjectStorageKeysReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage Key Create
		/// Provisions a new Object Storage Key on your account.
		/// 
		/// Accounts with negative balances cannot access this command.
		/// 
		/// * To create a Limited Access Key with specific permissions, send a `bucket_access` array.
		/// 
		/// * To create a Limited Access Key without access to any buckets, send an empty `bucket_access` array.
		/// 
		/// * To create an Access Key with unlimited access to all clusters and all buckets, omit the `bucket_access` array.
		/// 
		/// CreateObjectStorageKeys object-storage/keys
		/// </summary>
		/// <param name="requestBody">The label of the key to create. This is used to identify the created key.
		///</param>
		/// <returns>The new keypair.  **This is the only time** the secret key is returned.</returns>
		public async Task<ObjectStorageKey> CreateObjectStorageKeysAsync(ObjectStorageKey requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/keys";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ObjectStorageKey>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage Key Revoke
		/// Revokes an Object Storage Key.  This keypair will no longer be usable by third-party clients.
		/// 
		/// DeleteObjectStorageKey object-storage/keys/{keyId}
		/// </summary>
		/// <returns>Deletion successful</returns>
		public async Task<string> DeleteObjectStorageKeyAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/keys/{keyId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage Key View
		/// Returns a single Object Storage Key provisioned for your account.
		/// 
		/// GetObjectStorageKey object-storage/keys/{keyId}
		/// </summary>
		/// <returns>The keypair</returns>
		public async Task<ObjectStorageKey> GetObjectStorageKeyAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/keys/{keyId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ObjectStorageKey>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage Key Update
		/// Updates an Object Storage Key on your account.
		/// 
		/// UpdateObjectStorageKey object-storage/keys/{keyId}
		/// </summary>
		/// <param name="requestBody">The fields to update.</param>
		/// <returns>Update Successful</returns>
		public async Task<ObjectStorageKey> UpdateObjectStorageKeyAsync(UpdateObjectStorageKeyPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/keys/{keyId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ObjectStorageKey>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Object Storage Transfer View
		/// The amount of outbound data transfer used by your account's Object Storage buckets.
		/// Object Storage adds 1 terabyte of outbound data transfer to your data transfer pool.
		/// See the [Object Storage Overview](/docs/products/storage/object-storage/#pricing)
		/// guide for details on Object Storage transfer quotas.
		/// 
		/// GetObjectStorageTransfer object-storage/transfer
		/// </summary>
		/// <returns>Returns the amount of outbound data transfer used by your account's Object Storage buckets.
		///</returns>
		public async Task<object> GetObjectStorageTransferAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "object-storage/transfer";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<object>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Profile View
		/// Returns information about the current User. This can be used to see who is acting in applications where more than one token is managed. For example, in third-party OAuth applications.
		/// 
		/// This endpoint is always accessible, no matter what OAuth scopes the acting token has.
		/// 
		/// GetProfile profile
		/// </summary>
		/// <returns>Profile response.</returns>
		public async Task<Profile> GetProfileAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Profile>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Profile Update
		/// Update information in your Profile.  This endpoint requires the "account:read_write" OAuth Scope.
		/// 
		/// UpdateProfile profile
		/// </summary>
		/// <param name="requestBody">The fields to update.</param>
		/// <returns>Profile updated successfully.</returns>
		public async Task<Profile> UpdateProfileAsync(Profile requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Profile>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Authorized Apps List
		/// This is a collection of OAuth apps that you've given access to your Account, and includes the level of access granted.
		/// 
		/// GetProfileApps profile/apps
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A paginated list of apps you've authorized.
		///</returns>
		public async Task<GetProfileAppsReturn> GetProfileAppsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/apps?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetProfileAppsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// App Access Revoke
		/// Expires this app token. This token may no longer be used to access your Account.
		/// 
		/// DeleteProfileApp profile/apps/{appId}
		/// </summary>
		/// <returns>App's authorization has been revoked.</returns>
		public async Task<string> DeleteProfileAppAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/apps/{appId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Authorized App View
		/// Returns information about a single app you've authorized to access your Account.
		/// 
		/// GetProfileApp profile/apps/{appId}
		/// </summary>
		/// <returns>The app requested.</returns>
		public async Task<AuthorizedApp> GetProfileAppAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/apps/{appId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AuthorizedApp>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Trusted Devices List
		/// Returns a paginated list of active TrustedDevices for your User. Browsers with an active Remember Me Session are logged into your account until the session expires or is revoked.
		/// 
		/// GetDevices profile/devices
		/// </summary>
		/// <returns>Returns a paginated list of TrustedDevice objects.</returns>
		public async Task<GetDevicesReturn> GetDevicesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/devices";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetDevicesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Trusted Device Revoke
		/// Revoke an active TrustedDevice for your User.  Once a TrustedDevice is revoked, this device will have to log in again before accessing your Linode account.
		/// 
		/// RevokeTrustedDevice profile/devices/{deviceId}
		/// </summary>
		/// <returns>Session revoked successfully</returns>
		public async Task<string> RevokeTrustedDeviceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/devices/{deviceId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Trusted Device View
		/// Returns a single active TrustedDevice for your User.
		/// 
		/// GetTrustedDevice profile/devices/{deviceId}
		/// </summary>
		/// <returns>The requested TrustedDevice object</returns>
		public async Task<TrustedDevice> GetTrustedDeviceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/devices/{deviceId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<TrustedDevice>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Grants List
		/// This returns a GrantsResponse describing what the acting User has been granted access to.  For unrestricted users, this will return a  204 and no body because unrestricted users have access to everything without grants.  This will not return information about entities you do not have access to.  This endpoint is useful when writing third-party OAuth applications to see what options you should present to the acting User.
		/// 
		/// For example, if they do not have `global.add_linodes`, you might not display a button to deploy a new Linode.
		/// 
		/// Any client may access this endpoint; no OAuth scopes are required.
		/// 
		/// GetProfileGrants profile/grants
		/// </summary>
		/// <returns>GrantsResponse</returns>
		public async Task<GrantsResponse> GetProfileGrantsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/grants";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GrantsResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Logins List
		/// Returns a collection of successful account logins from this user during the last 90 days.
		/// 
		/// GetProfileLogins profile/logins
		/// </summary>
		/// <returns>An array of successful account logins from this user during the last 90 days.
		///</returns>
		public async Task<GetProfileLoginsReturn> GetProfileLoginsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/logins";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetProfileLoginsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Login View
		/// Returns a login object displaying information about a successful account login from this user.
		/// 
		/// GetProfileLogin profile/logins/{loginId}
		/// </summary>
		/// <returns>The requested login object.</returns>
		public async Task<Login> GetProfileLoginAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/logins/{loginId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Login>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Phone Number Delete
		/// Delete the verified phone number for the User making this request.
		/// 
		/// Use this command to opt out of SMS messages for the requesting User after a phone number has been verified with the **Phone Number Verify** ([POST /profile/phone-number/verify](/docs/api/profile/#phone-number-verify)) command.
		/// 
		/// DeleteProfilePhoneNumber profile/phone-number
		/// </summary>
		/// <returns>Phone number deletion request successful.
		///</returns>
		public async Task<string> DeleteProfilePhoneNumberAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/phone-number";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Phone Number Verification Code Send
		/// Send a one-time verification code via SMS message to the submitted phone number. Providing your phone number helps ensure you can securely access your Account in case other ways to connect are lost. Your phone number is only used to verify your identity by sending an SMS message. Standard carrier messaging fees may apply.
		/// 
		/// * By accessing this command you are opting in to receive SMS messages. You can opt out of SMS messages by using the **Phone Number Delete** ([DELETE /profile/phone-number](/docs/api/profile/#phone-number-delete)) command after your phone number is verified.
		/// 
		/// * Verification codes are valid for 10 minutes after they are sent.
		/// 
		/// * Subsequent requests made prior to code expiration result in sending the same code.
		/// 
		/// Once a verification code is received, verify your phone number with the **Phone Number Verify** ([POST /profile/phone-number/verify](/docs/api/profile/#phone-number-verify)) command.
		/// 
		/// PostProfilePhoneNumber profile/phone-number
		/// </summary>
		/// <param name="requestBody">Enter a phone number and country code for verification.</param>
		/// <returns>Phone number verification code request successful.
		///</returns>
		public async Task<string> PostProfilePhoneNumberAsync(PostProfilePhoneNumberPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/phone-number";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Phone Number Verify
		/// Verify a phone number by confirming the one-time code received via SMS message after accessing the **Phone Verification Code Send** ([POST /profile/phone-number](/docs/api/profile/#phone-number-verification-code-send)) command.
		/// 
		/// * Verification codes are valid for 10 minutes after they are sent.
		/// 
		/// * Only the same User that made the verification code request can use that code with this command.
		/// 
		/// Once completed, the verified phone number is assigned to the User making the request. To change the verified phone number for a User, first use the **Phone Number Delete** ([DELETE /profile/phone-number](/docs/api/profile/#phone-number-delete)) command, then begin the verification process again with the **Phone Verification Code Send** ([POST /profile/phone-number](/docs/api/profile/#phone-number-verification-code-send)) command.
		/// 
		/// PostProfilePhoneNumberVerify profile/phone-number/verify
		/// </summary>
		/// <param name="requestBody">Enter a phone verification code for confirmation.</param>
		/// <returns>Phone number verification successful.
		///</returns>
		public async Task<string> PostProfilePhoneNumberVerifyAsync(PostProfilePhoneNumberVerifyPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/phone-number/verify";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// User Preferences View
		/// View a list of user preferences tied to the OAuth client that generated
		/// the token making the request. The user preferences endpoints allow
		/// consumers of the API to store arbitrary JSON data, such as a user's font
		/// size preference or preferred display name. User preferences are available
		/// for each OAuth client registered to your account, and as such an account can
		/// have multiple user preferences.
		/// 
		/// GetUserPreferences profile/preferences
		/// </summary>
		/// <returns>Returns an object of user preferences.</returns>
		public async Task<string> GetUserPreferencesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/preferences";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// User Preferences Update
		/// Updates a user's preferences. These preferences are tied to the OAuth client that generated the token making the request. The user preferences endpoints allow consumers of the API to store arbitrary JSON data, such as a user's font size preference or preferred display name. An account may have multiple preferences. Preferences, and the pertaining request body, may contain any arbitrary JSON data that the user would like to store.
		/// 
		/// UpdateUserPreferences profile/preferences
		/// </summary>
		/// <param name="requestBody">The user preferences to update or store.
		///</param>
		/// <returns>Returns an object of user preferences.</returns>
		public async Task<string> UpdateUserPreferencesAsync(string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/preferences";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Security Questions List
		/// Returns a collection of security questions and their responses, if any, for your User Profile.
		/// 
		/// GetSecurityQuestions profile/security-questions
		/// </summary>
		/// <returns>Returns a list of security questions.</returns>
		public async Task<SecurityQuestionsGet> GetSecurityQuestionsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/security-questions";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<SecurityQuestionsGet>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Security Questions Answer
		/// Adds security question responses for your User.
		/// 
		/// Requires exactly three unique questions.
		/// 
		/// Previous responses are overwritten if answered or reset to `null` if unanswered.
		/// 
		/// **Note**: Security questions must be answered for your User prior to accessing the **Two Factor Secret Create** ([POST /profile/tfa-enable](/docs/api/profile/#two-factor-secret-create)) command.
		/// 
		/// PostSecurityQuestions profile/security-questions
		/// </summary>
		/// <param name="requestBody">Answer Security Questions</param>
		/// <returns>Security Questions answered successfully.</returns>
		public async Task<SecurityQuestionsPost> PostSecurityQuestionsAsync(SecurityQuestionsPost requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/security-questions";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<SecurityQuestionsPost>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// SSH Keys List
		/// Returns a collection of SSH Keys you've added to your Profile.
		/// 
		/// GetSSHKeys profile/sshkeys
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated list of SSH Key objects.</returns>
		public async Task<GetSSHKeysReturn> GetSSHKeysAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/sshkeys?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetSSHKeysReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// SSH Key Add
		/// Adds an SSH Key to your Account profile.
		/// 
		/// AddSSHKey profile/sshkeys
		/// </summary>
		/// <param name="requestBody">Add SSH Key</param>
		/// <returns>SSH Key associated successfully.</returns>
		public async Task<SSHKey> AddSSHKeyAsync(SSHKey requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/sshkeys";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<SSHKey>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// SSH Key Delete
		/// Deletes an SSH Key you have access to.
		/// 
		/// **Note:** deleting an SSH Key will *not* remove it from any Linode or Disk that was deployed with `authorized_keys`. In those cases, the keys must be manually deleted on the Linode or Disk. This endpoint will only delete the key's association from your Profile.
		/// 
		/// DeleteSSHKey profile/sshkeys/{sshKeyId}
		/// </summary>
		/// <returns>SSH Key deleted successfully.</returns>
		public async Task<string> DeleteSSHKeyAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/sshkeys/{sshKeyId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// SSH Key View
		/// Returns a single SSH Key object identified by `id` that you have access to view.
		/// 
		/// GetSSHKey profile/sshkeys/{sshKeyId}
		/// </summary>
		/// <returns>An SSH Key object</returns>
		public async Task<SSHKey> GetSSHKeyAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/sshkeys/{sshKeyId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<SSHKey>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// SSH Key Update
		/// Updates an SSH Key that you have permission to `read_write`.
		/// 
		/// Only SSH key labels can be updated.
		/// 
		/// UpdateSSHKey profile/sshkeys/{sshKeyId}
		/// </summary>
		/// <param name="requestBody">The fields to update.
		///</param>
		/// <returns>SSH Key updated successfully.</returns>
		public async Task<SSHKey> UpdateSSHKeyAsync(UpdateSSHKeyPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/sshkeys/{sshKeyId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<SSHKey>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Two Factor Authentication Disable
		/// Disables Two Factor Authentication for your User. Once successful, login attempts from untrusted computers will only require a password before being successful. This is less secure, and is discouraged.
		/// 
		/// TfaDisable profile/tfa-disable
		/// </summary>
		/// <returns>TFA disabled.</returns>
		public async Task<string> TfaDisableAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/tfa-disable";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Two Factor Secret Create
		/// Generates a Two Factor secret for your User. To enable TFA for your User, enter the secret obtained from this command with the **Two Factor Authentication Confirm/Enable** ([POST /profile/tfa-enable-confirm](/docs/api/profile/#two-factor-authentication-confirmenable)) command.
		/// Once enabled, logins from untrusted computers are required to provide
		/// a TFA code before they are successful.
		/// 
		/// **Note**: Before you can enable TFA, security questions must be answered for your User by accessing the **Security Questions Answer** ([POST /profile/security-questions](/docs/api/profile/#security-questions-answer)) command.
		/// 
		/// TfaEnable profile/tfa-enable
		/// </summary>
		/// <returns>Two Factor secret generated</returns>
		public async Task<object> TfaEnableAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/tfa-enable";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<object>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Two Factor Authentication Confirm/Enable
		/// Confirms that you can successfully generate Two Factor codes and enables TFA on your Account. Once this is complete, login attempts from untrusted computers will be required to provide a Two Factor code before they are successful.
		/// 
		/// TfaConfirm profile/tfa-enable-confirm
		/// </summary>
		/// <param name="requestBody">The Two Factor code you generated with your Two Factor secret.</param>
		/// <returns>TFA enabled successfully</returns>
		public async Task<object> TfaConfirmAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/tfa-enable-confirm";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<object>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Personal Access Tokens List
		/// Returns a paginated list of Personal Access Tokens currently active for your User.
		/// 
		/// GetPersonalAccessTokens profile/tokens
		/// </summary>
		/// <returns>A paginated list of active tokens.</returns>
		public async Task<GetPersonalAccessTokensReturn> GetPersonalAccessTokensAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/tokens";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetPersonalAccessTokensReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Personal Access Token Create
		/// Creates a Personal Access Token for your User. The raw token will be returned in the response, but will never be returned again afterward so be sure to take note of it. You may create a token with _at most_ the scopes of your current token. The created token will be able to access your Account until the given expiry, or until it is revoked.
		/// 
		/// CreatePersonalAccessToken profile/tokens
		/// </summary>
		/// <param name="requestBody">Information about the requested token.</param>
		/// <returns>Token created successfully.</returns>
		public async Task<PersonalAccessToken> CreatePersonalAccessTokenAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/tokens";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<PersonalAccessToken>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Personal Access Token Revoke
		/// Revokes a Personal Access Token. The token will be invalidated immediately, and requests using that token will fail with a 401. It is possible to revoke access to the token making the request to revoke a token, but keep in mind that doing so could lose you access to the api and require you to create a new token through some other means.
		/// 
		/// DeletePersonalAccessToken profile/tokens/{tokenId}
		/// </summary>
		/// <returns>Token revoked successfully.</returns>
		public async Task<string> DeletePersonalAccessTokenAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/tokens/{tokenId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Personal Access Token View
		/// Returns a single Personal Access Token.
		/// 
		/// GetPersonalAccessToken profile/tokens/{tokenId}
		/// </summary>
		/// <returns>The requested token.</returns>
		public async Task<PersonalAccessToken> GetPersonalAccessTokenAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/tokens/{tokenId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<PersonalAccessToken>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Personal Access Token Update
		/// Updates a Personal Access Token.
		/// 
		/// UpdatePersonalAccessToken profile/tokens/{tokenId}
		/// </summary>
		/// <param name="requestBody">The fields to update.</param>
		/// <returns>Token updated successfully.</returns>
		public async Task<PersonalAccessToken> UpdatePersonalAccessTokenAsync(PersonalAccessToken requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profile/tokens/{tokenId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<PersonalAccessToken>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Regions List
		/// Lists the Regions available for Linode services. Not all services are guaranteed to be
		/// available in all Regions.
		/// 
		/// GetRegions regions
		/// </summary>
		/// <returns>Returns an array of Regions.</returns>
		public async Task<GetRegionsReturn> GetRegionsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "regions";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetRegionsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Region View
		/// Returns a single Region.
		/// 
		/// GetRegion regions/{regionId}
		/// </summary>
		/// <returns>A single Region object.</returns>
		public async Task<Region> GetRegionAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "regions/{regionId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Region>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Support Tickets List
		/// Returns a collection of Support Tickets on your Account. Support Tickets can be both tickets you open with Linode for support, as well as tickets generated by Linode regarding your Account.
		/// This collection includes all Support Tickets generated on your Account, with open tickets returned first.
		/// 
		/// GetTickets support/tickets
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated list of SupportTicket objects.</returns>
		public async Task<GetTicketsReturn> GetTicketsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "support/tickets?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetTicketsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Support Ticket Open
		/// Open a Support Ticket.
		/// Only one of the ID attributes (`linode_id`, `domain_id`, etc.) can be set on a single Support Ticket.
		/// 
		/// CreateTicket support/tickets
		/// </summary>
		/// <param name="requestBody">Open a Support Ticket.</param>
		/// <returns>Support Ticket opened.</returns>
		public async Task<SupportTicket> CreateTicketAsync(SupportTicketRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "support/tickets";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<SupportTicket>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Support Ticket View
		/// Returns a Support Ticket under your Account.
		/// 
		/// GetTicket support/tickets/{ticketId}
		/// </summary>
		/// <returns>Returns a single SupportTicket object.</returns>
		public async Task<SupportTicket> GetTicketAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "support/tickets/{ticketId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<SupportTicket>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Support Ticket Close
		/// Closes a Support Ticket you have access to modify.
		/// 
		/// CloseTicket support/tickets/{ticketId}/close
		/// </summary>
		/// <returns>Support Ticket closed successfully.</returns>
		public async Task<string> CloseTicketAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "support/tickets/{ticketId}/close";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Replies List
		/// Returns a collection of replies to a Support Ticket on your Account.
		/// 
		/// GetTicketReplies support/tickets/{ticketId}/replies
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a paginated list of SupportTicketReply objects.</returns>
		public async Task<GetTicketRepliesReturn> GetTicketRepliesAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "support/tickets/{ticketId}/replies?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetTicketRepliesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Reply Create
		/// Adds a reply to an existing Support Ticket.
		/// 
		/// CreateTicketReply support/tickets/{ticketId}/replies
		/// </summary>
		/// <param name="requestBody">Add a reply.</param>
		/// <returns>Reply created.</returns>
		public async Task<SupportTicketReply> CreateTicketReplyAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "support/tickets/{ticketId}/replies";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<SupportTicketReply>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Tags List
		/// Tags are User-defined labels attached to objects in your Account, such as Linodes. They are used for specifying and grouping attributes of objects that are relevant to the User.
		/// 
		/// This endpoint returns a paginated list of Tags on your account.
		/// 
		/// GetTags tags
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A paginated list of Tags</returns>
		public async Task<GetTagsReturn> GetTagsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetTagsReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// New Tag Create
		/// Creates a new Tag and optionally tags requested objects with it immediately.
		/// 
		/// **Important**: You must be an unrestricted User in order to add or modify Tags.
		/// 
		/// CreateTag tags
		/// </summary>
		/// <param name="requestBody">The tag to create, and optionally the objects to tag.
		///</param>
		/// <returns>The new Tag.</returns>
		public async Task<Tag> CreateTagAsync(CreateTagPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Tag>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Tag Delete
		/// Remove a Tag from all objects and delete it.
		/// 
		/// **Important**: You must be an unrestricted User in order to add or modify Tags.
		/// 
		/// DeleteTag tags/{label}
		/// </summary>
		/// <returns>Tag deleted.</returns>
		public async Task<string> DeleteTagAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/{label}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Tagged Objects List
		/// Returns a paginated list of all objects you've tagged with the requested Tag. This is a mixed collection of all object types.
		/// 
		/// GetTaggedObjects tags/{label}
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>A paginated list of objects, organized by type, that have been tagged with the requested Tag.
		///</returns>
		public async Task<object> GetTaggedObjectsAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/{label}?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<object>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Volumes List
		/// Returns a paginated list of Volumes you have permission to view.
		/// 
		/// GetVolumes volumes
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns an array of all Volumes on your Account.</returns>
		public async Task<GetVolumesReturn> GetVolumesAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GetVolumesReturn>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Volume Create
		/// Creates a Volume on your Account. In order for this to complete successfully, your User must have the `add_volumes` grant. Creating a new Volume will start accruing additional charges on your account.
		/// 
		/// CreateVolume volumes
		/// </summary>
		/// <param name="requestBody">The requested initial state of a new Volume.</param>
		/// <returns>Creating Volume.
		///</returns>
		public async Task<Volume> CreateVolumeAsync(CreateVolumePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Volume>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Volume Delete
		/// Deletes a Volume you have permission to `read_write`.
		/// 
		/// * **Deleting a Volume is a destructive action and cannot be undone.**
		/// 
		/// * Deleting stops billing for the Volume. You will be billed for time used within
		/// the billing period the Volume was active.
		/// 
		/// * Volumes that are migrating cannot be deleted until the migration is finished.
		/// 
		/// DeleteVolume volumes/{volumeId}
		/// </summary>
		/// <returns>Volume deletion successful.</returns>
		public async Task<string> DeleteVolumeAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes/{volumeId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Volume View
		/// Get information about a single Volume.
		/// 
		/// GetVolume volumes/{volumeId}
		/// </summary>
		/// <param name="page">The page of a collection to return.
		/// Minimum: 1
		// </param>
		/// <param name="page_size">The number of items to return per page.
		/// Minimum: 25
		/// Maximum: 500
		// </param>
		/// <returns>Returns a single Volume object.</returns>
		public async Task<Volume> GetVolumeAsync(int page, int page_size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes/{volumeId}?page="+page+"&page_size="+page_size;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Volume>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Volume Update
		/// Updates a Volume that you have permission to `read_write`.
		/// 
		/// UpdateVolume volumes/{volumeId}
		/// </summary>
		/// <param name="requestBody">If any updated field fails to pass validation, the Volume will not be updated.
		///</param>
		/// <returns>The updated Volume.</returns>
		public async Task<Volume> UpdateVolumeAsync(Volume requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes/{volumeId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Volume>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Volume Attach
		/// Attaches a Volume on your Account to an existing Linode on your Account. In order for this request to complete successfully, your User must have `read_only` or `read_write` permission to the Volume and `read_write` permission to the Linode. Additionally, the Volume and Linode must be located in the same Region.
		/// 
		/// AttachVolume volumes/{volumeId}/attach
		/// </summary>
		/// <param name="requestBody">Volume to attach to a Linode.</param>
		/// <returns>Volume was attached to a Linode.</returns>
		public async Task<Volume> AttachVolumeAsync(AttachVolumePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes/{volumeId}/attach";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Volume>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Volume Clone
		/// Creates a Volume on your Account. In order for this request to complete successfully, your User must have the `add_volumes` grant. The new Volume will have the same size and data as the source Volume. Creating a new Volume will incur a charge on your Account.
		/// * Only Volumes with a `status` of "active" can be cloned.
		/// 
		/// CloneVolume volumes/{volumeId}/clone
		/// </summary>
		/// <param name="requestBody">The requested state your Volume will be cloned into.</param>
		/// <returns>Clone started.</returns>
		public async Task<Volume> CloneVolumeAsync(CloneVolumePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes/{volumeId}/clone";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Volume>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Volume Detach
		/// Detaches a Volume on your Account from a Linode on your Account. In order for this request to complete successfully, your User must have `read_write` access to the Volume and `read_write` access to the Linode.
		/// 
		/// DetachVolume volumes/{volumeId}/detach
		/// </summary>
		/// <returns>Volume was detached from a Linode.</returns>
		public async Task<string> DetachVolumeAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes/{volumeId}/detach";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Volume Resize
		/// Resize an existing Volume on your Account. In order for this request to complete successfully, your User must have the `read_write` permissions to the Volume.
		/// * Volumes can only be resized up.
		/// * Only Volumes with a `status` of "active" can be resized.
		/// 
		/// ResizeVolume volumes/{volumeId}/resize
		/// </summary>
		/// <param name="requestBody">The requested size to increase your Volume to.</param>
		/// <returns>Volume resize started.</returns>
		public async Task<Volume> ResizeVolumeAsync(ResizeVolumePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes/{volumeId}/resize";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Volume>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
	}
	
	public class CancelAccountReturn
	{
		
		/// <summary>
		/// A link to Linode's exit survey.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="survey_link")]
		public string Survey_link { get; set; }
	}
	
	public class CreateEntityTransferPostBody
	{
		
		/// <summary>
		/// An object representing an Entity Transfer.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="entities")]
		public EntityTransfer Entities { get; set; }
	}
	
	public class GetEventsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Event[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetInvoicesReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Invoice[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetInvoiceItemsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InvoiceItem[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetAccountLoginsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Login[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetMaintenanceReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Maintenance[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetNotificationsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Notification[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetClientsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public OAuthClient[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetPaymentMethodsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public PaymentMethod[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class CreatePaymentMethodPostBody
	{
		
		/// <summary>
		/// An object representing the credit card information you have on file with
		///Linode to make Payments against your Account.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="data")]
		public CreditCard Data { get; set; }
		
		/// <summary>
		/// Payment Method Response Object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="is_default")]
		public PaymentMethod Is_default { get; set; }
		
		/// <summary>
		/// The type of Payment Method.
		///
		///Alternative Payment Methods including Google Pay and PayPal can be added using the Cloud Manager. See the [Manage Payment Methods](/docs/products/platform/billing/guides/payment-methods/) guide
		///for details and instructions.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CreatePaymentMethodPostBodyType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreatePaymentMethodPostBodyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		credit_card = 0,
	}
	
	public class GetPaymentsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Payment[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class CreatePayPalPaymentReturn
	{
		
		/// <summary>
		/// The checkout token generated for this Payment.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="checkout_token")]
		public string Checkout_token { get; set; }
		
		/// <summary>
		/// The paypal-generated ID for this Payment. Used when authorizing the Payment in PayPal's interface.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payment_id")]
		public string Payment_id { get; set; }
	}
	
	public class CreatePromoCreditPostBody
	{
		
		/// <summary>
		/// The Promo Code.
		///
		/// Required
		/// Min length: 1
		/// Max length: 32
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="promo_code")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(32)]
		public string Promo_code { get; set; }
	}
	
	public class GetServiceTransfersReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ServiceTransfer[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class CreateServiceTransferPostBody
	{
		
		/// <summary>
		/// An object representing a Service Transfer.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="entities")]
		public ServiceTransfer Entities { get; set; }
	}
	
	public class GetUsersReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public User[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class PutDatabasesMongoDBInstancePutBody
	{
		
		/// <summary>
		/// Managed MongoDB Database request object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_list")]
		public DatabaseMongoDBRequest Allow_list { get; set; }
		
		/// <summary>
		/// Managed MongoDB Database request object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public DatabaseMongoDBRequest Label { get; set; }
		
		/// <summary>
		/// Managed MongoDB Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updates")]
		public DatabaseMongoDB Updates { get; set; }
	}
	
	public class PutDatabasesMySQLInstancePutBody
	{
		
		/// <summary>
		/// Managed MySQL Database request object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_list")]
		public DatabaseMySQLRequest Allow_list { get; set; }
		
		/// <summary>
		/// Managed MySQL Database request object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public DatabaseMySQLRequest Label { get; set; }
		
		/// <summary>
		/// Managed MySQL Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updates")]
		public DatabaseMySQL Updates { get; set; }
	}
	
	public class PutDatabasesPostgreSQLInstancePutBody
	{
		
		/// <summary>
		/// Managed PostgreSQL Database request object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_list")]
		public DatabasePostgreSQLRequest Allow_list { get; set; }
		
		/// <summary>
		/// Managed PostgreSQL Database request object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public DatabasePostgreSQLRequest Label { get; set; }
		
		/// <summary>
		/// Managed PostgreSQL Databases object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updates")]
		public DatabasePostgreSQL Updates { get; set; }
	}
	
	public class GetDomainsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Domain[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class CloneDomainPostBody
	{
		
		/// <summary>
		/// The new domain for the clone. Domain labels cannot be longer than 63 characters and must conform to [RFC1035](https://tools.ietf.org/html/rfc1035). Domains must be unique on Linode's platform, including across different Linode accounts; there cannot be two Domains representing the same domain.
		///
		/// Required
		/// Min length: 1
		/// Max length: 253
		/// Pattern: \A(\*\.)?([a-zA-Z0-9-_]{1,63}\.)+([a-zA-Z]{2,3}\.)?([a-zA-Z]{2,16}|xn--[a-zA-Z0-9]+)\Z
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domain")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(253)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"\A(\*\.)?([a-zA-Z0-9-_]{1,63}\.)+([a-zA-Z]{2,3}\.)?([a-zA-Z]{2,16}|xn--[a-zA-Z0-9]+)\Z")]
		public string Domain { get; set; }
	}
	
	public class GetDomainRecordsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public DomainRecord[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class UpdateDomainRecordPutBody
	{
		
		/// <summary>
		/// A single record on a Domain.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public DomainRecord Name { get; set; }
		
		/// <summary>
		/// A single record on a Domain.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public DomainRecord Port { get; set; }
		
		/// <summary>
		/// A single record on a Domain.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public DomainRecord Priority { get; set; }
		
		/// <summary>
		/// A single record on a Domain.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public DomainRecord Protocol { get; set; }
		
		/// <summary>
		/// A single record on a Domain.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service")]
		public DomainRecord Service { get; set; }
		
		/// <summary>
		/// A single record on a Domain.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public DomainRecord Tag { get; set; }
		
		/// <summary>
		/// A single record on a Domain.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public DomainRecord Target { get; set; }
		
		/// <summary>
		/// A single record on a Domain.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ttl_sec")]
		public DomainRecord Ttl_sec { get; set; }
		
		/// <summary>
		/// A single record on a Domain.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="weight")]
		public DomainRecord Weight { get; set; }
	}
	
	public class GetImagesReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Image[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class ImagesPostPostBody
	{
		
		/// <summary>
		/// Description for the uploaded Image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Label for the uploaded Image.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The region to upload to. Once uploaded, the Image can be used in any region.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
	}
	
	public class ImagesPostReturn
	{
		
		/// <summary>
		/// Image object
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public Image Image { get; set; }
		
		/// <summary>
		/// The URL to upload the Image to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upload_to")]
		public string Upload_to { get; set; }
	}
	
	public class GetLinodeInstancesReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Linode[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetBackupsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="automatic")]
		public string[] Automatic { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="snapshot")]
		public GetBackupsReturnSnapshot Snapshot { get; set; }
	}
	
	public class GetBackupsReturnSnapshot
	{
		
		/// <summary>
		/// An object representing a Backup or snapshot for a Linode with Backup service enabled.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="current")]
		public Backup Current { get; set; }
		
		/// <summary>
		/// An object representing a Backup or snapshot for a Linode with Backup service enabled.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="in_progress")]
		public Backup In_progress { get; set; }
	}
	
	public class CreateSnapshotPostBody
	{
		
		/// <summary>
		/// The label for the new snapshot.
		/// Required
		/// Min length: 1
		/// Max length: 255
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		public string Label { get; set; }
	}
	
	public class RestoreBackupPostBody
	{
		
		/// <summary>
		/// The ID of the Linode to restore a Backup to.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="linode_id")]
		public int Linode_id { get; set; }
		
		/// <summary>
		/// If True, deletes all Disks and Configs on the target Linode
		///before restoring.
		///
		///If False, and the Disk image size is larger than the available
		///space on the Linode, an error message indicating insufficient
		///space is returned.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="overwrite")]
		public System.Nullable<System.Boolean> Overwrite { get; set; }
	}
	
	public class BootLinodeInstancePostBody
	{
		
		/// <summary>
		/// The Linode Config ID to boot into.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="config_id")]
		public System.Nullable<System.Int32> Config_id { get; set; }
	}
	
	public class CloneLinodeInstancePostBody
	{
		
		/// <summary>
		/// If this field is set to `true`, the created Linode will
		///automatically be enrolled in the Linode Backup service. This
		///will incur an additional charge. Pricing is included in the
		///response from
		///[/linodes/types](/docs/api/linode-types/#types-list).
		///
		///* Can only be included when cloning to a new Linode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backups_enabled")]
		public System.Nullable<System.Boolean> Backups_enabled { get; set; }
		
		/// <summary>
		/// An array of configuration profile IDs.
		///* If the `configs` parameter **is not provided**, then **all configuration profiles and their associated disks will be cloned** from the source Linode. Any disks specified by the `disks` parameter will also be cloned.
		///* **If an empty array is provided** for the `configs` parameter, then **no configuration profiles (nor their associated disks) will be cloned** from the source Linode. Any disks specified by the `disks` parameter will still be cloned.
		///* **If a non-empty array is provided** for the `configs` parameter, then **the configuration profiles specified in the array (and their associated disks) will be cloned** from the source Linode. Any disks specified by the `disks` parameter will also be cloned.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configs")]
		public int[] Configs { get; set; }
		
		/// <summary>
		/// An array of disk IDs.
		///* If the `disks` parameter **is not provided**, then **no extra disks will be cloned** from the source Linode. All disks associated with the configuration profiles specified by the `configs` parameter will still be cloned.
		///* **If an empty array is provided** for the `disks` parameter, then **no extra disks will be cloned** from the source Linode. All disks associated with the configuration profiles specified by the `configs` parameter will still be cloned.
		///* **If a non-empty array is provided** for the `disks` parameter, then **the disks specified in the array will be cloned** from the source Linode, in addition to any disks associated with the configuration profiles specified by the `configs` parameter.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public int[] Disks { get; set; }
		
		/// <summary>
		/// A label used to group Linodes for display. Linodes are not required to have a group.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public string Group { get; set; }
		
		/// <summary>
		/// The label to assign this Linode when cloning to a new Linode.
		///* Can only be provided when cloning to a new Linode.
		///* Defaults to "linode".
		///
		/// Min length: 3
		/// Max length: 64
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(3)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		public string Label { get; set; }
		
		/// <summary>
		/// If an existing Linode is the target for the clone, the ID of that Linode. The existing Linode must have enough resources to accept the clone.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linode_id")]
		public System.Nullable<System.Int32> Linode_id { get; set; }
		
		/// <summary>
		/// If true, the created Linode will have private networking enabled and assigned a private IPv4 address.
		///* Can only be provided when cloning to a new Linode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="private_ip")]
		public System.Nullable<System.Boolean> Private_ip { get; set; }
		
		/// <summary>
		/// This is the Region where the Linode will be deployed.
		///To view all available Regions you can deploy to see [/regions](/docs/api/regions/#regions-list).
		///* Region can only be provided and is required when cloning to a new Linode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// A Linode's Type determines what resources are available to
		///it, including disk space, memory, and virtual cpus. The
		///amounts available to a specific Linode are returned as
		///`specs` on the Linode object.
		///
		///To view all available Linode Types you can deploy with
		///see [/linode/types](/docs/api/linode-types/#types-list).
		///
		///* Type can only be provided and is required when cloning to a new Linode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class GetLinodeConfigsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public LinodeConfig[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetLinodeDisksReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Disk[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetLinodeFirewallsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Firewall[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class UpdateLinodeIPPutBody
	{
		
		/// <summary>
		/// The reverse DNS assigned to this address. For public IPv4 addresses, this will be set to a default value provided by Linode if not explicitly set.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rdns")]
		public string Rdns { get; set; }
	}
	
	public class MutateLinodeInstancePostBody
	{
		
		/// <summary>
		/// Automatically resize disks when resizing a Linode. When resizing down to a smaller plan your Linode's data must fit within the smaller disk size.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_auto_disk_resize")]
		public System.Nullable<System.Boolean> Allow_auto_disk_resize { get; set; }
	}
	
	public class GetLinodeNodeBalancersReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NodeBalancer[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class RescueLinodeInstancePostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="devices")]
		public RescueDevices Devices { get; set; }
	}
	
	public class ResizeLinodeInstancePostBody
	{
		
		/// <summary>
		/// Automatically resize disks when resizing a Linode. When resizing down to a smaller plan your Linode's data must fit within the smaller disk size.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_auto_disk_resize")]
		public System.Nullable<System.Boolean> Allow_auto_disk_resize { get; set; }
		
		/// <summary>
		/// The ID representing the Linode Type.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class GetLinodeVolumesReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Volume[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetKernelsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Kernel[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetStackScriptsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public StackScript[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetLinodeTypesReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public LinodeType[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetLKEClustersReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public LKECluster[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class CreateLKEClusterPostBody
	{
		
		/// <summary>
		/// Defines settings for the Kubernetes Control Plane. Allows for the enabling of High Availability (HA) for Control Plane Components. Enabling High Availability for LKE is an **irreversible** change.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="control_plane")]
		public CreateLKEClusterPostBodyControl_plane Control_plane { get; set; }
		
		/// <summary>
		/// A Kubernetes cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="k8s_version")]
		public LKECluster K8s_version { get; set; }
		
		/// <summary>
		/// A Kubernetes cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public LKECluster Label { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="node_pools")]
		public LKENodePoolRequestBody[] Node_pools { get; set; }
		
		/// <summary>
		/// A Kubernetes cluster.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region")]
		public LKECluster Region { get; set; }
		
		/// <summary>
		/// A Kubernetes cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public LKECluster Tags { get; set; }
	}
	
	public class CreateLKEClusterPostBodyControl_plane
	{
		
		/// <summary>
		/// Defines whether High Availability is enabled for the Control Plane Components of the cluster. Defaults to `false`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="high_availability")]
		public System.Nullable<System.Boolean> High_availability { get; set; }
	}
	
	public class GetLKEClusterAPIEndpointsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public GetLKEClusterAPIEndpointsReturnData[] GetLKEClusterAPIEndpointsReturnData { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetLKEClusterAPIEndpointsReturnData
	{
		
		/// <summary>
		/// A Kubernetes API server endpoint for this cluster.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endpoint")]
		public string Endpoint { get; set; }
	}
	
	public class GetLKEClusterDashboardReturn
	{
		
		/// <summary>
		/// The Cluster Dashboard access URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class GetLKEClusterKubeconfigReturn
	{
		
		/// <summary>
		/// The Base64-encoded Kubeconfig file for this Cluster.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kubeconfig")]
		public string Kubeconfig { get; set; }
	}
	
	public class GetLKEClusterNodeReturn
	{
		
		/// <summary>
		/// The Node's ID.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The Linode's ID. If no Linode is currently provisioned for this Node, this is `null`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instance_id")]
		public System.Nullable<System.Int32> Instance_id { get; set; }
		
		/// <summary>
		/// The creation status of this Node. This status is distinct from this Node's readiness as a Kubernetes Node Object as determined by the command `kubectl get nodes`.
		///
		///`not_ready` indicates that the Linode is still being created.
		///
		///`ready` indicates that the Linode has successfully been created and is running Kubernetes software.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public LKENodeStatusStatus Status { get; set; }
	}
	
	public class GetLKEClusterPoolsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public LKENodePool[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetLKEVersionsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public LKEVersion[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetLongviewClientsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public LongviewClient[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetLongviewSubscriptionsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public LongviewSubscription[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetManagedContactsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ManagedContact[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetManagedCredentialsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ManagedCredential[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class ViewManagedSSHKeyReturn
	{
		
		/// <summary>
		/// The unique SSH public key assigned to your Linode account's Managed service.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssh_key")]
		public string Ssh_key { get; set; }
	}
	
	public class GetManagedIssuesReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ManagedIssue[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetManagedLinodeSettingsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ManagedLinodeSettings[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetManagedServicesReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ManagedService[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetManagedStatsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public string Data { get; set; }
	}
	
	public class GetFirewallsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Firewall[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class UpdateFirewallPutBody
	{
		
		/// <summary>
		/// A resource that controls incoming and outgoing network traffic to a Linode service. Only one Firewall can be attached to a Linode at any given time. [Create a Firewall Device](/docs/api/networking/#firewall-create) to assign a Firewall to a Linode service. Currently, Firewalls can only be assigned to Linode instances.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public Firewall Label { get; set; }
		
		/// <summary>
		/// The status to be applied to this Firewall.
		/// 
		/// * When a Firewall is first created its status is `enabled`.
		/// * Use the [Delete Firewall](/docs/api/networking/#firewall-delete) endpoint to delete a Firewall.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<UpdateFirewallPutBodyStatus> Status { get; set; }
		
		/// <summary>
		/// A resource that controls incoming and outgoing network traffic to a Linode service. Only one Firewall can be attached to a Linode at any given time. [Create a Firewall Device](/docs/api/networking/#firewall-create) to assign a Firewall to a Linode service. Currently, Firewalls can only be assigned to Linode instances.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Firewall Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateFirewallPutBodyStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
	}
	
	public class GetFirewallDevicesReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public FirewallDevices[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetIPsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public IPAddress[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class UpdateIPPutBody
	{
		
		/// <summary>
		/// The reverse DNS assigned to this address. For public IPv4 addresses, this will be set to a default value provided by Linode if not explicitly set.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rdns")]
		public string Rdns { get; set; }
	}
	
	public class GetIPv6PoolsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public IPv6Pool[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetIPv6RangesReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public IPv6Range[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class PostIPv6RangeReturn
	{
		
		/// <summary>
		/// The IPv6 network range, including subnet and prefix length.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="range")]
		public string Range { get; set; }
		
		/// <summary>
		/// The route target IPV6 SLAAC address for this range. Does not include the prefix length.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="route_target")]
		public string Route_target { get; set; }
	}
	
	public class GetVLANsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Vlans[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetNodeBalancersReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NodeBalancer[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetNodeBalancerConfigsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NodeBalancerConfig[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetNodeBalancerConfigNodesReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NodeBalancerNode[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetObjectStorageBucketsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ObjectStorageBucket[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class CreateObjectStorageBucketPostBody
	{
		
		/// <summary>
		/// The Access Control Level of the bucket using a canned ACL string. For more fine-grained control of ACLs, use the S3 API directly.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acl")]
		public System.Nullable<CreateObjectStorageBucketPostBodyAcl> Acl { get; set; }
		
		/// <summary>
		/// The ID of the Object Storage Cluster where this bucket should be created.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cluster")]
		public string Cluster { get; set; }
		
		/// <summary>
		/// If true, the bucket will be created with CORS enabled for all origins. For more fine-grained controls of CORS, use the S3 API directly.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cors_enabled")]
		public System.Nullable<System.Boolean> Cors_enabled { get; set; }
		
		/// <summary>
		/// The name for this bucket. Must be unique in the cluster you are creating the bucket in, or an error will be returned. Labels will be reserved only for the cluster that active buckets are created and stored in. If you want to reserve this bucket's label in another cluster, you must create a new bucket with the same label in the new cluster.
		///
		/// Required
		/// Pattern: ^[a-z0-09][a-z0-9-]*[a-z0-9]?$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-z0-09][a-z0-9-]*[a-z0-9]?$")]
		public string Label { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CreateObjectStorageBucketPostBodyAcl
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public-read")]
		publicMinusread = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="authenticated-read")]
		authenticatedMinusread = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public-read-write")]
		publicMinusreadMinuswrite = 3,
	}
	
	public class GetObjectStorageBucketinClusterReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ObjectStorageBucket[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class ViewObjectStorageBucketACLReturn
	{
		
		/// <summary>
		/// The Access Control Level of the bucket, as a canned ACL string. For more fine-grained control of ACLs, use the S3 API directly.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acl")]
		public System.Nullable<ViewObjectStorageBucketACLReturnAcl> Acl { get; set; }
		
		/// <summary>
		/// The full XML of the object's ACL policy.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acl_xml")]
		public string Acl_xml { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ViewObjectStorageBucketACLReturnAcl
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public-read")]
		publicMinusread = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="authenticated-read")]
		authenticatedMinusread = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public-read-write")]
		publicMinusreadMinuswrite = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 4,
	}
	
	public class UpdateObjectStorageBucketACLReturn
	{
		
		/// <summary>
		/// The Access Control Level of the bucket, as a canned ACL string. For more fine-grained control of ACLs, use the S3 API directly.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acl")]
		public System.Nullable<UpdateObjectStorageBucketACLReturnAcl> Acl { get; set; }
		
		/// <summary>
		/// The full XML of the object's ACL policy.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acl_xml")]
		public string Acl_xml { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateObjectStorageBucketACLReturnAcl
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public-read")]
		publicMinusread = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="authenticated-read")]
		authenticatedMinusread = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public-read-write")]
		publicMinusreadMinuswrite = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 4,
	}
	
	public class GetObjectStorageClustersReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ObjectStorageCluster[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetObjectStorageKeysReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ObjectStorageKey[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class UpdateObjectStorageKeyPutBody
	{
		
		/// <summary>
		/// The label for this keypair, for display purposes only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
	}
	
	public class GetProfileAppsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public AuthorizedApp[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetDevicesReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TrustedDevice[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetProfileLoginsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Login[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class PostProfilePhoneNumberPostBody
	{
		
		/// <summary>
		/// The two-letter ISO 3166 country code associated with the phone number.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="iso_code")]
		public string Iso_code { get; set; }
		
		/// <summary>
		/// A valid phone number.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="phone_number")]
		public string Phone_number { get; set; }
	}
	
	public class PostProfilePhoneNumberVerifyPostBody
	{
		
		/// <summary>
		/// The one-time code received via SMS message after accessing the **Phone Verification Code Send** ([POST /profile/phone-number](/docs/api/profile/#phone-number-verification-code-send)) command.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="otp_code")]
		public string Otp_code { get; set; }
	}
	
	public class GetSSHKeysReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SSHKey[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class UpdateSSHKeyPutBody
	{
		
		/// <summary>
		/// A credential object for authenticating a User's secure shell connection to a Linode.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public SSHKey Label { get; set; }
	}
	
	public class GetPersonalAccessTokensReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public PersonalAccessToken[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetRegionsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Region[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetTicketsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SupportTicket[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetTicketRepliesReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SupportTicketReply[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class GetTagsReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Tag[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class CreateTagPostBody
	{
		
		/// <summary>
		/// A list of Domain IDs to apply the new Tag to.  You must be allowed to `read_write` all of the requested Domains, or the Tag will not be created and an error will be returned.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domains")]
		public int[] Domains { get; set; }
		
		/// <summary>
		/// The new Tag.
		///
		/// Required
		/// Min length: 3
		/// Max length: 50
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(3)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string Label { get; set; }
		
		/// <summary>
		/// A list of Linode IDs to apply the new Tag to.  You must be allowed to `read_write` all of the requested Linodes, or the Tag will not be created and an error will be returned.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linodes")]
		public int[] Linodes { get; set; }
		
		/// <summary>
		/// A list of NodeBalancer IDs to apply the new Tag to. You must be allowed to `read_write` all of the requested NodeBalancers, or the Tag will not be created and an error will be returned.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodebalancers")]
		public int[] Nodebalancers { get; set; }
		
		/// <summary>
		/// A list of Volume IDs to apply the new Tag to.  You must be allowed to `read_write` all of the requested Volumes, or the Tag will not be created and an error will be returned.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumes")]
		public int[] Volumes { get; set; }
	}
	
	public class GetVolumesReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Volume[] Data { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public PaginationEnvelope Page { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public PaginationEnvelope Pages { get; set; }
		
		/// <summary>
		/// An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](/docs/api/#pagination) for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public PaginationEnvelope Results { get; set; }
	}
	
	public class CreateVolumePostBody
	{
		
		/// <summary>
		/// When creating a Volume attached to a Linode, the ID of the Linode Config to include the new Volume in. This Config must belong to the Linode referenced by `linode_id`. Must _not_ be provided if `linode_id` is not sent. If a `linode_id` is sent without a `config_id`, the volume will be attached:
		///
		///  * to the Linode's only config if it only has one config.
		///  * to the Linode's last used config, if possible.
		///
		///If no config can be selected for attachment, an error will be returned.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="config_id")]
		public System.Nullable<System.Int32> Config_id { get; set; }
		
		/// <summary>
		/// The Volume's label, which is also used in the `filesystem_path` of the resulting volume.
		///
		/// Required
		/// Min length: 1
		/// Max length: 32
		/// Pattern: ^[a-zA-Z]((?!--|__)[a-zA-Z0-9-_])+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(32)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z]((?!--|__)[a-zA-Z0-9-_])+$")]
		public string Label { get; set; }
		
		/// <summary>
		/// The Linode this volume should be attached to upon creation. If not given, the volume will be created without an attachment.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linode_id")]
		public System.Nullable<System.Int32> Linode_id { get; set; }
		
		/// <summary>
		/// The Region to deploy this Volume in. This is only required if a linode_id is not given.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The initial size of this volume, in GB.  Be aware that volumes may only be resized up after creation.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		/// <summary>
		/// An array of Tags applied to this object.  Tags are for organizational purposes only.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
	}
	
	public class AttachVolumePostBody
	{
		
		/// <summary>
		/// The ID of the Linode Config to include this Volume in. Must belong to the Linode referenced by `linode_id`. If not given, the last booted Config will be chosen.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="config_id")]
		public System.Nullable<System.Int32> Config_id { get; set; }
		
		/// <summary>
		/// The ID of the Linode to attach the volume to.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="linode_id")]
		public int Linode_id { get; set; }
		
		/// <summary>
		/// Defaults to true, if false is provided, the Volume will not be attached to the Linode Config. In this case more than 8 Volumes may be attached to a Linode if a Linode has 16GB of RAM or more. The number of volumes that can be attached is equal to the number of GB of RAM that the Linode has, up to a maximum of 64. `config_id` should not be passed if this is set to false and linode_id must be passed. The Linode must be running.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="persist_across_boots")]
		public System.Nullable<System.Boolean> Persist_across_boots { get; set; }
	}
	
	public class CloneVolumePostBody
	{
		
		/// <summary>
		/// A Block Storage Volume associated with your Account.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public Volume Label { get; set; }
	}
	
	public class ResizeVolumePostBody
	{
		
		/// <summary>
		/// A Block Storage Volume associated with your Account.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public Volume Size { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
