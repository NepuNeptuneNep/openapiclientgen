//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class _400
	{
		
		/// <summary>
		/// The error code name
		/// Required
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Code { get; set; }
		
		/// <summary>
		/// Errors that may have been generated during the parse, compile, or installation of a policy module
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public _400Errors[] _400Errors { get; set; }
		
		/// <summary>
		/// The description of the error
		/// Required
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Message { get; set; }
	}
	
	public class _400Errors
	{
		
		/// <summary>
		/// The error code name
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Code { get; set; }
		
		/// <summary>
		/// Where the error occurred
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public _400ErrorsLocation Location { get; set; }
		
		/// <summary>
		/// A general description of the error
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Message { get; set; }
	}
	
	public class _400ErrorsLocation
	{
		
		/// <summary>
		/// The column in the policy module where the error occurred
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="col")]
		public System.Nullable<System.Double> Col { get; set; }
		
		/// <summary>
		/// The policy module name that generated the error
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="file")]
		public string File { get; set; }
		
		/// <summary>
		/// The line number in the policy module where the error occurred
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="row")]
		public System.Nullable<System.Double> Row { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class _404
	{
		
		/// <summary>
		/// The error code name
		/// Required
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Code { get; set; }
		
		/// <summary>
		/// The description of the error (including the name of any undefined policy module)
		/// Required
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class _200Explanations
	{
		
		[System.Runtime.Serialization.DataMember(Name="explanation")]
		public _200ExplanationsExplanation[] _200ExplanationsExplanation { get; set; }
	}
	
	public class _200ExplanationsExplanation
	{
		
		/// <summary>
		/// The query's term bindings at the point when the trace event was emitted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locals")]
		public _200ExplanationsExplanationLocals[] _200ExplanationsExplanationLocals { get; set; }
		
		/// <summary>
		/// The AST element associated with the evaluation step.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="node")]
		public _200ExplanationsExplanationNode Node { get; set; }
		
		/// <summary>
		/// The kind of *trace event*
		///
		///Each trace event represents a step in the query evaluation process. Trace events are emitted at the following points:
		///- enter - before a body or rule is evaluated
		///- exit - after a body or rule has evaluated successfully
		///- eval - before an expression is evaluated
		///- fail - after an expression has evaluated to false.
		///- redo - before evaluation restarts from a body, rule, or expression.
		///
		///By default, OPA searches for all sets of term bindings that make all expressions in the query evaluate to true. Because there may be multiple answers, the search can restart when OPA determines the query is true or false. When the search restarts, a *redo trace event* is emitted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="op")]
		public System.Nullable<_200ExplanationsExplanationOp> Op { get; set; }
		
		/// <summary>
		/// The parent query. Use this field to identify trace events from related queries.
		///
		///For example, if query A references rule R, trace events emitted when evaluating rule R will have the *parent_id* field set to query Aâ€™s *query_id*.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parent_id")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> Parent_id { get; set; }
		
		/// <summary>
		/// The query that the trace event was emitted for. Use this field to distinguish trace events emitted by from different queries.
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="query_id")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> Query_id { get; set; }
		
		/// <summary>
		/// The type of the **node** field
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<_200ExplanationsExplanationType> Type { get; set; }
	}
	
	public class _200ExplanationsExplanationLocals
	{
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public _200ExplanationsExplanationLocalsKey Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public _200ExplanationsExplanationLocalsValue Value { get; set; }
	}
	
	public class _200ExplanationsExplanationLocalsKey
	{
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class _200ExplanationsExplanationLocalsValue
	{
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class _200ExplanationsExplanationNode
	{
		
		/// <summary>
		/// Node number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="index")]
		public System.Nullable<System.Double> Index { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="terms")]
		public _200ExplanationsExplanationNodeTerms[] _200ExplanationsExplanationNodeTerms { get; set; }
	}
	
	public class _200ExplanationsExplanationNodeTerms
	{
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum _200ExplanationsExplanationOp
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enter = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		exit = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eval = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		fail = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		redo = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum _200ExplanationsExplanationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		expr = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rule = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		body = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class _200Metrics
	{
		
		[System.Runtime.Serialization.DataMember(Name="metrics")]
		public _200MetricsMetrics Metrics { get; set; }
	}
	
	public class _200MetricsMetrics
	{
		
		/// <summary>
		/// *Description is forthcoming*
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="counter_server_query_cache_hit")]
		public System.Nullable<System.Double> Counter_server_query_cache_hit { get; set; }
		
		/// <summary>
		/// (Only returned if `instrument` is true.) *Description is forthcoming*
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_query_compile_stage_build_comprehension_index_ns")]
		public System.Nullable<System.Double> Timer_query_compile_stage_build_comprehension_index_ns { get; set; }
		
		/// <summary>
		/// (Only returned if `instrument` is true.) *Description is forthcoming*
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_query_compile_stage_check_safety_ns")]
		public System.Nullable<System.Double> Timer_query_compile_stage_check_safety_ns { get; set; }
		
		/// <summary>
		/// (Only returned if `instrument` is true.) *Description is forthcoming*
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_query_compile_stage_check_types_ns")]
		public System.Nullable<System.Double> Timer_query_compile_stage_check_types_ns { get; set; }
		
		/// <summary>
		/// (Only returned if `instrument` is true.) *Description is forthcoming*
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_query_compile_stage_check_undefined_funcs_ns")]
		public System.Nullable<System.Double> Timer_query_compile_stage_check_undefined_funcs_ns { get; set; }
		
		/// <summary>
		/// (Only returned if `instrument` is true.) *Description is forthcoming*
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_query_compile_stage_check_unsafe_builtins_ns")]
		public System.Nullable<System.Double> Timer_query_compile_stage_check_unsafe_builtins_ns { get; set; }
		
		/// <summary>
		/// (Only returned if `instrument` is true.) *Description is forthcoming*
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_query_compile_stage_resolve_refs_ns")]
		public System.Nullable<System.Double> Timer_query_compile_stage_resolve_refs_ns { get; set; }
		
		/// <summary>
		/// (Only returned if `instrument` is true.) *Description is forthcoming*
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_query_compile_stage_rewrite_comprehension_terms_ns")]
		public System.Nullable<System.Double> Timer_query_compile_stage_rewrite_comprehension_terms_ns { get; set; }
		
		/// <summary>
		/// (Only returned if `instrument` is true.) *Description is forthcoming*
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_query_compile_stage_rewrite_dynamic_terms_ns")]
		public System.Nullable<System.Double> Timer_query_compile_stage_rewrite_dynamic_terms_ns { get; set; }
		
		/// <summary>
		/// (Only returned if `instrument` is true.) *Description is forthcoming*
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_query_compile_stage_rewrite_expr_terms_ns")]
		public System.Nullable<System.Double> Timer_query_compile_stage_rewrite_expr_terms_ns { get; set; }
		
		/// <summary>
		/// (Only returned if `instrument` is true.) *Description is forthcoming*
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_query_compile_stage_rewrite_local_vars_ns")]
		public System.Nullable<System.Double> Timer_query_compile_stage_rewrite_local_vars_ns { get; set; }
		
		/// <summary>
		/// (Only returned if `instrument` is true.) *Description is forthcoming*
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_query_compile_stage_rewrite_to_capture_value_ns")]
		public System.Nullable<System.Double> Timer_query_compile_stage_rewrite_to_capture_value_ns { get; set; }
		
		/// <summary>
		/// (Only returned if `instrument` is true.) *Description is forthcoming*
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_query_compile_stage_rewrite_with_values_ns")]
		public System.Nullable<System.Double> Timer_query_compile_stage_rewrite_with_values_ns { get; set; }
		
		/// <summary>
		/// Time taken (in nanonseconds) to parse the input
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_rego_input_parse_ns")]
		public System.Nullable<System.Double> Timer_rego_input_parse_ns { get; set; }
		
		/// <summary>
		/// Time taken (in nanonseconds) to compile the loaded policy modules
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_rego_module_compile_ns")]
		public System.Nullable<System.Double> Timer_rego_module_compile_ns { get; set; }
		
		/// <summary>
		/// Time taken (in nanoseconds) to parse the input policy module
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_rego_module_parse_ns")]
		public System.Nullable<System.Double> Timer_rego_module_parse_ns { get; set; }
		
		/// <summary>
		/// Time taken (in nanoseconds) to compile the query
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_rego_query_compile_ns")]
		public System.Nullable<System.Double> Timer_rego_query_compile_ns { get; set; }
		
		/// <summary>
		/// Time taken (in nanonseconds) to evaluate the query
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_rego_query_eval_ns")]
		public System.Nullable<System.Double> Timer_rego_query_eval_ns { get; set; }
		
		/// <summary>
		/// Time taken (in nanoseconds) to parse the query
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_rego_query_parse_ns")]
		public System.Nullable<System.Double> Timer_rego_query_parse_ns { get; set; }
		
		/// <summary>
		/// Time taken (in nanoseconds) to handle the API request
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_server_handler_ns")]
		public System.Nullable<System.Double> Timer_server_handler_ns { get; set; }
		
		/// <summary>
		/// *Description is forthcoming*
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timer_server_read_bytes_ns")]
		public System.Nullable<System.Double> Timer_server_read_bytes_ns { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class _200Provenance
	{
		
		[System.Runtime.Serialization.DataMember(Name="provenance")]
		public _200ProvenanceProvenance Provenance { get; set; }
	}
	
	public class _200ProvenanceProvenance
	{
		
		/// <summary>
		/// The Git commit id of this OPA build.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="build_commit")]
		public string Build_commit { get; set; }
		
		/// <summary>
		/// The hostname where this instance was built.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="build_hostname")]
		public string Build_hostname { get; set; }
		
		/// <summary>
		/// When this OPA instance was built (in [ISO8601 format](https://www.w3.org/TR/NOTE-datetime))
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="build_timestamp")]
		public string Build_timestamp { get; set; }
		
		/// <summary>
		/// A set of key-value pairs describing each bundle activated on the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bundles")]
		public System.Collections.Generic.Dictionary<string, object> Bundles { get; set; }
		
		/// <summary>
		/// The version of this OPA instance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class _200Result
	{
		
		[System.Runtime.Serialization.DataMember(Name="result")]
		public _200ResultResult[] _200ResultResult { get; set; }
	}
	
	public class _200ResultResult
	{
		
		/// <summary>
		/// The types for declarations and runtime objects passed to your implementation. This consists of an abstract syntax tree (AST) of policy modules, package and import declarations, rules, expressions, and terms.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ast")]
		public _200ResultResultAst Ast { get; set; }
		
		/// <summary>
		/// The name of a policy module
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Id { get; set; }
		
		/// <summary>
		/// A string representation of the full Rego policy
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="raw")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Raw { get; set; }
	}
	
	public class _200ResultResultAst
	{
		
		[System.Runtime.Serialization.DataMember(Name="package")]
		public _200ResultResultAstPackage Package { get; set; }
		
		/// <summary>
		/// When OPA evaluates a rule, it generates the content of a [virtual documents](https://www.openpolicyagent.org/docs/latest/philosophy/#the-opa-document-model)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public _200ResultResultAstRules[] _200ResultResultAstRules { get; set; }
	}
	
	public class _200ResultResultAstPackage
	{
		
		/// <summary>
		/// The path to the package
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public _200ResultResultAstPackagePath[] _200ResultResultAstPackagePath { get; set; }
	}
	
	public class _200ResultResultAstPackagePath
	{
		
		/// <summary>
		/// The type of the path operation
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<_200ResultResultAstPackagePathType> Type { get; set; }
		
		/// <summary>
		/// The path variable
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum _200ResultResultAstPackagePathType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		import = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		package = 1,
	}
	
	public class _200ResultResultAstRules
	{
		
		/// <summary>
		/// A list of the terms in this rule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public _200ResultResultAstRulesBody[] _200ResultResultAstRulesBody { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="head")]
		public _200ResultResultAstRulesHead Head { get; set; }
	}
	
	public class _200ResultResultAstRulesBody
	{
		
		/// <summary>
		/// The location of this term in the list (starts at 0)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="index")]
		public System.Nullable<System.Double> Index { get; set; }
		
		/// <summary>
		/// The type/value pairing for this term
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="terms")]
		public _200ResultResultAstRulesBodyTerms[] _200ResultResultAstRulesBodyTerms { get; set; }
	}
	
	public class _200ResultResultAstRulesBodyTerms
	{
		
		/// <summary>
		/// The type of the term variable
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// The list of types and values for the term variable
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public _200ResultResultAstRulesBodyTermsValue[] _200ResultResultAstRulesBodyTermsValue { get; set; }
	}
	
	public class _200ResultResultAstRulesBodyTermsValue
	{
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class _200ResultResultAstRulesHead
	{
		
		/// <summary>
		/// The type/value pairing for this rule's head
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public _200ResultResultAstRulesHeadKey Key { get; set; }
		
		/// <summary>
		/// The head of the rule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class _200ResultResultAstRulesHeadKey
	{
		
		/// <summary>
		/// The type of the head
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// The value of the head
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class _200SingleResult
	{
		
		[System.Runtime.Serialization.DataMember(Name="result")]
		public _200SingleResultResult Result { get; set; }
	}
	
	public class _200SingleResultResult
	{
		
		/// <summary>
		/// Bundles
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bundles")]
		public _200SingleResultResultBundles Bundles { get; set; }
		
		/// <summary>
		/// Logs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="decision_logs")]
		public _200SingleResultResultDecision_logs Decision_logs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="default_authorization_decision")]
		public string Default_authorization_decision { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="default_decision")]
		public string Default_decision { get; set; }
		
		/// <summary>
		/// Keys
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="keys")]
		public _200SingleResultResultKeys Keys { get; set; }
		
		/// <summary>
		/// Labels
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public _200SingleResultResultLabels Labels { get; set; }
		
		/// <summary>
		/// The types of services
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="services")]
		public _200SingleResultResultServices Services { get; set; }
		
		/// <summary>
		/// Status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public _200SingleResultResultStatus Status { get; set; }
	}
	
	public class _200SingleResultResultBundles
	{
		
		/// <summary>
		/// Auth
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authz")]
		public _200SingleResultResultBundlesAuthz Authz { get; set; }
	}
	
	public class _200SingleResultResultBundlesAuthz
	{
		
		/// <summary>
		/// Service
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Service { get; set; }
	}
	
	public class _200SingleResultResultDecision_logs
	{
		
		/// <summary>
		/// Service
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Service { get; set; }
	}
	
	public class _200SingleResultResultKeys
	{
		
		/// <summary>
		/// Global Key
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="global-key")]
		public _200SingleResultResultKeysGlobal_key Global_key { get; set; }
	}
	
	public class _200SingleResultResultKeysGlobal_key
	{
		
		/// <summary>
		/// Scope
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scope")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Scope { get; set; }
	}
	
	public class _200SingleResultResultLabels
	{
		
		/// <summary>
		/// Label ID
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Id { get; set; }
		
		/// <summary>
		/// Version
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Version { get; set; }
	}
	
	public class _200SingleResultResultServices
	{
		
		[System.Runtime.Serialization.DataMember(Name="acmecorp")]
		public _200SingleResultResultServicesAcmecorp Acmecorp { get; set; }
	}
	
	public class _200SingleResultResultServicesAcmecorp
	{
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class _200SingleResultResultStatus
	{
		
		/// <summary>
		/// Service
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Service { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DataSchema
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InputSchema
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PartialQuerySchema
	{
	}
	
	/// <summary>
	/// A JSON patch operation
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PatchesSchemaElement
	{
		
		/// <summary>
		/// JSON patch operation type
		/// Required
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="op")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PatchesSchemaElementOp Op { get; set; }
		
		/// <summary>
		/// A [JSON pointer](https://tools.ietf.org/html/rfc6901) to a location within the target document where the operation is performed.
		///
		///The *effective path* is this value prefixed with the API call's `path` parameter.
		///
		///The server will return a *bad request* (404) response if:
		///
		///- The *parent* of the effective path does not refer to an existing document
		///- For **remove** and **replace** operations, the effective path does not refer to an existing document.
		/// Required
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Path { get; set; }
		
		/// <summary>
		/// The value to add, replace or test.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Collections.Generic.Dictionary<string, object> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PatchesSchemaElementOp
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		add = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		remove = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		replace = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		move = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		copy = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		test = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class QSchema
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class QueryInputSchema
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WebhookInputSchema
	{
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Execute a simple query
		/// This API queries the document at */data/system/main* by default (however, you can [configure OPA](https://www.openpolicyagent.org/docs/latest/configuration/) to use a different path to serve these queries). That document defines the response.
		/// For example, use the following in `PUT /v1/policies/{path}`) to define a rule that will produce a value for the */data/system/main* document:
		/// 
		/// ```yaml
		/// package system
		/// main = msg {
		/// msg := sprintf("hello, %v", input.user)
		/// }
		/// ```
		/// 
		/// The server will return a *not found* (404) response if */data/system/main* is undefined.
		/// PostSimpleQuery 
		/// </summary>
		/// <param name="pretty">If true, response will be in a human-readable format.</param>
		/// <param name="requestBody">The text of the input document (in JSON format)</param>
		/// <returns>Success</returns>
		public async Task PostSimpleQueryAsync(bool pretty, QueryInputSchema requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "?pretty="+pretty;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Health
		/// This API endpoint verifies that the server is operational.
		/// 
		/// The response from the server is either 200 or 500:
		/// - **200** - OPA service is healthy. If `bundles` is true, then all configured bundles have been activated. If `plugins` is true, then all plugins are in an 'OK' state.
		/// - **500** - OPA service is *not* healthy. If `bundles` is true, at least one of configured bundles has not yet been activated. If `plugins` is true, at least one plugins is in a 'not OK' state.
		/// 
		/// ---
		/// **Note**
		/// This check is only for initial bundle activation. Subsequent downloads will not affect the health check.
		/// 
		/// Use the **status** endpoint (in the (management API)[management.html]) for more fine-grained bundle status monitoring.
		/// 
		/// ---
		/// GetHealth health
		/// </summary>
		/// <param name="bundles">Reports on bundle activation status (useful for 'ready' checks at startup).
		///
		///This includes any discovery bundles or bundles defined in the loaded discovery configuration.</param>
		/// <param name="plugins">Reports on plugin status</param>
		/// <returns>OPA service is healthy</returns>
		public async Task GetHealthAsync(bool bundles, bool plugins, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "health?bundles="+bundles+"&plugins="+plugins;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Compile
		/// This API endpoint allows you to partially evaluate Rego queries and obtain a simplified version of the policy. The example below assumes that OPA has been given the following policy (use `PUT /v1/policies/{path}`):
		/// 
		/// ```yaml
		/// package example
		/// allow {
		/// input.subject.clearance_level >= data.reports[_].clearance_level
		/// }
		/// ```
		/// Compile API **request body** so that it contain the following fields:
		/// 
		/// | Field | Type | Required | Description |
		/// | --- | --- | --- | --- |
		/// | `query` | `string` | Yes | The query to partially evaluate and compile. |
		/// | `input` | `any` | No | The input document to use during partial evaluation (default: undefined). |
		/// | `unknowns` | `array[string]` | No | The terms to treat as unknown during partial evaluation (default: `["input"]`]). |
		/// 
		/// For example:
		/// 
		/// ```json
		/// {
		/// "query": "data.example.allow == true",
		/// "input": {
		/// "subject": {
		/// "clearance_level": 4
		/// }
		/// },
		/// "unknowns": [
		/// "data.reports"
		/// ]
		/// }
		/// ```
		/// ### Partial evaluation
		/// In some cases, the result of partial valuation is a conclusive, unconditional answer. See [the guidance](https://www.openpolicyagent.org/docs/latest/rest-api/#unconditional-results-from-partial-evaluation) for details.
		/// PostCompile v1/compile
		/// </summary>
		/// <param name="pretty">If true, response will be in a human-readable format.</param>
		/// <param name="explain">If set to *full*, response will include query explanations in addition to the result.</param>
		/// <param name="metrics">If true, compiler performance metrics will be returned in the response.</param>
		/// <param name="instrument">If true, response will return additional performance metrics in addition to the result and the standard metrics.
		///
		///**Caution:** This can add significant overhead to query evaluation. The recommendation is to only use this parameter if you are debugging a performance problem.</param>
		/// <param name="requestBody">The query (in JSON format)</param>
		/// <returns>Success</returns>
		public async Task<_200Result> PostCompileAsync(bool pretty, string explain, bool metrics, bool instrument, PartialQuerySchema requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/compile?pretty="+pretty+"&explain=" + (explain==null? "" : System.Uri.EscapeDataString(explain))+"&metrics="+metrics+"&instrument="+instrument;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<_200Result>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get configurations
		/// This API endpoint responds with active configuration (result response)
		/// 
		/// ---
		/// **Note**
		/// The `credentials` field in the `services` configuration and
		/// 
		/// The `private_key` and `key` fields in the `keys` configuration will be omitted from the API response
		/// 
		/// ---
		/// GetConfig v1/config
		/// </summary>
		/// <param name="pretty">If true, response will be in a human-readable format.</param>
		/// <returns>Success</returns>
		public async Task<_200SingleResult> GetConfigAsync(bool pretty, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/config?pretty="+pretty;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<_200SingleResult>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a document
		/// This API endpoint deletes an existing document from the server
		/// DeleteDocument v1/data/{path}
		/// </summary>
		public async Task DeleteDocumentAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/data/{path}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a document
		/// This API endpoint returns the document specified by `path`.
		/// 
		/// The server will return a *bad request* (400) response if either:
		/// - The query requires an input document and you do not provide it
		/// - You provide the input document but the query has already defined it.
		/// GetDocument v1/data/{path}
		/// </summary>
		/// <param name="input">Provide the text for an [input document](https://www.openpolicyagent.org/docs/latest/kubernetes-primer/#input-document) in JSON format</param>
		/// <param name="pretty">If true, response will be in a human-readable format.</param>
		/// <param name="provenance">If true, response will include build and version information in addition to the result.</param>
		/// <param name="explain">If set to *full*, response will include query explanations in addition to the result.</param>
		/// <param name="metrics">If true, compiler performance metrics will be returned in the response.</param>
		/// <param name="instrument">If true, response will return additional performance metrics in addition to the result and the standard metrics.
		///
		///**Caution:** This can add significant overhead to query evaluation. The recommendation is to only use this parameter if you are debugging a performance problem.</param>
		/// <returns>Success</returns>
		public async Task<_200Result> GetDocumentAsync(System.Collections.Generic.Dictionary<string, object> input, bool pretty, bool provenance, string explain, bool metrics, bool instrument, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/data/{path}?input=" + input+"&pretty="+pretty+"&provenance="+provenance+"&explain=" + (explain==null? "" : System.Uri.EscapeDataString(explain))+"&metrics="+metrics+"&instrument="+instrument;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<_200Result>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Update a document
		/// This API endpoint updates an existing document on the server by describing the changes required (using [JSON patch operations](http://jsonpatch.com/))
		/// PatchDocument v1/data/{path}
		/// </summary>
		/// <param name="requestBody">The list of JSON patch operations.</param>
		public async Task PatchDocumentAsync(PatchDocumentPatchBody[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/data/{path}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create or overwrite a document
		/// If the path does not refer to an existing document (for example *us-west/servers*), the server will attempt to create all the necessary containing documents.
		/// 
		/// This behavior is similar to the Unix command [mkdir -p](https://en.wikipedia.org/wiki/Mkdir#Options).
		/// PutDocument v1/data/{path}
		/// </summary>
		/// <param name="requestBody">The JSON document to write to the specified path.</param>
		public async Task PutDocumentAsync(DataSchema requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/data/{path}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List policies
		/// This API endpoint responds with a list of all policy modules on the server (result response)
		/// GetPolicies v1/policies
		/// </summary>
		/// <param name="pretty">If true, response will be in a human-readable format.</param>
		/// <returns>Success</returns>
		public async Task<_200Result> GetPoliciesAsync(bool pretty, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/policies?pretty="+pretty;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<_200Result>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a policy module
		/// This API endpoint removes an existing policy module from the server
		/// DeletePolicyModule v1/policies/{id}
		/// </summary>
		/// <param name="pretty">If true, response will be in a human-readable format.</param>
		/// <returns>Success</returns>
		public async Task<_200Result> DeletePolicyModuleAsync(bool pretty, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/policies/{id}?pretty="+pretty;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<_200Result>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a policy module
		/// This API endpoint returns the details of the specified policy module (`{id}`)
		/// GetPolicyModule v1/policies/{id}
		/// </summary>
		/// <param name="pretty">If true, response will be in a human-readable format.</param>
		/// <returns>Success</returns>
		public async Task<_200Result> GetPolicyModuleAsync(bool pretty, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/policies/{id}?pretty="+pretty;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<_200Result>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Execute an ad-hoc query (simple)
		/// This API endpoint returns bindings for the variables in the query.
		/// 
		/// For more complex JSON queries, use `POST /v1/query` instead.
		/// GetQuery v1/query
		/// </summary>
		/// <param name="q">The [URL-encoded](https://www.w3schools.com/tags/ref_urlencode.ASP) ad-hoc query to execute.</param>
		/// <param name="pretty">If true, response will be in a human-readable format.</param>
		/// <param name="explain">If set to *full*, response will include query explanations in addition to the result.</param>
		/// <param name="metrics">If true, compiler performance metrics will be returned in the response.</param>
		/// <returns>Success</returns>
		public async Task<_200Result> GetQueryAsync(string q, bool pretty, string explain, bool metrics, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/query?q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&pretty="+pretty+"&explain=" + (explain==null? "" : System.Uri.EscapeDataString(explain))+"&metrics="+metrics;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<_200Result>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
	}
	
	public class PatchDocumentPatchBody
	{
		
		/// <summary>
		/// JSON patch operation type
		/// Required
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="op")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PatchesSchemaElementOp Op { get; set; }
		
		/// <summary>
		/// A [JSON pointer](https://tools.ietf.org/html/rfc6901) to a location within the target document where the operation is performed.
		///
		///The *effective path* is this value prefixed with the API call's `path` parameter.
		///
		///The server will return a *bad request* (404) response if:
		///
		///- The *parent* of the effective path does not refer to an existing document
		///- For **remove** and **replace** operations, the effective path does not refer to an existing document.
		/// Required
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string Path { get; set; }
		
		/// <summary>
		/// The value to add, replace or test.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Collections.Generic.Dictionary<string, object> Value { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
