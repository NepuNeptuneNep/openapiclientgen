//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// A request to add assets to a group.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AddAssetsToGroupRequest
	{
		
		/// <summary>
		/// Optional. When this value is set to `false` and one of the given assets is already an existing member of the group, the operation fails with an `Already Exists` error. When set to `true` this situation is silently ignored by the server. Default value is `false`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowExisting")]
		public System.Nullable<System.Boolean> AllowExisting { get; set; }
		
		/// <summary>
		/// Lists the asset IDs of all assets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public AssetList Assets { get; set; }
		
		/// <summary>
		/// Optional. An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes after the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestId")]
		public string RequestId { get; set; }
	}
	
	/// <summary>
	/// Lists the asset IDs of all assets.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AssetList
	{
		
		/// <summary>
		/// Required. A list of asset IDs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetIds")]
		public string[] AssetIds { get; set; }
	}
	
	/// <summary>
	/// A request to aggregate one or more values.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AggregateAssetsValuesRequest
	{
		
		/// <summary>
		/// Array of aggregations to perform. Up to 25 aggregations can be defined.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aggregations")]
		public Aggregation[] Aggregations { get; set; }
		
		/// <summary>
		/// The aggregation will be performed on assets that match the provided filter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filter")]
		public string Filter { get; set; }
	}
	
	/// <summary>
	/// Message describing an aggregation. The message includes the aggregation type, parameters, and the field on which to perform the aggregation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Aggregation
	{
		
		/// <summary>
		/// Object count.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public AggregationCount Count { get; set; }
		
		/// <summary>
		/// The name of the field on which to aggregate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="field")]
		public string Field { get; set; }
		
		/// <summary>
		/// Frequency distribution of all field values.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="frequency")]
		public AggregationFrequency Frequency { get; set; }
		
		/// <summary>
		/// Histogram of bucketed assets counts by field value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="histogram")]
		public AggregationHistogram Histogram { get; set; }
		
		/// <summary>
		/// Sum of field values.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sum")]
		public AggregationSum Sum { get; set; }
	}
	
	/// <summary>
	/// Object count.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AggregationCount
	{
	}
	
	/// <summary>
	/// Frequency distribution of all field values.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AggregationFrequency
	{
	}
	
	/// <summary>
	/// Histogram of bucketed assets counts by field value.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AggregationHistogram
	{
		
		/// <summary>
		/// Lower bounds of buckets. The response will contain `n+1` buckets for `n` bounds. The first bucket will count all assets for which the field value is smaller than the first bound. Subsequent buckets will count assets for which the field value is greater or equal to a lower bound and smaller than the next one. The last bucket will count assets for which the field value is greater or equal to the final lower bound. You can define up to 20 lower bounds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lowerBounds")]
		public double[] LowerBounds { get; set; }
	}
	
	/// <summary>
	/// Sum of field values.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AggregationSum
	{
	}
	
	/// <summary>
	/// A response to a request to aggregated assets values.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AggregateAssetsValuesResponse
	{
		
		/// <summary>
		/// The aggregation results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public AggregationResult[] Results { get; set; }
	}
	
	/// <summary>
	/// Message describing a result of an aggregation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AggregationResult
	{
		
		/// <summary>
		/// The result of a count aggregation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public AggregationResultCount Count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="field")]
		public string Field { get; set; }
		
		/// <summary>
		/// The result of a frequency distribution aggregation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="frequency")]
		public AggregationResultFrequency Frequency { get; set; }
		
		/// <summary>
		/// The result of a bucketed histogram aggregation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="histogram")]
		public AggregationResultHistogram Histogram { get; set; }
		
		/// <summary>
		/// The result of a sum aggregation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sum")]
		public AggregationResultSum Sum { get; set; }
	}
	
	/// <summary>
	/// The result of a count aggregation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AggregationResultCount
	{
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// The result of a frequency distribution aggregation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AggregationResultFrequency
	{
		
		[System.Runtime.Serialization.DataMember(Name="values")]
		public System.Collections.Generic.Dictionary<string, string> Values { get; set; }
	}
	
	/// <summary>
	/// The result of a bucketed histogram aggregation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AggregationResultHistogram
	{
		
		/// <summary>
		/// Buckets in the histogram. There will be `n+1` buckets matching `n` lower bounds in the request. The first bucket will be from -infinity to the first bound. Subsequent buckets will be between one bound and the next. The final bucket will be from the final bound to infinity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="buckets")]
		public AggregationResultHistogramBucket[] Buckets { get; set; }
	}
	
	/// <summary>
	/// A histogram bucket with a lower and upper bound, and a count of items with a field value between those bounds. The lower bound is inclusive and the upper bound is exclusive. Lower bound may be -infinity and upper bound may be infinity.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AggregationResultHistogramBucket
	{
		
		/// <summary>
		/// Count of items in the bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public string Count { get; set; }
		
		/// <summary>
		/// Lower bound - inclusive.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lowerBound")]
		public System.Nullable<System.Double> LowerBound { get; set; }
		
		/// <summary>
		/// Upper bound - exclusive.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upperBound")]
		public System.Nullable<System.Double> UpperBound { get; set; }
	}
	
	/// <summary>
	/// The result of a sum aggregation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AggregationResultSum
	{
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Double> Value { get; set; }
	}
	
	/// <summary>
	/// An asset represents a resource in your environment. Asset types include virtual machines and databases.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Asset
	{
		
		/// <summary>
		/// Output only. The list of groups that the asset is assigned to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignedGroups")]
		public string[] AssignedGroups { get; set; }
		
		/// <summary>
		/// Generic asset attributes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="attributes")]
		public System.Collections.Generic.Dictionary<string, string> Attributes { get; set; }
		
		/// <summary>
		/// Output only. The timestamp when the asset was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Message containing insights list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="insightList")]
		public InsightList InsightList { get; set; }
		
		/// <summary>
		/// Labels as key value pairs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Details of a machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineDetails")]
		public MachineDetails MachineDetails { get; set; }
		
		/// <summary>
		/// Output only. The full name of the asset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Performance data for an asset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="performanceData")]
		public AssetPerformanceData PerformanceData { get; set; }
		
		/// <summary>
		/// Output only. The list of sources contributing to the asset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sources")]
		public string[] Sources { get; set; }
		
		/// <summary>
		/// Output only. The timestamp when the asset was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// Message containing insights list.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InsightList
	{
		
		/// <summary>
		/// Output only. Insights of the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="insights")]
		public Insight[] Insights { get; set; }
		
		/// <summary>
		/// Output only. Update timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// An insight about an asset.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Insight
	{
		
		/// <summary>
		/// A generic insight about an asset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="genericInsight")]
		public GenericInsight GenericInsight { get; set; }
		
		/// <summary>
		/// An insight about potential migrations for an asset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="migrationInsight")]
		public MigrationInsight MigrationInsight { get; set; }
	}
	
	/// <summary>
	/// A generic insight about an asset.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GenericInsight
	{
		
		/// <summary>
		/// Output only. Additional information about the insight, each entry can be a logical entry and must make sense if it is displayed with line breaks between each entry. Text can contain md style links.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalInformation")]
		public string[] AdditionalInformation { get; set; }
		
		/// <summary>
		/// Output only. In case message_code is not yet known by the client default_message will be the message to be used instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultMessage")]
		public string DefaultMessage { get; set; }
		
		/// <summary>
		/// Output only. Represents a globally unique message id for this insight, can be used for localization purposes, in case message_code is not yet known by the client use default_message instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="messageId")]
		public string MessageId { get; set; }
	}
	
	/// <summary>
	/// An insight about potential migrations for an asset.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MigrationInsight
	{
		
		/// <summary>
		/// Compute engine migration target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computeEngineTarget")]
		public ComputeEngineMigrationTarget ComputeEngineTarget { get; set; }
		
		/// <summary>
		/// Describes the fit level of an asset for migration to a specific target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fit")]
		public FitDescriptor Fit { get; set; }
	}
	
	/// <summary>
	/// Compute engine migration target.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ComputeEngineMigrationTarget
	{
		
		/// <summary>
		/// Compute Engine target shape descriptor.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shape")]
		public ComputeEngineShapeDescriptor Shape { get; set; }
	}
	
	/// <summary>
	/// Compute Engine target shape descriptor.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ComputeEngineShapeDescriptor
	{
		
		/// <summary>
		/// Number of logical cores.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logicalCoreCount")]
		public System.Nullable<System.Int32> LogicalCoreCount { get; set; }
		
		/// <summary>
		/// Compute Engine machine type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineType")]
		public string MachineType { get; set; }
		
		/// <summary>
		/// Memory in mebibytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memoryMb")]
		public System.Nullable<System.Int32> MemoryMb { get; set; }
		
		/// <summary>
		/// Number of physical cores.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="physicalCoreCount")]
		public System.Nullable<System.Int32> PhysicalCoreCount { get; set; }
		
		/// <summary>
		/// Compute Engine machine series.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="series")]
		public string Series { get; set; }
		
		/// <summary>
		/// Compute Engine storage. Never empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storage")]
		public ComputeStorageDescriptor[] Storage { get; set; }
	}
	
	/// <summary>
	/// Compute Engine storage option descriptor.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ComputeStorageDescriptor
	{
		
		/// <summary>
		/// Disk size in GiB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sizeGb")]
		public System.Nullable<System.Int32> SizeGb { get; set; }
		
		/// <summary>
		/// Disk type backing the storage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<ComputeStorageDescriptorType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ComputeStorageDescriptorType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PERSISTENT_DISK_TYPE_UNSPECIFIED")]
		PERSISTENT_DISK_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PERSISTENT_DISK_TYPE_STANDARD")]
		PERSISTENT_DISK_TYPE_STANDARD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PERSISTENT_DISK_TYPE_BALANCED")]
		PERSISTENT_DISK_TYPE_BALANCED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PERSISTENT_DISK_TYPE_SSD")]
		PERSISTENT_DISK_TYPE_SSD = 3,
	}
	
	/// <summary>
	/// Describes the fit level of an asset for migration to a specific target.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FitDescriptor
	{
		
		/// <summary>
		/// Fit level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fitLevel")]
		public System.Nullable<FitDescriptorFitLevel> FitLevel { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum FitDescriptorFitLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FIT_LEVEL_UNSPECIFIED")]
		FIT_LEVEL_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FIT")]
		FIT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NO_FIT")]
		NO_FIT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="REQUIRES_EFFORT")]
		REQUIRES_EFFORT = 3,
	}
	
	/// <summary>
	/// Details of a machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MachineDetails
	{
		
		/// <summary>
		/// Details of the machine architecture.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="architecture")]
		public MachineArchitectureDetails Architecture { get; set; }
		
		/// <summary>
		/// Number of CPU cores in the machine. Must be non-negative.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="coreCount")]
		public System.Nullable<System.Int32> CoreCount { get; set; }
		
		/// <summary>
		/// Machine creation time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Details of machine disks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public MachineDiskDetails Disks { get; set; }
		
		/// <summary>
		/// Information from Guest-level collections.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestOs")]
		public GuestOsDetails GuestOs { get; set; }
		
		/// <summary>
		/// Machine name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineName")]
		public string MachineName { get; set; }
		
		/// <summary>
		/// The amount of memory in the machine. Must be non-negative.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memoryMb")]
		public System.Nullable<System.Int32> MemoryMb { get; set; }
		
		/// <summary>
		/// Details of network adapters and settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public MachineNetworkDetails Network { get; set; }
		
		/// <summary>
		/// Information about the platform.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platform")]
		public PlatformDetails Platform { get; set; }
		
		/// <summary>
		/// Power state of the machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="powerState")]
		public System.Nullable<MachineDetailsPowerState> PowerState { get; set; }
		
		/// <summary>
		/// Machine unique identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uuid")]
		public string Uuid { get; set; }
	}
	
	/// <summary>
	/// Details of the machine architecture.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MachineArchitectureDetails
	{
		
		/// <summary>
		/// Details about the BIOS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bios")]
		public BiosDetails Bios { get; set; }
		
		/// <summary>
		/// CPU architecture, e.g., "x64-based PC", "x86_64", "i686" etc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuArchitecture")]
		public string CpuArchitecture { get; set; }
		
		/// <summary>
		/// CPU name, e.g., "Intel Xeon E5-2690", "AMD EPYC 7571" etc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuName")]
		public string CpuName { get; set; }
		
		/// <summary>
		/// Number of processor sockets allocated to the machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuSocketCount")]
		public System.Nullable<System.Int32> CpuSocketCount { get; set; }
		
		/// <summary>
		/// Number of CPU threads allocated to the machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuThreadCount")]
		public System.Nullable<System.Int32> CpuThreadCount { get; set; }
		
		/// <summary>
		/// Firmware type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmwareType")]
		public System.Nullable<MachineArchitectureDetailsFirmwareType> FirmwareType { get; set; }
		
		/// <summary>
		/// CPU hyper-threading support.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hyperthreading")]
		public System.Nullable<MachineArchitectureDetailsHyperthreading> Hyperthreading { get; set; }
		
		/// <summary>
		/// Hardware vendor.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vendor")]
		public string Vendor { get; set; }
	}
	
	/// <summary>
	/// Details about the BIOS.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BiosDetails
	{
		
		/// <summary>
		/// BIOS name. This fields is deprecated. Please use the `id` field instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="biosName")]
		public string BiosName { get; set; }
		
		/// <summary>
		/// BIOS ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// BIOS manufacturer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="manufacturer")]
		public string Manufacturer { get; set; }
		
		/// <summary>
		/// Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values. * A month and day, with a zero year (for example, an anniversary). * A year on its own, with a zero month and a zero day. * A year and month, with a zero day (for example, a credit card expiration date). Related types: * google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public Date ReleaseDate { get; set; }
		
		/// <summary>
		/// SMBIOS UUID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smbiosUuid")]
		public string SmbiosUuid { get; set; }
		
		/// <summary>
		/// BIOS version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values. * A month and day, with a zero year (for example, an anniversary). * A year on its own, with a zero month and a zero day. * A year and month, with a zero day (for example, a credit card expiration date). Related types: * google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Date
	{
		
		/// <summary>
		/// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="day")]
		public System.Nullable<System.Int32> Day { get; set; }
		
		/// <summary>
		/// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="month")]
		public System.Nullable<System.Int32> Month { get; set; }
		
		/// <summary>
		/// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="year")]
		public System.Nullable<System.Int32> Year { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MachineArchitectureDetailsFirmwareType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FIRMWARE_TYPE_UNSPECIFIED")]
		FIRMWARE_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BIOS")]
		BIOS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="EFI")]
		EFI = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MachineArchitectureDetailsHyperthreading
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CPU_HYPER_THREADING_UNSPECIFIED")]
		CPU_HYPER_THREADING_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DISABLED")]
		DISABLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ENABLED")]
		ENABLED = 2,
	}
	
	/// <summary>
	/// Details of machine disks.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MachineDiskDetails
	{
		
		/// <summary>
		/// VM disks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public DiskEntryList Disks { get; set; }
		
		/// <summary>
		/// Disk total Capacity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalCapacityBytes")]
		public string TotalCapacityBytes { get; set; }
		
		/// <summary>
		/// Total disk free space.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalFreeBytes")]
		public string TotalFreeBytes { get; set; }
	}
	
	/// <summary>
	/// VM disks.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiskEntryList
	{
		
		/// <summary>
		/// Disk entries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entries")]
		public DiskEntry[] Entries { get; set; }
	}
	
	/// <summary>
	/// Single disk entry.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiskEntry
	{
		
		/// <summary>
		/// Disk capacity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="capacityBytes")]
		public string CapacityBytes { get; set; }
		
		/// <summary>
		/// Disk label.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskLabel")]
		public string DiskLabel { get; set; }
		
		/// <summary>
		/// Disk label type (e.g. BIOS/GPT)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskLabelType")]
		public string DiskLabelType { get; set; }
		
		/// <summary>
		/// Disk free space.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="freeBytes")]
		public string FreeBytes { get; set; }
		
		/// <summary>
		/// Disk hardware address (e.g. 0:1 for SCSI).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hwAddress")]
		public string HwAddress { get; set; }
		
		/// <summary>
		/// Disks interface type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaceType")]
		public System.Nullable<DiskEntryInterfaceType> InterfaceType { get; set; }
		
		/// <summary>
		/// Disk partition list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="partitions")]
		public DiskPartitionList Partitions { get; set; }
		
		/// <summary>
		/// VMware disk config details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmware")]
		public VmwareDiskConfig Vmware { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DiskEntryInterfaceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INTERFACE_TYPE_UNSPECIFIED")]
		INTERFACE_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IDE")]
		IDE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SATA")]
		SATA = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SAS")]
		SAS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SCSI")]
		SCSI = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NVME")]
		NVME = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FC")]
		FC = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ISCSI")]
		ISCSI = 7,
	}
	
	/// <summary>
	/// Disk partition list.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiskPartitionList
	{
		
		/// <summary>
		/// Partition entries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entries")]
		public DiskPartition[] Entries { get; set; }
	}
	
	/// <summary>
	/// Disk Partition details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiskPartition
	{
		
		/// <summary>
		/// Partition capacity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="capacityBytes")]
		public string CapacityBytes { get; set; }
		
		/// <summary>
		/// Partition file system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileSystem")]
		public string FileSystem { get; set; }
		
		/// <summary>
		/// Partition free space.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="freeBytes")]
		public string FreeBytes { get; set; }
		
		/// <summary>
		/// Mount pount (Linux/Windows) or drive letter (Windows).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mountPoint")]
		public string MountPoint { get; set; }
		
		/// <summary>
		/// Disk partition list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subPartitions")]
		public DiskPartitionList SubPartitions { get; set; }
		
		/// <summary>
		/// Partition type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Partition UUID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uuid")]
		public string Uuid { get; set; }
	}
	
	/// <summary>
	/// VMware disk config details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareDiskConfig
	{
		
		/// <summary>
		/// VMDK backing type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backingType")]
		public System.Nullable<VmwareDiskConfigBackingType> BackingType { get; set; }
		
		/// <summary>
		/// RDM compatibility mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rdmCompatibility")]
		public System.Nullable<VmwareDiskConfigRdmCompatibility> RdmCompatibility { get; set; }
		
		/// <summary>
		/// Is VMDK shared with other VMs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shared")]
		public System.Nullable<System.Boolean> Shared { get; set; }
		
		/// <summary>
		/// VMDK disk mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmdkMode")]
		public System.Nullable<VmwareDiskConfigVmdkMode> VmdkMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum VmwareDiskConfigBackingType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BACKING_TYPE_UNSPECIFIED")]
		BACKING_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BACKING_TYPE_FLAT_V1")]
		BACKING_TYPE_FLAT_V1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BACKING_TYPE_FLAT_V2")]
		BACKING_TYPE_FLAT_V2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BACKING_TYPE_PMEM")]
		BACKING_TYPE_PMEM = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BACKING_TYPE_RDM_V1")]
		BACKING_TYPE_RDM_V1 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BACKING_TYPE_RDM_V2")]
		BACKING_TYPE_RDM_V2 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BACKING_TYPE_SESPARSE")]
		BACKING_TYPE_SESPARSE = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BACKING_TYPE_SESPARSE_V1")]
		BACKING_TYPE_SESPARSE_V1 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BACKING_TYPE_SESPARSE_V2")]
		BACKING_TYPE_SESPARSE_V2 = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum VmwareDiskConfigRdmCompatibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RDM_COMPATIBILITY_UNSPECIFIED")]
		RDM_COMPATIBILITY_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PHYSICAL_COMPATIBILITY")]
		PHYSICAL_COMPATIBILITY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VIRTUAL_COMPATIBILITY")]
		VIRTUAL_COMPATIBILITY = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum VmwareDiskConfigVmdkMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VMDK_MODE_UNSPECIFIED")]
		VMDK_MODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DEPENDENT")]
		DEPENDENT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INDEPENDENT_PERSISTENT")]
		INDEPENDENT_PERSISTENT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INDEPENDENT_NONPERSISTENT")]
		INDEPENDENT_NONPERSISTENT = 3,
	}
	
	/// <summary>
	/// Information from Guest-level collections.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GuestOsDetails
	{
		
		/// <summary>
		/// Guest OS config information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="config")]
		public GuestConfigDetails Config { get; set; }
		
		/// <summary>
		/// What family the OS belong to, if known.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="family")]
		public System.Nullable<GuestOsDetailsFamily> Family { get; set; }
		
		/// <summary>
		/// The name of the operating system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osName")]
		public string OsName { get; set; }
		
		/// <summary>
		/// Guest OS runtime information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runtime")]
		public GuestRuntimeDetails Runtime { get; set; }
		
		/// <summary>
		/// The version of the operating system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Guest OS config information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GuestConfigDetails
	{
		
		/// <summary>
		/// Fstab content.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fstab")]
		public FstabEntryList Fstab { get; set; }
		
		/// <summary>
		/// Hosts content.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosts")]
		public HostsEntryList Hosts { get; set; }
		
		/// <summary>
		/// OS issue (typically /etc/issue in Linux).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issue")]
		public string Issue { get; set; }
		
		/// <summary>
		/// NFS exports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nfsExports")]
		public NfsExportList NfsExports { get; set; }
		
		/// <summary>
		/// Security-Enhanced Linux (SELinux) mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selinuxMode")]
		public System.Nullable<GuestConfigDetailsSelinuxMode> SelinuxMode { get; set; }
	}
	
	/// <summary>
	/// Fstab content.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FstabEntryList
	{
		
		/// <summary>
		/// Fstab entries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entries")]
		public FstabEntry[] Entries { get; set; }
	}
	
	/// <summary>
	/// Single fstab entry.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FstabEntry
	{
		
		/// <summary>
		/// The mount point for the filesystem.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="file")]
		public string File { get; set; }
		
		/// <summary>
		/// Used by dump to determine which filesystems need to be dumped.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="freq")]
		public System.Nullable<System.Int32> Freq { get; set; }
		
		/// <summary>
		/// Mount options associated with the filesystem.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mntops")]
		public string Mntops { get; set; }
		
		/// <summary>
		/// Used by the fsck(8) program to determine the order in which filesystem checks are done at reboot time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="passno")]
		public System.Nullable<System.Int32> Passno { get; set; }
		
		/// <summary>
		/// The block special device or remote filesystem to be mounted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public string Spec { get; set; }
		
		/// <summary>
		/// The type of the filesystem.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vfstype")]
		public string Vfstype { get; set; }
	}
	
	/// <summary>
	/// Hosts content.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostsEntryList
	{
		
		/// <summary>
		/// Hosts entries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entries")]
		public HostsEntry[] Entries { get; set; }
	}
	
	/// <summary>
	/// Single /etc/hosts entry.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostsEntry
	{
		
		/// <summary>
		/// List of host names / aliases.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostNames")]
		public string[] HostNames { get; set; }
		
		/// <summary>
		/// IP (raw, IPv4/6 agnostic).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	/// <summary>
	/// NFS exports.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NfsExportList
	{
		
		/// <summary>
		/// NFS export entries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entries")]
		public NfsExport[] Entries { get; set; }
	}
	
	/// <summary>
	/// NFS export.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NfsExport
	{
		
		/// <summary>
		/// The directory being exported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exportDirectory")]
		public string ExportDirectory { get; set; }
		
		/// <summary>
		/// The hosts or networks to which the export is being shared.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosts")]
		public string[] Hosts { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum GuestConfigDetailsSelinuxMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SE_LINUX_MODE_UNSPECIFIED")]
		SE_LINUX_MODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SE_LINUX_MODE_DISABLED")]
		SE_LINUX_MODE_DISABLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SE_LINUX_MODE_PERMISSIVE")]
		SE_LINUX_MODE_PERMISSIVE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SE_LINUX_MODE_ENFORCING")]
		SE_LINUX_MODE_ENFORCING = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum GuestOsDetailsFamily
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OS_FAMILY_UNKNOWN")]
		OS_FAMILY_UNKNOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OS_FAMILY_WINDOWS")]
		OS_FAMILY_WINDOWS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OS_FAMILY_LINUX")]
		OS_FAMILY_LINUX = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OS_FAMILY_UNIX")]
		OS_FAMILY_UNIX = 3,
	}
	
	/// <summary>
	/// Guest OS runtime information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GuestRuntimeDetails
	{
		
		/// <summary>
		/// Domain, e.g. c.stratozone-development.internal.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// Guest installed application list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="installedApps")]
		public GuestInstalledApplicationList InstalledApps { get; set; }
		
		/// <summary>
		/// Last time the OS was booted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastBootTime")]
		public string LastBootTime { get; set; }
		
		/// <summary>
		/// Machine name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineName")]
		public string MachineName { get; set; }
		
		/// <summary>
		/// Runtime networking information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public RuntimeNetworkInfo Network { get; set; }
		
		/// <summary>
		/// Open file list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="openFileList")]
		public OpenFileList OpenFileList { get; set; }
		
		/// <summary>
		/// List of running guest OS processes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="processes")]
		public RunningProcessList Processes { get; set; }
		
		/// <summary>
		/// List of running guest OS services.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="services")]
		public RunningServiceList Services { get; set; }
	}
	
	/// <summary>
	/// Guest installed application list.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GuestInstalledApplicationList
	{
		
		/// <summary>
		/// Application entries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entries")]
		public GuestInstalledApplication[] Entries { get; set; }
	}
	
	/// <summary>
	/// Guest installed application information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GuestInstalledApplication
	{
		
		/// <summary>
		/// Installed application name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applicationName")]
		public string ApplicationName { get; set; }
		
		/// <summary>
		/// The time when the application was installed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="installTime")]
		public string InstallTime { get; set; }
		
		/// <summary>
		/// License strings associated with the installed application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenses")]
		public string[] Licenses { get; set; }
		
		/// <summary>
		/// Source path.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Installed application vendor.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vendor")]
		public string Vendor { get; set; }
		
		/// <summary>
		/// Installed application version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Runtime networking information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RuntimeNetworkInfo
	{
		
		/// <summary>
		/// Network connection list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connections")]
		public NetworkConnectionList Connections { get; set; }
		
		/// <summary>
		/// Time of the last network scan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scanTime")]
		public string ScanTime { get; set; }
	}
	
	/// <summary>
	/// Network connection list.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkConnectionList
	{
		
		/// <summary>
		/// Network connection entries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entries")]
		public NetworkConnection[] Entries { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkConnection
	{
		
		/// <summary>
		/// Local IP address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localIpAddress")]
		public string LocalIpAddress { get; set; }
		
		/// <summary>
		/// Local port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localPort")]
		public System.Nullable<System.Int32> LocalPort { get; set; }
		
		/// <summary>
		/// Process ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pid")]
		public string Pid { get; set; }
		
		/// <summary>
		/// Process or service name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="processName")]
		public string ProcessName { get; set; }
		
		/// <summary>
		/// Connection protocol (e.g. TCP/UDP).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public string Protocol { get; set; }
		
		/// <summary>
		/// Remote IP address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remoteIpAddress")]
		public string RemoteIpAddress { get; set; }
		
		/// <summary>
		/// Remote port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remotePort")]
		public System.Nullable<System.Int32> RemotePort { get; set; }
		
		/// <summary>
		/// Network connection state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<NetworkConnectionState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum NetworkConnectionState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="STATE_UNSPECIFIED")]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OPENING")]
		OPENING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OPEN")]
		OPEN = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LISTEN")]
		LISTEN = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CLOSING")]
		CLOSING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CLOSED")]
		CLOSED = 5,
	}
	
	/// <summary>
	/// Open file list.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OpenFileList
	{
		
		/// <summary>
		/// Open file details entries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entries")]
		public OpenFileDetails[] Entries { get; set; }
	}
	
	/// <summary>
	/// Open file Information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OpenFileDetails
	{
		
		/// <summary>
		/// Opened file command.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Opened file file path.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filePath")]
		public string FilePath { get; set; }
		
		/// <summary>
		/// Opened file file type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileType")]
		public string FileType { get; set; }
		
		/// <summary>
		/// Opened file user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public string User { get; set; }
	}
	
	/// <summary>
	/// List of running guest OS processes.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RunningProcessList
	{
		
		/// <summary>
		/// Running process entries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entries")]
		public RunningProcess[] Entries { get; set; }
	}
	
	/// <summary>
	/// Guest OS running process details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RunningProcess
	{
		
		/// <summary>
		/// Process extended attributes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="attributes")]
		public System.Collections.Generic.Dictionary<string, string> Attributes { get; set; }
		
		/// <summary>
		/// Process full command line.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cmdline")]
		public string Cmdline { get; set; }
		
		/// <summary>
		/// Process binary path.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exePath")]
		public string ExePath { get; set; }
		
		/// <summary>
		/// Process ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pid")]
		public string Pid { get; set; }
		
		/// <summary>
		/// User running the process.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public string User { get; set; }
	}
	
	/// <summary>
	/// List of running guest OS services.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RunningServiceList
	{
		
		/// <summary>
		/// Running service entries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entries")]
		public RunningService[] Entries { get; set; }
	}
	
	/// <summary>
	/// Guest OS running service details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RunningService
	{
		
		/// <summary>
		/// Service command line.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cmdline")]
		public string Cmdline { get; set; }
		
		/// <summary>
		/// Service binary path.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exePath")]
		public string ExePath { get; set; }
		
		/// <summary>
		/// Service pid.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pid")]
		public string Pid { get; set; }
		
		/// <summary>
		/// Service name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceName")]
		public string ServiceName { get; set; }
		
		/// <summary>
		/// Service start mode (OS-agnostic).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startMode")]
		public System.Nullable<RunningServiceStartMode> StartMode { get; set; }
		
		/// <summary>
		/// Service state (OS-agnostic).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<RunningServiceState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum RunningServiceStartMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="START_MODE_UNSPECIFIED")]
		START_MODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BOOT")]
		BOOT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SYSTEM")]
		SYSTEM = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AUTO")]
		AUTO = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MANUAL")]
		MANUAL = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DISABLED")]
		DISABLED = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum RunningServiceState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="STATE_UNSPECIFIED")]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PAUSED")]
		PAUSED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="STOPPED")]
		STOPPED = 3,
	}
	
	/// <summary>
	/// Details of network adapters and settings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MachineNetworkDetails
	{
		
		/// <summary>
		/// List of network adapters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adapters")]
		public NetworkAdapterList Adapters { get; set; }
		
		/// <summary>
		/// The primary IP address of the machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primaryIpAddress")]
		public string PrimaryIpAddress { get; set; }
		
		/// <summary>
		/// MAC address of the machine. This property is used to uniqly identify the machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primaryMacAddress")]
		public string PrimaryMacAddress { get; set; }
		
		/// <summary>
		/// The public IP address of the machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicIpAddress")]
		public string PublicIpAddress { get; set; }
	}
	
	/// <summary>
	/// List of network adapters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkAdapterList
	{
		
		/// <summary>
		/// Network adapter entries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entries")]
		public NetworkAdapterDetails[] Entries { get; set; }
	}
	
	/// <summary>
	/// Details of network adapter.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkAdapterDetails
	{
		
		/// <summary>
		/// Network adapter type (e.g. VMXNET3).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adapterType")]
		public string AdapterType { get; set; }
		
		/// <summary>
		/// List of allocated/assigned network addresses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public NetworkAddressList Addresses { get; set; }
		
		/// <summary>
		/// MAC address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="macAddress")]
		public string MacAddress { get; set; }
	}
	
	/// <summary>
	/// List of allocated/assigned network addresses.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkAddressList
	{
		
		/// <summary>
		/// Network address entries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entries")]
		public NetworkAddress[] Entries { get; set; }
	}
	
	/// <summary>
	/// Details of network address.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkAddress
	{
		
		/// <summary>
		/// Whether DHCP is used to assign addresses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignment")]
		public System.Nullable<NetworkAddressAssignment> Assignment { get; set; }
		
		/// <summary>
		/// Broadcast address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bcast")]
		public string Bcast { get; set; }
		
		/// <summary>
		/// Fully qualified domain name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fqdn")]
		public string Fqdn { get; set; }
		
		/// <summary>
		/// Assigned or configured IP Address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
		
		/// <summary>
		/// Subnet mask.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetMask")]
		public string SubnetMask { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum NetworkAddressAssignment
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ADDRESS_ASSIGNMENT_UNSPECIFIED")]
		ADDRESS_ASSIGNMENT_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ADDRESS_ASSIGNMENT_STATIC")]
		ADDRESS_ASSIGNMENT_STATIC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ADDRESS_ASSIGNMENT_DHCP")]
		ADDRESS_ASSIGNMENT_DHCP = 2,
	}
	
	/// <summary>
	/// Information about the platform.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlatformDetails
	{
		
		/// <summary>
		/// AWS EC2 specific details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="awsEc2Details")]
		public AwsEc2PlatformDetails AwsEc2Details { get; set; }
		
		/// <summary>
		/// Azure VM specific details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="azureVmDetails")]
		public AzureVmPlatformDetails AzureVmDetails { get; set; }
		
		/// <summary>
		/// Generic platform details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="genericDetails")]
		public GenericPlatformDetails GenericDetails { get; set; }
		
		/// <summary>
		/// Platform specific details for Physical Machines.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="physicalDetails")]
		public PhysicalPlatformDetails PhysicalDetails { get; set; }
		
		/// <summary>
		/// VMware specific details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmwareDetails")]
		public VmwarePlatformDetails VmwareDetails { get; set; }
	}
	
	/// <summary>
	/// AWS EC2 specific details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AwsEc2PlatformDetails
	{
		
		/// <summary>
		/// The location of the machine in the AWS format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// AWS platform's machine type label.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineTypeLabel")]
		public string MachineTypeLabel { get; set; }
	}
	
	/// <summary>
	/// Azure VM specific details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AzureVmPlatformDetails
	{
		
		/// <summary>
		/// The location of the machine in the Azure format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Azure platform's machine type label.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineTypeLabel")]
		public string MachineTypeLabel { get; set; }
		
		/// <summary>
		/// Azure platform's provisioning state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioningState")]
		public string ProvisioningState { get; set; }
	}
	
	/// <summary>
	/// Generic platform details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GenericPlatformDetails
	{
		
		/// <summary>
		/// Free text representation of the machine location. The format of this field should not be relied on. Different VMs in the same location may have different string values for this field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
	}
	
	/// <summary>
	/// Platform specific details for Physical Machines.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PhysicalPlatformDetails
	{
		
		/// <summary>
		/// Free text representation of the machine location. The format of this field should not be relied on. Different machines in the same location may have different string values for this field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
	}
	
	/// <summary>
	/// VMware specific details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwarePlatformDetails
	{
		
		/// <summary>
		/// ESX version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="esxVersion")]
		public string EsxVersion { get; set; }
		
		/// <summary>
		/// VMware os enum - https://vdc-repo.vmware.com/vmwb-repository/dcr-public/da47f910-60ac-438b-8b9b-6122f4d14524/16b7274a-bf8b-4b4c-a05e-746f2aa93c8c/doc/vim.vm.GuestOsDescriptor.GuestOsIdentifier.html.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osid")]
		public string Osid { get; set; }
		
		/// <summary>
		/// Folder name in vCenter where asset resides.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vcenterFolder")]
		public string VcenterFolder { get; set; }
		
		/// <summary>
		/// vCenter URI used in collection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vcenterUri")]
		public string VcenterUri { get; set; }
		
		/// <summary>
		/// vCenter version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vcenterVersion")]
		public string VcenterVersion { get; set; }
		
		/// <summary>
		/// vCenter VM ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vcenterVmId")]
		public string VcenterVmId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MachineDetailsPowerState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="POWER_STATE_UNSPECIFIED")]
		POWER_STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PENDING")]
		PENDING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SUSPENDING")]
		SUSPENDING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SUSPENDED")]
		SUSPENDED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETING")]
		DELETING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETED")]
		DELETED = 6,
	}
	
	/// <summary>
	/// Performance data for an asset.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AssetPerformanceData
	{
		
		/// <summary>
		/// Daily resource usage aggregations. Contains all of the data available for an asset, up to the last 420 days. Aggregations are sorted from oldest to most recent.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dailyResourceUsageAggregations")]
		public DailyResourceUsageAggregation[] DailyResourceUsageAggregations { get; set; }
	}
	
	/// <summary>
	/// Usage data aggregation for a single day.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DailyResourceUsageAggregation
	{
		
		/// <summary>
		/// Statistical aggregation of CPU usage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpu")]
		public DailyResourceUsageAggregationCPU Cpu { get; set; }
		
		/// <summary>
		/// Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values. * A month and day, with a zero year (for example, an anniversary). * A year on its own, with a zero month and a zero day. * A year and month, with a zero day (for example, a credit card expiration date). Related types: * google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date")]
		public Date Date { get; set; }
		
		/// <summary>
		/// Statistical aggregation of disk usage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disk")]
		public DailyResourceUsageAggregationDisk Disk { get; set; }
		
		/// <summary>
		/// Statistical aggregation of memory usage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memory")]
		public DailyResourceUsageAggregationMemory Memory { get; set; }
		
		/// <summary>
		/// Statistical aggregation of network usage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public DailyResourceUsageAggregationNetwork Network { get; set; }
	}
	
	/// <summary>
	/// Statistical aggregation of CPU usage.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DailyResourceUsageAggregationCPU
	{
		
		/// <summary>
		/// Statistical aggregation of samples for a single resource usage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="utilizationPercentage")]
		public DailyResourceUsageAggregationStats UtilizationPercentage { get; set; }
	}
	
	/// <summary>
	/// Statistical aggregation of samples for a single resource usage.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DailyResourceUsageAggregationStats
	{
		
		/// <summary>
		/// Average usage value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="average")]
		public System.Nullable<System.Single> Average { get; set; }
		
		/// <summary>
		/// Median usage value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="median")]
		public System.Nullable<System.Single> Median { get; set; }
		
		/// <summary>
		/// 95th percentile usage value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ninteyFifthPercentile")]
		public System.Nullable<System.Single> NinteyFifthPercentile { get; set; }
		
		/// <summary>
		/// Peak usage value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peak")]
		public System.Nullable<System.Single> Peak { get; set; }
	}
	
	/// <summary>
	/// Statistical aggregation of disk usage.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DailyResourceUsageAggregationDisk
	{
		
		/// <summary>
		/// Statistical aggregation of samples for a single resource usage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iops")]
		public DailyResourceUsageAggregationStats Iops { get; set; }
	}
	
	/// <summary>
	/// Statistical aggregation of memory usage.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DailyResourceUsageAggregationMemory
	{
		
		/// <summary>
		/// Statistical aggregation of samples for a single resource usage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="utilizationPercentage")]
		public DailyResourceUsageAggregationStats UtilizationPercentage { get; set; }
	}
	
	/// <summary>
	/// Statistical aggregation of network usage.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DailyResourceUsageAggregationNetwork
	{
		
		/// <summary>
		/// Statistical aggregation of samples for a single resource usage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="egressBps")]
		public DailyResourceUsageAggregationStats EgressBps { get; set; }
		
		/// <summary>
		/// Statistical aggregation of samples for a single resource usage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ingressBps")]
		public DailyResourceUsageAggregationStats IngressBps { get; set; }
	}
	
	/// <summary>
	/// Contains data reported from an inventory source on an asset.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AssetFrame
	{
		
		/// <summary>
		/// Generic asset attributes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="attributes")]
		public System.Collections.Generic.Dictionary<string, string> Attributes { get; set; }
		
		/// <summary>
		/// Labels as key value pairs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Details of a machine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineDetails")]
		public MachineDetails MachineDetails { get; set; }
		
		/// <summary>
		/// Asset performance data samples. Samples that are from more than 40 days ago or after tomorrow are ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="performanceSamples")]
		public PerformanceSample[] PerformanceSamples { get; set; }
		
		/// <summary>
		/// The time the data was reported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reportTime")]
		public string ReportTime { get; set; }
		
		/// <summary>
		/// Optional. Trace token is optionally provided to assist with debugging and traceability.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="traceToken")]
		public string TraceToken { get; set; }
	}
	
	/// <summary>
	/// Performance data sample.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PerformanceSample
	{
		
		/// <summary>
		/// CPU usage sample.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpu")]
		public CpuUsageSample Cpu { get; set; }
		
		/// <summary>
		/// Disk usage sample. Values are across all disks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disk")]
		public DiskUsageSample Disk { get; set; }
		
		/// <summary>
		/// Memory usage sample.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memory")]
		public MemoryUsageSample Memory { get; set; }
		
		/// <summary>
		/// Network usage sample. Values are across all network interfaces.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public NetworkUsageSample Network { get; set; }
		
		/// <summary>
		/// Time the sample was collected. If omitted, the frame report time will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sampleTime")]
		public string SampleTime { get; set; }
	}
	
	/// <summary>
	/// CPU usage sample.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CpuUsageSample
	{
		
		/// <summary>
		/// Percentage of total CPU capacity utilized. Must be in the interval [0, 100]. On most systems can be calculated using 100 - idle percentage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="utilizedPercentage")]
		public System.Nullable<System.Single> UtilizedPercentage { get; set; }
	}
	
	/// <summary>
	/// Disk usage sample. Values are across all disks.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiskUsageSample
	{
		
		/// <summary>
		/// Average IOPS sampled over a short window. Must be non-negative.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="averageIops")]
		public System.Nullable<System.Single> AverageIops { get; set; }
	}
	
	/// <summary>
	/// Memory usage sample.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MemoryUsageSample
	{
		
		/// <summary>
		/// Percentage of system memory utilized. Must be in the interval [0, 100].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="utilizedPercentage")]
		public System.Nullable<System.Single> UtilizedPercentage { get; set; }
	}
	
	/// <summary>
	/// Network usage sample. Values are across all network interfaces.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkUsageSample
	{
		
		/// <summary>
		/// Average network egress in B/s sampled over a short window. Must be non-negative.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="averageEgressBps")]
		public System.Nullable<System.Single> AverageEgressBps { get; set; }
		
		/// <summary>
		/// Average network ingress in B/s sampled over a short window. Must be non-negative.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="averageIngressBps")]
		public System.Nullable<System.Single> AverageIngressBps { get; set; }
	}
	
	/// <summary>
	/// A request to delete a list of asset.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchDeleteAssetsRequest
	{
		
		/// <summary>
		/// Optional. When this value is set to `true` the request is a no-op for non-existing assets. See https://google.aip.dev/135#delete-if-existing for additional details. Default value is `false`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowMissing")]
		public System.Nullable<System.Boolean> AllowMissing { get; set; }
		
		/// <summary>
		/// Required. The IDs of the assets to delete. A maximum of 1000 assets can be deleted in a batch. Format: projects/{project}/locations/{location}/assets/{name}.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="names")]
		public string[] Names { get; set; }
	}
	
	/// <summary>
	/// A request to update a list of assets.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchUpdateAssetsRequest
	{
		
		/// <summary>
		/// Required. The request message specifying the resources to update. A maximum of 1000 assets can be modified in a batch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requests")]
		public UpdateAssetRequest[] Requests { get; set; }
	}
	
	/// <summary>
	/// A request to update an asset.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateAssetRequest
	{
		
		/// <summary>
		/// An asset represents a resource in your environment. Asset types include virtual machines and databases.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="asset")]
		public Asset Asset { get; set; }
		
		/// <summary>
		/// Optional. An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestId")]
		public string RequestId { get; set; }
		
		/// <summary>
		/// Required. Field mask is used to specify the fields to be overwritten in the `Asset` resource by the update. The values specified in the `update_mask` field are relative to the resource, not the full request. A field will be overwritten if it is in the mask. A single * value in the mask lets you to overwrite all fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateMask")]
		public string UpdateMask { get; set; }
	}
	
	/// <summary>
	/// Response for updating a list of assets.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchUpdateAssetsResponse
	{
		
		/// <summary>
		/// Update asset content. The content only includes values after field mask being applied.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public Asset[] Assets { get; set; }
	}
	
	/// <summary>
	/// The request message for Operations.CancelOperation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CancelOperationRequest
	{
	}
	
	/// <summary>
	/// The user preferences relating to Compute Engine target platform.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ComputeEnginePreferences
	{
		
		/// <summary>
		/// License type to consider when calculating costs for virtual machine insights and recommendations. If unspecified, costs are calculated based on the default licensing plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseType")]
		public System.Nullable<ComputeEnginePreferencesLicenseType> LicenseType { get; set; }
		
		/// <summary>
		/// The type of machines to consider when calculating virtual machine migration insights and recommendations. Not all machine types are available in all zones and regions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machinePreferences")]
		public MachinePreferences MachinePreferences { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ComputeEnginePreferencesLicenseType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LICENSE_TYPE_UNSPECIFIED")]
		LICENSE_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LICENSE_TYPE_DEFAULT")]
		LICENSE_TYPE_DEFAULT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LICENSE_TYPE_BRING_YOUR_OWN_LICENSE")]
		LICENSE_TYPE_BRING_YOUR_OWN_LICENSE = 2,
	}
	
	/// <summary>
	/// The type of machines to consider when calculating virtual machine migration insights and recommendations. Not all machine types are available in all zones and regions.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MachinePreferences
	{
		
		/// <summary>
		/// Compute Engine machine series to consider for insights and recommendations. If empty, no restriction is applied on the machine series.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedMachineSeries")]
		public MachineSeries[] AllowedMachineSeries { get; set; }
	}
	
	/// <summary>
	/// A Compute Engine machine series.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MachineSeries
	{
		
		/// <summary>
		/// Code to identify a Compute Engine machine series. Consult https://cloud.google.com/compute/docs/machine-resource#machine_type_comparison for more details on the available series.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
	}
	
	/// <summary>
	/// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Empty
	{
	}
	
	/// <summary>
	/// Message representing a frame which failed to be processed due to an error.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ErrorFrame
	{
		
		/// <summary>
		/// Output only. Frame ingestion time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ingestionTime")]
		public string IngestionTime { get; set; }
		
		/// <summary>
		/// Output only. The identifier of the ErrorFrame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Contains data reported from an inventory source on an asset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="originalFrame")]
		public AssetFrame OriginalFrame { get; set; }
		
		/// <summary>
		/// Output only. All the violations that were detected for the frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="violations")]
		public FrameViolationEntry[] Violations { get; set; }
	}
	
	/// <summary>
	/// A resource that contains a single violation of a reported `AssetFrame` resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FrameViolationEntry
	{
		
		/// <summary>
		/// The field of the original frame where the violation occurred.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="field")]
		public string Field { get; set; }
		
		/// <summary>
		/// A message describing the violation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="violation")]
		public string Violation { get; set; }
	}
	
	/// <summary>
	/// A resource that reports result of the import job execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExecutionReport
	{
		
		/// <summary>
		/// A resource that aggregates errors across import job files.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executionErrors")]
		public ValidationReport ExecutionErrors { get; set; }
		
		/// <summary>
		/// Total number of asset frames reported for the import job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="framesReported")]
		public System.Nullable<System.Int32> FramesReported { get; set; }
		
		/// <summary>
		/// Output only. Total number of rows in the import job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalRowsCount")]
		public System.Nullable<System.Int32> TotalRowsCount { get; set; }
	}
	
	/// <summary>
	/// A resource that aggregates errors across import job files.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ValidationReport
	{
		
		/// <summary>
		/// List of errors found in files.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileValidations")]
		public FileValidationReport[] FileValidations { get; set; }
		
		/// <summary>
		/// List of job level errors.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jobErrors")]
		public ImportError[] JobErrors { get; set; }
	}
	
	/// <summary>
	/// A resource that aggregates the validation errors found in an import job file.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FileValidationReport
	{
		
		/// <summary>
		/// List of file level errors.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileErrors")]
		public ImportError[] FileErrors { get; set; }
		
		/// <summary>
		/// The name of the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileName")]
		public string FileName { get; set; }
		
		/// <summary>
		/// Flag indicating that processing was aborted due to maximum number of errors.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="partialReport")]
		public System.Nullable<System.Boolean> PartialReport { get; set; }
		
		/// <summary>
		/// Partial list of rows that encountered validation error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rowErrors")]
		public ImportRowError[] RowErrors { get; set; }
	}
	
	/// <summary>
	/// A resource that reports the errors encountered while processing an import job.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportError
	{
		
		/// <summary>
		/// The error information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorDetails")]
		public string ErrorDetails { get; set; }
		
		/// <summary>
		/// The severity of the error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="severity")]
		public System.Nullable<ImportErrorSeverity> Severity { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ImportErrorSeverity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SEVERITY_UNSPECIFIED")]
		SEVERITY_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ERROR")]
		ERROR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WARNING")]
		WARNING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INFO")]
		INFO = 3,
	}
	
	/// <summary>
	/// A resource that reports the import job errors at row level.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportRowError
	{
		
		/// <summary>
		/// The list of errors detected in the row.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public ImportError[] Errors { get; set; }
		
		/// <summary>
		/// The row number where the error was detected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rowNumber")]
		public System.Nullable<System.Int32> RowNumber { get; set; }
		
		/// <summary>
		/// The name of the VM in the row.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmName")]
		public string VmName { get; set; }
		
		/// <summary>
		/// The VM UUID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmUuid")]
		public string VmUuid { get; set; }
	}
	
	/// <summary>
	/// Collection of frame data.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Frames
	{
		
		/// <summary>
		/// A repeated field of asset data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="framesData")]
		public AssetFrame[] FramesData { get; set; }
	}
	
	/// <summary>
	/// A resource that represents an asset group. The purpose of an asset group is to bundle a set of assets that have something in common, while allowing users to add annotations to the group. An asset can belong to multiple groups.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Group
	{
		
		/// <summary>
		/// Output only. The timestamp when the group was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Optional. The description of the group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Optional. User-friendly display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Labels as key value pairs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Output only. The name of the group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. The timestamp when the group was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// A resource that represents a payload file in an import job.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportDataFile
	{
		
		/// <summary>
		/// Output only. The timestamp when the file was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// User-friendly display name. Maximum length is 63 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Required. The payload format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public System.Nullable<ImportDataFileFormat> Format { get; set; }
		
		/// <summary>
		/// Output only. The name of the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. The state of the import data file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<ImportDataFileState> State { get; set; }
		
		/// <summary>
		/// A resource that contains a URI to which a data file can be uploaded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uploadFileInfo")]
		public UploadFileInfo UploadFileInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ImportDataFileFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IMPORT_JOB_FORMAT_UNSPECIFIED")]
		IMPORT_JOB_FORMAT_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IMPORT_JOB_FORMAT_RVTOOLS_XLSX")]
		IMPORT_JOB_FORMAT_RVTOOLS_XLSX = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IMPORT_JOB_FORMAT_RVTOOLS_CSV")]
		IMPORT_JOB_FORMAT_RVTOOLS_CSV = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV")]
		IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV")]
		IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IMPORT_JOB_FORMAT_STRATOZONE_CSV")]
		IMPORT_JOB_FORMAT_STRATOZONE_CSV = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ImportDataFileState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="STATE_UNSPECIFIED")]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CREATING")]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 2,
	}
	
	/// <summary>
	/// A resource that contains a URI to which a data file can be uploaded.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UploadFileInfo
	{
		
		/// <summary>
		/// Output only. The headers that were used to sign the URI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public System.Collections.Generic.Dictionary<string, string> Headers { get; set; }
		
		/// <summary>
		/// Output only. Upload URI for the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signedUri")]
		public string SignedUri { get; set; }
		
		/// <summary>
		/// Output only. Expiration time of the upload URI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uriExpirationTime")]
		public string UriExpirationTime { get; set; }
	}
	
	/// <summary>
	/// A resource that represents the background job that imports asset frames.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportJob
	{
		
		/// <summary>
		/// Required. Reference to a source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetSource")]
		public string AssetSource { get; set; }
		
		/// <summary>
		/// Output only. The timestamp when the import job was completed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completeTime")]
		public string CompleteTime { get; set; }
		
		/// <summary>
		/// Output only. The timestamp when the import job was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Optional. User-friendly display name. Maximum length is 256 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// A resource that reports result of the import job execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executionReport")]
		public ExecutionReport ExecutionReport { get; set; }
		
		/// <summary>
		/// Labels as key value pairs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Output only. The full name of the import job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. The state of the import job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<ImportJobState> State { get; set; }
		
		/// <summary>
		/// Output only. The timestamp when the import job was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
		
		/// <summary>
		/// A resource that aggregates errors across import job files.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validationReport")]
		public ValidationReport ValidationReport { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ImportJobState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IMPORT_JOB_STATE_UNSPECIFIED")]
		IMPORT_JOB_STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IMPORT_JOB_STATE_PENDING")]
		IMPORT_JOB_STATE_PENDING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IMPORT_JOB_STATE_RUNNING")]
		IMPORT_JOB_STATE_RUNNING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IMPORT_JOB_STATE_COMPLETED")]
		IMPORT_JOB_STATE_COMPLETED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IMPORT_JOB_STATE_FAILED")]
		IMPORT_JOB_STATE_FAILED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IMPORT_JOB_STATE_VALIDATING")]
		IMPORT_JOB_STATE_VALIDATING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IMPORT_JOB_STATE_FAILED_VALIDATION")]
		IMPORT_JOB_STATE_FAILED_VALIDATION = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IMPORT_JOB_STATE_READY")]
		IMPORT_JOB_STATE_READY = 7,
	}
	
	/// <summary>
	/// Response message for listing assets.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListAssetsResponse
	{
		
		/// <summary>
		/// A list of assets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public Asset[] Assets { get; set; }
		
		/// <summary>
		/// A token identifying a page of results the server should return.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// A response for listing error frames.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListErrorFramesResponse
	{
		
		/// <summary>
		/// The list of error frames.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorFrames")]
		public ErrorFrame[] ErrorFrames { get; set; }
		
		/// <summary>
		/// A token identifying a page of results the server should return.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// A response for listing groups.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListGroupsResponse
	{
		
		/// <summary>
		/// The list of Group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groups")]
		public Group[] Groups { get; set; }
		
		/// <summary>
		/// A token identifying a page of results the server should return.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// Response for listing payload files of an import job.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListImportDataFilesResponse
	{
		
		/// <summary>
		/// The list of import data files.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="importDataFiles")]
		public ImportDataFile[] ImportDataFiles { get; set; }
		
		/// <summary>
		/// A token that can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// A response for listing import jobs.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListImportJobsResponse
	{
		
		/// <summary>
		/// The list of import jobs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="importJobs")]
		public ImportJob[] ImportJobs { get; set; }
		
		/// <summary>
		/// A token identifying a page of results the server should return.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// The response message for Locations.ListLocations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListLocationsResponse
	{
		
		/// <summary>
		/// A list of locations that matches the specified filter in the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locations")]
		public Location[] Locations { get; set; }
		
		/// <summary>
		/// The standard List next-page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// A resource that represents a Google Cloud location.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Location
	{
		
		/// <summary>
		/// The friendly name for this location, typically a nearby city name. For example, "Tokyo".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Cross-service attributes for the location. For example {"cloud.googleapis.com/region": "us-east1"}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// The canonical id for this location. For example: `"us-east1"`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationId")]
		public string LocationId { get; set; }
		
		/// <summary>
		/// Service-specific metadata. For example the available capacity at the given location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, object> Metadata { get; set; }
		
		/// <summary>
		/// Resource name for the location, which may vary between implementations. For example: `"projects/example-project/locations/us-east1"`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// The response message for Operations.ListOperations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListOperationsResponse
	{
		
		/// <summary>
		/// The standard List next-page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// A list of operations that matches the specified filter in the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operations")]
		public Operation[] Operations { get; set; }
	}
	
	/// <summary>
	/// This resource represents a long-running operation that is the result of a network API call.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Operation
	{
		
		/// <summary>
		/// If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="done")]
		public System.Nullable<System.Boolean> Done { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Status Error { get; set; }
		
		/// <summary>
		/// Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, object> Metadata { get; set; }
		
		/// <summary>
		/// The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public System.Collections.Generic.Dictionary<string, object> Response { get; set; }
	}
	
	/// <summary>
	/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Status
	{
		
		/// <summary>
		/// The status code, which should be an enum value of google.rpc.Code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// A list of messages that carry the error details. There is a common set of message types for APIs to use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string[] Details { get; set; }
		
		/// <summary>
		/// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// Response message for listing preference sets.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListPreferenceSetsResponse
	{
		
		/// <summary>
		/// A token identifying a page of results the server should return.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The list of PreferenceSets
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preferenceSets")]
		public PreferenceSet[] PreferenceSets { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// The preferences that apply to all assets in a given context.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PreferenceSet
	{
		
		/// <summary>
		/// Output only. The timestamp when the preference set was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// A description of the preference set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// User-friendly display name. Maximum length is 63 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Output only. Name of the preference set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. The timestamp when the preference set was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
		
		/// <summary>
		/// VirtualMachinePreferences enables you to create sets of assumptions, for example, a geographical location and pricing track, for your migrated virtual machines. The set of preferences influence recommendations for migrating virtual machine assets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualMachinePreferences")]
		public VirtualMachinePreferences VirtualMachinePreferences { get; set; }
	}
	
	/// <summary>
	/// VirtualMachinePreferences enables you to create sets of assumptions, for example, a geographical location and pricing track, for your migrated virtual machines. The set of preferences influence recommendations for migrating virtual machine assets.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualMachinePreferences
	{
		
		/// <summary>
		/// Commitment plan to consider when calculating costs for virtual machine insights and recommendations. If you are unsure which value to set, a 3 year commitment plan is often a good value to start with.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commitmentPlan")]
		public System.Nullable<VirtualMachinePreferencesCommitmentPlan> CommitmentPlan { get; set; }
		
		/// <summary>
		/// The user preferences relating to Compute Engine target platform.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computeEnginePreferences")]
		public ComputeEnginePreferences ComputeEnginePreferences { get; set; }
		
		/// <summary>
		/// The user preferences relating to target regions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="regionPreferences")]
		public RegionPreferences RegionPreferences { get; set; }
		
		/// <summary>
		/// Sizing optimization strategy specifies the preferred strategy used when extrapolating usage data to calculate insights and recommendations for a virtual machine. If you are unsure which value to set, a moderate sizing optimization strategy is often a good value to start with.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sizingOptimizationStrategy")]
		public System.Nullable<VirtualMachinePreferencesSizingOptimizationStrategy> SizingOptimizationStrategy { get; set; }
		
		/// <summary>
		/// Preferences concerning Sole Tenancy nodes and VMs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="soleTenancyPreferences")]
		public SoleTenancyPreferences SoleTenancyPreferences { get; set; }
		
		/// <summary>
		/// Target product for assets using this preference set. Specify either target product or business goal, but not both.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetProduct")]
		public System.Nullable<VirtualMachinePreferencesTargetProduct> TargetProduct { get; set; }
		
		/// <summary>
		/// The user preferences relating to Google Cloud VMware Engine target platform.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmwareEnginePreferences")]
		public VmwareEnginePreferences VmwareEnginePreferences { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum VirtualMachinePreferencesCommitmentPlan
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMMITMENT_PLAN_UNSPECIFIED")]
		COMMITMENT_PLAN_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMMITMENT_PLAN_NONE")]
		COMMITMENT_PLAN_NONE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMMITMENT_PLAN_ONE_YEAR")]
		COMMITMENT_PLAN_ONE_YEAR = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMMITMENT_PLAN_THREE_YEARS")]
		COMMITMENT_PLAN_THREE_YEARS = 3,
	}
	
	/// <summary>
	/// The user preferences relating to target regions.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionPreferences
	{
		
		/// <summary>
		/// A list of preferred regions, ordered by the most preferred region first. Set only valid Google Cloud region names. See https://cloud.google.com/compute/docs/regions-zones for available regions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preferredRegions")]
		public string[] PreferredRegions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum VirtualMachinePreferencesSizingOptimizationStrategy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED")]
		SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE")]
		SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SIZING_OPTIMIZATION_STRATEGY_MODERATE")]
		SIZING_OPTIMIZATION_STRATEGY_MODERATE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE")]
		SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE = 3,
	}
	
	/// <summary>
	/// Preferences concerning Sole Tenancy nodes and VMs.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SoleTenancyPreferences
	{
		
		/// <summary>
		/// Commitment plan to consider when calculating costs for virtual machine insights and recommendations. If you are unsure which value to set, a 3 year commitment plan is often a good value to start with.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commitmentPlan")]
		public System.Nullable<SoleTenancyPreferencesCommitmentPlan> CommitmentPlan { get; set; }
		
		/// <summary>
		/// CPU overcommit ratio. Acceptable values are between 1.0 and 2.0 inclusive.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuOvercommitRatio")]
		public System.Nullable<System.Double> CpuOvercommitRatio { get; set; }
		
		/// <summary>
		/// Sole Tenancy nodes maintenance policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostMaintenancePolicy")]
		public System.Nullable<SoleTenancyPreferencesHostMaintenancePolicy> HostMaintenancePolicy { get; set; }
		
		/// <summary>
		/// A list of sole tenant node types. An empty list means that all possible node types will be considered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeTypes")]
		public SoleTenantNodeType[] NodeTypes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SoleTenancyPreferencesCommitmentPlan
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMMITMENT_PLAN_UNSPECIFIED")]
		COMMITMENT_PLAN_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ON_DEMAND")]
		ON_DEMAND = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMMITMENT_1_YEAR")]
		COMMITMENT_1_YEAR = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMMITMENT_3_YEAR")]
		COMMITMENT_3_YEAR = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SoleTenancyPreferencesHostMaintenancePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HOST_MAINTENANCE_POLICY_UNSPECIFIED")]
		HOST_MAINTENANCE_POLICY_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HOST_MAINTENANCE_POLICY_DEFAULT")]
		HOST_MAINTENANCE_POLICY_DEFAULT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HOST_MAINTENANCE_POLICY_RESTART_IN_PLACE")]
		HOST_MAINTENANCE_POLICY_RESTART_IN_PLACE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HOST_MAINTENANCE_POLICY_MIGRATE_WITHIN_NODE_GROUP")]
		HOST_MAINTENANCE_POLICY_MIGRATE_WITHIN_NODE_GROUP = 3,
	}
	
	/// <summary>
	/// A Sole Tenant node type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SoleTenantNodeType
	{
		
		/// <summary>
		/// Name of the Sole Tenant node. Consult https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeName")]
		public string NodeName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum VirtualMachinePreferencesTargetProduct
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMPUTE_MIGRATION_TARGET_PRODUCT_UNSPECIFIED")]
		COMPUTE_MIGRATION_TARGET_PRODUCT_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE")]
		COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMPUTE_MIGRATION_TARGET_PRODUCT_VMWARE_ENGINE")]
		COMPUTE_MIGRATION_TARGET_PRODUCT_VMWARE_ENGINE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMPUTE_MIGRATION_TARGET_PRODUCT_SOLE_TENANCY")]
		COMPUTE_MIGRATION_TARGET_PRODUCT_SOLE_TENANCY = 3,
	}
	
	/// <summary>
	/// The user preferences relating to Google Cloud VMware Engine target platform.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmwareEnginePreferences
	{
		
		/// <summary>
		/// Commitment plan to consider when calculating costs for virtual machine insights and recommendations. If you are unsure which value to set, a 3 year commitment plan is often a good value to start with.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commitmentPlan")]
		public System.Nullable<VmwareEnginePreferencesCommitmentPlan> CommitmentPlan { get; set; }
		
		/// <summary>
		/// CPU overcommit ratio. Acceptable values are between 1.0 and 8.0, with 0.1 increment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuOvercommitRatio")]
		public System.Nullable<System.Double> CpuOvercommitRatio { get; set; }
		
		/// <summary>
		/// Memory overcommit ratio. Acceptable values are 1.0, 1.25, 1.5, 1.75 and 2.0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memoryOvercommitRatio")]
		public System.Nullable<System.Double> MemoryOvercommitRatio { get; set; }
		
		/// <summary>
		/// The Deduplication and Compression ratio is based on the logical (Used Before) space required to store data before applying deduplication and compression, in relation to the physical (Used After) space required after applying deduplication and compression. Specifically, the ratio is the Used Before space divided by the Used After space. For example, if the Used Before space is 3 GB, but the physical Used After space is 1 GB, the deduplication and compression ratio is 3x. Acceptable values are between 1.0 and 4.0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageDeduplicationCompressionRatio")]
		public System.Nullable<System.Double> StorageDeduplicationCompressionRatio { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum VmwareEnginePreferencesCommitmentPlan
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMMITMENT_PLAN_UNSPECIFIED")]
		COMMITMENT_PLAN_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ON_DEMAND")]
		ON_DEMAND = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMMITMENT_1_YEAR_MONTHLY_PAYMENTS")]
		COMMITMENT_1_YEAR_MONTHLY_PAYMENTS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMMITMENT_3_YEAR_MONTHLY_PAYMENTS")]
		COMMITMENT_3_YEAR_MONTHLY_PAYMENTS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMMITMENT_1_YEAR_UPFRONT_PAYMENT")]
		COMMITMENT_1_YEAR_UPFRONT_PAYMENT = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMMITMENT_3_YEAR_UPFRONT_PAYMENT")]
		COMMITMENT_3_YEAR_UPFRONT_PAYMENT = 5,
	}
	
	/// <summary>
	/// Response message for listing report configs.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListReportConfigsResponse
	{
		
		/// <summary>
		/// A token identifying a page of results the server should return.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// A list of report configs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reportConfigs")]
		public ReportConfig[] ReportConfigs { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// The groups and associated preference sets on which we can generate reports.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportConfig
	{
		
		/// <summary>
		/// Output only. The timestamp when the resource was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Free-text description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// User-friendly display name. Maximum length is 63 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Required. Collection of combinations of groups and preference sets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPreferencesetAssignments")]
		public ReportConfigGroupPreferenceSetAssignment[] GroupPreferencesetAssignments { get; set; }
		
		/// <summary>
		/// Output only. Name of resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. The timestamp when the resource was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// Represents a combination of a group with a preference set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportConfigGroupPreferenceSetAssignment
	{
		
		/// <summary>
		/// Required. Name of the group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public string Group { get; set; }
		
		/// <summary>
		/// Required. Name of the Preference Set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preferenceSet")]
		public string PreferenceSet { get; set; }
	}
	
	/// <summary>
	/// Response message for listing Reports.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListReportsResponse
	{
		
		/// <summary>
		/// A token identifying a page of results the server should return.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The list of Reports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reports")]
		public Report[] Reports { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// Report represents a point-in-time rendering of the ReportConfig results.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Report
	{
		
		/// <summary>
		/// Output only. Creation timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Free-text description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// User-friendly display name. Maximum length is 63 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Output only. Name of resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Report creation state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<ReportState> State { get; set; }
		
		/// <summary>
		/// Describes the Summary view of a Report, which contains aggregated values for all the groups and preference sets included in this Report.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="summary")]
		public ReportSummary Summary { get; set; }
		
		/// <summary>
		/// Report type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<ReportType> Type { get; set; }
		
		/// <summary>
		/// Output only. Last update timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ReportState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="STATE_UNSPECIFIED")]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PENDING")]
		PENDING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SUCCEEDED")]
		SUCCEEDED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FAILED")]
		FAILED = 3,
	}
	
	/// <summary>
	/// Describes the Summary view of a Report, which contains aggregated values for all the groups and preference sets included in this Report.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportSummary
	{
		
		/// <summary>
		/// Aggregate statistics for a collection of assets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allAssetsStats")]
		public ReportSummaryAssetAggregateStats AllAssetsStats { get; set; }
		
		/// <summary>
		/// Findings for each Group included in this report.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupFindings")]
		public ReportSummaryGroupFinding[] GroupFindings { get; set; }
	}
	
	/// <summary>
	/// Aggregate statistics for a collection of assets.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportSummaryAssetAggregateStats
	{
		
		/// <summary>
		/// A Histogram Chart shows a distribution of values into buckets, showing a count of values which fall into a bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="coreCountHistogram")]
		public ReportSummaryHistogramChartData CoreCountHistogram { get; set; }
		
		/// <summary>
		/// A Histogram Chart shows a distribution of values into buckets, showing a count of values which fall into a bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memoryBytesHistogram")]
		public ReportSummaryHistogramChartData MemoryBytesHistogram { get; set; }
		
		/// <summary>
		/// Utilization Chart is a specific type of visualization which displays a metric classified into "Used" and "Free" buckets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memoryUtilizationChart")]
		public ReportSummaryUtilizationChartData MemoryUtilizationChart { get; set; }
		
		/// <summary>
		/// Describes a collection of data points rendered as a Chart.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operatingSystem")]
		public ReportSummaryChartData OperatingSystem { get; set; }
		
		/// <summary>
		/// A Histogram Chart shows a distribution of values into buckets, showing a count of values which fall into a bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageBytesHistogram")]
		public ReportSummaryHistogramChartData StorageBytesHistogram { get; set; }
		
		/// <summary>
		/// Utilization Chart is a specific type of visualization which displays a metric classified into "Used" and "Free" buckets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageUtilizationChart")]
		public ReportSummaryUtilizationChartData StorageUtilizationChart { get; set; }
		
		/// <summary>
		/// Count of the number of unique assets in this collection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalAssets")]
		public string TotalAssets { get; set; }
		
		/// <summary>
		/// Sum of the CPU core count of all the assets in this collection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalCores")]
		public string TotalCores { get; set; }
		
		/// <summary>
		/// Sum of the memory in bytes of all the assets in this collection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalMemoryBytes")]
		public string TotalMemoryBytes { get; set; }
		
		/// <summary>
		/// Sum of persistent storage in bytes of all the assets in this collection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalStorageBytes")]
		public string TotalStorageBytes { get; set; }
	}
	
	/// <summary>
	/// A Histogram Chart shows a distribution of values into buckets, showing a count of values which fall into a bucket.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportSummaryHistogramChartData
	{
		
		/// <summary>
		/// Buckets in the histogram. There will be `n+1` buckets matching `n` lower bounds in the request. The first bucket will be from -infinity to the first bound. Subsequent buckets will be between one bound and the next. The final bucket will be from the final bound to infinity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="buckets")]
		public ReportSummaryHistogramChartDataBucket[] Buckets { get; set; }
	}
	
	/// <summary>
	/// A histogram bucket with a lower and upper bound, and a count of items with a field value between those bounds. The lower bound is inclusive and the upper bound is exclusive. Lower bound may be -infinity and upper bound may be infinity.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportSummaryHistogramChartDataBucket
	{
		
		/// <summary>
		/// Count of items in the bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public string Count { get; set; }
		
		/// <summary>
		/// Lower bound - inclusive.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lowerBound")]
		public string LowerBound { get; set; }
		
		/// <summary>
		/// Upper bound - exclusive.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upperBound")]
		public string UpperBound { get; set; }
	}
	
	/// <summary>
	/// Utilization Chart is a specific type of visualization which displays a metric classified into "Used" and "Free" buckets.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportSummaryUtilizationChartData
	{
		
		/// <summary>
		/// Aggregate value which falls into the "Free" bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="free")]
		public string Free { get; set; }
		
		/// <summary>
		/// Aggregate value which falls into the "Used" bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="used")]
		public string Used { get; set; }
	}
	
	/// <summary>
	/// Describes a collection of data points rendered as a Chart.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportSummaryChartData
	{
		
		/// <summary>
		/// Each data point in the chart is represented as a name-value pair with the name being the x-axis label, and the value being the y-axis value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataPoints")]
		public ReportSummaryChartDataDataPoint[] DataPoints { get; set; }
	}
	
	/// <summary>
	/// Describes a single data point in the Chart.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportSummaryChartDataDataPoint
	{
		
		/// <summary>
		/// The X-axis label for this data point.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The Y-axis value for this data point.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Double> Value { get; set; }
	}
	
	/// <summary>
	/// Summary Findings for a specific Group.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportSummaryGroupFinding
	{
		
		/// <summary>
		/// Aggregate statistics for a collection of assets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetAggregateStats")]
		public ReportSummaryAssetAggregateStats AssetAggregateStats { get; set; }
		
		/// <summary>
		/// Description for the Group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Display Name for the Group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// This field is deprecated, do not rely on it having a value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="overlappingAssetCount")]
		public string OverlappingAssetCount { get; set; }
		
		/// <summary>
		/// Findings for each of the PreferenceSets for this group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preferenceSetFindings")]
		public ReportSummaryGroupPreferenceSetFinding[] PreferenceSetFindings { get; set; }
	}
	
	/// <summary>
	/// Summary Findings for a specific Group/PreferenceSet combination.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportSummaryGroupPreferenceSetFinding
	{
		
		/// <summary>
		/// A set of findings that applies to assets destined for Compute Engine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computeEngineFinding")]
		public ReportSummaryComputeEngineFinding ComputeEngineFinding { get; set; }
		
		/// <summary>
		/// Description for the Preference Set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Display Name of the Preference Set
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// VirtualMachinePreferences enables you to create sets of assumptions, for example, a geographical location and pricing track, for your migrated virtual machines. The set of preferences influence recommendations for migrating virtual machine assets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machinePreferences")]
		public VirtualMachinePreferences MachinePreferences { get; set; }
		
		/// <summary>
		/// Represents an amount of money with its currency type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monthlyCostCompute")]
		public Money MonthlyCostCompute { get; set; }
		
		/// <summary>
		/// Represents an amount of money with its currency type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monthlyCostNetworkEgress")]
		public Money MonthlyCostNetworkEgress { get; set; }
		
		/// <summary>
		/// Represents an amount of money with its currency type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monthlyCostOsLicense")]
		public Money MonthlyCostOsLicense { get; set; }
		
		/// <summary>
		/// Represents an amount of money with its currency type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monthlyCostOther")]
		public Money MonthlyCostOther { get; set; }
		
		/// <summary>
		/// Represents an amount of money with its currency type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monthlyCostStorage")]
		public Money MonthlyCostStorage { get; set; }
		
		/// <summary>
		/// Represents an amount of money with its currency type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monthlyCostTotal")]
		public Money MonthlyCostTotal { get; set; }
		
		/// <summary>
		/// A set of findings that applies to assets destined for Sole-Tenant nodes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="soleTenantFinding")]
		public ReportSummarySoleTenantFinding SoleTenantFinding { get; set; }
		
		/// <summary>
		/// A set of findings that applies to assets destined for VMWare Engine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmwareEngineFinding")]
		public ReportSummaryVmwareEngineFinding VmwareEngineFinding { get; set; }
	}
	
	/// <summary>
	/// A set of findings that applies to assets destined for Compute Engine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportSummaryComputeEngineFinding
	{
		
		/// <summary>
		/// Count of assets which were allocated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allocatedAssetCount")]
		public string AllocatedAssetCount { get; set; }
		
		/// <summary>
		/// Set of disk types allocated to assets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allocatedDiskTypes")]
		public ComputeStorageDescriptorType[] AllocatedDiskTypes { get; set; }
		
		/// <summary>
		/// Set of regions in which the assets were allocated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allocatedRegions")]
		public string[] AllocatedRegions { get; set; }
		
		/// <summary>
		/// Distribution of assets based on the Machine Series.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineSeriesAllocations")]
		public ReportSummaryMachineSeriesAllocation[] MachineSeriesAllocations { get; set; }
	}
	
	/// <summary>
	/// Represents a data point tracking the count of assets allocated for a specific Machine Series.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportSummaryMachineSeriesAllocation
	{
		
		/// <summary>
		/// Count of assets allocated to this machine series.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allocatedAssetCount")]
		public string AllocatedAssetCount { get; set; }
		
		/// <summary>
		/// A Compute Engine machine series.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineSeries")]
		public MachineSeries MachineSeries { get; set; }
	}
	
	/// <summary>
	/// Represents an amount of money with its currency type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Money
	{
		
		/// <summary>
		/// The three-letter currency code defined in ISO 4217.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currencyCode")]
		public string CurrencyCode { get; set; }
		
		/// <summary>
		/// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nanos")]
		public System.Nullable<System.Int32> Nanos { get; set; }
		
		/// <summary>
		/// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="units")]
		public string Units { get; set; }
	}
	
	/// <summary>
	/// A set of findings that applies to assets destined for Sole-Tenant nodes.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportSummarySoleTenantFinding
	{
		
		/// <summary>
		/// Count of assets which are allocated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allocatedAssetCount")]
		public string AllocatedAssetCount { get; set; }
		
		/// <summary>
		/// Set of regions in which the assets are allocated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allocatedRegions")]
		public string[] AllocatedRegions { get; set; }
		
		/// <summary>
		/// Set of per-nodetype allocation records
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeAllocations")]
		public ReportSummarySoleTenantNodeAllocation[] NodeAllocations { get; set; }
	}
	
	/// <summary>
	/// Represents the assets allocated to a specific Sole-Tenant node type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportSummarySoleTenantNodeAllocation
	{
		
		/// <summary>
		/// Count of assets allocated to these nodes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allocatedAssetCount")]
		public string AllocatedAssetCount { get; set; }
		
		/// <summary>
		/// A Sole Tenant node type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="node")]
		public SoleTenantNodeType Node { get; set; }
		
		/// <summary>
		/// Count of this node type to be provisioned
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeCount")]
		public string NodeCount { get; set; }
	}
	
	/// <summary>
	/// A set of findings that applies to assets destined for VMWare Engine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportSummaryVmwareEngineFinding
	{
		
		/// <summary>
		/// Count of assets which are allocated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allocatedAssetCount")]
		public string AllocatedAssetCount { get; set; }
		
		/// <summary>
		/// Set of regions in which the assets were allocated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allocatedRegions")]
		public string[] AllocatedRegions { get; set; }
		
		/// <summary>
		/// Set of per-nodetype allocation records
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeAllocations")]
		public ReportSummaryVmwareNodeAllocation[] NodeAllocations { get; set; }
	}
	
	/// <summary>
	/// Represents assets allocated to a specific VMWare Node type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportSummaryVmwareNodeAllocation
	{
		
		/// <summary>
		/// Count of assets allocated to these nodes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allocatedAssetCount")]
		public string AllocatedAssetCount { get; set; }
		
		/// <summary>
		/// Count of this node type to be provisioned
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeCount")]
		public string NodeCount { get; set; }
		
		/// <summary>
		/// A VMWare Engine Node
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmwareNode")]
		public ReportSummaryVmwareNode VmwareNode { get; set; }
	}
	
	/// <summary>
	/// A VMWare Engine Node
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportSummaryVmwareNode
	{
		
		/// <summary>
		/// Code to identify VMware Engine node series, e.g. "ve1-standard-72". Based on the displayName of cloud.google.com/vmware-engine/docs/reference/rest/v1/projects.locations.nodeTypes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ReportType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TYPE_UNSPECIFIED")]
		TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TOTAL_COST_OF_OWNERSHIP")]
		TOTAL_COST_OF_OWNERSHIP = 1,
	}
	
	/// <summary>
	/// Response message for listing sources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListSourcesResponse
	{
		
		/// <summary>
		/// A token identifying a page of results the server should return.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The list of sources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sources")]
		public Source[] Sources { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// Source represents an object from which asset information is streamed to Migration Center.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Source
	{
		
		/// <summary>
		/// Output only. The timestamp when the source was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Free-text description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// User-friendly display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Output only. The number of frames that were reported by the source and contained errors.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorFrameCount")]
		public System.Nullable<System.Int32> ErrorFrameCount { get; set; }
		
		/// <summary>
		/// If `true`, the source is managed by other service(s).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managed")]
		public System.Nullable<System.Boolean> Managed { get; set; }
		
		/// <summary>
		/// Output only. The full name of the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. Number of frames that are still being processed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pendingFrameCount")]
		public System.Nullable<System.Int32> PendingFrameCount { get; set; }
		
		/// <summary>
		/// The information confidence of the source. The higher the value, the higher the confidence.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public System.Nullable<System.Int32> Priority { get; set; }
		
		/// <summary>
		/// Output only. The state of the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<SourceState> State { get; set; }
		
		/// <summary>
		/// Data source type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<SourceType> Type { get; set; }
		
		/// <summary>
		/// Output only. The timestamp when the source was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SourceState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="STATE_UNSPECIFIED")]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETING")]
		DELETING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INVALID")]
		INVALID = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SOURCE_TYPE_UNKNOWN")]
		SOURCE_TYPE_UNKNOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SOURCE_TYPE_UPLOAD")]
		SOURCE_TYPE_UPLOAD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SOURCE_TYPE_GUEST_OS_SCAN")]
		SOURCE_TYPE_GUEST_OS_SCAN = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SOURCE_TYPE_INVENTORY_SCAN")]
		SOURCE_TYPE_INVENTORY_SCAN = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SOURCE_TYPE_CUSTOM")]
		SOURCE_TYPE_CUSTOM = 4,
	}
	
	/// <summary>
	/// Represents the metadata of the long-running operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OperationMetadata
	{
		
		/// <summary>
		/// Output only. API version used to start the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiVersion")]
		public string ApiVersion { get; set; }
		
		/// <summary>
		/// Output only. The time the operation was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Output only. The time the operation finished running.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// Output only. Identifies whether the user has requested cancellation of the operation. Operations that have been cancelled successfully have Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestedCancellation")]
		public System.Nullable<System.Boolean> RequestedCancellation { get; set; }
		
		/// <summary>
		/// Output only. Human-readable status of the operation, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusMessage")]
		public string StatusMessage { get; set; }
		
		/// <summary>
		/// Output only. Server-defined resource path for the target of the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
		
		/// <summary>
		/// Output only. Name of the verb executed by the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="verb")]
		public string Verb { get; set; }
	}
	
	/// <summary>
	/// A request to remove assets from a group.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RemoveAssetsFromGroupRequest
	{
		
		/// <summary>
		/// Optional. When this value is set to `false` and one of the given assets is not an existing member of the group, the operation fails with a `Not Found` error. When set to `true` this situation is silently ignored by the server. Default value is `false`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowMissing")]
		public System.Nullable<System.Boolean> AllowMissing { get; set; }
		
		/// <summary>
		/// Lists the asset IDs of all assets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public AssetList Assets { get; set; }
		
		/// <summary>
		/// Optional. An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes after the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestId")]
		public string RequestId { get; set; }
	}
	
	/// <summary>
	/// A response to a call to `ReportAssetFrame`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReportAssetFramesResponse
	{
	}
	
	/// <summary>
	/// A request to run an import job.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RunImportJobRequest
	{
		
		/// <summary>
		/// Optional. An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes after the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestId")]
		public string RequestId { get; set; }
	}
	
	/// <summary>
	/// Describes the Migration Center settings related to the project.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Settings
	{
		
		/// <summary>
		/// Disable Cloud Logging for the Migration Center API. Users are billed for the logs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disableCloudLogging")]
		public System.Nullable<System.Boolean> DisableCloudLogging { get; set; }
		
		/// <summary>
		/// Output only. The name of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The preference set used by default for a project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preferenceSet")]
		public string PreferenceSet { get; set; }
	}
	
	/// <summary>
	/// A request to validate an import job.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ValidateImportJobRequest
	{
		
		/// <summary>
		/// Optional. An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes after the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestId")]
		public string RequestId { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Adds assets to a group.
		/// Migrationcenter_projects_locations_groups_addAssets v1/{group}:addAssets
		/// </summary>
		/// <param name="group">Required. Group reference.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Migrationcenter_projects_locations_groups_addAssetsAsync(string group, AddAssetsToGroupRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (group==null? "" : System.Uri.EscapeDataString(group))+":addAssets";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes assets from a group.
		/// Migrationcenter_projects_locations_groups_removeAssets v1/{group}:removeAssets
		/// </summary>
		/// <param name="group">Required. Group reference.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Migrationcenter_projects_locations_groups_removeAssetsAsync(string group, RemoveAssetsFromGroupRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (group==null? "" : System.Uri.EscapeDataString(group))+":removeAssets";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a source.
		/// Migrationcenter_projects_locations_sources_delete v1/{name}
		/// </summary>
		/// <param name="name">Required. Name of the resource.</param>
		/// <param name="requestId">Optional. An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes after the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Migrationcenter_projects_locations_sources_deleteAsync(string name, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the details of an error frame.
		/// Migrationcenter_projects_locations_sources_errorFrames_get v1/{name}
		/// </summary>
		/// <param name="name">Required. The name of the frame to retrieve. Format: projects/{project}/locations/{location}/sources/{source}/errorFrames/{error_frame}</param>
		/// <param name="view">Optional. An optional view mode to control the level of details for the frame. The default is a basic frame view.</param>
		/// <returns>Successful response</returns>
		public async Task<ErrorFrame> Migrationcenter_projects_locations_sources_errorFrames_getAsync(string name, Migrationcenter_projects_locations_sources_errorFrames_getView view, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&view=" + view;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ErrorFrame>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the parameters of a source.
		/// Migrationcenter_projects_locations_sources_patch v1/{name}
		/// </summary>
		/// <param name="name">Output only. The full name of the source.</param>
		/// <param name="requestId">Optional. An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <param name="updateMask">Required. Field mask is used to specify the fields to be overwritten in the `Source` resource by the update. The values specified in the `update_mask` field are relative to the resource, not the full request. A field will be overwritten if it is in the mask. A single * value in the mask lets you to overwrite all fields.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Migrationcenter_projects_locations_sources_patchAsync(string name, string requestId, string updateMask, Source requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists information about the supported locations for this service.
		/// Migrationcenter_projects_locations_list v1/{name}/locations
		/// </summary>
		/// <param name="name">The resource that owns the locations collection, if applicable.</param>
		/// <param name="filter">A filter to narrow down results to a preferred subset. The filtering language accepts strings like `"displayName=tokyo"`, and is documented in more detail in [AIP-160](https://google.aip.dev/160).</param>
		/// <param name="pageSize">The maximum number of results to return. If not set, the service selects a default.</param>
		/// <param name="pageToken">A page token received from the `next_page_token` field in the response. Send that page token to receive the subsequent page.</param>
		/// <returns>Successful response</returns>
		public async Task<ListLocationsResponse> Migrationcenter_projects_locations_listAsync(string name, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/locations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListLocationsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists operations that match the specified filter in the request. If the server doesn't support this method, it returns `UNIMPLEMENTED`.
		/// Migrationcenter_projects_locations_operations_list v1/{name}/operations
		/// </summary>
		/// <param name="name">The name of the operation's parent resource.</param>
		/// <param name="filter">The standard list filter.</param>
		/// <param name="pageSize">The standard list page size.</param>
		/// <param name="pageToken">The standard list page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListOperationsResponse> Migrationcenter_projects_locations_operations_listAsync(string name, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/operations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListOperationsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`.
		/// Migrationcenter_projects_locations_operations_cancel v1/{name}:cancel
		/// </summary>
		/// <param name="name">The name of the operation resource to be cancelled.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Migrationcenter_projects_locations_operations_cancelAsync(string name, CancelOperationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":cancel";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Empty>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Runs an import job.
		/// Migrationcenter_projects_locations_importJobs_run v1/{name}:run
		/// </summary>
		/// <param name="name">Required. The name of the import job to run.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Migrationcenter_projects_locations_importJobs_runAsync(string name, RunImportJobRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":run";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Validates an import job.
		/// Migrationcenter_projects_locations_importJobs_validate v1/{name}:validate
		/// </summary>
		/// <param name="name">Required. The name of the import job to validate.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Migrationcenter_projects_locations_importJobs_validateAsync(string name, ValidateImportJobRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":validate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all the assets in a given project and location.
		/// Migrationcenter_projects_locations_assets_list v1/{parent}/assets
		/// </summary>
		/// <param name="parent">Required. Parent value for `ListAssetsRequest`.</param>
		/// <param name="filter">Filtering results.</param>
		/// <param name="orderBy">Field to sort by. See https://google.aip.dev/132#ordering for more details.</param>
		/// <param name="pageSize">Requested page size. Server may return fewer items than requested. If unspecified, server will pick an appropriate default.</param>
		/// <param name="pageToken">A token identifying a page of results the server should return.</param>
		/// <param name="view">View of the assets. Defaults to BASIC.</param>
		/// <returns>Successful response</returns>
		public async Task<ListAssetsResponse> Migrationcenter_projects_locations_assets_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Migrationcenter_projects_locations_assets_listView view, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/assets&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&view=" + view;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListAssetsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Aggregates the requested fields based on provided function.
		/// Migrationcenter_projects_locations_assets_aggregateValues v1/{parent}/assets:aggregateValues
		/// </summary>
		/// <param name="parent">Required. Parent value for `AggregateAssetsValuesRequest`.</param>
		/// <returns>Successful response</returns>
		public async Task<AggregateAssetsValuesResponse> Migrationcenter_projects_locations_assets_aggregateValuesAsync(string parent, AggregateAssetsValuesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/assets:aggregateValues";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AggregateAssetsValuesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes list of Assets.
		/// Migrationcenter_projects_locations_assets_batchDelete v1/{parent}/assets:batchDelete
		/// </summary>
		/// <param name="parent">Required. Parent value for batch asset delete.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Migrationcenter_projects_locations_assets_batchDeleteAsync(string parent, BatchDeleteAssetsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/assets:batchDelete";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Empty>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the parameters of a list of assets.
		/// Migrationcenter_projects_locations_assets_batchUpdate v1/{parent}/assets:batchUpdate
		/// </summary>
		/// <param name="parent">Required. Parent value for batch asset update.</param>
		/// <returns>Successful response</returns>
		public async Task<BatchUpdateAssetsResponse> Migrationcenter_projects_locations_assets_batchUpdateAsync(string parent, BatchUpdateAssetsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/assets:batchUpdate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BatchUpdateAssetsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Reports a set of frames.
		/// Migrationcenter_projects_locations_assets_reportAssetFrames v1/{parent}/assets:reportAssetFrames
		/// </summary>
		/// <param name="parent">Required. Parent of the resource.</param>
		/// <param name="source">Required. Reference to a source.</param>
		/// <returns>Successful response</returns>
		public async Task<ReportAssetFramesResponse> Migrationcenter_projects_locations_assets_reportAssetFramesAsync(string parent, string source, Frames requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/assets:reportAssetFrames&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReportAssetFramesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all error frames in a given source and location.
		/// Migrationcenter_projects_locations_sources_errorFrames_list v1/{parent}/errorFrames
		/// </summary>
		/// <param name="parent">Required. Parent value (the source) for `ListErrorFramesRequest`.</param>
		/// <param name="pageSize">Requested page size. Server may return fewer items than requested. If unspecified, server will pick an appropriate default.</param>
		/// <param name="pageToken">A token identifying a page of results the server should return.</param>
		/// <param name="view">Optional. An optional view mode to control the level of details of each error frame. The default is a BASIC frame view.</param>
		/// <returns>Successful response</returns>
		public async Task<ListErrorFramesResponse> Migrationcenter_projects_locations_sources_errorFrames_listAsync(string parent, int pageSize, string pageToken, Migrationcenter_projects_locations_sources_errorFrames_listView view, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/errorFrames&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&view=" + view;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListErrorFramesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all groups in a given project and location.
		/// Migrationcenter_projects_locations_groups_list v1/{parent}/groups
		/// </summary>
		/// <param name="parent">Required. Parent value for `ListGroupsRequest`.</param>
		/// <param name="filter">Filtering results.</param>
		/// <param name="orderBy">Field to sort by. See https://google.aip.dev/132#ordering for more details.</param>
		/// <param name="pageSize">Requested page size. Server may return fewer items than requested. If unspecified, server will pick an appropriate default.</param>
		/// <param name="pageToken">A token identifying a page of results the server should return.</param>
		/// <returns>Successful response</returns>
		public async Task<ListGroupsResponse> Migrationcenter_projects_locations_groups_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/groups&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListGroupsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new group in a given project and location.
		/// Migrationcenter_projects_locations_groups_create v1/{parent}/groups
		/// </summary>
		/// <param name="parent">Required. Value for parent.</param>
		/// <param name="groupId">Required. User specified ID for the group. It will become the last component of the group name. The ID must be unique within the project, must conform with RFC-1034, is restricted to lower-cased letters, and has a maximum length of 63 characters. The ID must match the regular expression: `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.</param>
		/// <param name="requestId">Optional. An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Migrationcenter_projects_locations_groups_createAsync(string parent, string groupId, string requestId, Group requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/groups&groupId=" + (groupId==null? "" : System.Uri.EscapeDataString(groupId))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List import data files.
		/// Migrationcenter_projects_locations_importJobs_importDataFiles_list v1/{parent}/importDataFiles
		/// </summary>
		/// <param name="parent">Required. Name of the parent of the `ImportDataFiles` resource.</param>
		/// <param name="filter">Filtering results.</param>
		/// <param name="orderBy">Field to sort by. See https://google.aip.dev/132#ordering for more details.</param>
		/// <param name="pageSize">The maximum number of data files to return. The service may return fewer than this value. If unspecified, at most 500 data files will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.</param>
		/// <param name="pageToken">A page token, received from a previous `ListImportDataFiles` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListImportDataFiles` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListImportDataFilesResponse> Migrationcenter_projects_locations_importJobs_importDataFiles_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/importDataFiles&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListImportDataFilesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an import data file.
		/// Migrationcenter_projects_locations_importJobs_importDataFiles_create v1/{parent}/importDataFiles
		/// </summary>
		/// <param name="parent">Required. Name of the parent of the ImportDataFile.</param>
		/// <param name="importDataFileId">Required. The ID of the new data file.</param>
		/// <param name="requestId">Optional. An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Migrationcenter_projects_locations_importJobs_importDataFiles_createAsync(string parent, string importDataFileId, string requestId, ImportDataFile requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/importDataFiles&importDataFileId=" + (importDataFileId==null? "" : System.Uri.EscapeDataString(importDataFileId))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all import jobs.
		/// Migrationcenter_projects_locations_importJobs_list v1/{parent}/importJobs
		/// </summary>
		/// <param name="parent">Required. Parent value for `ListImportJobsRequest`.</param>
		/// <param name="filter">Filtering results.</param>
		/// <param name="orderBy">Field to sort by. See https://google.aip.dev/132#ordering for more details.</param>
		/// <param name="pageSize">Requested page size. Server may return fewer items than requested. If unspecified, server will pick an appropriate default.</param>
		/// <param name="pageToken">A token identifying a page of results the server should return.</param>
		/// <param name="view">Optional. The level of details of each import job. Default value is BASIC.</param>
		/// <returns>Successful response</returns>
		public async Task<ListImportJobsResponse> Migrationcenter_projects_locations_importJobs_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Migrationcenter_projects_locations_importJobs_listView view, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/importJobs&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&view=" + view;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListImportJobsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an import job.
		/// Migrationcenter_projects_locations_importJobs_create v1/{parent}/importJobs
		/// </summary>
		/// <param name="parent">Required. Value for parent.</param>
		/// <param name="importJobId">Required. ID of the import job.</param>
		/// <param name="requestId">Optional. An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Migrationcenter_projects_locations_importJobs_createAsync(string parent, string importJobId, string requestId, ImportJob requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/importJobs&importJobId=" + (importJobId==null? "" : System.Uri.EscapeDataString(importJobId))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all the preference sets in a given project and location.
		/// Migrationcenter_projects_locations_preferenceSets_list v1/{parent}/preferenceSets
		/// </summary>
		/// <param name="parent">Required. Parent value for `ListPreferenceSetsRequest`.</param>
		/// <param name="orderBy">Field to sort by. See https://google.aip.dev/132#ordering for more details.</param>
		/// <param name="pageSize">Requested page size. Server may return fewer items than requested. If unspecified, at most 500 preference sets will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.</param>
		/// <param name="pageToken">A token identifying a page of results the server should return.</param>
		/// <returns>Successful response</returns>
		public async Task<ListPreferenceSetsResponse> Migrationcenter_projects_locations_preferenceSets_listAsync(string parent, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/preferenceSets&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListPreferenceSetsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new preference set in a given project and location.
		/// Migrationcenter_projects_locations_preferenceSets_create v1/{parent}/preferenceSets
		/// </summary>
		/// <param name="parent">Required. Value for parent.</param>
		/// <param name="preferenceSetId">Required. User specified ID for the preference set. It will become the last component of the preference set name. The ID must be unique within the project, must conform with RFC-1034, is restricted to lower-cased letters, and has a maximum length of 63 characters. The ID must match the regular expression `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.</param>
		/// <param name="requestId">Optional. An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Migrationcenter_projects_locations_preferenceSets_createAsync(string parent, string preferenceSetId, string requestId, PreferenceSet requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/preferenceSets&preferenceSetId=" + (preferenceSetId==null? "" : System.Uri.EscapeDataString(preferenceSetId))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists ReportConfigs in a given project and location.
		/// Migrationcenter_projects_locations_reportConfigs_list v1/{parent}/reportConfigs
		/// </summary>
		/// <param name="parent">Required. Parent value for `ListReportConfigsRequest`.</param>
		/// <param name="filter">Filtering results.</param>
		/// <param name="orderBy">Field to sort by. See https://google.aip.dev/132#ordering for more details.</param>
		/// <param name="pageSize">Requested page size. Server may return fewer items than requested. If unspecified, server will pick an appropriate default.</param>
		/// <param name="pageToken">A token identifying a page of results the server should return.</param>
		/// <returns>Successful response</returns>
		public async Task<ListReportConfigsResponse> Migrationcenter_projects_locations_reportConfigs_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/reportConfigs&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListReportConfigsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a report configuration.
		/// Migrationcenter_projects_locations_reportConfigs_create v1/{parent}/reportConfigs
		/// </summary>
		/// <param name="parent">Required. Value for parent.</param>
		/// <param name="reportConfigId">Required. User specified ID for the report config. It will become the last component of the report config name. The ID must be unique within the project, must conform with RFC-1034, is restricted to lower-cased letters, and has a maximum length of 63 characters. The ID must match the regular expression: [a-z]([a-z0-9-]{0,61}[a-z0-9])?.</param>
		/// <param name="requestId">Optional. An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Migrationcenter_projects_locations_reportConfigs_createAsync(string parent, string reportConfigId, string requestId, ReportConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/reportConfigs&reportConfigId=" + (reportConfigId==null? "" : System.Uri.EscapeDataString(reportConfigId))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists Reports in a given ReportConfig.
		/// Migrationcenter_projects_locations_reportConfigs_reports_list v1/{parent}/reports
		/// </summary>
		/// <param name="parent">Required. Parent value for `ListReportsRequest`.</param>
		/// <param name="filter">Filtering results.</param>
		/// <param name="orderBy">Field to sort by. See https://google.aip.dev/132#ordering for more details.</param>
		/// <param name="pageSize">Requested page size. The server may return fewer items than requested. If unspecified, the server will pick an appropriate default value.</param>
		/// <param name="pageToken">A token identifying a page of results that the server should return.</param>
		/// <param name="view">Determines what information to retrieve for each Report.</param>
		/// <returns>Successful response</returns>
		public async Task<ListReportsResponse> Migrationcenter_projects_locations_reportConfigs_reports_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Migrationcenter_projects_locations_reportConfigs_reports_listView view, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/reports&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&view=" + view;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListReportsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a report.
		/// Migrationcenter_projects_locations_reportConfigs_reports_create v1/{parent}/reports
		/// </summary>
		/// <param name="parent">Required. Value for parent.</param>
		/// <param name="reportId">Required. User specified id for the report. It will become the last component of the report name. The id must be unique within the project, must conform with RFC-1034, is restricted to lower-cased letters, and has a maximum length of 63 characters. The id must match the regular expression: [a-z]([a-z0-9-]{0,61}[a-z0-9])?.</param>
		/// <param name="requestId">Optional. An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Migrationcenter_projects_locations_reportConfigs_reports_createAsync(string parent, string reportId, string requestId, Report requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/reports&reportId=" + (reportId==null? "" : System.Uri.EscapeDataString(reportId))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all the sources in a given project and location.
		/// Migrationcenter_projects_locations_sources_list v1/{parent}/sources
		/// </summary>
		/// <param name="parent">Required. Parent value for `ListSourcesRequest`.</param>
		/// <param name="filter">Filtering results.</param>
		/// <param name="orderBy">Field to sort by. See https://google.aip.dev/132#ordering for more details.</param>
		/// <param name="pageSize">Requested page size. The server may return fewer items than requested. If unspecified, the server will pick an appropriate default value.</param>
		/// <param name="pageToken">A token identifying a page of results that the server should return.</param>
		/// <returns>Successful response</returns>
		public async Task<ListSourcesResponse> Migrationcenter_projects_locations_sources_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/sources&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListSourcesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new source in a given project and location.
		/// Migrationcenter_projects_locations_sources_create v1/{parent}/sources
		/// </summary>
		/// <param name="parent">Required. Value for parent.</param>
		/// <param name="requestId">Optional. An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <param name="sourceId">Required. User specified ID for the source. It will become the last component of the source name. The ID must be unique within the project, must conform with RFC-1034, is restricted to lower-cased letters, and has a maximum length of 63 characters. The ID must match the regular expression: `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Migrationcenter_projects_locations_sources_createAsync(string parent, string requestId, string sourceId, Source requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/sources&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&sourceId=" + (sourceId==null? "" : System.Uri.EscapeDataString(sourceId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	public enum Migrationcenter_projects_locations_sources_errorFrames_getView
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ERROR_FRAME_VIEW_UNSPECIFIED")]
		ERROR_FRAME_VIEW_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ERROR_FRAME_VIEW_BASIC")]
		ERROR_FRAME_VIEW_BASIC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ERROR_FRAME_VIEW_FULL")]
		ERROR_FRAME_VIEW_FULL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="REPORT_VIEW_STANDARD")]
		REPORT_VIEW_STANDARD = 3,
	}
	
	public enum Migrationcenter_projects_locations_assets_listView
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ASSET_VIEW_UNSPECIFIED")]
		ASSET_VIEW_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ASSET_VIEW_BASIC")]
		ASSET_VIEW_BASIC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ASSET_VIEW_FULL")]
		ASSET_VIEW_FULL = 2,
	}
	
	public enum Migrationcenter_projects_locations_sources_errorFrames_listView
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ERROR_FRAME_VIEW_UNSPECIFIED")]
		ERROR_FRAME_VIEW_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ERROR_FRAME_VIEW_BASIC")]
		ERROR_FRAME_VIEW_BASIC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ERROR_FRAME_VIEW_FULL")]
		ERROR_FRAME_VIEW_FULL = 2,
	}
	
	public enum Migrationcenter_projects_locations_importJobs_listView
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IMPORT_JOB_VIEW_UNSPECIFIED")]
		IMPORT_JOB_VIEW_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IMPORT_JOB_VIEW_BASIC")]
		IMPORT_JOB_VIEW_BASIC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IMPORT_JOB_VIEW_FULL")]
		IMPORT_JOB_VIEW_FULL = 2,
	}
	
	public enum Migrationcenter_projects_locations_reportConfigs_reports_listView
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="REPORT_VIEW_UNSPECIFIED")]
		REPORT_VIEW_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="REPORT_VIEW_BASIC")]
		REPORT_VIEW_BASIC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="REPORT_VIEW_FULL")]
		REPORT_VIEW_FULL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="REPORT_VIEW_STANDARD")]
		REPORT_VIEW_STANDARD = 3,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
