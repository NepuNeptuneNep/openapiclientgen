//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// The structure representing the AddNotificationChannelsResponse.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AddNotificationChannelsResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="notificationConfiguration")]
		public NotificationConfiguration NotificationConfiguration { get; set; }
	}
	
	/// <summary>
	/// The configuration for notifications stored for each profiling group. This includes up to to two channels and a list of event publishers associated with each channel.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotificationConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="channels")]
		public Channel[] Channels { get; set; }
	}
	
	/// <summary>
	/// Notification medium for users to get alerted for events that occur in application profile. We support SNS topic as a notification channel.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Channel
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="eventPublishers")]
		public EventPublisher[] EventPublishers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum EventPublisher
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AnomalyDetection")]
		AnomalyDetection = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServiceQuotaExceededException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InternalServerException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConflictException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ValidationException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ThrottlingException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceNotFoundException
	{
	}
	
	/// <summary>
	/// The structure representing the BatchGetFrameMetricDataResponse.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchGetFrameMetricDataResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endTimes")]
		public TimestampStructure[] EndTimes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="frameMetricData")]
		public FrameMetricDatum[] FrameMetricData { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public AggregationPeriod Resolution { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="unprocessedEndTimes")]
		public UnprocessedEndTimeMap UnprocessedEndTimes { get; set; }
	}
	
	/// <summary>
	///  A data type that contains a <code>Timestamp</code> object. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TimestampStructure
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.DateTimeOffset Value { get; set; }
	}
	
	/// <summary>
	///  Information about a frame metric and its values. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FrameMetricDatum
	{
		
		/// <summary>
		///  The frame name, metric type, and thread states. These are used to derive the value of the metric for the frame.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="frameMetric")]
		public FrameMetric FrameMetric { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="values")]
		public double[] Values { get; set; }
	}
	
	/// <summary>
	///  The frame name, metric type, and thread states. These are used to derive the value of the metric for the frame.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FrameMetric
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="frameName")]
		public string FrameName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="threadStates")]
		public string[] ThreadStates { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public MetricType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MetricType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AggregatedRelativeTotalTime")]
		AggregatedRelativeTotalTime = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AggregationPeriod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PT5M")]
		PT5M = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PT1H")]
		PT1H = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="P1D")]
		P1D = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UnprocessedEndTimeMap
	{
	}
	
	/// <summary>
	/// The structure representing the configureAgentResponse.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigureAgentResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configuration")]
		public AgentConfiguration Configuration { get; set; }
	}
	
	/// <summary>
	///  The response of <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html"> <code>ConfigureAgent</code> </a> that specifies if an agent profiles or not and for how long to return profiling data. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AgentConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="agentParameters")]
		public AgentParameters AgentParameters { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="periodInSeconds")]
		public int PeriodInSeconds { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="shouldProfile")]
		public bool ShouldProfile { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AgentParameters
	{
	}
	
	/// <summary>
	/// The structure representing the createProfilingGroupResponse.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateProfilingGroupResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="profilingGroup")]
		public ProfilingGroupDescription ProfilingGroup { get; set; }
	}
	
	/// <summary>
	///  Contains information about a profiling group. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProfilingGroupDescription
	{
		
		[System.Runtime.Serialization.DataMember(Name="agentOrchestrationConfig")]
		public AgentOrchestrationConfig AgentOrchestrationConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="computePlatform")]
		public ComputePlatform ComputePlatform { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="profilingStatus")]
		public ProfilingStatus ProfilingStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagsMap Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
	}
	
	/// <summary>
	///  Specifies whether profiling is enabled or disabled for a profiling group. It is used by <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html"> <code>ConfigureAgent</code> </a> to enable or disable profiling for a profiling group. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AgentOrchestrationConfig
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="profilingEnabled")]
		public bool ProfilingEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ComputePlatform
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Default")]
		Default = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSLambda")]
		AWSLambda = 1,
	}
	
	/// <summary>
	///  Profiling status includes information about the last time a profile agent pinged back, the last time a profile was received, and the aggregation period and start time for the most recent aggregated profile. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProfilingStatus
	{
		
		[System.Runtime.Serialization.DataMember(Name="latestAgentOrchestratedAt")]
		public System.DateTimeOffset LatestAgentOrchestratedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="latestAgentProfileReportedAt")]
		public System.DateTimeOffset LatestAgentProfileReportedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="latestAggregatedProfile")]
		public AggregatedProfileTime LatestAggregatedProfile { get; set; }
	}
	
	/// <summary>
	///  Specifies the aggregation period and aggregation start time for an aggregated profile. An aggregated profile is used to collect posted agent profiles during an aggregation period. There are three possible aggregation periods (1 day, 1 hour, or 5 minutes). 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AggregatedProfileTime
	{
		
		[System.Runtime.Serialization.DataMember(Name="period")]
		public AggregationPeriod Period { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="start")]
		public System.DateTimeOffset Start { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagsMap
	{
	}
	
	/// <summary>
	/// The structure representing the deleteProfilingGroupResponse.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteProfilingGroupResponse
	{
	}
	
	/// <summary>
	/// The structure representing the describeProfilingGroupResponse.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeProfilingGroupResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="profilingGroup")]
		public ProfilingGroupDescription ProfilingGroup { get; set; }
	}
	
	/// <summary>
	/// The structure representing the GetFindingsReportAccountSummaryResponse.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetFindingsReportAccountSummaryResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="reportSummaries")]
		public FindingsReportSummary[] ReportSummaries { get; set; }
	}
	
	/// <summary>
	///  Information about potential recommendations that might be created from the analysis of profiling data. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FindingsReportSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="profileEndTime")]
		public System.DateTimeOffset ProfileEndTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="profileStartTime")]
		public System.DateTimeOffset ProfileStartTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="profilingGroupName")]
		public string ProfilingGroupName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="totalNumberOfFindings")]
		public System.Nullable<System.Int32> TotalNumberOfFindings { get; set; }
	}
	
	/// <summary>
	/// The structure representing the GetNotificationConfigurationResponse.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetNotificationConfigurationResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notificationConfiguration")]
		public NotificationConfiguration NotificationConfiguration { get; set; }
	}
	
	/// <summary>
	/// The structure representing the <code>getPolicyResponse</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetPolicyResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public string Policy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="revisionId")]
		public string RevisionId { get; set; }
	}
	
	/// <summary>
	/// The structure representing the getProfileResponse.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetProfileResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="profile")]
		public string Profile { get; set; }
	}
	
	/// <summary>
	/// The structure representing the GetRecommendationsResponse.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetRecommendationsResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="anomalies")]
		public Anomaly[] Anomalies { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="profileEndTime")]
		public System.DateTimeOffset ProfileEndTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="profileStartTime")]
		public System.DateTimeOffset ProfileStartTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="profilingGroupName")]
		public string ProfilingGroupName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="recommendations")]
		public Recommendation[] Recommendations { get; set; }
	}
	
	/// <summary>
	///  Details about an anomaly in a specific metric of application profile. The anomaly is detected using analysis of the metric data over a period of time. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Anomaly
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public AnomalyInstance[] Instances { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metric")]
		public Metric Metric { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
	}
	
	/// <summary>
	/// The specific duration in which the metric is flagged as anomalous.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AnomalyInstance
	{
		
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="userFeedback")]
		public UserFeedback UserFeedback { get; set; }
	}
	
	/// <summary>
	/// Feedback that can be submitted for each instance of an anomaly by the user. Feedback is be used for improvements in generating recommendations for the application.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UserFeedback
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public FeedbackType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum FeedbackType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Positive")]
		Positive = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Negative")]
		Negative = 1,
	}
	
	/// <summary>
	///  Details about the metric that the analysis used when it detected the anomaly. The metric what is analyzed to create recommendations. It includes the name of the frame that was analyzed and the type and thread states used to derive the metric value for that frame. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Metric
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="frameName")]
		public string FrameName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="threadStates")]
		public string[] ThreadStates { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public MetricType Type { get; set; }
	}
	
	/// <summary>
	/// A potential improvement that was found from analyzing the profiling data.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Recommendation
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="allMatchesCount")]
		public int AllMatchesCount { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="allMatchesSum")]
		public double AllMatchesSum { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public System.DateTimeOffset EndTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pattern")]
		public Pattern Pattern { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public System.DateTimeOffset StartTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="topMatches")]
		public Match[] TopMatches { get; set; }
	}
	
	/// <summary>
	///  A set of rules used to make a recommendation during an analysis. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Pattern
	{
		
		[System.Runtime.Serialization.DataMember(Name="countersToAggregate")]
		public string[] CountersToAggregate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resolutionSteps")]
		public string ResolutionSteps { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="targetFrames")]
		public string[][] TargetFrames { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="thresholdPercent")]
		public System.Nullable<System.Double> ThresholdPercent { get; set; }
	}
	
	/// <summary>
	/// The part of a profile that contains a recommendation found during analysis.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Match
	{
		
		[System.Runtime.Serialization.DataMember(Name="frameAddress")]
		public string FrameAddress { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="targetFramesIndex")]
		public System.Nullable<System.Int32> TargetFramesIndex { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="thresholdBreachValue")]
		public System.Nullable<System.Double> ThresholdBreachValue { get; set; }
	}
	
	/// <summary>
	/// The structure representing the ListFindingsReportsResponse.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListFindingsReportsResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="findingsReportSummaries")]
		public FindingsReportSummary[] FindingsReportSummaries { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// The structure representing the listProfileTimesResponse.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListProfileTimesResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="profileTimes")]
		public ProfileTime[] ProfileTimes { get; set; }
	}
	
	/// <summary>
	///  Contains the start time of a profile. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProfileTime
	{
		
		[System.Runtime.Serialization.DataMember(Name="start")]
		public System.DateTimeOffset Start { get; set; }
	}
	
	/// <summary>
	/// The structure representing the listProfilingGroupsResponse.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListProfilingGroupsResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="profilingGroupNames")]
		public string[] ProfilingGroupNames { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="profilingGroups")]
		public ProfilingGroupDescription[] ProfilingGroups { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagsMap Tags { get; set; }
	}
	
	/// <summary>
	/// The structure representing the postAgentProfileResponse.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PostAgentProfileResponse
	{
	}
	
	/// <summary>
	/// The structure representing the <code>putPermissionResponse</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutPermissionResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public string Policy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="revisionId")]
		public string RevisionId { get; set; }
	}
	
	/// <summary>
	/// The structure representing the RemoveNotificationChannelResponse.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RemoveNotificationChannelResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="notificationConfiguration")]
		public NotificationConfiguration NotificationConfiguration { get; set; }
	}
	
	/// <summary>
	/// The structure representing the <code>removePermissionResponse</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RemovePermissionResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public string Policy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="revisionId")]
		public string RevisionId { get; set; }
	}
	
	/// <summary>
	/// The structure representing the SubmitFeedbackResponse.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubmitFeedbackResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagResourceResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UntagResourceResponse
	{
	}
	
	/// <summary>
	/// The structure representing the updateProfilingGroupResponse.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateProfilingGroupResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="profilingGroup")]
		public ProfilingGroupDescription ProfilingGroup { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ActionGroup
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="agentPermissions")]
		agentPermissions = 0,
	}
	
	/// <summary>
	/// The structure representing the AddNotificationChannelsRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AddNotificationChannelsRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channels")]
		public Channel[] Channels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AgentParameterField
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SamplingIntervalInMilliseconds")]
		SamplingIntervalInMilliseconds = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ReportingIntervalInMilliseconds")]
		ReportingIntervalInMilliseconds = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MinimumTimeForReportingInMilliseconds")]
		MinimumTimeForReportingInMilliseconds = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MemoryUsageLimitPercent")]
		MemoryUsageLimitPercent = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MaxStackDepth")]
		MaxStackDepth = 4,
	}
	
	/// <summary>
	/// The structure representing the BatchGetFrameMetricDataRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchGetFrameMetricDataRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="frameMetrics")]
		public FrameMetric[] FrameMetrics { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Metadata
	{
	}
	
	/// <summary>
	/// The structure representing the configureAgentRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigureAgentRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="fleetInstanceId")]
		public string FleetInstanceId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public Metadata Metadata { get; set; }
	}
	
	/// <summary>
	/// The structure representing the createProfiliingGroupRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateProfilingGroupRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="agentOrchestrationConfig")]
		public AgentOrchestrationConfig AgentOrchestrationConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="computePlatform")]
		public ComputePlatform ComputePlatform { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="profilingGroupName")]
		public string ProfilingGroupName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagsMap Tags { get; set; }
	}
	
	/// <summary>
	/// The structure representing the deleteProfilingGroupRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteProfilingGroupRequest
	{
	}
	
	/// <summary>
	/// The structure representing the describeProfilingGroupRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeProfilingGroupRequest
	{
	}
	
	/// <summary>
	/// The structure representing the GetFindingsReportAccountSummaryRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetFindingsReportAccountSummaryRequest
	{
	}
	
	/// <summary>
	/// The structure representing the GetNotificationConfigurationRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetNotificationConfigurationRequest
	{
	}
	
	/// <summary>
	///  The structure representing the <code>getPolicyRequest</code>. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetPolicyRequest
	{
	}
	
	/// <summary>
	/// The structure representing the getProfileRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetProfileRequest
	{
	}
	
	/// <summary>
	/// The structure representing the GetRecommendationsRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetRecommendationsRequest
	{
	}
	
	/// <summary>
	/// The structure representing the ListFindingsReportsRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListFindingsReportsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum OrderBy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TimestampDescending")]
		TimestampDescending = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TimestampAscending")]
		TimestampAscending = 1,
	}
	
	/// <summary>
	/// The structure representing the listProfileTimesRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListProfileTimesRequest
	{
	}
	
	/// <summary>
	/// The structure representing the listProfilingGroupsRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListProfilingGroupsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MetadataField
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ComputePlatform")]
		ComputePlatform = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AgentId")]
		AgentId = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AwsRequestId")]
		AwsRequestId = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ExecutionEnvironment")]
		ExecutionEnvironment = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LambdaFunctionArn")]
		LambdaFunctionArn = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LambdaMemoryLimitInMB")]
		LambdaMemoryLimitInMB = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LambdaRemainingTimeInMilliseconds")]
		LambdaRemainingTimeInMilliseconds = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LambdaTimeGapBetweenInvokesInMilliseconds")]
		LambdaTimeGapBetweenInvokesInMilliseconds = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LambdaPreviousExecutionTimeInMilliseconds")]
		LambdaPreviousExecutionTimeInMilliseconds = 8,
	}
	
	/// <summary>
	/// The structure representing the postAgentProfileRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PostAgentProfileRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="agentProfile")]
		public string AgentProfile { get; set; }
	}
	
	/// <summary>
	/// The structure representing the <code>putPermissionRequest</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutPermissionRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="principals")]
		public string[] Principals { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="revisionId")]
		public string RevisionId { get; set; }
	}
	
	/// <summary>
	/// The structure representing the RemoveNotificationChannelRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RemoveNotificationChannelRequest
	{
	}
	
	/// <summary>
	///  <pre><code> The structure representing the &lt;code&gt;removePermissionRequest&lt;/code&gt;.&lt;/p&gt; </code></pre>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RemovePermissionRequest
	{
	}
	
	/// <summary>
	/// The structure representing the SubmitFeedbackRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubmitFeedbackRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public FeedbackType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagResourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagsMap Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UntagResourceRequest
	{
	}
	
	/// <summary>
	/// The structure representing the updateProfilingGroupRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateProfilingGroupRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="agentOrchestrationConfig")]
		public AgentOrchestrationConfig AgentOrchestrationConfig { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Add up to 2 anomaly notifications channels for a profiling group.
		/// AddNotificationChannels profilingGroups/{profilingGroupName}/notificationConfiguration
		/// </summary>
		/// <param name="profilingGroupName">The name of the profiling group that we are setting up notifications for.</param>
		/// <returns>Success</returns>
		public async Task<AddNotificationChannelsResponse> AddNotificationChannelsAsync(string profilingGroupName, AddNotificationChannelsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profilingGroups/"+ (profilingGroupName==null? "" : System.Uri.EscapeDataString(profilingGroupName))+"/notificationConfiguration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AddNotificationChannelsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the current configuration for anomaly notifications for a profiling group.
		/// GetNotificationConfiguration profilingGroups/{profilingGroupName}/notificationConfiguration
		/// </summary>
		/// <param name="profilingGroupName">The name of the profiling group we want to get the notification configuration for.</param>
		/// <returns>Success</returns>
		public async Task<GetNotificationConfigurationResponse> GetNotificationConfigurationAsync(string profilingGroupName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profilingGroups/"+ (profilingGroupName==null? "" : System.Uri.EscapeDataString(profilingGroupName))+"/notificationConfiguration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetNotificationConfigurationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the time series of values for a requested list of frame metrics from a time period.
		/// BatchGetFrameMetricData profilingGroups/{profilingGroupName}/frames/-/metrics
		/// </summary>
		/// <param name="endTime"> The end time of the time period for the returned time series values. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC. </param>
		/// <param name="period"> The duration of the frame metrics used to return the time series values. Specify using the ISO 8601 format. The maximum period duration is one day (<code>PT24H</code> or <code>P1D</code>). </param>
		/// <param name="profilingGroupName"> The name of the profiling group associated with the the frame metrics used to return the time series values. </param>
		/// <param name="startTime"> The start time of the time period for the frame metrics used to return the time series values. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC. </param>
		/// <param name="targetResolution"><p>The requested resolution of time steps for the returned time series of values. If the requested target resolution is not available due to data not being retained we provide a best effort result by falling back to the most granular available resolution after the target resolution. There are 3 valid values. </p> <ul> <li> <p> <code>P1D</code> — 1 day </p> </li> <li> <p> <code>PT1H</code> — 1 hour </p> </li> <li> <p> <code>PT5M</code> — 5 minutes </p> </li> </ul></param>
		/// <returns>Success</returns>
		public async Task<BatchGetFrameMetricDataResponse> BatchGetFrameMetricDataAsync(System.DateTimeOffset endTime, string period, string profilingGroupName, System.DateTimeOffset startTime, AggregationPeriod targetResolution, BatchGetFrameMetricDataPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profilingGroups/"+ (profilingGroupName==null? "" : System.Uri.EscapeDataString(profilingGroupName))+"/frames/-/metrics?endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&period=" + (period==null? "" : System.Uri.EscapeDataString(period))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&targetResolution=" + targetResolution;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BatchGetFrameMetricDataResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Used by profiler agents to report their current state and to receive remote configuration updates. For example, <code>ConfigureAgent</code> can be used to tell an agent whether to profile or not and for how long to return profiling data.
		/// ConfigureAgent profilingGroups/{profilingGroupName}/configureAgent
		/// </summary>
		/// <param name="profilingGroupName"> The name of the profiling group for which the configured agent is collecting profiling data. </param>
		/// <returns>Success</returns>
		public async Task<ConfigureAgentResponse> ConfigureAgentAsync(string profilingGroupName, ConfigureAgentPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profilingGroups/"+ (profilingGroupName==null? "" : System.Uri.EscapeDataString(profilingGroupName))+"/configureAgent";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ConfigureAgentResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a profiling group.
		/// CreateProfilingGroup profilingGroups#clientToken
		/// </summary>
		/// <param name="clientToken"> Amazon CodeGuru Profiler uses this universally unique identifier (UUID) to prevent the accidental creation of duplicate profiling groups if there are failures and retries. </param>
		public async Task CreateProfilingGroupAsync(string clientToken, CreateProfilingGroupPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profilingGroups#clientToken?clientToken=" + (clientToken==null? "" : System.Uri.EscapeDataString(clientToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a profiling group.
		/// DeleteProfilingGroup profilingGroups/{profilingGroupName}
		/// </summary>
		/// <param name="profilingGroupName">The name of the profiling group to delete.</param>
		public async Task DeleteProfilingGroupAsync(string profilingGroupName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profilingGroups/"+ (profilingGroupName==null? "" : System.Uri.EscapeDataString(profilingGroupName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html"> <code>ProfilingGroupDescription</code> </a> object that contains information about the requested profiling group.
		/// DescribeProfilingGroup profilingGroups/{profilingGroupName}
		/// </summary>
		/// <param name="profilingGroupName"> The name of the profiling group to get information about. </param>
		/// <returns>Success</returns>
		public async Task<DescribeProfilingGroupResponse> DescribeProfilingGroupAsync(string profilingGroupName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profilingGroups/"+ (profilingGroupName==null? "" : System.Uri.EscapeDataString(profilingGroupName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeProfilingGroupResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a profiling group.
		/// UpdateProfilingGroup profilingGroups/{profilingGroupName}
		/// </summary>
		/// <param name="profilingGroupName">The name of the profiling group to update.</param>
		/// <returns>Success</returns>
		public async Task<UpdateProfilingGroupResponse> UpdateProfilingGroupAsync(string profilingGroupName, UpdateProfilingGroupPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profilingGroups/"+ (profilingGroupName==null? "" : System.Uri.EscapeDataString(profilingGroupName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateProfilingGroupResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_FindingsReportSummary.html"> <code>FindingsReportSummary</code> </a> objects that contain analysis results for all profiling groups in your AWS account.
		/// GetFindingsReportAccountSummary internal/findingsReports
		/// </summary>
		/// <param name="dailyReportsOnly">A <code>Boolean</code> value indicating whether to only return reports from daily profiles. If set to <code>True</code>, only analysis data from daily profiles is returned. If set to <code>False</code>, analysis data is returned from smaller time windows (for example, one hour).</param>
		/// <param name="maxResults">The maximum number of results returned by <code> GetFindingsReportAccountSummary</code> in paginated output. When this parameter is used, <code>GetFindingsReportAccountSummary</code> only returns <code>maxResults</code> results in a single page along with a <code>nextToken</code> response element. The remaining results of the initial request can be seen by sending another <code>GetFindingsReportAccountSummary</code> request with the returned <code>nextToken</code> value.</param>
		/// <param name="nextToken"><p>The <code>nextToken</code> value returned from a previous paginated <code>GetFindingsReportAccountSummary</code> request where <code>maxResults</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>nextToken</code> value. </p> <note> <p>This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.</p> </note></param>
		/// <returns>Success</returns>
		public async Task<GetFindingsReportAccountSummaryResponse> GetFindingsReportAccountSummaryAsync(bool dailyReportsOnly, int maxResults, string nextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "internal/findingsReports?dailyReportsOnly="+dailyReportsOnly+"&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetFindingsReportAccountSummaryResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the JSON-formatted resource-based policy on a profiling group.
		/// GetPolicy profilingGroups/{profilingGroupName}/policy
		/// </summary>
		/// <param name="profilingGroupName">The name of the profiling group.</param>
		/// <returns>Success</returns>
		public async Task<GetPolicyResponse> GetPolicyAsync(string profilingGroupName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profilingGroups/"+ (profilingGroupName==null? "" : System.Uri.EscapeDataString(profilingGroupName))+"/policy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetPolicyResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p> Gets the aggregated profile of a profiling group for a specified time range. Amazon CodeGuru Profiler collects posted agent profiles for a profiling group into aggregated profiles. </p> <pre><code> &lt;note&gt; &lt;p&gt; Because aggregated profiles expire over time &lt;code&gt;GetProfile&lt;/code&gt; is not idempotent. &lt;/p&gt; &lt;/note&gt; &lt;p&gt; Specify the time range for the requested aggregated profile using 1 or 2 of the following parameters: &lt;code&gt;startTime&lt;/code&gt;, &lt;code&gt;endTime&lt;/code&gt;, &lt;code&gt;period&lt;/code&gt;. The maximum time range allowed is 7 days. If you specify all 3 parameters, an exception is thrown. If you specify only &lt;code&gt;period&lt;/code&gt;, the latest aggregated profile is returned. &lt;/p&gt; &lt;p&gt; Aggregated profiles are available with aggregation periods of 5 minutes, 1 hour, and 1 day, aligned to UTC. The aggregation period of an aggregated profile determines how long it is retained. For more information, see &lt;a href=&quot;https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_AggregatedProfileTime.html&quot;&gt; &lt;code&gt;AggregatedProfileTime&lt;/code&gt; &lt;/a&gt;. The aggregated profile's aggregation period determines how long it is retained by CodeGuru Profiler. &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; If the aggregation period is 5 minutes, the aggregated profile is retained for 15 days. &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; If the aggregation period is 1 hour, the aggregated profile is retained for 60 days. &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; If the aggregation period is 1 day, the aggregated profile is retained for 3 years. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;There are two use cases for calling &lt;code&gt;GetProfile&lt;/code&gt;.&lt;/p&gt; &lt;ol&gt; &lt;li&gt; &lt;p&gt; If you want to return an aggregated profile that already exists, use &lt;a href=&quot;https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ListProfileTimes.html&quot;&gt; &lt;code&gt;ListProfileTimes&lt;/code&gt; &lt;/a&gt; to view the time ranges of existing aggregated profiles. Use them in a &lt;code&gt;GetProfile&lt;/code&gt; request to return a specific, existing aggregated profile. &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; If you want to return an aggregated profile for a time range that doesn't align with an existing aggregated profile, then CodeGuru Profiler makes a best effort to combine existing aggregated profiles from the requested time range and return them as one aggregated profile. &lt;/p&gt; &lt;p&gt; If aggregated profiles do not exist for the full time range requested, then aggregated profiles for a smaller time range are returned. For example, if the requested time range is from 00:00 to 00:20, and the existing aggregated profiles are from 00:15 and 00:25, then the aggregated profiles from 00:15 to 00:20 are returned. &lt;/p&gt; &lt;/li&gt; &lt;/ol&gt; </code></pre>
		/// GetProfile profilingGroups/{profilingGroupName}/profile
		/// </summary>
		/// <param name="endTime"><p> The end time of the requested profile. Specify using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC. </p> <p> If you specify <code>endTime</code>, then you must also specify <code>period</code> or <code>startTime</code>, but not both. </p></param>
		/// <param name="maxDepth"> The maximum depth of the stacks in the code that is represented in the aggregated profile. For example, if CodeGuru Profiler finds a method <code>A</code>, which calls method <code>B</code>, which calls method <code>C</code>, which calls method <code>D</code>, then the depth is 4. If the <code>maxDepth</code> is set to 2, then the aggregated profile contains representations of methods <code>A</code> and <code>B</code>. </param>
		/// <param name="period"><p> Used with <code>startTime</code> or <code>endTime</code> to specify the time range for the returned aggregated profile. Specify using the ISO 8601 format. For example, <code>P1DT1H1M1S</code>. </p> <pre><code> &lt;p&gt; To get the latest aggregated profile, specify only &lt;code&gt;period&lt;/code&gt;. &lt;/p&gt; </code></pre></param>
		/// <param name="profilingGroupName">The name of the profiling group to get.</param>
		/// <param name="startTime"><p>The start time of the profile to get. Specify using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.</p> <pre><code> &lt;p&gt; If you specify &lt;code&gt;startTime&lt;/code&gt;, then you must also specify &lt;code&gt;period&lt;/code&gt; or &lt;code&gt;endTime&lt;/code&gt;, but not both. &lt;/p&gt; </code></pre></param>
		/// <returns>Success</returns>
		public async Task<GetProfileResponse> GetProfileAsync(System.DateTimeOffset endTime, int maxDepth, string period, string profilingGroupName, System.DateTimeOffset startTime, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profilingGroups/"+ (profilingGroupName==null? "" : System.Uri.EscapeDataString(profilingGroupName))+"/profile?endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&maxDepth="+maxDepth+"&period=" + (period==null? "" : System.Uri.EscapeDataString(period))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetProfileResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_Recommendation.html"> <code>Recommendation</code> </a> objects that contain recommendations for a profiling group for a given time period. A list of <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_Anomaly.html"> <code>Anomaly</code> </a> objects that contains details about anomalies detected in the profiling group for the same time period is also returned.
		/// GetRecommendations internal/profilingGroups/{profilingGroupName}/recommendations#endTime&startTime
		/// </summary>
		/// <param name="endTime"> The start time of the profile to get analysis data about. You must specify <code>startTime</code> and <code>endTime</code>. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC. </param>
		/// <param name="locale"><p> The language used to provide analysis. Specify using a string that is one of the following <code>BCP 47</code> language codes. </p> <ul> <li> <p> <code>de-DE</code> - German, Germany </p> </li> <li> <p> <code>en-GB</code> - English, United Kingdom </p> </li> <li> <p> <code>en-US</code> - English, United States </p> </li> <li> <p> <code>es-ES</code> - Spanish, Spain </p> </li> <li> <p> <code>fr-FR</code> - French, France </p> </li> <li> <p> <code>it-IT</code> - Italian, Italy </p> </li> <li> <p> <code>ja-JP</code> - Japanese, Japan </p> </li> <li> <p> <code>ko-KR</code> - Korean, Republic of Korea </p> </li> <li> <p> <code>pt-BR</code> - Portugese, Brazil </p> </li> <li> <p> <code>zh-CN</code> - Chinese, China </p> </li> <li> <p> <code>zh-TW</code> - Chinese, Taiwan </p> </li> </ul></param>
		/// <param name="profilingGroupName"> The name of the profiling group to get analysis data about. </param>
		/// <param name="startTime"> The end time of the profile to get analysis data about. You must specify <code>startTime</code> and <code>endTime</code>. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC. </param>
		/// <returns>Success</returns>
		public async Task<GetRecommendationsResponse> GetRecommendationsAsync(System.DateTimeOffset endTime, string locale, string profilingGroupName, System.DateTimeOffset startTime, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "internal/profilingGroups/"+ (profilingGroupName==null? "" : System.Uri.EscapeDataString(profilingGroupName))+"/recommendations#endTime&startTime?endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetRecommendationsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the available reports for a given profiling group and time range.
		/// ListFindingsReports internal/profilingGroups/{profilingGroupName}/findingsReports#endTime&startTime
		/// </summary>
		/// <param name="dailyReportsOnly">A <code>Boolean</code> value indicating whether to only return reports from daily profiles. If set to <code>True</code>, only analysis data from daily profiles is returned. If set to <code>False</code>, analysis data is returned from smaller time windows (for example, one hour).</param>
		/// <param name="endTime"> The end time of the profile to get analysis data about. You must specify <code>startTime</code> and <code>endTime</code>. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC. </param>
		/// <param name="maxResults">The maximum number of report results returned by <code>ListFindingsReports</code> in paginated output. When this parameter is used, <code>ListFindingsReports</code> only returns <code>maxResults</code> results in a single page along with a <code>nextToken</code> response element. The remaining results of the initial request can be seen by sending another <code>ListFindingsReports</code> request with the returned <code>nextToken</code> value.</param>
		/// <param name="nextToken"><p>The <code>nextToken</code> value returned from a previous paginated <code>ListFindingsReportsRequest</code> request where <code>maxResults</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>nextToken</code> value. </p> <note> <p>This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.</p> </note></param>
		/// <param name="profilingGroupName">The name of the profiling group from which to search for analysis data.</param>
		/// <param name="startTime"> The start time of the profile to get analysis data about. You must specify <code>startTime</code> and <code>endTime</code>. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC. </param>
		/// <returns>Success</returns>
		public async Task<ListFindingsReportsResponse> ListFindingsReportsAsync(bool dailyReportsOnly, System.DateTimeOffset endTime, int maxResults, string nextToken, string profilingGroupName, System.DateTimeOffset startTime, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "internal/profilingGroups/"+ (profilingGroupName==null? "" : System.Uri.EscapeDataString(profilingGroupName))+"/findingsReports#endTime&startTime?dailyReportsOnly="+dailyReportsOnly+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListFindingsReportsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the start times of the available aggregated profiles of a profiling group for an aggregation period within the specified time range.
		/// ListProfileTimes profilingGroups/{profilingGroupName}/profileTimes#endTime&period&startTime
		/// </summary>
		/// <param name="endTime">The end time of the time range from which to list the profiles.</param>
		/// <param name="maxResults">The maximum number of profile time results returned by <code>ListProfileTimes</code> in paginated output. When this parameter is used, <code>ListProfileTimes</code> only returns <code>maxResults</code> results in a single page with a <code>nextToken</code> response element. The remaining results of the initial request can be seen by sending another <code>ListProfileTimes</code> request with the returned <code>nextToken</code> value. </param>
		/// <param name="nextToken"><p>The <code>nextToken</code> value returned from a previous paginated <code>ListProfileTimes</code> request where <code>maxResults</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>nextToken</code> value. </p> <note> <p>This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.</p> </note></param>
		/// <param name="orderBy">The order (ascending or descending by start time of the profile) to use when listing profiles. Defaults to <code>TIMESTAMP_DESCENDING</code>. </param>
		/// <param name="period"><p> The aggregation period. This specifies the period during which an aggregation profile collects posted agent profiles for a profiling group. There are 3 valid values. </p> <ul> <li> <p> <code>P1D</code> — 1 day </p> </li> <li> <p> <code>PT1H</code> — 1 hour </p> </li> <li> <p> <code>PT5M</code> — 5 minutes </p> </li> </ul></param>
		/// <param name="profilingGroupName">The name of the profiling group.</param>
		/// <param name="startTime">The start time of the time range from which to list the profiles.</param>
		/// <returns>Success</returns>
		public async Task<ListProfileTimesResponse> ListProfileTimesAsync(System.DateTimeOffset endTime, int maxResults, string nextToken, OrderBy orderBy, AggregationPeriod period, string profilingGroupName, System.DateTimeOffset startTime, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profilingGroups/"+ (profilingGroupName==null? "" : System.Uri.EscapeDataString(profilingGroupName))+"/profileTimes#endTime&period&startTime?endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&orderBy=" + orderBy+"&period=" + period+"&startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListProfileTimesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of profiling groups. The profiling groups are returned as <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html"> <code>ProfilingGroupDescription</code> </a> objects.
		/// ListProfilingGroups profilingGroups
		/// </summary>
		/// <param name="includeDescription">A <code>Boolean</code> value indicating whether to include a description. If <code>true</code>, then a list of <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html"> <code>ProfilingGroupDescription</code> </a> objects that contain detailed information about profiling groups is returned. If <code>false</code>, then a list of profiling group names is returned.</param>
		/// <param name="maxResults">The maximum number of profiling groups results returned by <code>ListProfilingGroups</code> in paginated output. When this parameter is used, <code>ListProfilingGroups</code> only returns <code>maxResults</code> results in a single page along with a <code>nextToken</code> response element. The remaining results of the initial request can be seen by sending another <code>ListProfilingGroups</code> request with the returned <code>nextToken</code> value. </param>
		/// <param name="nextToken"><p>The <code>nextToken</code> value returned from a previous paginated <code>ListProfilingGroups</code> request where <code>maxResults</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>nextToken</code> value. </p> <note> <p>This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.</p> </note></param>
		/// <returns>Success</returns>
		public async Task<ListProfilingGroupsResponse> ListProfilingGroupsAsync(bool includeDescription, int maxResults, string nextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profilingGroups?includeDescription="+includeDescription+"&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListProfilingGroupsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of the tags that are assigned to a specified resource.
		/// ListTagsForResource tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn"> The Amazon Resource Name (ARN) of the resource that contains the tags to return. </param>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceResponse> ListTagsForResourceAsync(string resourceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListTagsForResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Use to assign one or more tags to a resource.
		/// TagResource tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn"> The Amazon Resource Name (ARN) of the resource that the tags are added to. </param>
		public async Task TagResourceAsync(string resourceArn, TagResourcePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Submits profiling data to an aggregated profile of a profiling group. To get an aggregated profile that is created with this profiling data, use <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_GetProfile.html"> <code>GetProfile</code> </a>.
		/// PostAgentProfile profilingGroups/{profilingGroupName}/agentProfile#Content-Type
		/// </summary>
		/// <param name="profileToken"> Amazon CodeGuru Profiler uses this universally unique identifier (UUID) to prevent the accidental submission of duplicate profiling data if there are failures and retries. </param>
		/// <param name="profilingGroupName"> The name of the profiling group with the aggregated profile that receives the submitted profiling data. </param>
		public async Task PostAgentProfileAsync(string profileToken, string profilingGroupName, PostAgentProfilePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profilingGroups/"+ (profilingGroupName==null? "" : System.Uri.EscapeDataString(profilingGroupName))+"/agentProfile#Content-Type?profileToken=" + (profileToken==null? "" : System.Uri.EscapeDataString(profileToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p> Adds permissions to a profiling group's resource-based policy that are provided using an action group. If a profiling group doesn't have a resource-based policy, one is created for it using the permissions in the action group and the roles and users in the <code>principals</code> parameter. </p> <pre><code> &lt;p&gt; The one supported action group that can be added is &lt;code&gt;agentPermission&lt;/code&gt; which grants &lt;code&gt;ConfigureAgent&lt;/code&gt; and &lt;code&gt;PostAgent&lt;/code&gt; permissions. For more information, see &lt;a href=&quot;https://docs.aws.amazon.com/codeguru/latest/profiler-ug/resource-based-policies.html&quot;&gt;Resource-based policies in CodeGuru Profiler&lt;/a&gt; in the &lt;i&gt;Amazon CodeGuru Profiler User Guide&lt;/i&gt;, &lt;a href=&quot;https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html&quot;&gt; &lt;code&gt;ConfigureAgent&lt;/code&gt; &lt;/a&gt;, and &lt;a href=&quot;https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_PostAgentProfile.html&quot;&gt; &lt;code&gt;PostAgentProfile&lt;/code&gt; &lt;/a&gt;. &lt;/p&gt; &lt;p&gt; The first time you call &lt;code&gt;PutPermission&lt;/code&gt; on a profiling group, do not specify a &lt;code&gt;revisionId&lt;/code&gt; because it doesn't have a resource-based policy. Subsequent calls must provide a &lt;code&gt;revisionId&lt;/code&gt; to specify which revision of the resource-based policy to add the permissions to. &lt;/p&gt; &lt;p&gt; The response contains the profiling group's JSON-formatted resource policy. &lt;/p&gt; </code></pre>
		/// PutPermission profilingGroups/{profilingGroupName}/policy/{actionGroup}
		/// </summary>
		/// <param name="actionGroup"> Specifies an action group that contains permissions to add to a profiling group resource. One action group is supported, <code>agentPermissions</code>, which grants permission to perform actions required by the profiling agent, <code>ConfigureAgent</code> and <code>PostAgentProfile</code> permissions. </param>
		/// <param name="profilingGroupName">The name of the profiling group to grant access to.</param>
		/// <returns>Success</returns>
		public async Task<PutPermissionResponse> PutPermissionAsync(ActionGroup actionGroup, string profilingGroupName, PutPermissionPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profilingGroups/"+ (profilingGroupName==null? "" : System.Uri.EscapeDataString(profilingGroupName))+"/policy/"+actionGroup;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PutPermissionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove one anomaly notifications channel for a profiling group.
		/// RemoveNotificationChannel profilingGroups/{profilingGroupName}/notificationConfiguration/{channelId}
		/// </summary>
		/// <param name="channelId">The id of the channel that we want to stop receiving notifications.</param>
		/// <param name="profilingGroupName">The name of the profiling group we want to change notification configuration for.</param>
		/// <returns>Success</returns>
		public async Task<RemoveNotificationChannelResponse> RemoveNotificationChannelAsync(string channelId, string profilingGroupName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profilingGroups/"+ (profilingGroupName==null? "" : System.Uri.EscapeDataString(profilingGroupName))+"/notificationConfiguration/"+ (channelId==null? "" : System.Uri.EscapeDataString(channelId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RemoveNotificationChannelResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes permissions from a profiling group's resource-based policy that are provided using an action group. The one supported action group that can be removed is <code>agentPermission</code> which grants <code>ConfigureAgent</code> and <code>PostAgent</code> permissions. For more information, see <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-ug/resource-based-policies.html">Resource-based policies in CodeGuru Profiler</a> in the <i>Amazon CodeGuru Profiler User Guide</i>, <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html"> <code>ConfigureAgent</code> </a>, and <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_PostAgentProfile.html"> <code>PostAgentProfile</code> </a>.
		/// RemovePermission profilingGroups/{profilingGroupName}/policy/{actionGroup}#revisionId
		/// </summary>
		/// <param name="actionGroup"> Specifies an action group that contains the permissions to remove from a profiling group's resource-based policy. One action group is supported, <code>agentPermissions</code>, which grants <code>ConfigureAgent</code> and <code>PostAgentProfile</code> permissions. </param>
		/// <param name="profilingGroupName">The name of the profiling group.</param>
		/// <param name="revisionId"> A universally unique identifier (UUID) for the revision of the resource-based policy from which you want to remove permissions. </param>
		/// <returns>Success</returns>
		public async Task<RemovePermissionResponse> RemovePermissionAsync(ActionGroup actionGroup, string profilingGroupName, string revisionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "profilingGroups/"+ (profilingGroupName==null? "" : System.Uri.EscapeDataString(profilingGroupName))+"/policy/"+actionGroup+"#revisionId&revisionId=" + (revisionId==null? "" : System.Uri.EscapeDataString(revisionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RemovePermissionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sends feedback to CodeGuru Profiler about whether the anomaly detected by the analysis is useful or not.
		/// SubmitFeedback internal/profilingGroups/{profilingGroupName}/anomalies/{anomalyInstanceId}/feedback
		/// </summary>
		/// <param name="anomalyInstanceId">The universally unique identifier (UUID) of the <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_AnomalyInstance.html"> <code>AnomalyInstance</code> </a> object that is included in the analysis data.</param>
		/// <param name="profilingGroupName">The name of the profiling group that is associated with the analysis data.</param>
		public async Task SubmitFeedbackAsync(string anomalyInstanceId, string profilingGroupName, SubmitFeedbackPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "internal/profilingGroups/"+ (profilingGroupName==null? "" : System.Uri.EscapeDataString(profilingGroupName))+"/anomalies/"+ (anomalyInstanceId==null? "" : System.Uri.EscapeDataString(anomalyInstanceId))+"/feedback";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Use to remove one or more tags from a resource.
		/// UntagResource tags/{resourceArn}#tagKeys
		/// </summary>
		/// <param name="resourceArn"> The Amazon Resource Name (ARN) of the resource that contains the tags to remove. </param>
		/// <param name="tagKeys"> A list of tag keys. Existing tags of resources with keys in this list are removed from the specified resource. </param>
		public async Task UntagResourceAsync(string resourceArn, string[] tagKeys, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn))+"#tagKeys&"+string.Join("&", tagKeys.Select(z => $"tagKeys={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public class AddNotificationChannelsPostBody
	{
		
		/// <summary>
		/// One or 2 channels to report to when anomalies are detected.
		/// Required
		/// Minimum items: 1
		/// Maximum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="channels")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(2)]
		public Channel[] Channels { get; set; }
	}
	
	public class BatchGetFrameMetricDataPostBody
	{
		
		/// <summary>
		///  The details of the metrics that are used to request a time series of values. The metric includes the name of the frame, the aggregation type to calculate the metric value for the frame, and the thread states to use to get the count for the metric value of the frame.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="frameMetrics")]
		public FrameMetric[] FrameMetrics { get; set; }
	}
	
	public class ConfigureAgentPostBody
	{
		
		/// <summary>
		///  A universally unique identifier (UUID) for a profiling instance. For example, if the profiling instance is an Amazon EC2 instance, it is the instance ID. If it is an AWS Fargate container, it is the container's task ID. 
		/// Max length: 255
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fleetInstanceId")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		public string FleetInstanceId { get; set; }
		
		/// <summary>
		/// <p> Metadata captured about the compute platform the agent is running on. It includes information about sampling and reporting. The valid fields are:</p> <ul> <li> <p> <code>COMPUTE_PLATFORM</code> - The compute platform on which the agent is running </p> </li> <li> <p> <code>AGENT_ID</code> - The ID for an agent instance. </p> </li> <li> <p> <code>AWS_REQUEST_ID</code> - The AWS request ID of a Lambda invocation. </p> </li> <li> <p> <code>EXECUTION_ENVIRONMENT</code> - The execution environment a Lambda function is running on. </p> </li> <li> <p> <code>LAMBDA_FUNCTION_ARN</code> - The Amazon Resource Name (ARN) that is used to invoke a Lambda function. </p> </li> <li> <p> <code>LAMBDA_MEMORY_LIMIT_IN_MB</code> - The memory allocated to a Lambda function. </p> </li> <li> <p> <code>LAMBDA_REMAINING_TIME_IN_MILLISECONDS</code> - The time in milliseconds before execution of a Lambda function times out. </p> </li> <li> <p> <code>LAMBDA_TIME_GAP_BETWEEN_INVOKES_IN_MILLISECONDS</code> - The time in milliseconds between two invocations of a Lambda function. </p> </li> <li> <p> <code>LAMBDA_PREVIOUS_EXECUTION_TIME_IN_MILLISECONDS</code> - The time in milliseconds for the previous Lambda invocation. </p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, string> Metadata { get; set; }
	}
	
	public class CreateProfilingGroupPostBody
	{
		
		/// <summary>
		///  Specifies whether profiling is enabled or disabled for a profiling group. It is used by <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html"> <code>ConfigureAgent</code> </a> to enable or disable profiling for a profiling group. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="agentOrchestrationConfig")]
		public CreateProfilingGroupPostBodyAgentOrchestrationConfig AgentOrchestrationConfig { get; set; }
		
		/// <summary>
		///  The compute platform of the profiling group. Use <code>AWSLambda</code> if your application runs on AWS Lambda. Use <code>Default</code> if your application runs on a compute platform that is not AWS Lambda, such an Amazon EC2 instance, an on-premises server, or a different platform. If not specified, <code>Default</code> is used. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computePlatform")]
		public ComputePlatform ComputePlatform { get; set; }
		
		/// <summary>
		/// The name of the profiling group to create.
		/// Required
		/// Max length: 255
		/// Min length: 1
		/// Pattern: ^[\w-]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="profilingGroupName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[\w-]+$")]
		public string ProfilingGroupName { get; set; }
		
		/// <summary>
		///  A list of tags to add to the created profiling group. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public class CreateProfilingGroupPostBodyAgentOrchestrationConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="profilingEnabled")]
		public System.Nullable<System.Boolean> ProfilingEnabled { get; set; }
	}
	
	public class UpdateProfilingGroupPutBody
	{
		
		/// <summary>
		///  Specifies whether profiling is enabled or disabled for a profiling group. It is used by <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html"> <code>ConfigureAgent</code> </a> to enable or disable profiling for a profiling group. 
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="agentOrchestrationConfig")]
		public UpdateProfilingGroupPutBodyAgentOrchestrationConfig AgentOrchestrationConfig { get; set; }
	}
	
	public class UpdateProfilingGroupPutBodyAgentOrchestrationConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="profilingEnabled")]
		public System.Nullable<System.Boolean> ProfilingEnabled { get; set; }
	}
	
	public class TagResourcePostBody
	{
		
		/// <summary>
		///  The list of tags that are added to the specified resource. 
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public class PostAgentProfilePostBody
	{
		
		/// <summary>
		///  The submitted profiling data. 
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="agentProfile")]
		public string AgentProfile { get; set; }
	}
	
	public class PutPermissionPutBody
	{
		
		/// <summary>
		///  A list ARNs for the roles and users you want to grant access to the profiling group. Wildcards are not are supported in the ARNs. 
		/// Required
		/// Minimum items: 1
		/// Maximum items: 50
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="principals")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string[] Principals { get; set; }
		
		/// <summary>
		///  A universally unique identifier (UUID) for the revision of the policy you are adding to the profiling group. Do not specify this when you add permissions to a profiling group for the first time. If a policy already exists on the profiling group, you must specify the <code>revisionId</code>. 
		/// Pattern: [a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="revisionId")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}")]
		public string RevisionId { get; set; }
	}
	
	public class SubmitFeedbackPostBody
	{
		
		/// <summary>
		/// Optional feedback about this anomaly.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		///  The feedback tpye. Thee are two valid values, <code>Positive</code> and <code>Negative</code>. 
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public FeedbackType Type { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
