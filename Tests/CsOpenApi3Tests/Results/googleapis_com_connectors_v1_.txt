//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AuditConfig
	{
		
		/// <summary>
		/// The configuration for logging of each type of permission.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="auditLogConfigs")]
		public AuditLogConfig[] AuditLogConfigs { get; set; }
		
		/// <summary>
		/// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service")]
		public string Service { get; set; }
	}
	
	/// <summary>
	/// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AuditLogConfig
	{
		
		/// <summary>
		/// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exemptedMembers")]
		public string[] ExemptedMembers { get; set; }
		
		/// <summary>
		/// The log type that this config enables.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logType")]
		public System.Nullable<AuditLogConfigLogType> LogType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AuditLogConfigLogType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOG_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADMIN_READ = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_WRITE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_READ = 3,
	}
	
	/// <summary>
	/// AuthConfig defines details of a authentication type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AuthConfig
	{
		
		/// <summary>
		/// List containing additional auth configs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalVariables")]
		public ConfigVariable[] AdditionalVariables { get; set; }
		
		/// <summary>
		/// Identifier key for auth config
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authKey")]
		public string AuthKey { get; set; }
		
		/// <summary>
		/// The type of authentication configured.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authType")]
		public System.Nullable<AuthConfigAuthType> AuthType { get; set; }
		
		/// <summary>
		/// Parameters to support Oauth 2.0 Auth Code Grant Authentication. See https://www.rfc-editor.org/rfc/rfc6749#section-1.3.1 for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oauth2AuthCodeFlow")]
		public Oauth2AuthCodeFlow Oauth2AuthCodeFlow { get; set; }
		
		/// <summary>
		/// Parameters to support Oauth 2.0 Client Credentials Grant Authentication. See https://tools.ietf.org/html/rfc6749#section-1.3.4 for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oauth2ClientCredentials")]
		public Oauth2ClientCredentials Oauth2ClientCredentials { get; set; }
		
		/// <summary>
		/// Parameters to support JSON Web Token (JWT) Profile for Oauth 2.0 Authorization Grant based authentication. See https://tools.ietf.org/html/rfc7523 for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oauth2JwtBearer")]
		public Oauth2JwtBearer Oauth2JwtBearer { get; set; }
		
		/// <summary>
		/// Parameters to support Ssh public key Authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sshPublicKey")]
		public SshPublicKey SshPublicKey { get; set; }
		
		/// <summary>
		/// Parameters to support Username and Password Authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userPassword")]
		public UserPassword UserPassword { get; set; }
	}
	
	/// <summary>
	/// ConfigVariable represents a configuration variable present in a Connection. or AuthConfig.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigVariable
	{
		
		/// <summary>
		/// Value is a bool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="boolValue")]
		public System.Nullable<System.Boolean> BoolValue { get; set; }
		
		/// <summary>
		/// Encryption Key value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptionKeyValue")]
		public EncryptionKey EncryptionKeyValue { get; set; }
		
		/// <summary>
		/// Value is an integer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="intValue")]
		public string IntValue { get; set; }
		
		/// <summary>
		/// Key of the config variable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Secret provides a reference to entries in Secret Manager.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secretValue")]
		public Secret SecretValue { get; set; }
		
		/// <summary>
		/// Value is a string.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stringValue")]
		public string StringValue { get; set; }
	}
	
	/// <summary>
	/// Encryption Key value.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EncryptionKey
	{
		
		/// <summary>
		/// The [KMS key name] with which the content of the Operation is encrypted. The expected format: `projects/*/locations/*/keyRings/*/cryptoKeys/*`. Will be empty string if google managed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kmsKeyName")]
		public string KmsKeyName { get; set; }
		
		/// <summary>
		/// Type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<EncryptionKeyType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EncryptionKeyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GOOGLE_MANAGED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUSTOMER_MANAGED = 2,
	}
	
	/// <summary>
	/// Secret provides a reference to entries in Secret Manager.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Secret
	{
		
		/// <summary>
		/// The resource name of the secret version in the format, format as: `projects/*/secrets/*/versions/*`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secretVersion")]
		public string SecretVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AuthConfigAuthType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTH_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USER_PASSWORD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OAUTH2_JWT_BEARER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OAUTH2_CLIENT_CREDENTIALS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SSH_PUBLIC_KEY = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OAUTH2_AUTH_CODE_FLOW = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GOOGLE_AUTHENTICATION = 6,
	}
	
	/// <summary>
	/// Parameters to support Oauth 2.0 Auth Code Grant Authentication. See https://www.rfc-editor.org/rfc/rfc6749#section-1.3.1 for more details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Oauth2AuthCodeFlow
	{
		
		/// <summary>
		/// Authorization code to be exchanged for access and refresh tokens.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authCode")]
		public string AuthCode { get; set; }
		
		/// <summary>
		/// Auth URL for Authorization Code Flow
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authUri")]
		public string AuthUri { get; set; }
		
		/// <summary>
		/// Client ID for user-provided OAuth app.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientId")]
		public string ClientId { get; set; }
		
		/// <summary>
		/// Secret provides a reference to entries in Secret Manager.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientSecret")]
		public Secret ClientSecret { get; set; }
		
		/// <summary>
		/// Whether to enable PKCE when the user performs the auth code flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enablePkce")]
		public System.Nullable<System.Boolean> EnablePkce { get; set; }
		
		/// <summary>
		/// PKCE verifier to be used during the auth code exchange.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pkceVerifier")]
		public string PkceVerifier { get; set; }
		
		/// <summary>
		/// Redirect URI to be provided during the auth code exchange.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirectUri")]
		public string RedirectUri { get; set; }
		
		/// <summary>
		/// Scopes the connection will request when the user performs the auth code flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scopes")]
		public string[] Scopes { get; set; }
	}
	
	/// <summary>
	/// Parameters to support Oauth 2.0 Client Credentials Grant Authentication. See https://tools.ietf.org/html/rfc6749#section-1.3.4 for more details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Oauth2ClientCredentials
	{
		
		/// <summary>
		/// The client identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientId")]
		public string ClientId { get; set; }
		
		/// <summary>
		/// Secret provides a reference to entries in Secret Manager.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientSecret")]
		public Secret ClientSecret { get; set; }
	}
	
	/// <summary>
	/// Parameters to support JSON Web Token (JWT) Profile for Oauth 2.0 Authorization Grant based authentication. See https://tools.ietf.org/html/rfc7523 for more details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Oauth2JwtBearer
	{
		
		/// <summary>
		/// Secret provides a reference to entries in Secret Manager.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientKey")]
		public Secret ClientKey { get; set; }
		
		/// <summary>
		/// JWT claims used for the jwt-bearer authorization grant.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jwtClaims")]
		public JwtClaims JwtClaims { get; set; }
	}
	
	/// <summary>
	/// JWT claims used for the jwt-bearer authorization grant.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JwtClaims
	{
		
		/// <summary>
		/// Value for the "aud" claim.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="audience")]
		public string Audience { get; set; }
		
		/// <summary>
		/// Value for the "iss" claim.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issuer")]
		public string Issuer { get; set; }
		
		/// <summary>
		/// Value for the "sub" claim.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subject")]
		public string Subject { get; set; }
	}
	
	/// <summary>
	/// Parameters to support Ssh public key Authentication.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SshPublicKey
	{
		
		/// <summary>
		/// Format of SSH Client cert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certType")]
		public string CertType { get; set; }
		
		/// <summary>
		/// Secret provides a reference to entries in Secret Manager.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sshClientCert")]
		public Secret SshClientCert { get; set; }
		
		/// <summary>
		/// Secret provides a reference to entries in Secret Manager.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sshClientCertPass")]
		public Secret SshClientCertPass { get; set; }
		
		/// <summary>
		/// The user account used to authenticate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// Parameters to support Username and Password Authentication.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UserPassword
	{
		
		/// <summary>
		/// Secret provides a reference to entries in Secret Manager.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public Secret Password { get; set; }
		
		/// <summary>
		/// Username.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// AuthConfigTemplate defines required field over an authentication type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AuthConfigTemplate
	{
		
		/// <summary>
		/// Identifier key for auth config
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authKey")]
		public string AuthKey { get; set; }
		
		/// <summary>
		/// The type of authentication configured.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authType")]
		public AuthConfigAuthType AuthType { get; set; }
		
		/// <summary>
		/// Config variables to describe an `AuthConfig` for a `Connection`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configVariableTemplates")]
		public ConfigVariableTemplate[] ConfigVariableTemplates { get; set; }
		
		/// <summary>
		/// Connector specific description for an authentication template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Display name for authentication template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
	}
	
	/// <summary>
	/// ConfigVariableTemplate provides metadata about a `ConfigVariable` that is used in a Connection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigVariableTemplate
	{
		
		/// <summary>
		/// This configuration captures the details required to render an authorization link for the OAuth Authorization Code Flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizationCodeLink")]
		public AuthorizationCodeLink AuthorizationCodeLink { get; set; }
		
		/// <summary>
		/// Description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Display name of the parameter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Enum options. To be populated if `ValueType` is `ENUM`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enumOptions")]
		public EnumOption[] EnumOptions { get; set; }
		
		/// <summary>
		/// Indicates if current template is part of advanced settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAdvanced")]
		public System.Nullable<System.Boolean> IsAdvanced { get; set; }
		
		/// <summary>
		/// Key of the config variable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Optional. Location Tyep denotes where this value should be sent in BYOC connections.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationType")]
		public System.Nullable<ConfigVariableTemplateLocationType> LocationType { get; set; }
		
		/// <summary>
		/// Flag represents that this `ConfigVariable` must be provided for a connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="required")]
		public System.Nullable<System.Boolean> Required { get; set; }
		
		/// <summary>
		/// Struct for representing boolean expressions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requiredCondition")]
		public LogicalExpression RequiredCondition { get; set; }
		
		/// <summary>
		/// This configuration defines all the Cloud IAM roles that needs to be granted to a particular Google Cloud resource for the selected principal like service account. These configurations will let UI display to customers what IAM roles need to be granted by them. Or these configurations can be used by the UI to render a 'grant' button to do the same on behalf of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="roleGrant")]
		public RoleGrant RoleGrant { get; set; }
		
		/// <summary>
		/// State of the config variable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<ConfigVariableTemplateState> State { get; set; }
		
		/// <summary>
		/// Regular expression in RE2 syntax used for validating the `value` of a `ConfigVariable`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validationRegex")]
		public string ValidationRegex { get; set; }
		
		/// <summary>
		/// Type of the parameter: string, int, bool etc. consider custom type for the benefit for the validation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="valueType")]
		public System.Nullable<ConfigVariableTemplateValueType> ValueType { get; set; }
	}
	
	/// <summary>
	/// This configuration captures the details required to render an authorization link for the OAuth Authorization Code Flow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AuthorizationCodeLink
	{
		
		/// <summary>
		/// The client ID assigned to the Google Cloud Connectors OAuth app for the connector data source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientId")]
		public string ClientId { get; set; }
		
		/// <summary>
		/// Whether to enable PKCE for the auth code flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enablePkce")]
		public System.Nullable<System.Boolean> EnablePkce { get; set; }
		
		/// <summary>
		/// The scopes for which the user will authorize Google Cloud Connectors on the connector data source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scopes")]
		public string[] Scopes { get; set; }
		
		/// <summary>
		/// The base URI the user must click to trigger the authorization code login flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
	}
	
	/// <summary>
	/// EnumOption definition
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EnumOption
	{
		
		/// <summary>
		/// Display name of the option.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Id of the option.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ConfigVariableTemplateLocationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCATION_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HEADER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PAYLOAD = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		QUERY_PARAM = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PATH_PARAM = 4,
	}
	
	/// <summary>
	/// Struct for representing boolean expressions.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LogicalExpression
	{
		
		/// <summary>
		/// A list of fields to be compared.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fieldComparisons")]
		public FieldComparison[] FieldComparisons { get; set; }
		
		/// <summary>
		/// A list of nested conditions to be compared.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logicalExpressions")]
		public LogicalExpression[] LogicalExpressions { get; set; }
		
		/// <summary>
		/// The logical operator to use between the fields and conditions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logicalOperator")]
		public System.Nullable<LogicalExpressionLogicalOperator> LogicalOperator { get; set; }
	}
	
	/// <summary>
	/// Field that needs to be compared.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FieldComparison
	{
		
		/// <summary>
		/// Boolean value
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="boolValue")]
		public System.Nullable<System.Boolean> BoolValue { get; set; }
		
		/// <summary>
		/// Comparator to use for comparing the field value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comparator")]
		public System.Nullable<FieldComparisonComparator> Comparator { get; set; }
		
		/// <summary>
		/// Integer value
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="intValue")]
		public string IntValue { get; set; }
		
		/// <summary>
		/// Key of the field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// String value
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stringValue")]
		public string StringValue { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FieldComparisonComparator
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPARATOR_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EQUALS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_EQUALS = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum LogicalExpressionLogicalOperator
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPERATOR_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AND = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OR = 2,
	}
	
	/// <summary>
	/// This configuration defines all the Cloud IAM roles that needs to be granted to a particular Google Cloud resource for the selected principal like service account. These configurations will let UI display to customers what IAM roles need to be granted by them. Or these configurations can be used by the UI to render a 'grant' button to do the same on behalf of the user.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RoleGrant
	{
		
		/// <summary>
		/// Template that UI can use to provide helper text to customers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helperTextTemplate")]
		public string HelperTextTemplate { get; set; }
		
		/// <summary>
		/// Prinicipal/Identity for whom the role need to assigned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="principal")]
		public System.Nullable<RoleGrantPrincipal> Principal { get; set; }
		
		/// <summary>
		/// Resource definition
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public Resource Resource { get; set; }
		
		/// <summary>
		/// List of roles that need to be granted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="roles")]
		public string[] Roles { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RoleGrantPrincipal
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRINCIPAL_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONNECTOR_SA = 1,
	}
	
	/// <summary>
	/// Resource definition
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Resource
	{
		
		/// <summary>
		/// Template to uniquely represent a Google Cloud resource in a format IAM expects This is a template that can have references to other values provided in the config variable template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pathTemplate")]
		public string PathTemplate { get; set; }
		
		/// <summary>
		/// Different types of resource supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<ResourceType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ResourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GCP_PROJECT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GCP_RESOURCE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GCP_SECRETMANAGER_SECRET = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GCP_SECRETMANAGER_SECRET_VERSION = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ConfigVariableTemplateState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEPRECATED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ConfigVariableTemplateValueType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VALUE_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STRING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BOOL = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SECRET = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENUM = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTHORIZATION_CODE = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENCRYPTION_KEY = 7,
	}
	
	/// <summary>
	/// Associates `members`, or principals, with a `role`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Binding
	{
		
		/// <summary>
		/// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="condition")]
		public Expr Condition { get; set; }
		
		/// <summary>
		/// Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workforce identity pool. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/group/{group_id}`: All workforce identities in a group. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All workforce identities with a specific attribute value. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/*`: All identities in a workforce identity pool. * `principal://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workload identity pool. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/group/{group_id}`: A workload identity pool group. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All identities in a workload identity pool with a certain attribute. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/*`: All identities in a workload identity pool. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `deleted:principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: Deleted single identity in a workforce identity pool. For example, `deleted:principal://iam.googleapis.com/locations/global/workforcePools/my-pool-id/subject/my-subject-attribute-value`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="members")]
		public string[] Members { get; set; }
		
		/// <summary>
		/// Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="role")]
		public string Role { get; set; }
	}
	
	/// <summary>
	/// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Expr
	{
		
		/// <summary>
		/// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Textual representation of an expression in Common Expression Language syntax.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expression")]
		public string Expression { get; set; }
		
		/// <summary>
		/// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	/// <summary>
	/// The request message for Operations.CancelOperation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CancelOperationRequest
	{
	}
	
	/// <summary>
	/// Connection represents an instance of connector.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Connection
	{
		
		/// <summary>
		/// AuthConfig defines details of a authentication type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authConfig")]
		public AuthConfig AuthConfig { get; set; }
		
		/// <summary>
		/// Optional. Configuration for configuring the connection with an external system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configVariables")]
		public ConfigVariable[] ConfigVariables { get; set; }
		
		/// <summary>
		/// Output only. Connection revision. This field is only updated when the connection is created or updated by User.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionRevision")]
		public string ConnectionRevision { get; set; }
		
		/// <summary>
		/// Required. Connector version on which the connection is created. The format is: projects/*/locations/*/providers/*/connectors/*/versions/* Only global location is supported for ConnectorVersion resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectorVersion")]
		public string ConnectorVersion { get; set; }
		
		/// <summary>
		/// This cofiguration provides infra configs like rate limit threshold which need to be configurable for every connector version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectorVersionInfraConfig")]
		public ConnectorVersionInfraConfig ConnectorVersionInfraConfig { get; set; }
		
		/// <summary>
		/// Output only. Flag to mark the version indicating the launch stage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectorVersionLaunchStage")]
		public System.Nullable<ConnectionConnectorVersionLaunchStage> ConnectorVersionLaunchStage { get; set; }
		
		/// <summary>
		/// Output only. Created time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Optional. Description of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Optional. Configuration of the Connector's destination. Only accepted for Connectors that accepts user defined destination(s).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinationConfigs")]
		public DestinationConfig[] DestinationConfigs { get; set; }
		
		/// <summary>
		/// Output only. GCR location where the envoy image is stored. formatted like: gcr.io/{bucketName}/{imageName}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="envoyImageLocation")]
		public string EnvoyImageLocation { get; set; }
		
		/// <summary>
		/// Eventing Configuration of a connection
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventingConfig")]
		public EventingConfig EventingConfig { get; set; }
		
		/// <summary>
		/// Optional. Eventing enablement type. Will be nil if eventing is not enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventingEnablementType")]
		public System.Nullable<ConnectionEventingEnablementType> EventingEnablementType { get; set; }
		
		/// <summary>
		/// Eventing runtime data has the details related to eventing managed by the system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventingRuntimeData")]
		public EventingRuntimeData EventingRuntimeData { get; set; }
		
		/// <summary>
		/// Output only. GCR location where the runtime image is stored. formatted like: gcr.io/{bucketName}/{imageName}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageLocation")]
		public string ImageLocation { get; set; }
		
		/// <summary>
		/// Output only. Is trusted tester program enabled for the project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isTrustedTester")]
		public System.Nullable<System.Boolean> IsTrustedTester { get; set; }
		
		/// <summary>
		/// Optional. Resource labels to represent user-provided metadata. Refer to cloud documentation on labels for more details. https://cloud.google.com/compute/docs/labeling-resources
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Determines whether or no a connection is locked. If locked, a reason must be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lockConfig")]
		public LockConfig LockConfig { get; set; }
		
		/// <summary>
		/// Log configuration for the connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logConfig")]
		public ConnectorsLogConfig LogConfig { get; set; }
		
		/// <summary>
		/// Output only. Resource name of the Connection. Format: projects/{project}/locations/{location}/connections/{connection}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Node configuration for the connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeConfig")]
		public NodeConfig NodeConfig { get; set; }
		
		/// <summary>
		/// Optional. Service account needed for runtime plane to access Google Cloud resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceAccount")]
		public string ServiceAccount { get; set; }
		
		/// <summary>
		/// Output only. The name of the Service Directory service name. Used for Private Harpoon to resolve the ILB address. e.g. "projects/cloud-connectors-e2e-testing/locations/us-central1/namespaces/istio-system/services/istio-ingressgateway-connectors"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceDirectory")]
		public string ServiceDirectory { get; set; }
		
		/// <summary>
		/// SSL Configuration of a connection
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sslConfig")]
		public SslConfig SslConfig { get; set; }
		
		/// <summary>
		/// ConnectionStatus indicates the state of the connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ConnectionStatus Status { get; set; }
		
		/// <summary>
		/// Output only. This subscription type enum states the subscription type of the project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscriptionType")]
		public System.Nullable<ConnectionSubscriptionType> SubscriptionType { get; set; }
		
		/// <summary>
		/// Optional. Suspended indicates if a user has suspended a connection or not.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="suspended")]
		public System.Nullable<System.Boolean> Suspended { get; set; }
		
		/// <summary>
		/// Output only. Updated time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// This cofiguration provides infra configs like rate limit threshold which need to be configurable for every connector version
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConnectorVersionInfraConfig
	{
		
		/// <summary>
		/// Output only. The window used for ratelimiting runtime requests to connections.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionRatelimitWindowSeconds")]
		public string ConnectionRatelimitWindowSeconds { get; set; }
		
		/// <summary>
		/// Optional. Indicates whether connector is deployed on GKE/CloudRun
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deploymentModel")]
		public System.Nullable<ConnectorVersionInfraConfigDeploymentModel> DeploymentModel { get; set; }
		
		/// <summary>
		/// Autoscaling config for connector deployment system metrics.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hpaConfig")]
		public HPAConfig HpaConfig { get; set; }
		
		/// <summary>
		/// Output only. Max QPS supported for internal requests originating from Connd.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="internalclientRatelimitThreshold")]
		public string InternalclientRatelimitThreshold { get; set; }
		
		/// <summary>
		/// Output only. Max QPS supported by the connector version before throttling of requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ratelimitThreshold")]
		public string RatelimitThreshold { get; set; }
		
		/// <summary>
		/// Resource limits defined for connection pods of a given connector type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceLimits")]
		public ResourceLimits ResourceLimits { get; set; }
		
		/// <summary>
		/// Resource requests defined for connection pods of a given connector type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceRequests")]
		public ResourceRequests ResourceRequests { get; set; }
		
		/// <summary>
		/// Output only. The name of shared connector deployment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sharedDeployment")]
		public string SharedDeployment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ConnectorVersionInfraConfigDeploymentModel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEPLOYMENT_MODEL_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GKE_MST = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLOUD_RUN_MST = 2,
	}
	
	/// <summary>
	/// Autoscaling config for connector deployment system metrics.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HPAConfig
	{
		
		/// <summary>
		/// Output only. Percent CPU utilization where HPA triggers autoscaling.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuUtilizationThreshold")]
		public string CpuUtilizationThreshold { get; set; }
		
		/// <summary>
		/// Output only. Percent Memory utilization where HPA triggers autoscaling.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memoryUtilizationThreshold")]
		public string MemoryUtilizationThreshold { get; set; }
	}
	
	/// <summary>
	/// Resource limits defined for connection pods of a given connector type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceLimits
	{
		
		/// <summary>
		/// Output only. CPU limit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpu")]
		public string Cpu { get; set; }
		
		/// <summary>
		/// Output only. Memory limit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memory")]
		public string Memory { get; set; }
	}
	
	/// <summary>
	/// Resource requests defined for connection pods of a given connector type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceRequests
	{
		
		/// <summary>
		/// Output only. CPU request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpu")]
		public string Cpu { get; set; }
		
		/// <summary>
		/// Output only. Memory request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memory")]
		public string Memory { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ConnectionConnectorVersionLaunchStage
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LAUNCH_STAGE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREVIEW = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GA = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEPRECATED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIVATE_PREVIEW = 4,
	}
	
	/// <summary>
	/// Define the Connectors target endpoint.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DestinationConfig
	{
		
		/// <summary>
		/// The destinations for the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinations")]
		public Destination[] Destinations { get; set; }
		
		/// <summary>
		/// The key is the destination identifier that is supported by the Connector.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Destination
	{
		
		/// <summary>
		/// For publicly routable host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// The port is the target port number that is accepted by the destination.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// PSC service attachments. Format: projects/*/regions/*/serviceAttachments/*
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceAttachment")]
		public string ServiceAttachment { get; set; }
	}
	
	/// <summary>
	/// Eventing Configuration of a connection
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventingConfig
	{
		
		/// <summary>
		/// Additional eventing related field values
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalVariables")]
		public ConfigVariable[] AdditionalVariables { get; set; }
		
		/// <summary>
		/// AuthConfig defines details of a authentication type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authConfig")]
		public AuthConfig AuthConfig { get; set; }
		
		/// <summary>
		/// Dead Letter configuration details provided by the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deadLetterConfig")]
		public DeadLetterConfig DeadLetterConfig { get; set; }
		
		/// <summary>
		/// Enrichment Enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enrichmentEnabled")]
		public System.Nullable<System.Boolean> EnrichmentEnabled { get; set; }
		
		/// <summary>
		/// Optional. Ingress endpoint of the event listener. This is used only when private connectivity is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventsListenerIngressEndpoint")]
		public string EventsListenerIngressEndpoint { get; set; }
		
		/// <summary>
		/// AuthConfig defines details of a authentication type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="listenerAuthConfig")]
		public AuthConfig ListenerAuthConfig { get; set; }
		
		/// <summary>
		/// Optional. Private Connectivity Enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateConnectivityEnabled")]
		public System.Nullable<System.Boolean> PrivateConnectivityEnabled { get; set; }
		
		/// <summary>
		/// Define the Connectors target endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registrationDestinationConfig")]
		public DestinationConfig RegistrationDestinationConfig { get; set; }
	}
	
	/// <summary>
	/// Dead Letter configuration details provided by the user.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeadLetterConfig
	{
		
		/// <summary>
		/// Optional. Project which has the topic given.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="projectId")]
		public string ProjectId { get; set; }
		
		/// <summary>
		/// Optional. Topic to push events which couldn't be processed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="topic")]
		public string Topic { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ConnectionEventingEnablementType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EVENTING_ENABLEMENT_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EVENTING_AND_CONNECTION = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONLY_EVENTING = 2,
	}
	
	/// <summary>
	/// Eventing runtime data has the details related to eventing managed by the system.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventingRuntimeData
	{
		
		/// <summary>
		/// Output only. Events listener endpoint. The value will populated after provisioning the events listener.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventsListenerEndpoint")]
		public string EventsListenerEndpoint { get; set; }
		
		/// <summary>
		/// Output only. Events listener PSC Service attachment. The value will be populated after provisioning the events listener with private connectivity enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventsListenerPscSa")]
		public string EventsListenerPscSa { get; set; }
		
		/// <summary>
		/// EventingStatus indicates the state of eventing.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public EventingStatus Status { get; set; }
	}
	
	/// <summary>
	/// EventingStatus indicates the state of eventing.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventingStatus
	{
		
		/// <summary>
		/// Output only. Description of error if State is set to "ERROR".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Output only. State.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<EventingStatusState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EventingStatusState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INGRESS_ENDPOINT_REQUIRED = 3,
	}
	
	/// <summary>
	/// Determines whether or no a connection is locked. If locked, a reason must be specified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LockConfig
	{
		
		/// <summary>
		/// Indicates whether or not the connection is locked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locked")]
		public System.Nullable<System.Boolean> Locked { get; set; }
		
		/// <summary>
		/// Describes why a connection is locked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
	}
	
	/// <summary>
	/// Log configuration for the connection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConnectorsLogConfig
	{
		
		/// <summary>
		/// Enabled represents whether logging is enabled or not for a connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	/// <summary>
	/// Node configuration for the connection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeConfig
	{
		
		/// <summary>
		/// Maximum number of nodes in the runtime nodes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxNodeCount")]
		public System.Nullable<System.Int32> MaxNodeCount { get; set; }
		
		/// <summary>
		/// Minimum number of nodes in the runtime nodes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minNodeCount")]
		public System.Nullable<System.Int32> MinNodeCount { get; set; }
	}
	
	/// <summary>
	/// SSL Configuration of a connection
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SslConfig
	{
		
		/// <summary>
		/// Additional SSL related field values
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalVariables")]
		public ConfigVariable[] AdditionalVariables { get; set; }
		
		/// <summary>
		/// Type of Client Cert (PEM/JKS/.. etc.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientCertType")]
		public System.Nullable<SslConfigClientCertType> ClientCertType { get; set; }
		
		/// <summary>
		/// Secret provides a reference to entries in Secret Manager.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientCertificate")]
		public Secret ClientCertificate { get; set; }
		
		/// <summary>
		/// Secret provides a reference to entries in Secret Manager.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientPrivateKey")]
		public Secret ClientPrivateKey { get; set; }
		
		/// <summary>
		/// Secret provides a reference to entries in Secret Manager.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientPrivateKeyPass")]
		public Secret ClientPrivateKeyPass { get; set; }
		
		/// <summary>
		/// Secret provides a reference to entries in Secret Manager.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateServerCertificate")]
		public Secret PrivateServerCertificate { get; set; }
		
		/// <summary>
		/// Type of Server Cert (PEM/JKS/.. etc.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serverCertType")]
		public SslConfigClientCertType ServerCertType { get; set; }
		
		/// <summary>
		/// Trust Model of the SSL connection
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trustModel")]
		public System.Nullable<SslConfigTrustModel> TrustModel { get; set; }
		
		/// <summary>
		/// Controls the ssl type for the given connector version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<SslConfigType> Type { get; set; }
		
		/// <summary>
		/// Bool for enabling SSL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useSsl")]
		public System.Nullable<System.Boolean> UseSsl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SslConfigClientCertType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CERT_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PEM = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SslConfigTrustModel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIVATE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INSECURE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SslConfigType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SSL_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TLS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MTLS = 2,
	}
	
	/// <summary>
	/// ConnectionStatus indicates the state of the connection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConnectionStatus
	{
		
		/// <summary>
		/// Description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// State.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<ConnectionStatusState> State { get; set; }
		
		/// <summary>
		/// Status provides detailed information for the state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ConnectionStatusState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INACTIVE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTHORIZATION_REQUIRED = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ConnectionSubscriptionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUBSCRIPTION_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PAY_G = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PAID = 2,
	}
	
	/// <summary>
	/// ConnectionSchemaMetadata is the singleton resource of each connection. It includes the entity and action names of runtime resources exposed by a connection backend.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConnectionSchemaMetadata
	{
		
		/// <summary>
		/// Output only. List of actions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actions")]
		public string[] Actions { get; set; }
		
		/// <summary>
		/// Output only. List of entity names.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entities")]
		public string[] Entities { get; set; }
		
		/// <summary>
		/// Error message for users.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorMessage")]
		public string ErrorMessage { get; set; }
		
		/// <summary>
		/// Output only. Resource name. Format: projects/{project}/locations/{location}/connections/{connection}/connectionSchemaMetadata
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. Timestamp when the connection runtime schema refresh was triggered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="refreshTime")]
		public string RefreshTime { get; set; }
		
		/// <summary>
		/// Output only. The current state of runtime schema.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<ConnectionSchemaMetadataState> State { get; set; }
		
		/// <summary>
		/// Output only. Timestamp when the connection runtime schema was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ConnectionSchemaMetadataState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REFRESHING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REFRESHING_SCHEMA_METADATA = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATED_SCHEMA_METADATA = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REFRESH_SCHEMA_METADATA_FAILED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REFRESHING_FULL_SCHEMA = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATED_FULL_SCHEMA = 7,
	}
	
	/// <summary>
	/// Connectors indicates a specific connector type, e.x. Salesforce, SAP etc.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Connector
	{
		
		/// <summary>
		/// Output only. Created time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Output only. Description of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Output only. Display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Output only. Link to documentation page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="documentationUri")]
		public string DocumentationUri { get; set; }
		
		/// <summary>
		/// Eventing Details message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventingDetails")]
		public EventingDetails EventingDetails { get; set; }
		
		/// <summary>
		/// Output only. Link to external page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="externalUri")]
		public string ExternalUri { get; set; }
		
		/// <summary>
		/// Output only. Resource labels to represent user-provided metadata. Refer to cloud documentation on labels for more details. https://cloud.google.com/compute/docs/labeling-resources
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Output only. Flag to mark the version indicating the launch stage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="launchStage")]
		public ConnectionConnectorVersionLaunchStage LaunchStage { get; set; }
		
		/// <summary>
		/// Output only. Resource name of the Connector. Format: projects/{project}/locations/{location}/providers/{provider}/connectors/{connector} Only global location is supported for Connector resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. Updated time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
		
		/// <summary>
		/// Output only. Cloud storage location of icons etc consumed by UI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="webAssetsLocation")]
		public string WebAssetsLocation { get; set; }
	}
	
	/// <summary>
	/// Eventing Details message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventingDetails
	{
		
		/// <summary>
		/// Output only. Custom Event Types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customEventTypes")]
		public System.Nullable<System.Boolean> CustomEventTypes { get; set; }
		
		/// <summary>
		/// Output only. Description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Output only. Link to public documentation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="documentationLink")]
		public string DocumentationLink { get; set; }
		
		/// <summary>
		/// Output only. Cloud storage location of the icon.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iconLocation")]
		public string IconLocation { get; set; }
		
		/// <summary>
		/// Output only. Eventing Launch Stage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="launchStage")]
		public ConnectionConnectorVersionLaunchStage LaunchStage { get; set; }
		
		/// <summary>
		/// Output only. Name of the Eventing trigger.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. Array of search keywords.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="searchTags")]
		public string[] SearchTags { get; set; }
		
		/// <summary>
		/// Output only. The type of the event listener for a specific connector.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<EventingDetailsType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EventingDetailsType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEBHOOK = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JMS = 2,
	}
	
	/// <summary>
	/// This cofiguration provides infra configs like rate limit threshold which need to be configurable for every connector version
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConnectorInfraConfig
	{
		
		/// <summary>
		/// The window used for ratelimiting runtime requests to connections.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionRatelimitWindowSeconds")]
		public string ConnectionRatelimitWindowSeconds { get; set; }
		
		/// <summary>
		/// Indicate whether connector is deployed on GKE/CloudRun
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deploymentModel")]
		public ConnectorVersionInfraConfigDeploymentModel DeploymentModel { get; set; }
		
		/// <summary>
		/// Autoscaling config for connector deployment system metrics.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hpaConfig")]
		public HPAConfig HpaConfig { get; set; }
		
		/// <summary>
		/// Max QPS supported for internal requests originating from Connd.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="internalclientRatelimitThreshold")]
		public string InternalclientRatelimitThreshold { get; set; }
		
		/// <summary>
		/// Max QPS supported by the connector version before throttling of requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ratelimitThreshold")]
		public string RatelimitThreshold { get; set; }
		
		/// <summary>
		/// Resource limits defined for connection pods of a given connector type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceLimits")]
		public ResourceLimits ResourceLimits { get; set; }
		
		/// <summary>
		/// Resource requests defined for connection pods of a given connector type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceRequests")]
		public ResourceRequests ResourceRequests { get; set; }
		
		/// <summary>
		/// The name of shared connector deployment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sharedDeployment")]
		public string SharedDeployment { get; set; }
	}
	
	/// <summary>
	/// ConnectorVersion indicates a specific version of a connector.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConnectorVersion
	{
		
		/// <summary>
		/// Output only. List of auth configs supported by the Connector Version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authConfigTemplates")]
		public AuthConfigTemplate[] AuthConfigTemplates { get; set; }
		
		/// <summary>
		/// Output only. List of config variables needed to create a connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configVariableTemplates")]
		public ConfigVariableTemplate[] ConfigVariableTemplates { get; set; }
		
		/// <summary>
		/// This cofiguration provides infra configs like rate limit threshold which need to be configurable for every connector version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectorInfraConfig")]
		public ConnectorInfraConfig ConnectorInfraConfig { get; set; }
		
		/// <summary>
		/// Output only. Created time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Output only. List of destination configs needed to create a connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinationConfigTemplates")]
		public DestinationConfigTemplate[] DestinationConfigTemplates { get; set; }
		
		/// <summary>
		/// Output only. Display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Egress control config for connector runtime. These configurations define the rules to identify which outbound domains/hosts needs to be whitelisted. It may be a static information for a particular connector version or it is derived from the configurations provided by the customer in Connection resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="egressControlConfig")]
		public EgressControlConfig EgressControlConfig { get; set; }
		
		/// <summary>
		/// Eventing Config details of a connector version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventingConfigTemplate")]
		public EventingConfigTemplate EventingConfigTemplate { get; set; }
		
		/// <summary>
		/// Output only. Resource labels to represent user-provided metadata. Refer to cloud documentation on labels for more details. https://cloud.google.com/compute/docs/labeling-resources
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Output only. Flag to mark the version indicating the launch stage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="launchStage")]
		public ConnectionConnectorVersionLaunchStage LaunchStage { get; set; }
		
		/// <summary>
		/// Output only. Resource name of the Version. Format: projects/{project}/locations/{location}/providers/{provider}/connectors/{connector}/versions/{version} Only global location is supported for Connector resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. ReleaseVersion of the connector, for example: "1.0.1-alpha".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseVersion")]
		public string ReleaseVersion { get; set; }
		
		/// <summary>
		/// This configuration defines all the Cloud IAM roles that needs to be granted to a particular Google Cloud resource for the selected principal like service account. These configurations will let UI display to customers what IAM roles need to be granted by them. Or these configurations can be used by the UI to render a 'grant' button to do the same on behalf of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="roleGrant")]
		public RoleGrant RoleGrant { get; set; }
		
		/// <summary>
		/// Output only. Role grant configurations for this connector version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="roleGrants")]
		public RoleGrant[] RoleGrants { get; set; }
		
		/// <summary>
		/// Ssl config details of a connector version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sslConfigTemplate")]
		public SslConfigTemplate SslConfigTemplate { get; set; }
		
		/// <summary>
		/// Supported runtime features of a connector version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="supportedRuntimeFeatures")]
		public SupportedRuntimeFeatures SupportedRuntimeFeatures { get; set; }
		
		/// <summary>
		/// Output only. Unsupported connection types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unsupportedConnectionTypes")]
		public string[] UnsupportedConnectionTypes { get; set; }
		
		/// <summary>
		/// Output only. Updated time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// DestinationConfigTemplate defines required destinations supported by the Connector.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DestinationConfigTemplate
	{
		
		/// <summary>
		/// The default port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultPort")]
		public System.Nullable<System.Int32> DefaultPort { get; set; }
		
		/// <summary>
		/// Description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Display name of the parameter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Whether the current destination tempalate is part of Advanced settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAdvanced")]
		public System.Nullable<System.Boolean> IsAdvanced { get; set; }
		
		/// <summary>
		/// Key of the destination.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// The maximum number of destinations supported for this key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="max")]
		public System.Nullable<System.Int32> Max { get; set; }
		
		/// <summary>
		/// The minimum number of destinations supported for this key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="min")]
		public System.Nullable<System.Int32> Min { get; set; }
		
		/// <summary>
		/// Whether port number should be provided by customers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portFieldType")]
		public System.Nullable<DestinationConfigTemplatePortFieldType> PortFieldType { get; set; }
		
		/// <summary>
		/// Regex pattern for host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="regexPattern")]
		public string RegexPattern { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum DestinationConfigTemplatePortFieldType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FIELD_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REQUIRED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPTIONAL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_USED = 3,
	}
	
	/// <summary>
	/// Egress control config for connector runtime. These configurations define the rules to identify which outbound domains/hosts needs to be whitelisted. It may be a static information for a particular connector version or it is derived from the configurations provided by the customer in Connection resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EgressControlConfig
	{
		
		/// <summary>
		/// Static Comma separated backends which are common for all Connection resources. Supported formats for each backend are host:port or just host (host can be ip address or domain name).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backends")]
		public string Backends { get; set; }
		
		/// <summary>
		/// Extraction Rules to identity the backends from customer provided configuration in Connection resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extractionRules")]
		public ExtractionRules ExtractionRules { get; set; }
	}
	
	/// <summary>
	/// Extraction Rules to identity the backends from customer provided configuration in Connection resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExtractionRules
	{
		
		/// <summary>
		/// Collection of Extraction Rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extractionRule")]
		public ExtractionRule[] ExtractionRule { get; set; }
	}
	
	/// <summary>
	/// Extraction Rule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExtractionRule
	{
		
		/// <summary>
		/// Regex used to extract backend details from source. If empty, whole source value will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extractionRegex")]
		public string ExtractionRegex { get; set; }
		
		/// <summary>
		/// Source to extract the backend from.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Source Source { get; set; }
	}
	
	/// <summary>
	/// Source to extract the backend from.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Source
	{
		
		/// <summary>
		/// Field identifier. For example config vaiable name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fieldId")]
		public string FieldId { get; set; }
		
		/// <summary>
		/// Type of the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceType")]
		public System.Nullable<SourceSourceType> SourceType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SourceSourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOURCE_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONFIG_VARIABLE = 1,
	}
	
	/// <summary>
	/// Eventing Config details of a connector version.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventingConfigTemplate
	{
		
		/// <summary>
		/// Additional fields that need to be rendered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalVariables")]
		public ConfigVariableTemplate[] AdditionalVariables { get; set; }
		
		/// <summary>
		/// AuthConfigTemplates represents the auth values for the webhook adapter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authConfigTemplates")]
		public AuthConfigTemplate[] AuthConfigTemplates { get; set; }
		
		/// <summary>
		/// Auto refresh to extend webhook life.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoRefresh")]
		public System.Nullable<System.Boolean> AutoRefresh { get; set; }
		
		/// <summary>
		/// Auto Registration supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoRegistrationSupported")]
		public System.Nullable<System.Boolean> AutoRegistrationSupported { get; set; }
		
		/// <summary>
		/// ConfigVariableTemplate provides metadata about a `ConfigVariable` that is used in a Connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptionKeyTemplate")]
		public ConfigVariableTemplate EncryptionKeyTemplate { get; set; }
		
		/// <summary>
		/// Enrichment Supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enrichmentSupported")]
		public System.Nullable<System.Boolean> EnrichmentSupported { get; set; }
		
		/// <summary>
		/// The type of the event listener for a specific connector.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventListenerType")]
		public System.Nullable<EventingConfigTemplateEventListenerType> EventListenerType { get; set; }
		
		/// <summary>
		/// Is Eventing Supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isEventingSupported")]
		public System.Nullable<System.Boolean> IsEventingSupported { get; set; }
		
		/// <summary>
		/// ListenerAuthConfigTemplates represents the auth values for the event listener.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="listenerAuthConfigTemplates")]
		public AuthConfigTemplate[] ListenerAuthConfigTemplates { get; set; }
		
		/// <summary>
		/// DestinationConfigTemplate defines required destinations supported by the Connector.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registrationDestinationConfig")]
		public DestinationConfigTemplate RegistrationDestinationConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EventingConfigTemplateEventListenerType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EVENT_LISTENER_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEBHOOK_LISTENER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JMS_LISTENER = 2,
	}
	
	/// <summary>
	/// Ssl config details of a connector version
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SslConfigTemplate
	{
		
		/// <summary>
		/// Any additional fields that need to be rendered
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalVariables")]
		public ConfigVariableTemplate[] AdditionalVariables { get; set; }
		
		/// <summary>
		/// List of supported Client Cert Types
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientCertType")]
		public SslConfigClientCertType[] ClientCertType { get; set; }
		
		/// <summary>
		/// Boolean for determining if the connector version mandates TLS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isTlsMandatory")]
		public System.Nullable<System.Boolean> IsTlsMandatory { get; set; }
		
		/// <summary>
		/// List of supported Server Cert Types
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serverCertType")]
		public SslConfigClientCertType[] ServerCertType { get; set; }
		
		/// <summary>
		/// Controls the ssl type for the given connector version
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sslType")]
		public SslConfigType SslType { get; set; }
	}
	
	/// <summary>
	/// Supported runtime features of a connector version.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SupportedRuntimeFeatures
	{
		
		/// <summary>
		/// Specifies if the connector supports action apis like 'executeAction'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actionApis")]
		public System.Nullable<System.Boolean> ActionApis { get; set; }
		
		/// <summary>
		/// Specifies if the connector supports entity apis like 'createEntity'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entityApis")]
		public System.Nullable<System.Boolean> EntityApis { get; set; }
		
		/// <summary>
		/// Specifies if the connector supports 'ExecuteSqlQuery' operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sqlQuery")]
		public System.Nullable<System.Boolean> SqlQuery { get; set; }
	}
	
	/// <summary>
	/// CustomConnector represents the custom connector defined by the customer as part of byoc.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CustomConnector
	{
		
		/// <summary>
		/// Output only. Created time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Required. Type of the custom connector.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customConnectorType")]
		public System.Nullable<CustomConnectorCustomConnectorType> CustomConnectorType { get; set; }
		
		/// <summary>
		/// Optional. Description of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Optional. Display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Optional. Resource labels to represent user-provided metadata. Refer to cloud documentation on labels for more details. https://cloud.google.com/compute/docs/labeling-resources
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Optional. Logo of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logo")]
		public string Logo { get; set; }
		
		/// <summary>
		/// Identifier. Resource name of the CustomConnector. Format: projects/{project}/locations/{location}/customConnectors/{connector}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. Updated time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum CustomConnectorCustomConnectorType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUSTOM_CONNECTOR_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPEN_API = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROTO = 2,
	}
	
	/// <summary>
	/// CustomConnectorVersion indicates a specific version of a connector.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CustomConnectorVersion
	{
		
		/// <summary>
		/// AuthConfig defines details of a authentication type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authConfig")]
		public AuthConfig AuthConfig { get; set; }
		
		/// <summary>
		/// Optional. Backend variables config templates. This translates to additional variable templates in connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backendVariableTemplates")]
		public ConfigVariableTemplate[] BackendVariableTemplates { get; set; }
		
		/// <summary>
		/// Output only. Created time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Optional. Destination config(s) for accessing connector facade/ proxy. This is used only when enable_backend_destination_config is true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinationConfigs")]
		public DestinationConfig[] DestinationConfigs { get; set; }
		
		/// <summary>
		/// Optional. When enabled, the connector will be a facade/ proxy, and connects to the destination provided during connection creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableBackendDestinationConfig")]
		public System.Nullable<System.Boolean> EnableBackendDestinationConfig { get; set; }
		
		/// <summary>
		/// Optional. Resource labels to represent user-provided metadata. Refer to cloud documentation on labels for more details. https://cloud.google.com/compute/docs/labeling-resources
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Output only. Identifier. Resource name of the Version. Format: projects/{project}/locations/{location}/customConnectors/{custom_connector}/customConnectorVersions/{custom_connector_version}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required. Service account used by runtime plane to access auth config secrets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceAccount")]
		public string ServiceAccount { get; set; }
		
		/// <summary>
		/// Optional. Location of the custom connector spec.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="specLocation")]
		public string SpecLocation { get; set; }
		
		/// <summary>
		/// Output only. Updated time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// Time window specified for daily operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DailyCycle
	{
		
		/// <summary>
		/// Output only. Duration of the time window, set by service producer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public string Duration { get; set; }
		
		/// <summary>
		/// Represents a time of day. The date and time zone are either not significant or are specified elsewhere. An API may choose to allow leap seconds. Related types are google.type.Date and `google.protobuf.Timestamp`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public TimeOfDay StartTime { get; set; }
	}
	
	/// <summary>
	/// Represents a time of day. The date and time zone are either not significant or are specified elsewhere. An API may choose to allow leap seconds. Related types are google.type.Date and `google.protobuf.Timestamp`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TimeOfDay
	{
		
		/// <summary>
		/// Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hours")]
		public System.Nullable<System.Int32> Hours { get; set; }
		
		/// <summary>
		/// Minutes of hour of day. Must be from 0 to 59.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minutes")]
		public System.Nullable<System.Int32> Minutes { get; set; }
		
		/// <summary>
		/// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nanos")]
		public System.Nullable<System.Int32> Nanos { get; set; }
		
		/// <summary>
		/// Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seconds")]
		public System.Nullable<System.Int32> Seconds { get; set; }
	}
	
	/// <summary>
	/// Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values. * A month and day, with a zero year (for example, an anniversary). * A year on its own, with a zero month and a zero day. * A year and month, with a zero day (for example, a credit card expiration date). Related types: * google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Date
	{
		
		/// <summary>
		/// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="day")]
		public System.Nullable<System.Int32> Day { get; set; }
		
		/// <summary>
		/// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="month")]
		public System.Nullable<System.Int32> Month { get; set; }
		
		/// <summary>
		/// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="year")]
		public System.Nullable<System.Int32> Year { get; set; }
	}
	
	/// <summary>
	/// DenyMaintenancePeriod definition. Maintenance is forbidden within the deny period. The start_date must be less than the end_date.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DenyMaintenancePeriod
	{
		
		/// <summary>
		/// Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values. * A month and day, with a zero year (for example, an anniversary). * A year on its own, with a zero month and a zero day. * A year and month, with a zero day (for example, a credit card expiration date). Related types: * google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endDate")]
		public Date EndDate { get; set; }
		
		/// <summary>
		/// Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values. * A month and day, with a zero year (for example, an anniversary). * A year on its own, with a zero month and a zero day. * A year and month, with a zero day (for example, a credit card expiration date). Related types: * google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startDate")]
		public Date StartDate { get; set; }
		
		/// <summary>
		/// Represents a time of day. The date and time zone are either not significant or are specified elsewhere. An API may choose to allow leap seconds. Related types are google.type.Date and `google.protobuf.Timestamp`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public TimeOfDay Time { get; set; }
	}
	
	/// <summary>
	/// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Empty
	{
	}
	
	/// <summary>
	/// Regional encryption config for CMEK details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EncryptionConfig
	{
		
		/// <summary>
		/// Optional. Encryption type for the region.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptionType")]
		public System.Nullable<EncryptionConfigEncryptionType> EncryptionType { get; set; }
		
		/// <summary>
		/// Optional. KMS crypto key. This field accepts identifiers of the form `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/ {crypto_key}`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kmsKeyName")]
		public string KmsKeyName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EncryptionConfigEncryptionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENCRYPTION_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GMEK = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CMEK = 2,
	}
	
	/// <summary>
	/// Endpoint message includes details of the Destination endpoint.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EndPoint
	{
		
		/// <summary>
		/// The URI of the Endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endpointUri")]
		public string EndpointUri { get; set; }
		
		/// <summary>
		/// List of Header to be added to the Endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Header[] Headers { get; set; }
	}
	
	/// <summary>
	/// Header details for a given header to be added to Endpoint.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Header
	{
		
		/// <summary>
		/// Key of Header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Value of Header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// represents the Connector's Endpoint Attachment resource
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EndpointAttachment
	{
		
		/// <summary>
		/// Output only. Created time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Optional. Description of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Output only. The Private Service Connect connection endpoint ip
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endpointIp")]
		public string EndpointIp { get; set; }
		
		/// <summary>
		/// Optional. Resource labels to represent user-provided metadata. Refer to cloud documentation on labels for more details. https://cloud.google.com/compute/docs/labeling-resources
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Output only. Resource name of the Endpoint Attachment. Format: projects/{project}/locations/{location}/endpointAttachments/{endpoint_attachment}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required. The path of the service attachment
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceAttachment")]
		public string ServiceAttachment { get; set; }
		
		/// <summary>
		/// Output only. Updated time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// represents the Connector's EventSubscription resource
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventSubscription
	{
		
		/// <summary>
		/// Output only. Created time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Message for EventSubscription Destination to act on receiving an event
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinations")]
		public EventSubscriptionDestination Destinations { get; set; }
		
		/// <summary>
		/// Optional. Event type id of the event of current EventSubscription.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventTypeId")]
		public string EventTypeId { get; set; }
		
		/// <summary>
		/// JMS message denotes the source of the event
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jms")]
		public JMS Jms { get; set; }
		
		/// <summary>
		/// Required. Resource name of the EventSubscription. Format: projects/{project}/locations/{location}/connections/{connection}/eventSubscriptions/{event_subscription}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// EventSubscription Status denotes the status of the EventSubscription resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public EventSubscriptionStatus Status { get; set; }
		
		/// <summary>
		/// Optional. name of the Subscriber for the current EventSubscription.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscriber")]
		public string Subscriber { get; set; }
		
		/// <summary>
		/// Optional. Link for Subscriber of the current EventSubscription.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscriberLink")]
		public string SubscriberLink { get; set; }
		
		/// <summary>
		/// Output only. Updated time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// Message for EventSubscription Destination to act on receiving an event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventSubscriptionDestination
	{
		
		/// <summary>
		/// Endpoint message includes details of the Destination endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endpoint")]
		public EndPoint Endpoint { get; set; }
		
		/// <summary>
		/// Service account needed for runtime plane to trigger IP workflow.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceAccount")]
		public string ServiceAccount { get; set; }
		
		/// <summary>
		/// type of the destination
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<EventSubscriptionDestinationType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EventSubscriptionDestinationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENDPOINT = 1,
	}
	
	/// <summary>
	/// JMS message denotes the source of the event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JMS
	{
		
		/// <summary>
		/// Optional. Name of the JMS source. i.e. queueName or topicName
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Optional. Type of the JMS Source. i.e. Queue or Topic
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<JMSType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum JMSType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		QUEUE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TOPIC = 2,
	}
	
	/// <summary>
	/// EventSubscription Status denotes the status of the EventSubscription resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventSubscriptionStatus
	{
		
		/// <summary>
		/// Output only. Description of the state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Output only. State of Event Subscription resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<EventSubscriptionStatusState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EventSubscriptionStatusState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUSPENDED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 5,
	}
	
	/// <summary>
	/// EventType includes fields.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventType
	{
		
		/// <summary>
		/// Output only. Created time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Output only. Schema of the event payload after enriched. Will be null if read before send is not supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enrichedEventPayloadSchema")]
		public string EnrichedEventPayloadSchema { get; set; }
		
		/// <summary>
		/// Output only. Runtime entity type name. Will be null if entity type map is not available. Used for read before send feature.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entityType")]
		public string EntityType { get; set; }
		
		/// <summary>
		/// Output only. Schema of webhook event payload.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventPayloadSchema")]
		public string EventPayloadSchema { get; set; }
		
		/// <summary>
		/// Output only. Event type id. Example: `ticket.created`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventTypeId")]
		public string EventTypeId { get; set; }
		
		/// <summary>
		/// Output only. Id path denotes the path of id in webhook payload.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="idPath")]
		public string IdPath { get; set; }
		
		/// <summary>
		/// Output only. Resource name of the eventtype. Format: projects/{project}/locations/{location}/providers/{provider}/connectors/{connector}/versions/{version}/eventtypes/{eventtype} Only global location is supported for Connector resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. Updated time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// Metadata of an entity field.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Field
	{
		
		/// <summary>
		/// The following map contains fields that are not explicitly mentioned above,this give connectors the flexibility to add new metadata fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalDetails")]
		public System.Collections.Generic.Dictionary<string, object> AdditionalDetails { get; set; }
		
		/// <summary>
		/// The data type of the Field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataType")]
		public System.Nullable<FieldDataType> DataType { get; set; }
		
		/// <summary>
		/// The following field specifies the default value of the Field provided by the external system if a value is not provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultValue")]
		public object DefaultValue { get; set; }
		
		/// <summary>
		/// A brief description of the Field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Name of the Field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="field")]
		public string Field1 { get; set; }
		
		/// <summary>
		/// JsonSchema representation of schema metadata
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jsonSchema")]
		public JsonSchema JsonSchema { get; set; }
		
		/// <summary>
		/// The following boolean field specifies if the current Field acts as a primary key or id if the parent is of type entity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public System.Nullable<System.Boolean> Key { get; set; }
		
		/// <summary>
		/// Specifies whether a null value is allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nullable")]
		public System.Nullable<System.Boolean> Nullable { get; set; }
		
		/// <summary>
		/// Specifies if the Field is readonly.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="readonly")]
		public System.Nullable<System.Boolean> Readonly { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FieldDataType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_INT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_SMALLINT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_DOUBLE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_DATE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_DATETIME = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_TIME = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_STRING = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_LONG = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_BOOLEAN = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_DECIMAL = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_UUID = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_BLOB = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_BIT = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_TINYINT = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_INTEGER = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_BIGINT = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_FLOAT = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_REAL = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_NUMERIC = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_CHAR = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_VARCHAR = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_LONGVARCHAR = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_TIMESTAMP = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_NCHAR = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_NVARCHAR = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_LONGNVARCHAR = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_NULL = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_OTHER = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_JAVA_OBJECT = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_DISTINCT = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_STRUCT = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_ARRAY = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_CLOB = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_REF = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_DATALINK = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_ROWID = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_BINARY = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_VARBINARY = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_LONGVARBINARY = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_NCLOB = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_SQLXML = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_REF_CURSOR = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_TIME_WITH_TIMEZONE = 43,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_TYPE_TIMESTAMP_WITH_TIMEZONE = 44,
	}
	
	/// <summary>
	/// JsonSchema representation of schema metadata
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JsonSchema
	{
		
		/// <summary>
		/// A description of this schema.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Possible values for an enumeration. This works in conjunction with `type` to represent types with a fixed set of legal values
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enum")]
		public string[] Enum { get; set; }
		
		/// <summary>
		/// Format of the value as per https://json-schema.org/understanding-json-schema/reference/string.html#format
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
		
		/// <summary>
		/// JsonSchema representation of schema metadata
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public JsonSchema Items { get; set; }
		
		/// <summary>
		/// JDBC datatype of the field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jdbcType")]
		public FieldDataType JdbcType { get; set; }
		
		/// <summary>
		/// The child schemas, applicable only if this is of type `object`. The key is the name of the property and the value is the json schema that describes that property
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public System.Collections.Generic.Dictionary<string, JsonSchema> Properties { get; set; }
		
		/// <summary>
		/// Whether this property is required.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="required")]
		public string[] Required { get; set; }
		
		/// <summary>
		/// JSON Schema Validation: A Vocabulary for Structural Validation of JSON
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string[] Type { get; set; }
	}
	
	/// <summary>
	/// Metadata of an input parameter.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InputParameter
	{
		
		/// <summary>
		/// The data type of the Parameter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataType")]
		public FieldDataType DataType { get; set; }
		
		/// <summary>
		/// The following field specifies the default value of the Parameter provided by the external system if a value is not provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultValue")]
		public object DefaultValue { get; set; }
		
		/// <summary>
		/// A brief description of the Parameter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// JsonSchema representation of schema metadata
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jsonSchema")]
		public JsonSchema JsonSchema { get; set; }
		
		/// <summary>
		/// Specifies whether a null value is allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nullable")]
		public System.Nullable<System.Boolean> Nullable { get; set; }
		
		/// <summary>
		/// Name of the Parameter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parameter")]
		public string Parameter { get; set; }
	}
	
	/// <summary>
	/// Instance represents the interface for SLM services to actuate the state of control plane resources. Example Instance in JSON, where consumer-project-number=123456, producer-project-id=cloud-sql: ```json Instance: { "name": "projects/123456/locations/us-east1/instances/prod-instance", "create_time": { "seconds": 1526406431, }, "labels": { "env": "prod", "foo": "bar" }, "state": READY, "software_versions": { "software_update": "cloud-sql-09-28-2018", }, "maintenance_policy_names": { "UpdatePolicy": "projects/123456/locations/us-east1/maintenancePolicies/prod-update-policy", } "tenant_project_id": "cloud-sql-test-tenant", "producer_metadata": { "cloud-sql-tier": "basic", "cloud-sql-instance-size": "1G", }, "provisioned_resources": [ { "resource-type": "compute-instance", "resource-url": "https://www.googleapis.com/compute/v1/projects/cloud-sql/zones/us-east1-b/instances/vm-1", } ], "maintenance_schedules": { "csa_rollout": { "start_time": { "seconds": 1526406431, }, "end_time": { "seconds": 1535406431, }, }, "ncsa_rollout": { "start_time": { "seconds": 1526406431, }, "end_time": { "seconds": 1535406431, }, } }, "consumer_defined_name": "my-sql-instance1", } ``` LINT.IfChange
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Instance
	{
		
		/// <summary>
		/// consumer_defined_name is the name of the instance set by the service consumers. Generally this is different from the `name` field which reperesents the system-assigned id of the instance which the service consumers do not recognize. This is a required field for tenants onboarding to Maintenance Window notifications (go/slm-rollout-maintenance-policies#prerequisites).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="consumerDefinedName")]
		public string ConsumerDefinedName { get; set; }
		
		/// <summary>
		/// Output only. Timestamp when the resource was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Optional. The instance_type of this instance of format: projects/{project_number}/locations/{location_id}/instanceTypes/{instance_type_id}. Instance Type represents a high-level tier or SKU of the service that this instance belong to. When enabled(eg: Maintenance Rollout), Rollout uses 'instance_type' along with 'software_versions' to determine whether instance needs an update or not.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceType")]
		public string InstanceType { get; set; }
		
		/// <summary>
		/// Optional. Resource labels to represent user provided metadata. Each label is a key-value pair, where both the key and the value are arbitrary strings provided by the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Optional. The MaintenancePolicies that have been attached to the instance. The key must be of the type name of the oneof policy name defined in MaintenancePolicy, and the referenced policy must define the same policy type. For details, please refer to go/mr-user-guide. Should not be set if maintenance_settings.maintenance_policies is set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maintenancePolicyNames")]
		public System.Collections.Generic.Dictionary<string, string> MaintenancePolicyNames { get; set; }
		
		/// <summary>
		/// The MaintenanceSchedule contains the scheduling information of published maintenance schedule with same key as software_versions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maintenanceSchedules")]
		public System.Collections.Generic.Dictionary<string, MaintenanceSchedule> MaintenanceSchedules { get; set; }
		
		/// <summary>
		/// Maintenance settings associated with instance. Allows service producers and end users to assign settings that controls maintenance on this instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maintenanceSettings")]
		public MaintenanceSettings MaintenanceSettings { get; set; }
		
		/// <summary>
		/// Unique name of the resource. It uses the form: `projects/{project_number}/locations/{location_id}/instances/{instance_id}` Note: This name is passed, stored and logged across the rollout system. So use of consumer project_id or any other consumer PII in the name is strongly discouraged for wipeout (go/wipeout) compliance. See go/elysium/project_ids#storage-guidance for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Optional. notification_parameter are information that service producers may like to include that is not relevant to Rollout. This parameter will only be passed to Gamma and Cloud Logging for notification/logging purpose.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notificationParameters")]
		public System.Collections.Generic.Dictionary<string, NotificationParameter> NotificationParameters { get; set; }
		
		/// <summary>
		/// Output only. Custom string attributes used primarily to expose producer-specific information in monitoring dashboards. See go/get-instance-metadata.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="producerMetadata")]
		public System.Collections.Generic.Dictionary<string, string> ProducerMetadata { get; set; }
		
		/// <summary>
		/// Output only. The list of data plane resources provisioned for this instance, e.g. compute VMs. See go/get-instance-metadata.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisionedResources")]
		public ProvisionedResource[] ProvisionedResources { get; set; }
		
		/// <summary>
		/// Link to the SLM instance template. Only populated when updating SLM instances via SSA's Actuation service adaptor. Service producers with custom control plane (e.g. Cloud SQL) doesn't need to populate this field. Instead they should use software_versions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slmInstanceTemplate")]
		public string SlmInstanceTemplate { get; set; }
		
		/// <summary>
		/// SloMetadata contains resources required for proper SLO classification of the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sloMetadata")]
		public SloMetadata SloMetadata { get; set; }
		
		/// <summary>
		/// Software versions that are used to deploy this instance. This can be mutated by rollout services.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="softwareVersions")]
		public System.Collections.Generic.Dictionary<string, string> SoftwareVersions { get; set; }
		
		/// <summary>
		/// Output only. Current lifecycle state of the resource (e.g. if it's being created or ready to use).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<InstanceState> State { get; set; }
		
		/// <summary>
		/// Output only. ID of the associated GCP tenant project. See go/get-instance-metadata.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tenantProjectId")]
		public string TenantProjectId { get; set; }
		
		/// <summary>
		/// Output only. Timestamp when the resource was last modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// Maintenance schedule which is exposed to customer and potentially end user, indicating published upcoming future maintenance schedule
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MaintenanceSchedule
	{
		
		/// <summary>
		/// This field is deprecated, and will be always set to true since reschedule can happen multiple times now. This field should not be removed until all service producers remove this for their customers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canReschedule")]
		public System.Nullable<System.Boolean> CanReschedule { get; set; }
		
		/// <summary>
		/// The scheduled end time for the maintenance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// The rollout management policy this maintenance schedule is associated with. When doing reschedule update request, the reschedule should be against this given policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rolloutManagementPolicy")]
		public string RolloutManagementPolicy { get; set; }
		
		/// <summary>
		/// schedule_deadline_time is the time deadline any schedule start time cannot go beyond, including reschedule. It's normally the initial schedule start time plus maintenance window length (1 day or 1 week). Maintenance cannot be scheduled to start beyond this deadline.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleDeadlineTime")]
		public string ScheduleDeadlineTime { get; set; }
		
		/// <summary>
		/// The scheduled start time for the maintenance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
	}
	
	/// <summary>
	/// Maintenance settings associated with instance. Allows service producers and end users to assign settings that controls maintenance on this instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MaintenanceSettings
	{
		
		/// <summary>
		/// Optional. Exclude instance from maintenance. When true, rollout service will not attempt maintenance on the instance. Rollout service will include the instance in reported rollout progress as not attempted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclude")]
		public System.Nullable<System.Boolean> Exclude { get; set; }
		
		/// <summary>
		/// Optional. If the update call is triggered from rollback, set the value as true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isRollback")]
		public System.Nullable<System.Boolean> IsRollback { get; set; }
		
		/// <summary>
		/// Optional. The MaintenancePolicies that have been attached to the instance. The key must be of the type name of the oneof policy name defined in MaintenancePolicy, and the embedded policy must define the same policy type. For details, please refer to go/mr-user-guide. Should not be set if maintenance_policy_names is set. If only the name is needed, then only populate MaintenancePolicy.name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maintenancePolicies")]
		public System.Collections.Generic.Dictionary<string, MaintenancePolicy> MaintenancePolicies { get; set; }
	}
	
	/// <summary>
	/// LINT.IfChange Defines policies to service maintenance events.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MaintenancePolicy
	{
		
		/// <summary>
		/// Output only. The time when the resource was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Optional. Description of what this policy is for. Create/Update methods return INVALID_ARGUMENT if the length is greater than 512.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Optional. Resource labels to represent user provided metadata. Each label is a key-value pair, where both the key and the value are arbitrary strings provided by the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Required. MaintenancePolicy name using the form: `projects/{project_id}/locations/{location_id}/maintenancePolicies/{maintenance_policy_id}` where {project_id} refers to a GCP consumer project ID, {location_id} refers to a GCP region/zone, {maintenance_policy_id} must be 1-63 characters long and match the regular expression `[a-z0-9]([-a-z0-9]*[a-z0-9])?`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Optional. The state of the policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<MaintenancePolicyState> State { get; set; }
		
		/// <summary>
		/// Maintenance policy applicable to instance updates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updatePolicy")]
		public UpdatePolicy UpdatePolicy { get; set; }
		
		/// <summary>
		/// Output only. The time when the resource was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MaintenancePolicyState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 2,
	}
	
	/// <summary>
	/// Maintenance policy applicable to instance updates.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdatePolicy
	{
		
		/// <summary>
		/// Optional. Relative scheduling channel applied to resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="channel")]
		public System.Nullable<UpdatePolicyChannel> Channel { get; set; }
		
		/// <summary>
		/// Deny Maintenance Period that is applied to resource to indicate when maintenance is forbidden. The protocol supports zero-to-many such periods, but the current SLM Rollout implementation only supports zero-to-one.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="denyMaintenancePeriods")]
		public DenyMaintenancePeriod[] DenyMaintenancePeriods { get; set; }
		
		/// <summary>
		/// MaintenanceWindow definition.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="window")]
		public MaintenanceWindow Window { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum UpdatePolicyChannel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATE_CHANNEL_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EARLIER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LATER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEEK1 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEEK2 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEEK5 = 5,
	}
	
	/// <summary>
	/// MaintenanceWindow definition.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MaintenanceWindow
	{
		
		/// <summary>
		/// Time window specified for daily operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dailyCycle")]
		public DailyCycle DailyCycle { get; set; }
		
		/// <summary>
		/// Time window specified for weekly operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="weeklyCycle")]
		public WeeklyCycle WeeklyCycle { get; set; }
	}
	
	/// <summary>
	/// Time window specified for weekly operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class WeeklyCycle
	{
		
		/// <summary>
		/// User can specify multiple windows in a week. Minimum of 1 window.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public Schedule[] Schedule { get; set; }
	}
	
	/// <summary>
	/// Configure the schedule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Schedule
	{
		
		/// <summary>
		/// Allows to define schedule that runs specified day of the week.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="day")]
		public System.Nullable<ScheduleDay> Day { get; set; }
		
		/// <summary>
		/// Output only. Duration of the time window, set by service producer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public string Duration { get; set; }
		
		/// <summary>
		/// Represents a time of day. The date and time zone are either not significant or are specified elsewhere. An API may choose to allow leap seconds. Related types are google.type.Date and `google.protobuf.Timestamp`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public TimeOfDay StartTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ScheduleDay
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DAY_OF_WEEK_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MONDAY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TUESDAY = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEDNESDAY = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		THURSDAY = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FRIDAY = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SATURDAY = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUNDAY = 7,
	}
	
	/// <summary>
	/// Contains notification related data.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotificationParameter
	{
		
		/// <summary>
		/// Optional. Array of string values. e.g. instance's replica information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="values")]
		public string[] Values { get; set; }
	}
	
	/// <summary>
	/// Describes provisioned dataplane resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProvisionedResource
	{
		
		/// <summary>
		/// Type of the resource. This can be either a GCP resource or a custom one (e.g. another cloud provider's VM). For GCP compute resources use singular form of the names listed in GCP compute API documentation (https://cloud.google.com/compute/docs/reference/rest/v1/), prefixed with 'compute-', for example: 'compute-instance', 'compute-disk', 'compute-autoscaler'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceType")]
		public string ResourceType { get; set; }
		
		/// <summary>
		/// URL identifying the resource, e.g. "https://www.googleapis.com/compute/v1/projects/...)".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceUrl")]
		public string ResourceUrl { get; set; }
	}
	
	/// <summary>
	/// SloMetadata contains resources required for proper SLO classification of the instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SloMetadata
	{
		
		/// <summary>
		/// Optional. List of nodes. Some producers need to use per-node metadata to calculate SLO. This field allows such producers to publish per-node SLO meta data, which will be consumed by SSA Eligibility Exporter and published in the form of per node metric to Monarch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodes")]
		public NodeSloMetadata[] Nodes { get; set; }
		
		/// <summary>
		/// PerSliSloEligibility is a mapping from an SLI name to eligibility.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perSliEligibility")]
		public PerSliSloEligibility PerSliEligibility { get; set; }
		
		/// <summary>
		/// Name of the SLO tier the Instance belongs to. This name will be expected to match the tiers specified in the service SLO configuration. Field is mandatory and must not be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tier")]
		public string Tier { get; set; }
	}
	
	/// <summary>
	/// Node information for custom per-node SLO implementations. SSA does not support per-node SLO, but producers can populate per-node information in SloMetadata for custom precomputations. SSA Eligibility Exporter will emit per-node metric based on this information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeSloMetadata
	{
		
		/// <summary>
		/// The location of the node, if different from instance location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// The id of the node. This should be equal to SaasInstanceNode.node_id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeId")]
		public string NodeId { get; set; }
		
		/// <summary>
		/// PerSliSloEligibility is a mapping from an SLI name to eligibility.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perSliEligibility")]
		public PerSliSloEligibility PerSliEligibility { get; set; }
	}
	
	/// <summary>
	/// PerSliSloEligibility is a mapping from an SLI name to eligibility.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PerSliSloEligibility
	{
		
		/// <summary>
		/// An entry in the eligibilities map specifies an eligibility for a particular SLI for the given instance. The SLI key in the name must be a valid SLI name specified in the Eligibility Exporter binary flags otherwise an error will be emitted by Eligibility Exporter and the oncaller will be alerted. If an SLI has been defined in the binary flags but the eligibilities map does not contain it, the corresponding SLI time series will not be emitted by the Eligibility Exporter. This ensures a smooth rollout and compatibility between the data produced by different versions of the Eligibility Exporters. If eligibilities map contains a key for an SLI which has not been declared in the binary flags, there will be an error message emitted in the Eligibility Exporter log and the metric for the SLI in question will not be emitted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eligibilities")]
		public System.Collections.Generic.Dictionary<string, SloEligibility> Eligibilities { get; set; }
	}
	
	/// <summary>
	/// SloEligibility is a tuple containing eligibility value: true if an instance is eligible for SLO calculation or false if it should be excluded from all SLO-related calculations along with a user-defined reason.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SloEligibility
	{
		
		/// <summary>
		/// Whether an instance is eligible or ineligible.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eligible")]
		public System.Nullable<System.Boolean> Eligible { get; set; }
		
		/// <summary>
		/// User-defined reason for the current value of instance eligibility. Usually, this can be directly mapped to the internal state. An empty reason is allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InstanceState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READY = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REPAIRING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 6,
	}
	
	/// <summary>
	/// Response message for ListActions API
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListActionsResponse
	{
		
		/// <summary>
		/// list of actions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actions")]
		public RuntimeActionSchema[] Actions { get; set; }
		
		/// <summary>
		/// token for next page
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// Schema of a runtime action.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RuntimeActionSchema
	{
		
		/// <summary>
		/// Output only. Name of the action.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="action")]
		public string Action { get; set; }
		
		/// <summary>
		/// Output only. Brief Description of action
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Output only. Display Name of action to be shown on client side
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// JsonSchema representation of schema metadata
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inputJsonSchema")]
		public JsonSchema InputJsonSchema { get; set; }
		
		/// <summary>
		/// Output only. List of input parameter metadata for the action.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inputParameters")]
		public InputParameter[] InputParameters { get; set; }
		
		/// <summary>
		/// JsonSchema representation of schema metadata
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resultJsonSchema")]
		public JsonSchema ResultJsonSchema { get; set; }
		
		/// <summary>
		/// Output only. List of result field metadata.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resultMetadata")]
		public ResultMetadata[] ResultMetadata { get; set; }
	}
	
	/// <summary>
	/// Metadata of result field.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResultMetadata
	{
		
		/// <summary>
		/// The data type of the field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataType")]
		public FieldDataType DataType { get; set; }
		
		/// <summary>
		/// A brief description of the field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Name of the result field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="field")]
		public string Field { get; set; }
		
		/// <summary>
		/// JsonSchema representation of schema metadata
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jsonSchema")]
		public JsonSchema JsonSchema { get; set; }
	}
	
	/// <summary>
	/// Response message for ConnectorsService.ListConnections
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListConnectionsResponse
	{
		
		/// <summary>
		/// Connections.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connections")]
		public Connection[] Connections { get; set; }
		
		/// <summary>
		/// Next page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// Response message for Connectors.ListConnectorVersions.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListConnectorVersionsResponse
	{
		
		/// <summary>
		/// A list of connector versions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectorVersions")]
		public ConnectorVersion[] ConnectorVersions { get; set; }
		
		/// <summary>
		/// Next page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// Response message for Connectors.ListConnectors.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListConnectorsResponse
	{
		
		/// <summary>
		/// A list of connectors.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectors")]
		public Connector[] Connectors { get; set; }
		
		/// <summary>
		/// Next page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// Response message for Connectors.ListCustomConnectorVersions.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListCustomConnectorVersionsResponse
	{
		
		/// <summary>
		/// A list of connector versions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customConnectorVersions")]
		public CustomConnectorVersion[] CustomConnectorVersions { get; set; }
		
		/// <summary>
		/// Next page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// Response message for Connectors.ListCustomConnectors.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListCustomConnectorsResponse
	{
		
		/// <summary>
		/// A list of customConnectors.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customConnectors")]
		public CustomConnector[] CustomConnectors { get; set; }
		
		/// <summary>
		/// Next page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// Response message for ConnectorsService.ListEndpointAttachments
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListEndpointAttachmentsResponse
	{
		
		/// <summary>
		/// EndpointAttachments.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endpointAttachments")]
		public EndpointAttachment[] EndpointAttachments { get; set; }
		
		/// <summary>
		/// Next page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// Response message for ListEntityTypes API
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListEntityTypesResponse
	{
		
		/// <summary>
		/// list of entity types
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entityTypes")]
		public RuntimeEntitySchema[] EntityTypes { get; set; }
		
		/// <summary>
		/// token for next page
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// Schema of a runtime entity.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RuntimeEntitySchema
	{
		
		/// <summary>
		/// Output only. Name of the entity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entity")]
		public string Entity { get; set; }
		
		/// <summary>
		/// Output only. List of fields in the entity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fields")]
		public Field[] Fields { get; set; }
		
		/// <summary>
		/// JsonSchema representation of schema metadata
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jsonSchema")]
		public JsonSchema JsonSchema { get; set; }
	}
	
	/// <summary>
	/// Response message for ConnectorsService.ListEventSubscriptions
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListEventSubscriptionsResponse
	{
		
		/// <summary>
		/// Subscriptions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventSubscriptions")]
		public EventSubscription[] EventSubscriptions { get; set; }
		
		/// <summary>
		/// Next page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// Response message for Connectors.ListEventTypes.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListEventTypesResponse
	{
		
		/// <summary>
		/// A list of connector versions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventTypes")]
		public EventType[] EventTypes { get; set; }
		
		/// <summary>
		/// Next page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// The response message for Locations.ListLocations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListLocationsResponse
	{
		
		/// <summary>
		/// A list of locations that matches the specified filter in the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locations")]
		public Location[] Locations { get; set; }
		
		/// <summary>
		/// The standard List next-page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// A resource that represents a Google Cloud location.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Location
	{
		
		/// <summary>
		/// The friendly name for this location, typically a nearby city name. For example, "Tokyo".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Cross-service attributes for the location. For example {"cloud.googleapis.com/region": "us-east1"}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// The canonical id for this location. For example: `"us-east1"`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationId")]
		public string LocationId { get; set; }
		
		/// <summary>
		/// Service-specific metadata. For example the available capacity at the given location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, object> Metadata { get; set; }
		
		/// <summary>
		/// Resource name for the location, which may vary between implementations. For example: `"projects/example-project/locations/us-east1"`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Response message for ConnectorsService.ListManagedZones
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListManagedZonesResponse
	{
		
		/// <summary>
		/// ManagedZones.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managedZones")]
		public ManagedZone[] ManagedZones { get; set; }
		
		/// <summary>
		/// Next page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// represents the Connector's Managed Zone resource
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ManagedZone
	{
		
		/// <summary>
		/// Output only. Created time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Optional. Description of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required. DNS Name of the resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dns")]
		public string Dns { get; set; }
		
		/// <summary>
		/// Optional. Resource labels to represent user-provided metadata. Refer to cloud documentation on labels for more details. https://cloud.google.com/compute/docs/labeling-resources
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Output only. Resource name of the Managed Zone. Format: projects/{project}/locations/global/managedZones/{managed_zone}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required. The name of the Target Project
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetProject")]
		public string TargetProject { get; set; }
		
		/// <summary>
		/// Required. The name of the Target Project VPC Network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetVpc")]
		public string TargetVpc { get; set; }
		
		/// <summary>
		/// Output only. Updated time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// The response message for Operations.ListOperations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListOperationsResponse
	{
		
		/// <summary>
		/// The standard List next-page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// A list of operations that matches the specified filter in the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operations")]
		public Operation[] Operations { get; set; }
	}
	
	/// <summary>
	/// This resource represents a long-running operation that is the result of a network API call.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Operation
	{
		
		/// <summary>
		/// If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="done")]
		public System.Nullable<System.Boolean> Done { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Status Error { get; set; }
		
		/// <summary>
		/// Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, object> Metadata { get; set; }
		
		/// <summary>
		/// The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public System.Collections.Generic.Dictionary<string, object> Response { get; set; }
	}
	
	/// <summary>
	/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Status
	{
		
		/// <summary>
		/// The status code, which should be an enum value of google.rpc.Code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// A list of messages that carry the error details. There is a common set of message types for APIs to use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string[] Details { get; set; }
		
		/// <summary>
		/// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// Response message for Connectors.ListProviders.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListProvidersResponse
	{
		
		/// <summary>
		/// Next page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// A list of providers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="providers")]
		public Provider[] Providers { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// Provider indicates the owner who provides the connectors.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Provider
	{
		
		/// <summary>
		/// Output only. Created time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Output only. Description of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Output only. Display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Output only. Link to documentation page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="documentationUri")]
		public string DocumentationUri { get; set; }
		
		/// <summary>
		/// Output only. Link to external page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="externalUri")]
		public string ExternalUri { get; set; }
		
		/// <summary>
		/// Output only. Resource labels to represent user-provided metadata. Refer to cloud documentation on labels for more details. https://cloud.google.com/compute/docs/labeling-resources
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Output only. Flag to mark the version indicating the launch stage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="launchStage")]
		public ConnectionConnectorVersionLaunchStage LaunchStage { get; set; }
		
		/// <summary>
		/// Output only. Resource name of the Provider. Format: projects/{project}/locations/{location}/providers/{provider} Only global location is supported for Provider resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. Updated time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
		
		/// <summary>
		/// Output only. Cloud storage location of icons etc consumed by UI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="webAssetsLocation")]
		public string WebAssetsLocation { get; set; }
	}
	
	/// <summary>
	/// Response message for ConnectorsService.ListRuntimeActionSchemas.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListRuntimeActionSchemasResponse
	{
		
		/// <summary>
		/// Next page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Runtime action schemas.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runtimeActionSchemas")]
		public RuntimeActionSchema[] RuntimeActionSchemas { get; set; }
	}
	
	/// <summary>
	/// Response message for ConnectorsService.ListRuntimeEntitySchemas.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListRuntimeEntitySchemasResponse
	{
		
		/// <summary>
		/// Next page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Runtime entity schemas.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runtimeEntitySchemas")]
		public RuntimeEntitySchema[] RuntimeEntitySchemas { get; set; }
	}
	
	/// <summary>
	/// Expected request for ListenEvent API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListenEventRequest
	{
		
		/// <summary>
		/// Optional. Request payload.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payload")]
		public System.Collections.Generic.Dictionary<string, object> Payload { get; set; }
	}
	
	/// <summary>
	/// Expected response for ListenEvent API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListenEventResponse
	{
	}
	
	/// <summary>
	/// Regional Network Config.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkConfig
	{
		
		/// <summary>
		/// Output only. Egress IPs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="egressIps")]
		public string[] EgressIps { get; set; }
		
		/// <summary>
		/// Optional. Egress mode for the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="egressMode")]
		public System.Nullable<NetworkConfigEgressMode> EgressMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NetworkConfigEgressMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NETWORK_EGRESS_MODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTO_IP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATIC_IP = 2,
	}
	
	/// <summary>
	/// Represents the metadata of the long-running operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OperationMetadata
	{
		
		/// <summary>
		/// Output only. API version used to start the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiVersion")]
		public string ApiVersion { get; set; }
		
		/// <summary>
		/// Output only. The time the operation was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Output only. The time the operation finished running.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// Output only. Identifies whether the user has requested cancellation of the operation. Operations that have successfully been cancelled have Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestedCancellation")]
		public System.Nullable<System.Boolean> RequestedCancellation { get; set; }
		
		/// <summary>
		/// Output only. Human-readable status of the operation, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusMessage")]
		public string StatusMessage { get; set; }
		
		/// <summary>
		/// Output only. Server-defined resource path for the target of the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
		
		/// <summary>
		/// Output only. Name of the verb executed by the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="verb")]
		public string Verb { get; set; }
	}
	
	/// <summary>
	/// An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members`, or principals, to a single `role`. Principals can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** ``` { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } ``` **YAML example:** ``` bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA= version: 3 ``` For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Policy
	{
		
		/// <summary>
		/// Specifies cloud audit logging configuration for this policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="auditConfigs")]
		public AuditConfig[] AuditConfigs { get; set; }
		
		/// <summary>
		/// Associates a list of `members`, or principals, with a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one principal. The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of these principals can be Google groups. Each occurrence of a principal counts towards these limits. For example, if the `bindings` grant 50 different roles to `user:alice@example.com`, and not to any other principal, then you can add another 1,450 principals to the `bindings` in the `Policy`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bindings")]
		public Binding[] Bindings { get; set; }
		
		/// <summary>
		/// `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public System.Nullable<System.Int32> Version { get; set; }
	}
	
	/// <summary>
	/// Request message for ConnectorsService.RefreshConnectionSchemaMetadata.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RefreshConnectionSchemaMetadataRequest
	{
	}
	
	/// <summary>
	/// Regional Settings details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionalSettings
	{
		
		/// <summary>
		/// Regional encryption config for CMEK details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptionConfig")]
		public EncryptionConfig EncryptionConfig { get; set; }
		
		/// <summary>
		/// Output only. Resource name of the Connection. Format: projects/{project}/locations/{location}/regionalSettings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Regional Network Config.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkConfig")]
		public NetworkConfig NetworkConfig { get; set; }
	}
	
	/// <summary>
	/// Request message for ConnectorsService.RepairEventing
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RepairEventingRequest
	{
	}
	
	/// <summary>
	/// Request message for ConnectorsService.RefreshEventSubscription
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RetryEventSubscriptionRequest
	{
	}
	
	/// <summary>
	/// RuntimeConfig is the singleton resource of each location. It includes generic resource configs consumed by control plane and runtime plane like: pub/sub topic/subscription resource name, Cloud Storage location storing schema etc.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RuntimeConfig
	{
		
		/// <summary>
		/// Output only. Pub/Sub subscription for connd to receive message. E.g. projects/{project-id}/subscriptions/{topic-id}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="conndSubscription")]
		public string ConndSubscription { get; set; }
		
		/// <summary>
		/// Output only. Pub/Sub topic for connd to send message. E.g. projects/{project-id}/topics/{topic-id}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="conndTopic")]
		public string ConndTopic { get; set; }
		
		/// <summary>
		/// Output only. Pub/Sub subscription for control plane to receive message. E.g. projects/{project-id}/subscriptions/{topic-id}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="controlPlaneSubscription")]
		public string ControlPlaneSubscription { get; set; }
		
		/// <summary>
		/// Output only. Pub/Sub topic for control plne to send message. communication. E.g. projects/{project-id}/topics/{topic-id}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="controlPlaneTopic")]
		public string ControlPlaneTopic { get; set; }
		
		/// <summary>
		/// Output only. location_id of the runtime location. E.g. "us-west1".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationId")]
		public string LocationId { get; set; }
		
		/// <summary>
		/// Output only. Name of the runtimeConfig resource. Format: projects/{project}/locations/{location}/runtimeConfig
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. The endpoint of the connectors runtime ingress.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runtimeEndpoint")]
		public string RuntimeEndpoint { get; set; }
		
		/// <summary>
		/// Output only. The Cloud Storage bucket that stores connector's schema reports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schemaGcsBucket")]
		public string SchemaGcsBucket { get; set; }
		
		/// <summary>
		/// Output only. The name of the Service Directory service name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceDirectory")]
		public string ServiceDirectory { get; set; }
		
		/// <summary>
		/// Output only. The state of the location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<RuntimeConfigState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RuntimeConfigState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVATING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 6,
	}
	
	/// <summary>
	/// Request message for `SetIamPolicy` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SetIamPolicyRequest
	{
		
		/// <summary>
		/// An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members`, or principals, to a single `role`. Principals can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** ``` { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } ``` **YAML example:** ``` bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA= version: 3 ``` For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public Policy Policy { get; set; }
		
		/// <summary>
		/// OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only the fields in the mask will be modified. If no mask is provided, the following default mask is used: `paths: "bindings, etag"`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateMask")]
		public string UpdateMask { get; set; }
	}
	
	/// <summary>
	/// Global Settings details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Settings
	{
		
		/// <summary>
		/// Output only. Resource name of the Connection. Format: projects/{project}/locations/global/settings}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. Flag indicates if user is in PayG model
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payg")]
		public System.Nullable<System.Boolean> Payg { get; set; }
		
		/// <summary>
		/// Output only. Tenant project id of the consumer project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tenantProjectId")]
		public string TenantProjectId { get; set; }
		
		/// <summary>
		/// Optional. Flag indicates whether vpc-sc is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vpcsc")]
		public System.Nullable<System.Boolean> Vpcsc { get; set; }
	}
	
	/// <summary>
	/// Request message for `TestIamPermissions` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TestIamPermissionsRequest
	{
		
		/// <summary>
		/// The set of permissions to check for the `resource`. Permissions with wildcards (such as `*` or `storage.*`) are not allowed. For more information see [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public string[] Permissions { get; set; }
	}
	
	/// <summary>
	/// Response message for `TestIamPermissions` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TestIamPermissionsResponse
	{
		
		/// <summary>
		/// A subset of `TestPermissionsRequest.permissions` that the caller is allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public string[] Permissions { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Deletes a long-running operation. This method indicates that the client is no longer interested in the operation result. It does not cancel the operation. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
		/// Connectors_projects_locations_operations_delete v1/{name}
		/// </summary>
		/// <param name="name">The name of the operation resource to be deleted.</param>
		/// <param name="force">Optional. If set to true, any customConnectorVersion which is a child resource will also be deleted. https://aip.dev/135#cascading-delete</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Connectors_projects_locations_operations_deleteAsync(string name, bool force, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&force="+force;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Empty>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets details of a single event type.
		/// Connectors_projects_locations_providers_connectors_versions_eventtypes_get v1/{name}
		/// </summary>
		/// <param name="name">Required. Resource name of the form: `projects/*/locations/*/providers/*/connectors/*/versions/*/eventtypes/*` Only global location is supported for EventType resource.</param>
		/// <param name="view">Specifies which fields of the ConnectorVersion are returned in the response. Defaults to `CUSTOMER` view.</param>
		/// <returns>Successful response</returns>
		public async Task<EventType> Connectors_projects_locations_providers_connectors_versions_eventtypes_getAsync(string name, Connectors_projects_locations_providers_connectors_versions_eventtypes_getView view, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&view=" + view;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EventType>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the parameters of a single ManagedZone.
		/// Connectors_projects_locations_global_managedZones_patch v1/{name}
		/// </summary>
		/// <param name="name">Output only. Resource name of the Managed Zone. Format: projects/{project}/locations/global/managedZones/{managed_zone}</param>
		/// <param name="updateMask">Required. The list of fields to update. Fields are specified relative to the managedZone. A field will be overwritten if it is in the mask. You can modify only the fields listed below. To update the managedZone details: * `description` * `labels` * `target_project` * `target_network`</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Connectors_projects_locations_global_managedZones_patchAsync(string name, string updateMask, ManagedZone requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists information about the supported locations for this service.
		/// Connectors_projects_locations_list v1/{name}/locations
		/// </summary>
		/// <param name="name">The resource that owns the locations collection, if applicable.</param>
		/// <param name="filter">A filter to narrow down results to a preferred subset. The filtering language accepts strings like `"displayName=tokyo"`, and is documented in more detail in [AIP-160](https://google.aip.dev/160).</param>
		/// <param name="pageSize">The maximum number of results to return. If not set, the service selects a default.</param>
		/// <param name="pageToken">A page token received from the `next_page_token` field in the response. Send that page token to receive the subsequent page.</param>
		/// <returns>Successful response</returns>
		public async Task<ListLocationsResponse> Connectors_projects_locations_listAsync(string name, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/locations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListLocationsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists operations that match the specified filter in the request. If the server doesn't support this method, it returns `UNIMPLEMENTED`.
		/// Connectors_projects_locations_operations_list v1/{name}/operations
		/// </summary>
		/// <param name="name">The name of the operation's parent resource.</param>
		/// <param name="filter">The standard list filter.</param>
		/// <param name="pageSize">The standard list page size.</param>
		/// <param name="pageToken">The standard list page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListOperationsResponse> Connectors_projects_locations_operations_listAsync(string name, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/operations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListOperationsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`.
		/// Connectors_projects_locations_operations_cancel v1/{name}:cancel
		/// </summary>
		/// <param name="name">The name of the operation resource to be cancelled.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Connectors_projects_locations_operations_cancelAsync(string name, CancelOperationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":cancel";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Empty>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get action.
		/// Connectors_projects_locations_connections_connectionSchemaMetadata_getAction v1/{name}:getAction
		/// </summary>
		/// <param name="name">Required. Resource name format: projects/{project}/locations/{location}/connections/{connection}/connectionSchemaMetadata</param>
		/// <param name="actionId">Required. Id of the action.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Connectors_projects_locations_connections_connectionSchemaMetadata_getActionAsync(string name, string actionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":getAction&actionId=" + (actionId==null? "" : System.Uri.EscapeDataString(actionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get entity type.
		/// Connectors_projects_locations_connections_connectionSchemaMetadata_getEntityType v1/{name}:getEntityType
		/// </summary>
		/// <param name="name">Required. Resource name format: projects/{project}/locations/{location}/connections/{connection}/connectionSchemaMetadata</param>
		/// <param name="entityId">Required. Id of the entity type.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Connectors_projects_locations_connections_connectionSchemaMetadata_getEntityTypeAsync(string name, string entityId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":getEntityType&entityId=" + (entityId==null? "" : System.Uri.EscapeDataString(entityId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List actions.
		/// Connectors_projects_locations_connections_connectionSchemaMetadata_listActions v1/{name}:listActions
		/// </summary>
		/// <param name="name">Required. Resource name format. projects/{project}/locations/{location}/connections/{connection}/connectionSchemaMetadata</param>
		/// <param name="filter">Required. Filter Wildcards are not supported in the filter currently.</param>
		/// <param name="pageSize">Page size. If unspecified, at most 50 actions will be returned.</param>
		/// <param name="pageToken">Page token.</param>
		/// <param name="view">Specifies which fields are returned in response. Defaults to BASIC view.</param>
		/// <returns>Successful response</returns>
		public async Task<ListActionsResponse> Connectors_projects_locations_connections_connectionSchemaMetadata_listActionsAsync(string name, string filter, int pageSize, string pageToken, Connectors_projects_locations_connections_connectionSchemaMetadata_listActionsView view, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":listActions&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&view=" + view;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListActionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List entity types.
		/// Connectors_projects_locations_connections_connectionSchemaMetadata_listEntityTypes v1/{name}:listEntityTypes
		/// </summary>
		/// <param name="name">Required. Resource name format: projects/{project}/locations/{location}/connections/{connection}/connectionSchemaMetadata</param>
		/// <param name="filter">Required. Filter Wildcards are not supported in the filter currently.</param>
		/// <param name="pageSize">Page size. If unspecified, at most 50 entity types will be returned.</param>
		/// <param name="pageToken">Page token.</param>
		/// <param name="view">Specifies which fields are returned in response. Defaults to BASIC view.</param>
		/// <returns>Successful response</returns>
		public async Task<ListEntityTypesResponse> Connectors_projects_locations_connections_connectionSchemaMetadata_listEntityTypesAsync(string name, string filter, int pageSize, string pageToken, Connectors_projects_locations_connections_connectionSchemaMetadata_listActionsView view, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":listEntityTypes&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&view=" + view;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListEntityTypesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Refresh runtime schema of a connection.
		/// Connectors_projects_locations_connections_connectionSchemaMetadata_refresh v1/{name}:refresh
		/// </summary>
		/// <param name="name">Required. Resource name. Format: projects/{project}/locations/{location}/connections/{connection}/connectionSchemaMetadata</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Connectors_projects_locations_connections_connectionSchemaMetadata_refreshAsync(string name, RefreshConnectionSchemaMetadataRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":refresh";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// RepaiEventing tries to repair eventing related event subscriptions.
		/// Connectors_projects_locations_connections_repairEventing v1/{name}:repairEventing
		/// </summary>
		/// <param name="name">Required. Resource name of the form: `projects/*/locations/*/connections/*`</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Connectors_projects_locations_connections_repairEventingAsync(string name, RepairEventingRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":repairEventing";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// RetryEventSubscription retries the registration of Subscription.
		/// Connectors_projects_locations_connections_eventSubscriptions_retry v1/{name}:retry
		/// </summary>
		/// <param name="name">Required. Resource name of the form: `projects/*/locations/*/connections/*/eventSubscriptions/*`</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Connectors_projects_locations_connections_eventSubscriptions_retryAsync(string name, RetryEventSubscriptionRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":retry";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists Connections in a given project and location.
		/// Connectors_projects_locations_connections_list v1/{parent}/connections
		/// </summary>
		/// <param name="parent">Required. Parent resource of the Connection, of the form: `projects/*/locations/*`</param>
		/// <param name="filter">Filter.</param>
		/// <param name="orderBy">Order by parameters.</param>
		/// <param name="pageSize">Page size.</param>
		/// <param name="pageToken">Page token.</param>
		/// <param name="view">Specifies which fields of the Connection are returned in the response. Defaults to `BASIC` view.</param>
		/// <returns>Successful response</returns>
		public async Task<ListConnectionsResponse> Connectors_projects_locations_connections_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Connectors_projects_locations_connections_listView view, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/connections&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&view=" + view;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListConnectionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new Connection in a given project and location.
		/// Connectors_projects_locations_connections_create v1/{parent}/connections
		/// </summary>
		/// <param name="parent">Required. Parent resource of the Connection, of the form: `projects/*/locations/*`</param>
		/// <param name="connectionId">Required. Identifier to assign to the Connection. Must be unique within scope of the parent resource.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Connectors_projects_locations_connections_createAsync(string parent, string connectionId, Connection requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/connections&connectionId=" + (connectionId==null? "" : System.Uri.EscapeDataString(connectionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists Connectors in a given project and location.
		/// Connectors_projects_locations_providers_connectors_list v1/{parent}/connectors
		/// </summary>
		/// <param name="parent">Required. Parent resource of the connectors, of the form: `projects/*/locations/*/providers/*` Only global location is supported for Connector resource.</param>
		/// <param name="filter">Filter string.</param>
		/// <param name="pageSize">Page size.</param>
		/// <param name="pageToken">Page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListConnectorsResponse> Connectors_projects_locations_providers_connectors_listAsync(string parent, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/connectors&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListConnectorsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List CustomConnectorVersions in a given project
		/// Connectors_projects_locations_global_customConnectors_customConnectorVersions_list v1/{parent}/customConnectorVersions
		/// </summary>
		/// <param name="parent">Required. Parent resource of the connectors, of the form: `projects/*/locations/{location}/customConnectors/*/customConnectorVersions/*`</param>
		/// <param name="pageSize">Page size.</param>
		/// <param name="pageToken">Page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListCustomConnectorVersionsResponse> Connectors_projects_locations_global_customConnectors_customConnectorVersions_listAsync(string parent, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/customConnectorVersions&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListCustomConnectorVersionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new CustomConnectorVersion in a given project and location.
		/// Connectors_projects_locations_global_customConnectors_customConnectorVersions_create v1/{parent}/customConnectorVersions
		/// </summary>
		/// <param name="parent">Required. Parent resource of the CreateCustomConnector, of the form: `projects/{project}/locations/{location}/customConnectors/{custom_connector}`</param>
		/// <param name="customConnectorVersionId">Required. Identifier to assign to the CreateCustomConnectorVersion. Must be unique within scope of the parent resource.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Connectors_projects_locations_global_customConnectors_customConnectorVersions_createAsync(string parent, string customConnectorVersionId, CustomConnectorVersion requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/customConnectorVersions&customConnectorVersionId=" + (customConnectorVersionId==null? "" : System.Uri.EscapeDataString(customConnectorVersionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List CustomConnectorVersions in a given project
		/// Connectors_projects_locations_global_customConnectors_list v1/{parent}/customConnectors
		/// </summary>
		/// <param name="parent">Required. Parent resource of the custom connectors, of the form: `projects/*/locations/*` Only global location is supported for CustomConnector resource.</param>
		/// <param name="filter">Filter string.</param>
		/// <param name="pageSize">Page size.</param>
		/// <param name="pageToken">Page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListCustomConnectorsResponse> Connectors_projects_locations_global_customConnectors_listAsync(string parent, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/customConnectors&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListCustomConnectorsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new CustomConnector in a given project and location.
		/// Connectors_projects_locations_global_customConnectors_create v1/{parent}/customConnectors
		/// </summary>
		/// <param name="parent">Required. Parent resource of the CreateCustomConnector, of the form: `projects/{project}/locations/*`</param>
		/// <param name="customConnectorId">Required. Identifier to assign to the CreateCustomConnector. Must be unique within scope of the parent resource.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Connectors_projects_locations_global_customConnectors_createAsync(string parent, string customConnectorId, CustomConnector requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/customConnectors&customConnectorId=" + (customConnectorId==null? "" : System.Uri.EscapeDataString(customConnectorId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List EndpointAttachments in a given project
		/// Connectors_projects_locations_endpointAttachments_list v1/{parent}/endpointAttachments
		/// </summary>
		/// <param name="parent">Required. Parent resource od the EndpointAttachment, of the form: `projects/*/locations/*`</param>
		/// <param name="filter">Filter.</param>
		/// <param name="orderBy">Order by parameters.</param>
		/// <param name="pageSize">Page size.</param>
		/// <param name="pageToken">Page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListEndpointAttachmentsResponse> Connectors_projects_locations_endpointAttachments_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/endpointAttachments&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListEndpointAttachmentsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new EndpointAttachment in a given project and location.
		/// Connectors_projects_locations_endpointAttachments_create v1/{parent}/endpointAttachments
		/// </summary>
		/// <param name="parent">Required. Parent resource of the EndpointAttachment, of the form: `projects/*/locations/*`</param>
		/// <param name="endpointAttachmentId">Required. Identifier to assign to the EndpointAttachment. Must be unique within scope of the parent resource.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Connectors_projects_locations_endpointAttachments_createAsync(string parent, string endpointAttachmentId, EndpointAttachment requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/endpointAttachments&endpointAttachmentId=" + (endpointAttachmentId==null? "" : System.Uri.EscapeDataString(endpointAttachmentId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List EventSubscriptions in a given project,location and connection.
		/// Connectors_projects_locations_connections_eventSubscriptions_list v1/{parent}/eventSubscriptions
		/// </summary>
		/// <param name="parent">Required. Parent resource of the EventSubscription, of the form: `projects/*/locations/*/connections/*`</param>
		/// <param name="filter">Filter.</param>
		/// <param name="orderBy">Order by parameters.</param>
		/// <param name="pageSize">Page size.</param>
		/// <param name="pageToken">Page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListEventSubscriptionsResponse> Connectors_projects_locations_connections_eventSubscriptions_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/eventSubscriptions&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListEventSubscriptionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new EventSubscription in a given project,location and connection.
		/// Connectors_projects_locations_connections_eventSubscriptions_create v1/{parent}/eventSubscriptions
		/// </summary>
		/// <param name="parent">Required. Parent resource of the EventSubscription, of the form: `projects/*/locations/*/connections/*`</param>
		/// <param name="eventSubscriptionId">Required. Identifier to assign to the Event Subscription. Must be unique within scope of the parent resource.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Connectors_projects_locations_connections_eventSubscriptions_createAsync(string parent, string eventSubscriptionId, EventSubscription requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/eventSubscriptions&eventSubscriptionId=" + (eventSubscriptionId==null? "" : System.Uri.EscapeDataString(eventSubscriptionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists Event Types in a given Connector Version.
		/// Connectors_projects_locations_providers_connectors_versions_eventtypes_list v1/{parent}/eventtypes
		/// </summary>
		/// <param name="parent">Required. Parent resource of the connectors, of the form: `projects/*/locations/*/providers/*/connectors/*/versions/*` Only global location is supported for EventType resource.</param>
		/// <param name="pageSize">Page size.</param>
		/// <param name="pageToken">Page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListEventTypesResponse> Connectors_projects_locations_providers_connectors_versions_eventtypes_listAsync(string parent, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/eventtypes&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListEventTypesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List ManagedZones in a given project
		/// Connectors_projects_locations_global_managedZones_list v1/{parent}/managedZones
		/// </summary>
		/// <param name="parent">Required. Parent resource of the Managed Zone, of the form: `projects/*/locations/global`</param>
		/// <param name="filter">Filter.</param>
		/// <param name="orderBy">Order by parameters.</param>
		/// <param name="pageSize">Page size.</param>
		/// <param name="pageToken">Page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListManagedZonesResponse> Connectors_projects_locations_global_managedZones_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/managedZones&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListManagedZonesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new ManagedZone in a given project and location.
		/// Connectors_projects_locations_global_managedZones_create v1/{parent}/managedZones
		/// </summary>
		/// <param name="parent">Required. Parent resource of the ManagedZone, of the form: `projects/*/locations/global`</param>
		/// <param name="managedZoneId">Required. Identifier to assign to the ManagedZone. Must be unique within scope of the parent resource.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Connectors_projects_locations_global_managedZones_createAsync(string parent, string managedZoneId, ManagedZone requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/managedZones&managedZoneId=" + (managedZoneId==null? "" : System.Uri.EscapeDataString(managedZoneId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists Providers in a given project and location.
		/// Connectors_projects_locations_providers_list v1/{parent}/providers
		/// </summary>
		/// <param name="parent">Required. Parent resource of the API, of the form: `projects/*/locations/*` Only global location is supported for Provider resource.</param>
		/// <param name="pageSize">Page size.</param>
		/// <param name="pageToken">Page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListProvidersResponse> Connectors_projects_locations_providers_listAsync(string parent, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/providers&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListProvidersResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List schema of a runtime actions filtered by action name.
		/// Connectors_projects_locations_connections_runtimeActionSchemas_list v1/{parent}/runtimeActionSchemas
		/// </summary>
		/// <param name="parent">Required. Parent resource of RuntimeActionSchema Format: projects/{project}/locations/{location}/connections/{connection}</param>
		/// <param name="filter">Required. Filter Format: action="{actionId}" Only action field is supported with literal equality operator. Accepted filter example: action="CancelOrder" Wildcards are not supported in the filter currently.</param>
		/// <param name="pageSize">Page size.</param>
		/// <param name="pageToken">Page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListRuntimeActionSchemasResponse> Connectors_projects_locations_connections_runtimeActionSchemas_listAsync(string parent, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/runtimeActionSchemas&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListRuntimeActionSchemasResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List schema of a runtime entities filtered by entity name.
		/// Connectors_projects_locations_connections_runtimeEntitySchemas_list v1/{parent}/runtimeEntitySchemas
		/// </summary>
		/// <param name="parent">Required. Parent resource of RuntimeEntitySchema Format: projects/{project}/locations/{location}/connections/{connection}</param>
		/// <param name="filter">Required. Filter Format: entity="{entityId}" Only entity field is supported with literal equality operator. Accepted filter example: entity="Order" Wildcards are not supported in the filter currently.</param>
		/// <param name="pageSize">Page size.</param>
		/// <param name="pageToken">Page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListRuntimeEntitySchemasResponse> Connectors_projects_locations_connections_runtimeEntitySchemas_listAsync(string parent, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/runtimeEntitySchemas&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListRuntimeEntitySchemasResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists Connector Versions in a given project and location.
		/// Connectors_projects_locations_providers_connectors_versions_list v1/{parent}/versions
		/// </summary>
		/// <param name="parent">Required. Parent resource of the connectors, of the form: `projects/*/locations/*/providers/*/connectors/*` Only global location is supported for ConnectorVersion resource.</param>
		/// <param name="pageSize">Page size.</param>
		/// <param name="pageToken">Page token.</param>
		/// <param name="view">Specifies which fields of the ConnectorVersion are returned in the response. Defaults to `BASIC` view.</param>
		/// <returns>Successful response</returns>
		public async Task<ListConnectorVersionsResponse> Connectors_projects_locations_providers_connectors_versions_listAsync(string parent, int pageSize, string pageToken, Connectors_projects_locations_providers_connectors_versions_eventtypes_getView view, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/versions&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&view=" + view;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListConnectorVersionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// ListenEvent listens to the event.
		/// Connectors_projects_locations_connections_listenEvent v1/{resourcePath}:listenEvent
		/// </summary>
		/// <param name="resourcePath">Required. Resource path for request.</param>
		/// <returns>Successful response</returns>
		public async Task<ListenEventResponse> Connectors_projects_locations_connections_listenEventAsync(string resourcePath, ListenEventRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (resourcePath==null? "" : System.Uri.EscapeDataString(resourcePath))+":listenEvent";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListenEventResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. Returns an empty policy if the resource exists and does not have a policy set.
		/// Connectors_projects_locations_providers_getIamPolicy v1/{resource}:getIamPolicy
		/// </summary>
		/// <param name="resource">REQUIRED: The resource for which the policy is being requested. See [Resource names](https://cloud.google.com/apis/design/resource_names) for the appropriate value for this field.</param>
		/// <param name="options_requestedPolicyVersion">Optional. The maximum policy version that will be used to format the policy. Valid values are 0, 1, and 3. Requests specifying an invalid value will be rejected. Requests for policies with any conditional role bindings must specify version 3. Policies with no conditional role bindings may specify any valid value or leave the field unset. The policy in the response might use the policy version that you specified, or it might use a lower policy version. For example, if you specify version 3, but the policy has no conditional role bindings, the response uses version 1. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Connectors_projects_locations_providers_getIamPolicyAsync(string resource, int options_requestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+":getIamPolicy&options.requestedPolicyVersion="+options_requestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors.
		/// Connectors_projects_locations_providers_setIamPolicy v1/{resource}:setIamPolicy
		/// </summary>
		/// <param name="resource">REQUIRED: The resource for which the policy is being specified. See [Resource names](https://cloud.google.com/apis/design/resource_names) for the appropriate value for this field.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Connectors_projects_locations_providers_setIamPolicyAsync(string resource, SetIamPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+":setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource. If the resource does not exist, this will return an empty set of permissions, not a `NOT_FOUND` error. Note: This operation is designed to be used for building permission-aware UIs and command-line tools, not for authorization checking. This operation may "fail open" without warning.
		/// Connectors_projects_locations_providers_testIamPermissions v1/{resource}:testIamPermissions
		/// </summary>
		/// <param name="resource">REQUIRED: The resource for which the policy detail is being requested. See [Resource names](https://cloud.google.com/apis/design/resource_names) for the appropriate value for this field.</param>
		/// <returns>Successful response</returns>
		public async Task<TestIamPermissionsResponse> Connectors_projects_locations_providers_testIamPermissionsAsync(string resource, TestIamPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+":testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestIamPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	public enum Connectors_projects_locations_providers_connectors_versions_eventtypes_getView
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONNECTOR_VERSION_VIEW_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONNECTOR_VERSION_VIEW_BASIC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONNECTOR_VERSION_VIEW_FULL = 2,
	}
	
	public enum Connectors_projects_locations_connections_connectionSchemaMetadata_listActionsView
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VIEW_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BASIC = 1,
	}
	
	public enum Connectors_projects_locations_connections_listView
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONNECTION_VIEW_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BASIC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FULL = 2,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
