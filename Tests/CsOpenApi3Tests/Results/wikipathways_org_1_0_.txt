//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// createPathwayCreate a new pathway on the wiki with the given GPML code.<br>Note: To create/modify pathways via the web service, you need to have an account with web service write permissions. Please contact us to request write access for the web service.
		/// CreatePathwayPostByGpmlAndAuthAndUsernameAndFormat createPathway
		/// </summary>
		/// <param name="gpml">The GPML code for the new pathway</param>
		/// <param name="auth">The authentication info</param>
		/// <param name="username">The user name</param>
		/// <returns>everything ok</returns>
		public async Task CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatAsync(string gpml, string auth, string username, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "createPathway?gpml=" + (gpml==null? "" : System.Uri.EscapeDataString(gpml))+"&auth=" + (auth==null? "" : System.Uri.EscapeDataString(auth))+"&username=" + (username==null? "" : System.Uri.EscapeDataString(username))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// findInteractionsFind interactions defined in WikiPathways pathways.
		/// FindInteractionsGetByQueryAndFormat findInteractions
		/// </summary>
		/// <param name="query">The name of an entity to find interactions for (e.g. 'P53')</param>
		/// <returns>everything ok</returns>
		public async Task FindInteractionsGetByQueryAndFormatAsync(string query, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "findInteractions?query=" + (query==null? "" : System.Uri.EscapeDataString(query))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// findPathwaysByLiterature
		/// FindPathwaysByLiteratureGetByQueryAndFormat findPathwaysByLiterature
		/// </summary>
		/// <param name="query">The query, can be a pubmed id, author name or title keyword.</param>
		/// <returns>everything ok</returns>
		public async Task FindPathwaysByLiteratureGetByQueryAndFormatAsync(string query, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "findPathwaysByLiterature?query=" + (query==null? "" : System.Uri.EscapeDataString(query))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// findPathwaysByText
		/// FindPathwaysByTextGetByQueryAndSpeciesAndFormat findPathwaysByText
		/// </summary>
		/// <param name="query">The query, e.g. 'apoptosis'</param>
		/// <param name="species">Optional, limit the query by species. Leave</param>
		/// <returns>everything ok</returns>
		public async Task FindPathwaysByTextGetByQueryAndSpeciesAndFormatAsync(string query, string species, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "findPathwaysByText?query=" + (query==null? "" : System.Uri.EscapeDataString(query))+"&species=" + (species==null? "" : System.Uri.EscapeDataString(species))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// findPathwaysByXref
		/// FindPathwaysByXrefGetByIdsAndCodesAndFormat findPathwaysByXref
		/// </summary>
		/// <param name="ids">string</param>
		/// <param name="codes">string</param>
		/// <returns>everything ok</returns>
		public async Task FindPathwaysByXrefGetByIdsAndCodesAndFormatAsync(string[] ids, string[] codes, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "findPathwaysByXref?"+string.Join("&", ids.Select(z => $"ids={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", codes.Select(z => $"codes={System.Uri.EscapeDataString(z.ToString())}"))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// getColoredPathwayGet a colored image version of the pathway.
		/// GetColoredPathwayGetByPwIdAndRevisionAndGraphIdAndColorAndFileTypeAndFormat getColoredPathway
		/// </summary>
		/// <param name="pwId">The pathway identifier</param>
		/// <param name="revision">The revision of the pathway (use '0' for most recent)</param>
		/// <param name="graphId">string</param>
		/// <param name="color">string</param>
		/// <param name="fileType">The image type (One of 'svg', 'pdf' or 'png').</param>
		/// <returns>everything ok</returns>
		public async Task GetColoredPathwayGetByPwIdAndRevisionAndGraphIdAndColorAndFileTypeAndFormatAsync(string pwId, string revision, string[] graphId, string[] color, string fileType, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "getColoredPathway?pwId=" + (pwId==null? "" : System.Uri.EscapeDataString(pwId))+"&revision=" + (revision==null? "" : System.Uri.EscapeDataString(revision))+"&"+string.Join("&", graphId.Select(z => $"graphId={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", color.Select(z => $"color={System.Uri.EscapeDataString(z.ToString())}"))+"&fileType=" + (fileType==null? "" : System.Uri.EscapeDataString(fileType))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// getCurationTagHistory
		/// GetCurationTagHistoryGetByPwIdAndTimestampAndFormat getCurationTagHistory
		/// </summary>
		/// <param name="pwId">The pathway identifier</param>
		/// <param name="timestamp">Only include history from after the given date</param>
		/// <returns>everything ok</returns>
		public async Task GetCurationTagHistoryGetByPwIdAndTimestampAndFormatAsync(string pwId, string timestamp, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "getCurationTagHistory?pwId=" + (pwId==null? "" : System.Uri.EscapeDataString(pwId))+"&timestamp=" + (timestamp==null? "" : System.Uri.EscapeDataString(timestamp))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// getCurationTagsGet all curation tags for the given tag name. Use this method if you want to find all pathways that are tagged with a specific curation tag.
		/// GetCurationTagsGetByPwIdAndFormat getCurationTags
		/// </summary>
		/// <param name="pwId">The pathway identifier</param>
		/// <returns>everything ok</returns>
		public async Task GetCurationTagsGetByPwIdAndFormatAsync(string pwId, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "getCurationTags?pwId=" + (pwId==null? "" : System.Uri.EscapeDataString(pwId))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// getCurationTagsByNameGet all curation tags for the given tag name. Use this method if you want to find all pathways that are tagged with a specific curation tag.
		/// GetCurationTagsByNameGetByTagNameAndFormat getCurationTagsByName
		/// </summary>
		/// <param name="tagName">The tag name</param>
		/// <returns>everything ok</returns>
		public async Task GetCurationTagsByNameGetByTagNameAndFormatAsync(string tagName, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "getCurationTagsByName?tagName=" + (tagName==null? "" : System.Uri.EscapeDataString(tagName))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// getOntologyTermsByPathway
		/// GetOntologyTermsByPathwayGetByPwIdAndFormat getOntologyTermsByPathway
		/// </summary>
		/// <param name="pwId">The pathway identifier</param>
		/// <returns>everything ok</returns>
		public async Task GetOntologyTermsByPathwayGetByPwIdAndFormatAsync(string pwId, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "getOntologyTermsByPathway?pwId=" + (pwId==null? "" : System.Uri.EscapeDataString(pwId))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// getPathway
		/// GetPathwayGetByPwIdAndRevisionAndFormat getPathway
		/// </summary>
		/// <param name="pwId">The pathway identifier</param>
		/// <param name="revision">The revision number of the pathway (use 0 for most recent)</param>
		/// <returns>everything ok</returns>
		public async Task GetPathwayGetByPwIdAndRevisionAndFormatAsync(string pwId, int revision, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "getPathway?pwId=" + (pwId==null? "" : System.Uri.EscapeDataString(pwId))+"&revision="+revision+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// getPathwayAsDownload a pathway in the specified file format.
		/// GetPathwayAsGetByFileTypeAndPwIdAndRevisionAndFormat getPathwayAs
		/// </summary>
		/// <param name="fileType">The file type to convert to, e.g.</param>
		/// <param name="pwId">The pathway identifier</param>
		/// <param name="revision">The revision number of the pathway (use 0 for most recent)</param>
		/// <returns>everything ok</returns>
		public async Task GetPathwayAsGetByFileTypeAndPwIdAndRevisionAndFormatAsync(string fileType, string pwId, int revision, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "getPathwayAs?fileType=" + (fileType==null? "" : System.Uri.EscapeDataString(fileType))+"&pwId=" + (pwId==null? "" : System.Uri.EscapeDataString(pwId))+"&revision="+revision+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// getPathwayHistoryGet the revision history of a pathway.
		/// GetPathwayHistoryGetByPwIdAndTimestampAndFormat getPathwayHistory
		/// </summary>
		/// <param name="pwId">The pathway identifier</param>
		/// <param name="timestamp">Limit by time, only history items after the given</param>
		/// <returns>everything ok</returns>
		public async Task GetPathwayHistoryGetByPwIdAndTimestampAndFormatAsync(string pwId, string timestamp, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "getPathwayHistory?pwId=" + (pwId==null? "" : System.Uri.EscapeDataString(pwId))+"&timestamp=" + (timestamp==null? "" : System.Uri.EscapeDataString(timestamp))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// getPathwayInfoGet some general info about the pathway, such as the name, species, without downloading the GPML.
		/// GetPathwayInfoGetByPwIdAndFormat getPathwayInfo
		/// </summary>
		/// <param name="pwId">The pathway identifier</param>
		/// <returns>everything ok</returns>
		public async Task GetPathwayInfoGetByPwIdAndFormatAsync(string pwId, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "getPathwayInfo?pwId=" + (pwId==null? "" : System.Uri.EscapeDataString(pwId))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// getPathwaysByOntologyTerm
		/// GetPathwaysByOntologyTermGetByTermAndFormat getPathwaysByOntologyTerm
		/// </summary>
		/// <param name="term">The Ontology term</param>
		/// <returns>everything ok</returns>
		public async Task GetPathwaysByOntologyTermGetByTermAndFormatAsync(string term, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "getPathwaysByOntologyTerm?term=" + (term==null? "" : System.Uri.EscapeDataString(term))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// getPathwaysByParentOntologyTerm
		/// GetPathwaysByParentOntologyTermGetByTermAndFormat getPathwaysByParentOntologyTerm
		/// </summary>
		/// <param name="term">The Ontology term</param>
		/// <returns>everything ok</returns>
		public async Task GetPathwaysByParentOntologyTermGetByTermAndFormatAsync(string term, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "getPathwaysByParentOntologyTerm?term=" + (term==null? "" : System.Uri.EscapeDataString(term))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// getRecentChangesGet the recently changed pathways.<br>Note: the recent changes table only retains items for a limited time (2 months), so there is no guarantee that you will get all changes when the timestamp points to a date that is more than 2 months in the past.
		/// GetRecentChangesGetByTimestampAndFormat getRecentChanges
		/// </summary>
		/// <param name="timestamp">Get the changes after this time</param>
		/// <returns>everything ok</returns>
		public async Task GetRecentChangesGetByTimestampAndFormatAsync(string timestamp, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "getRecentChanges?timestamp=" + (timestamp==null? "" : System.Uri.EscapeDataString(timestamp))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// getUserByOrcid
		/// GetUserByOrcidGetByOrcidAndFormat getUserByOrcid
		/// </summary>
		/// <param name="orcid">string</param>
		/// <returns>everything ok</returns>
		public async Task GetUserByOrcidGetByOrcidAndFormatAsync(string orcid, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "getUserByOrcid?orcid=" + (orcid==null? "" : System.Uri.EscapeDataString(orcid))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// getXrefList
		/// GetXrefListGetByPwIdAndCodeAndFormat getXrefList
		/// </summary>
		/// <param name="pwId">The pathway identifier.</param>
		/// <param name="code">The database code to translate to (e.g. 'S' for UniProt).</param>
		/// <returns>everything ok</returns>
		public async Task GetXrefListGetByPwIdAndCodeAndFormatAsync(string pwId, string code, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "getXrefList?pwId=" + (pwId==null? "" : System.Uri.EscapeDataString(pwId))+"&code=" + (code==null? "" : System.Uri.EscapeDataString(code))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// listOrganisms
		/// ListOrganismsGetByFormat listOrganisms
		/// </summary>
		/// <returns>everything ok</returns>
		public async Task ListOrganismsGetByFormatAsync(CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "listOrganisms?format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// listPathways
		/// ListPathwaysGetByOrganismAndFormat listPathways
		/// </summary>
		/// <param name="organism">The organism to filter by (optional)</param>
		/// <returns>everything ok</returns>
		public async Task ListPathwaysGetByOrganismAndFormatAsync(string organism, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "listPathways?organism=" + (organism==null? "" : System.Uri.EscapeDataString(organism))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// loginStart a logged in session, using an existing WikiPathways account. This function will return an authentication code that can be used to excecute methods that need authentication (e.g. updatePathway).
		/// LoginGetByNameAndPassAndFormat login
		/// </summary>
		/// <param name="name">The usernameset_include_path(get_include_path().PATH_SEPARATOR.realpath('../includes').PATH_SEPARATOR.realpath('../').PATH_SEPARATOR);</param>
		/// <param name="pass">The password</param>
		/// <returns>everything ok</returns>
		public async Task LoginGetByNameAndPassAndFormatAsync(string name, string pass, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "login?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&pass=" + (pass==null? "" : System.Uri.EscapeDataString(pass))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// removeCurationTagRemove a curation tag from a pathway.
		/// RemoveCurationTagGetByPwIdAndTagNameAndAuthAndUsernameAndFormat removeCurationTag
		/// </summary>
		/// <param name="pwId">The pathway identifier</param>
		/// <param name="tagName">The name of the tag to apply</param>
		/// <param name="auth">The authentication data</param>
		/// <param name="username">The user name</param>
		/// <returns>everything ok</returns>
		public async Task RemoveCurationTagGetByPwIdAndTagNameAndAuthAndUsernameAndFormatAsync(string pwId, string tagName, string auth, string username, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "removeCurationTag?pwId=" + (pwId==null? "" : System.Uri.EscapeDataString(pwId))+"&tagName=" + (tagName==null? "" : System.Uri.EscapeDataString(tagName))+"&auth=" + (auth==null? "" : System.Uri.EscapeDataString(auth))+"&username=" + (username==null? "" : System.Uri.EscapeDataString(username))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// removeOntologyTag
		/// RemoveOntologyTagGetByPwIdAndTermIdAndAuthAndUserAndFormat removeOntologyTag
		/// </summary>
		/// <param name="pwId">The pathway identifier</param>
		/// <param name="termId">The ontology term identifier in the ontology</param>
		/// <param name="auth">The authentication key</param>
		/// <param name="user">The username</param>
		/// <returns>everything ok</returns>
		public async Task RemoveOntologyTagGetByPwIdAndTermIdAndAuthAndUserAndFormatAsync(string pwId, string termId, string auth, string user, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "removeOntologyTag?pwId=" + (pwId==null? "" : System.Uri.EscapeDataString(pwId))+"&termId=" + (termId==null? "" : System.Uri.EscapeDataString(termId))+"&auth=" + (auth==null? "" : System.Uri.EscapeDataString(auth))+"&user=" + (user==null? "" : System.Uri.EscapeDataString(user))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// saveCurationTag
		/// SaveCurationTagGetByPwIdAndTagNameAndTextAndRevisionAndAuthAndUsernameAndFormat saveCurationTag
		/// </summary>
		/// <param name="pwId">The pathway identifier</param>
		/// <param name="tagName">The name of the tag to apply</param>
		/// <param name="text">string</param>
		/// <param name="revision">The revision this tag applies to</param>
		/// <param name="auth">The authentication key</param>
		/// <param name="username">The user name</param>
		/// <returns>everything ok</returns>
		public async Task SaveCurationTagGetByPwIdAndTagNameAndTextAndRevisionAndAuthAndUsernameAndFormatAsync(string pwId, string tagName, string text, int revision, string auth, string username, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "saveCurationTag?pwId=" + (pwId==null? "" : System.Uri.EscapeDataString(pwId))+"&tagName=" + (tagName==null? "" : System.Uri.EscapeDataString(tagName))+"&text=" + (text==null? "" : System.Uri.EscapeDataString(text))+"&revision="+revision+"&auth=" + (auth==null? "" : System.Uri.EscapeDataString(auth))+"&username=" + (username==null? "" : System.Uri.EscapeDataString(username))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// saveOntologyTag
		/// SaveOntologyTagGetByPwIdAndTermAndTermIdAndAuthAndUserAndFormat saveOntologyTag
		/// </summary>
		/// <param name="pwId">The pathway identifier</param>
		/// <param name="term">The ontology term to apply</param>
		/// <param name="termId">The identifier of the term in the ontology</param>
		/// <param name="auth">The authentication key</param>
		/// <param name="user">The username</param>
		/// <returns>everything ok</returns>
		public async Task SaveOntologyTagGetByPwIdAndTermAndTermIdAndAuthAndUserAndFormatAsync(string pwId, string term, string termId, string auth, string user, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "saveOntologyTag?pwId=" + (pwId==null? "" : System.Uri.EscapeDataString(pwId))+"&term=" + (term==null? "" : System.Uri.EscapeDataString(term))+"&termId=" + (termId==null? "" : System.Uri.EscapeDataString(termId))+"&auth=" + (auth==null? "" : System.Uri.EscapeDataString(auth))+"&user=" + (user==null? "" : System.Uri.EscapeDataString(user))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// updatePathwayUpdate a pathway on the wiki with the given GPML code.<br>Note: To create/modify pathways via the web service, you need to have an account with web service write permissions. Please contact us to request write access for the web service.
		/// UpdatePathwayGetByPwIdAndDescriptionAndGpmlAndRevisionAndAuthAndUsernameAndFormat updatePathway
		/// </summary>
		/// <param name="pwId">The pathway identifier</param>
		/// <param name="description">A description of the modifications</param>
		/// <param name="gpml">The updated GPML code</param>
		/// <param name="revision">The revision the GPML code is based on</param>
		/// <param name="auth">The authentication key</param>
		/// <param name="username">The username</param>
		/// <returns>everything ok</returns>
		public async Task UpdatePathwayGetByPwIdAndDescriptionAndGpmlAndRevisionAndAuthAndUsernameAndFormatAsync(string pwId, string description, string gpml, int revision, string auth, string username, CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "updatePathway?pwId=" + (pwId==null? "" : System.Uri.EscapeDataString(pwId))+"&description=" + (description==null? "" : System.Uri.EscapeDataString(description))+"&gpml=" + (gpml==null? "" : System.Uri.EscapeDataString(gpml))+"&revision="+revision+"&auth=" + (auth==null? "" : System.Uri.EscapeDataString(auth))+"&username=" + (username==null? "" : System.Uri.EscapeDataString(username))+"&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum CreatePathwayPostByGpmlAndAuthAndUsernameAndFormatFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		json = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		xml = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		html = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dump = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		jpg = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pdf = 5,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
