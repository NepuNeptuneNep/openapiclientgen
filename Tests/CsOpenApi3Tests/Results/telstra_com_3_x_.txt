//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Error
	{
		
		/// <summary>
		/// Unique code of the error
		/// Required
		/// Min length: 1
		/// Max length: 100
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Code { get; set; }
		
		/// <summary>
		/// The field that caused the error
		/// Min length: 1
		/// Max length: 99999
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="field")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(99999)]
		public string Field { get; set; }
		
		/// <summary>
		/// The reason for the error
		/// Required
		/// Min length: 1
		/// Max length: 99999
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issue")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(99999)]
		public string Issue { get; set; }
		
		/// <summary>
		/// URI for detailed information related to this error for the developer.
		/// Min length: 1
		/// Max length: 99999
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="link")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(99999)]
		public string Link { get; set; }
		
		/// <summary>
		/// The location of the field that caused the error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public System.Nullable<ErrorLocation> Location { get; set; }
		
		/// <summary>
		/// Suggest practical actions for this particular issue.
		/// Required
		/// Min length: 1
		/// Max length: 99999
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="suggested_action")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(99999)]
		public string Suggested_action { get; set; }
		
		/// <summary>
		/// The value of the field that caused the error
		/// Min length: 1
		/// Max length: 99999
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(99999)]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ErrorLocation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="body")]
		body = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="path")]
		path = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="query")]
		query = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Errors
	{
		
		/// <summary>
		/// Minimum items: 1
		/// Maximum items: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errors")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public Error[] Errors1 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FreeTrialNumbers
	{
		
		/// <summary>
		/// The recipient number(s) registered to your Free Trial Numbers List. These are the mobile numbers that you can message during the Free Trial.
		///
		/// Required
		/// Minimum items: 0
		/// Maximum items: 10
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="freeTrialNumbers")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(10)]
		public string[] FreeTrialNumbers1 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MessageGet
	{
		
		/// <summary>
		/// The time you submitted the message to the queue for sending.
		/// Min length: 24
		/// Max length: 24
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTimestamp")]
		[System.ComponentModel.DataAnnotations.MinLength(24)]
		[System.ComponentModel.DataAnnotations.MaxLength(24)]
		public System.Nullable<System.DateTimeOffset> CreateTimestamp { get; set; }
		
		/// <summary>
		/// If set to **true**, you will receive a notification to the statusCallbackUrl when your message is delivered (paid feature).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deliveryNotification")]
		public System.Nullable<System.Boolean> DeliveryNotification { get; set; }
		
		/// <summary>
		/// * **outgoing** – messages sent from your account.
		///* **incoming** – messages sent to your account.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public System.Nullable<MessageGetDirection> Direction { get; set; }
		
		/// <summary>
		/// This will be either "privateNumber", one of your Virtual Numbers or your senderName.
		/// Min length: 1
		/// Max length: 13
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(13)]
		public string From { get; set; }
		
		/// <summary>
		/// The content of the message.
		/// Min length: 1
		/// Max length: 1600
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="messageContent")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(1600)]
		public string MessageContent { get; set; }
		
		/// <summary>
		/// Use this UUID with our other endpoints to fetch, update or delete the message.
		/// Min length: 36
		/// Max length: 36
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="messageId")]
		[System.ComponentModel.DataAnnotations.MinLength(36)]
		[System.ComponentModel.DataAnnotations.MaxLength(36)]
		public string MessageId { get; set; }
		
		/// <summary>
		/// The multimedia content of the message (MMS only). It will include:
		///
		/// Minimum items: 1
		/// Maximum items: 5
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multimedia")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(5)]
		public MultimediaGet[] Multimedia { get; set; }
		
		/// <summary>
		/// The priority assigned to the message.
		/// Minimum: 1
		/// Maximum: 3
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queuePriority")]
		[System.ComponentModel.DataAnnotations.Range(1, 3)]
		public System.Nullable<System.Int32> QueuePriority { get; set; }
		
		/// <summary>
		/// The time the message was received by the recipient's device.
		/// Min length: 24
		/// Max length: 24
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="receivedTimestamp")]
		[System.ComponentModel.DataAnnotations.MinLength(24)]
		[System.ComponentModel.DataAnnotations.MaxLength(24)]
		public System.Nullable<System.DateTimeOffset> ReceivedTimestamp { get; set; }
		
		/// <summary>
		/// How many minutes you asked the server to keep trying to send the message.
		/// Minimum: 1
		/// Maximum: 1440
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retryTimeout")]
		[System.ComponentModel.DataAnnotations.Range(1, 1440)]
		public System.Nullable<System.Int32> RetryTimeout { get; set; }
		
		/// <summary>
		/// The time the message is scheduled to send.
		/// Min length: 10
		/// Max length: 24
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleSend")]
		[System.ComponentModel.DataAnnotations.MinLength(10)]
		[System.ComponentModel.DataAnnotations.MaxLength(24)]
		public System.Nullable<System.DateTimeOffset> ScheduleSend { get; set; }
		
		/// <summary>
		/// The time the message was sent from the server.
		/// Min length: 24
		/// Max length: 24
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sentTimestamp")]
		[System.ComponentModel.DataAnnotations.MinLength(24)]
		[System.ComponentModel.DataAnnotations.MaxLength(24)]
		public System.Nullable<System.DateTimeOffset> SentTimestamp { get; set; }
		
		/// <summary>
		/// The status will be either queued, sent, delivered, expired or undeliverable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<MessageGetStatus> Status { get; set; }
		
		/// <summary>
		/// The URL the API will call when the status of the message changes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusCallbackUrl")]
		public string StatusCallbackUrl { get; set; }
		
		/// <summary>
		/// Any customisable tags assigned to the message.
		/// Minimum items: 0
		/// Maximum items: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(10)]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// The recipient's mobile number.
		/// Min length: 5
		/// Max length: 16
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		[System.ComponentModel.DataAnnotations.MinLength(5)]
		[System.ComponentModel.DataAnnotations.MaxLength(16)]
		public string To { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MessageGetDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="outgoing")]
		outgoing = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="incoming")]
		incoming = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MultimediaGet
	{
		
		/// <summary>
		/// The name of the multimedia file.
		/// Required
		/// Min length: 1
		/// Max length: 100
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fileName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string FileName { get; set; }
		
		/// <summary>
		/// The type of multimedia content (image, audio or video) followed by the type (e.g. jpeg, png, text).
		/// Required
		/// Min length: 1
		/// Max length: 100
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MessageGetStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="queued")]
		queued = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sent")]
		sent = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="delivered")]
		delivered = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="expired")]
		expired = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="undeliverable")]
		undeliverable = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MessageSent
	{
		
		/// <summary>
		/// If set to **true**, you will receive a notification to the statusCallbackUrl when your SMS is delivered (paid feature).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deliveryNotification")]
		public System.Nullable<System.Boolean> DeliveryNotification { get; set; }
		
		/// <summary>
		/// This will be either "privateNumber", one of your Virtual Numbers or your senderName.
		/// Min length: 1
		/// Max length: 13
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(13)]
		public string From { get; set; }
		
		/// <summary>
		/// The content of the message.
		/// Min length: 1
		/// Max length: 1600
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="messageContent")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(1600)]
		public string MessageContent { get; set; }
		
		/// <summary>
		/// Use this UUID with our other endpoints to fetch, update or delete the message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="messageId")]
		public string[] MessageId { get; set; }
		
		/// <summary>
		/// The multimedia content of the message (MMS only). It will include:
		///
		/// Minimum items: 1
		/// Maximum items: 5
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multimedia")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(5)]
		public MultimediaGet[] Multimedia { get; set; }
		
		/// <summary>
		/// How many minutes you asked the server to keep trying to send the message.
		/// Minimum: 1
		/// Maximum: 1440
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retryTimeout")]
		[System.ComponentModel.DataAnnotations.Range(1, 1440)]
		public System.Nullable<System.Int32> RetryTimeout { get; set; }
		
		/// <summary>
		/// The time (in Central Standard Time) the message is scheduled to send.
		/// Min length: 10
		/// Max length: 24
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleSend")]
		[System.ComponentModel.DataAnnotations.MinLength(10)]
		[System.ComponentModel.DataAnnotations.MaxLength(24)]
		public System.Nullable<System.DateTimeOffset> ScheduleSend { get; set; }
		
		/// <summary>
		/// The status will be either queued, sent, delivered, expired or undeliverable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public MessageGetStatus Status { get; set; }
		
		/// <summary>
		/// The URL the API will call when the status of the message changes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusCallbackUrl")]
		public string StatusCallbackUrl { get; set; }
		
		/// <summary>
		/// Any customisable tags assigned to the message.
		/// Minimum items: 0
		/// Maximum items: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(10)]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// The recipient's mobile number(s).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string[] To { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MessageUpdate
	{
		
		/// <summary>
		/// If set to **true**, you will receive a notification to the statusCallbackUrl when your message is delivered (paid feature).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deliveryNotification")]
		public System.Nullable<System.Boolean> DeliveryNotification { get; set; }
		
		/// <summary>
		/// This will be either "privateNumber", one of your Virtual Numbers or your senderName.
		/// Min length: 1
		/// Max length: 13
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(13)]
		public string From { get; set; }
		
		/// <summary>
		/// The content of the message.
		/// Min length: 1
		/// Max length: 1600
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="messageContent")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(1600)]
		public string MessageContent { get; set; }
		
		/// <summary>
		/// Use this UUID with our other endpoints to fetch, update or delete the message.
		/// Min length: 36
		/// Max length: 36
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="messageId")]
		[System.ComponentModel.DataAnnotations.MinLength(36)]
		[System.ComponentModel.DataAnnotations.MaxLength(36)]
		public string MessageId { get; set; }
		
		/// <summary>
		/// The multimedia content of the message (MMS only). It will include:
		///
		/// Minimum items: 1
		/// Maximum items: 5
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multimedia")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(5)]
		public MultimediaGet[] Multimedia { get; set; }
		
		/// <summary>
		/// The priority assigned to the message.
		/// Minimum: 1
		/// Maximum: 3
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queuePriority")]
		[System.ComponentModel.DataAnnotations.Range(1, 3)]
		public System.Nullable<System.Int32> QueuePriority { get; set; }
		
		/// <summary>
		/// How many minutes you asked the server to keep trying to send the message.
		/// Minimum: 1
		/// Maximum: 1440
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retryTimeout")]
		[System.ComponentModel.DataAnnotations.Range(1, 1440)]
		public System.Nullable<System.Int32> RetryTimeout { get; set; }
		
		/// <summary>
		/// The time the message is scheduled to send.
		/// Min length: 10
		/// Max length: 24
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleSend")]
		[System.ComponentModel.DataAnnotations.MinLength(10)]
		[System.ComponentModel.DataAnnotations.MaxLength(24)]
		public System.Nullable<System.DateTimeOffset> ScheduleSend { get; set; }
		
		/// <summary>
		/// The status will be either queued, sent, delivered, expired or undeliverable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public MessageGetStatus Status { get; set; }
		
		/// <summary>
		/// The URL the API will call when the status of the message changes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusCallbackUrl")]
		public string StatusCallbackUrl { get; set; }
		
		/// <summary>
		/// Any customisable tags assigned to the message.
		/// Minimum items: 0
		/// Maximum items: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(10)]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// The recipient's mobile number.
		/// Min length: 5
		/// Max length: 16
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		[System.ComponentModel.DataAnnotations.MinLength(5)]
		[System.ComponentModel.DataAnnotations.MaxLength(16)]
		public string To { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Multimedia
	{
		
		/// <summary>
		/// The name of the multimedia file.
		/// Required
		/// Min length: 1
		/// Max length: 100
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fileName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string FileName { get; set; }
		
		/// <summary>
		/// The base64 encoded content. You can use [this online tool](https://elmah.io/tools/base64-image-encoder/) to encode an image, or [Base64 Guru](https://base64.guru/) to encode a video or audio file.
		///
		/// Required
		/// Min length: 1
		/// Max length: 999999
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="payload")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(999999)]
		public string Payload { get; set; }
		
		/// <summary>
		/// the type of multimedia content file you're sending (image, audio or video) followed by the file type. Use the format "multimedia type/file type", e.g. "image/PNG" or "audio/MP3". Supported file types:JPEG, BMP, GIF87a, GIF89a, PNG, MP3, WAV, MPEG, MPG, MP4, 3GP and US-ASCII.
		/// Required
		/// Min length: 1
		/// Max length: 100
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Recipient_optout
	{
		
		/// <summary>
		/// The date and time we received the optout request.
		/// Min length: 24
		/// Max length: 24
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTimestamp")]
		[System.ComponentModel.DataAnnotations.MinLength(24)]
		[System.ComponentModel.DataAnnotations.MaxLength(24)]
		public System.Nullable<System.DateTimeOffset> CreateTimestamp { get; set; }
		
		/// <summary>
		/// The mobile number that sent the optout request.
		/// Min length: 5
		/// Max length: 16
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="optoutNumber")]
		[System.ComponentModel.DataAnnotations.MinLength(5)]
		[System.ComponentModel.DataAnnotations.MaxLength(16)]
		public string OptoutNumber { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Virtual_number
	{
		
		/// <summary>
		/// The last time the Virtual Number was used to send a message.
		/// Min length: 24
		/// Max length: 24
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUse")]
		[System.ComponentModel.DataAnnotations.MinLength(24)]
		[System.ComponentModel.DataAnnotations.MaxLength(24)]
		public System.Nullable<System.DateTimeOffset> LastUse { get; set; }
		
		/// <summary>
		/// The URL that replies to the Virtual Number will be posted to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replyCallbackUrl")]
		public string ReplyCallbackUrl { get; set; }
		
		/// <summary>
		/// Any customisable tags assigned to the Virtual Number.
		///
		/// Minimum items: 0
		/// Maximum items: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(10)]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// The Virtual Number assigned to your account.
		///
		/// Min length: 10
		/// Max length: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualNumber")]
		[System.ComponentModel.DataAnnotations.MinLength(10)]
		[System.ComponentModel.DataAnnotations.MaxLength(10)]
		public string VirtualNumber { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MessagePost
	{
		
		/// <summary>
		/// To receive a notification when your SMS has been delivered, set this parameter to **true** and make sure you provide a **statusCallbackUrl** (paid feature).
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deliveryNotification")]
		public System.Nullable<System.Boolean> DeliveryNotification { get; set; }
		
		/// <summary>
		/// When the recipient receives your message, you can choose whether they'll see a privateNumber, virtualNumber or senderName (paid plans only) in the **from** field.  
		///
		///* privateNumber: Use this string to have the message appear on the recipient's device as from "anonymous", "private" or similar.  
		///* 04xxxxxxxx: Use one of the Virtual Numbers associated with your account. You'll also be able to receive SMS replies to this number. 
		///* senderName: Choose a unique alphanumeric string of up to 11 characters (paid feature).
		///
		/// Required
		/// Min length: 1
		/// Max length: 13
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="from")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(13)]
		public string From { get; set; }
		
		/// <summary>
		/// Use this field to send an SMS. Your text message goes here.   
		///
		///Note: either messageContent or multimedia are required, or you can use both field if you want to send multimedia with text.
		///
		/// Min length: 1
		/// Max length: 1600
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="messageContent")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(1600)]
		public string MessageContent { get; set; }
		
		/// <summary>
		/// Use this field to send an MMS. Add your image, video or audio content here. 
		///
		///Note: either messageContent or multimedia are required, or you can use both field if you want to send multimedia with text.
		///
		///Include a JSON payload with:
		///
		///type: the type of multimedia content file you're sending (image, audio or video) followed by the file type. Use the format "multimedia type/file type", e.g. "image/PNG" or "audio/MP3". Supported file types: JPEG, BMP, GIF87a, GIF89a, PNG, MP3, WAV, MPEG, MPG, MP4, 3GP and US-ASCII.
		///
		///fileName: the name of your multimedia file.
		///
		///payload: the base64 encoded content. You can use [this online tool](https://elmah.io/tools/base64-image-encoder/) to encode an image, or [Base64 Guru](https://base64.guru/) to encode a video or audio file.
		///
		/// Minimum items: 1
		/// Maximum items: 5
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multimedia")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(5)]
		public Multimedia[] Multimedia { get; set; }
		
		/// <summary>
		/// If the message is queued or unable to reach the recipient's device, tell us how many minutes the network should keep trying. Use an integer between 1 and 1440. If you don't set a value, we'll try for 10 minutes.
		///
		/// Minimum: 1
		/// Maximum: 1440
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retryTimeout")]
		[System.ComponentModel.DataAnnotations.Range(1, 1440)]
		public System.Nullable<System.Int32> RetryTimeout { get; set; }
		
		/// <summary>
		/// Don't want to send the message right away? Tell us what time you want to add it to the queue for sending instead.
		///
		///Set the time in London Greenwich Mean Time (adjusting for any time difference) and use ISO format, e.g. "2019-08-24T15:39:00Z".
		///
		///You can schedule a message up to 10 days into the future. If you specify a timestamp outside of this limit, the API will return a FIELD_INVALID error.
		///
		/// Min length: 10
		/// Max length: 24
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleSend")]
		[System.ComponentModel.DataAnnotations.MinLength(10)]
		[System.ComponentModel.DataAnnotations.MaxLength(24)]
		public System.Nullable<System.DateTimeOffset> ScheduleSend { get; set; }
		
		/// <summary>
		/// Tell us the URL you want the API to call when the status of your SMS updates. 
		///
		///To receive a status update, this field must be provided and deliveryNotification must be set to **true**. 
		///
		///The status will be either:  
		///* **queued** – the message is in the queue for sending (default).
		///* **sent** – your message has been sent from the server.
		///* **expired** – we weren't able to send the message within the **retryTimeout** timeframe.
		///* **delivered** – the message has successfully reached the recipient's device. Note that we will only be able to return this status if you set **deliveryNotification** to **true** (paid feature).
		///* **undeliverable** – the delivery of your message failed (paid feature).
		///
		///Sample callback response:
		///
		///<pre><code class="language-sh">{
		///  "to":"0476543210", 
		///  "from":"0401234567",  
		///  "timestamp":"2022-11-10T05:06:42.823Z", 
		///  "messageId":"1520b774-46b0-4415-a05f-7bcb1c032c59", 
		///  "status":"delivered" 
		///}</code></pre>
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusCallbackUrl")]
		public string StatusCallbackUrl { get; set; }
		
		/// <summary>
		/// Create your own tags and use them to fetch and sort your messages through our other endpoints. You can assign up to 10 tags per message.
		///
		/// Minimum items: 1
		/// Maximum items: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(10)]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// This is the mobile number you want to send your message to. Write Australian numbers in national format (e.g. 0412345678) and international numbers (paid plans only) in E.164 format (e.g. +441234567890). 
		///
		///Use a string for a single recipient, and an array of string of multiple recipients, e.g. "to": ["0412345678", "+441234567890"]. If you're using the Free Trial, you can include up to 5 recipient numbers in the array. If you're using a paid plan, you can bulk send up to 500 messages at once.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string[] To { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MessagePut
	{
		
		/// <summary>
		/// To receive a notification when your SMS has been delivered, set this parameter to **true** and make sure you provide a **statusCallbackUrl** (paid feature).
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deliveryNotification")]
		public System.Nullable<System.Boolean> DeliveryNotification { get; set; }
		
		/// <summary>
		/// When the recipient receives your message, you can choose whether they'll see a privateNumber, virtualNumber or senderName (paid plans only) in the **from** field.
		///
		///* privateNumber: Use this string to have the message appear on the recipient's device as from "anonymous", "private" or similar.
		///* 04xxxxxxxx: Use one of the Virtual Numbers associated with your account. You'll also be able to receive SMS replies to this number.
		///* senderName: Choose a unique alphanumeric string of up to 11 characters (paid feature).
		///
		/// Required
		/// Min length: 1
		/// Max length: 13
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="from")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(13)]
		public string From { get; set; }
		
		/// <summary>
		/// Use this field to send an SMS. Your text message goes here. 
		///
		///Note: either messageContent or multimedia are required, or you can use both field if you want to send multimedia with text.
		///
		/// Min length: 1
		/// Max length: 1600
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="messageContent")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(1600)]
		public string MessageContent { get; set; }
		
		/// <summary>
		/// Use this field to send an MMS. Add your image, video or audio content here. 
		///
		///Note: either messageContent or multimedia are required, or you can use both fields if you want to send multimedia with text. 
		///
		///Include a JSON payload with:
		///
		///type: the type of multimedia content file you're sending (image, audio or video) followed by the file type. Use the format 'multimedia type/file type', e.g. "image/PNG" or "audio/MP3". Supported file types: JPEG, BMP, GIF87a, GIF89a, PNG, MP3, WAV, MPEG, MPG, MP4, 3GP and US-ASCII.
		///
		///fileName: the name of your multimedia file. 
		///
		///payload: the base64 encoded content. You can use [this online tool](https://elmah.io/tools/base64-image-encoder/) to encode an image, or [Base64 Guru](https://base64.guru/) to encode a video or audio file.
		///
		/// Minimum items: 1
		/// Maximum items: 5
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multimedia")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(5)]
		public Multimedia[] Multimedia { get; set; }
		
		/// <summary>
		/// If the message is queued or unable to reach the recipient's device, tell us how many minutes the network should keep trying. Use an integer between 1 and 1440. If you don't set a value, we'll try for 10 minutes.
		///
		/// Minimum: 1
		/// Maximum: 1440
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retryTimeout")]
		[System.ComponentModel.DataAnnotations.Range(1, 1440)]
		public System.Nullable<System.Int32> RetryTimeout { get; set; }
		
		/// <summary>
		/// Don't want to send the message right away? Tell us what time you want to add it to the queue for sending instead.
		///
		///Set the time in London Greenwich Mean Time (adjusting for any time difference) and use ISO format, e.g. "2019-08-24T15:39:00Z".
		///
		///You can schedule a message up to 10 days into the future. If you specify a timestamp outside of this limit, the API will return a FIELD_INVALID error.
		///
		/// Min length: 10
		/// Max length: 24
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleSend")]
		[System.ComponentModel.DataAnnotations.MinLength(10)]
		[System.ComponentModel.DataAnnotations.MaxLength(24)]
		public System.Nullable<System.DateTimeOffset> ScheduleSend { get; set; }
		
		/// <summary>
		/// Tell us the URL you want the API to call when the status of your SMS updates. 
		///
		///To receive a status update, this field must be provided and deliveryNotification must be set to **true**. 
		///
		///The status will be either:  
		///* **queued** – the message is in the queue for sending (default).
		///* **sent** – your message has been sent from the server.
		///* **expired** – we weren't able to send the message within the **retryTimeout** timeframe.
		///* **delivered** – the message has successfully reached the recipient's device. Note that we will only be able to return this status if you set **deliveryNotification** to **true** (paid feature).
		///* **undeliverable** – the delivery of your message failed (paid feature).
		///
		///Sample callback response:
		///
		///<pre><code class="language-sh">{
		///  "to":"0476543210", 
		///  "from":"0401234567", 
		///  "timestamp":"2022-11-10T05:06:42.823Z", 
		///  "messageId":"1520b774-46b0-4415-a05f-7bcb1c032c59", 
		///  "status":"delivered" 
		///}</code></pre>
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusCallbackUrl")]
		public string StatusCallbackUrl { get; set; }
		
		/// <summary>
		/// Create your own tags and use them to fetch and sort your messages through our other endpoints. You can assign up to 10 tags per message.
		///
		/// Minimum items: 1
		/// Maximum items: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(10)]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// This is the mobile number you want to send your message to. Write Australian numbers in national format (e.g. 0412345678) and international numbers (paid plans only) in E.164 format (e.g. +441234567890).
		///
		///Use a string for a single recipient, and an array of strings for multiple recipients, e.g. "to": ["0412345678", "+441234567890"]. If you're using the Free Trial, you can include up to 5 recipient numbers in the array. If you're using a paid plan, you can bulk send up to 500 messages at once.
		///
		/// Required
		/// Min length: 5
		/// Max length: 16
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="to")]
		[System.ComponentModel.DataAnnotations.MinLength(5)]
		[System.ComponentModel.DataAnnotations.MaxLength(16)]
		public string To { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MessageTags
	{
		
		/// <summary>
		/// Write the updated list of tag(s) here. You can assign up to 10 tags per message.
		///
		///Note that if you provide an empty array, any pre-existing tags will be wiped.
		///
		/// Required
		/// Minimum items: 0
		/// Maximum items: 10
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(10)]
		public string[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NumberPost
	{
		
		/// <summary>
		/// Tell us the URL that replies to the Virtual Number should be sent to.
		///
		///Sample callback response:
		///
		///<pre><code class="language-sh">{
		///  "to":"0476543210", 
		///  "from":"0401234567", 
		///  "timestamp":"2022-11-10T05:06:42.823Z", 
		///  "messageId":"75f263c0-60b5-11ed-8456-71ae4c63550d", 
		///  "messageContent":"Hi, example message", 
		///  "multimedia": { 
		///    "fileName:"image.jpeg" 
		///    "type:"image/jpeg" 
		///    "payload":"base64 payload"
		///  }
		///}</code></pre>
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replyCallbackUrl")]
		public string ReplyCallbackUrl { get; set; }
		
		/// <summary>
		/// Create your own tags and use them to fetch, sort and report on your Virtual Numbers through our other endpoints. You can assign up to 10 tags per number.
		///
		/// Minimum items: 1
		/// Maximum items: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(10)]
		public string[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NumberPut
	{
		
		/// <summary>
		/// Tell us the URL that replies to the Virtual Number should be sent to.
		///
		///Note that if you don't include this field, any pre-existing replyCallbackUrl will be wiped.
		///
		///Sample callback response:
		///
		///<pre><code class="language-sh">{
		///  "to":"0476543210", 
		///  "from":"0401234567", 
		///  "timestamp":"2022-11-10T05:06:42.823Z",
		///  "messageId":"75f263c0-60b5-11ed-8456-71ae4c63550d", 
		///  "messageContent":"Hi, example message", 
		///  "multimedia": { 
		///    "fileName:"image.jpeg" 
		///    "type:"image/jpeg" 
		///    "payload":"base64 payload" 
		///  }
		///}</code></pre>
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replyCallbackUrl")]
		public string ReplyCallbackUrl { get; set; }
		
		/// <summary>
		/// Create your own tags and use them to fetch, sort and report on your Virtual Numbers through our other endpoints. You can assign up to 10 tags per number. 
		///
		///Note that if you don't include this field, any pre-existing tags will be wiped.
		///
		/// Minimum items: 1
		/// Maximum items: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(10)]
		public string[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Trial_numbers
	{
		
		/// <summary>
		/// These are the mobile numbers you want to message during your Free Trial. Write Australian numbers in national format (e.g. "0412345678"). Use a string for a single recipient, and an array of strings for multiple recipients, (e.g. ["0412345678", "0487654321"]).
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="freeTrialNumbers")]
		public string[] FreeTrialNumbers { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// get all free trial numbers
		/// Use this endpoint to fetch the Free Trial Number(s) currently assigned to your account. These are the mobile numbers that you can message during the Free Trial.
		/// 
		/// If you're using a paid plan, there's no limit to the number of recipients that you can message, so you don't need to register Free Trial Numbers.
		/// 
		/// GetTrialNumbers free-trial-numbers
		/// </summary>
		/// <returns>A 200 OK response means your request has been successful. Your Free Trial Number(s) will be returned in the response body.
		///</returns>
		public async Task<FreeTrialNumbers> GetTrialNumbersAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "free-trial-numbers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FreeTrialNumbers>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// create free trial number list
		/// Your Free Trial Numbers are the 10 recipient mobile numbers that you can message during the Free Trial. The first five numbers you send an SMS/MMS to will automatically be added to your Free Trial Numbers list. After that, you can use this endpoint to register another five. Alternatively, you can use this endpoint to register all 10 numbers.
		/// 
		/// Use this endpoint to register a Free Trial Number to your account. To test out all the features that the trial has to offer, we recommend registering your own mobile number to your Free Trial Numbers list.
		/// 
		/// Note that you can only message mobile numbers that have been added to your Free Trial list and once registered, a Free Trial Number cannot be removed or replaced.
		/// 
		/// CreateTrialNumbers free-trial-numbers
		/// </summary>
		public async Task CreateTrialNumbersAsync(Trial_numbers requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "free-trial-numbers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// health check
		/// Use this endpoint to check the operational status of the messaging service. A 200 OK response means the service is up. If you receive a 504 response, the service is temporarily down. Check the [API Live Status page] (https://dev.telstra.com/api/status) to see if there's an active incident.
		/// HealthCheck health-check
		/// </summary>
		/// <returns>A 200 OK response means the messaging service is up.</returns>
		public async Task<HealthCheckReturn> HealthCheckAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "health-check";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HealthCheckReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// fetch all sent/received messages
		/// Fetch messages that have been sent from/to your account in the last 30 days.
		/// GetMessages messages
		/// </summary>
		/// <param name="limit">Tell us how many results you want us to return, up to a maximum of 50.
		///
		/// Minimum: 1
		/// Maximum: 50
		// </param>
		/// <param name="offset">Use the offset to navigate between the response results. An offset of 0 will display the first page of results, and so on.
		///
		/// Minimum: 0
		/// Maximum: 999999
		// </param>
		/// <param name="direction">Filter your messages by direction:
		///* **outgoing** – messages sent from your account.
		///* **incoming** – messages sent to your account.
		///</param>
		/// <param name="status">Filter your messages by one of the statuses below:
		///
		///* **queued** – messages queued for sending or still in transit.
		///* **sent** – messages that have been sent from the server.
		///* **delivered** – messages successful delivered to the recipient's device. Note that we will only be able to return this status if you set deliveryNotification to **true** (paid feature). 
		///* **expired** – message that couldn't be sent within the **retryTimeout** timeframe.
		///</param>
		/// <param name="filter">Filter your messages by:
		///
		///* tag - use one of the tags assigned to your message(s)
		///* number - either the Virtual Number used to send the message, or the Recipient Number the message was sent to.
		///</param>
		/// <returns>A 200 response means the call has been successful.
		///</returns>
		public async Task<GetMessagesReturn> GetMessagesAsync(int limit, int offset, MessageGetDirection direction, GetMessagesStatus status, string filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "messages?limit="+limit+"&offset="+offset+"&direction=" + direction+"&status=" + status+"&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetMessagesReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// send messages
		/// Send an SMS/MMS to a mobile number, or to multiple mobile numbers.
		/// 
		/// Free Trial users can message to up to 10 unique recipient numbers for free. The first five recipients will be automatically added to your Free Trial Numbers list. Need more? Just use the POST /free-trial-numbers call to add another five.
		/// 
		/// SendMessages messages
		/// </summary>
		public async Task SendMessagesAsync(MessagePost requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "messages";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// delete a message
		/// Use this endpoint to delete a message that's been scheduled for sending, but hasn't yet sent.
		/// 
		/// DeleteMessageById messages/{messageId}
		/// </summary>
		/// <param name="messageId">When you sent the original message, this is the UUID that was returned in the call response. Use this ID to fetch, update or delete a message with the appropriate endpoints.
		///
		/// Min length: 36
		/// Max length: 36
		// </param>
		public async Task DeleteMessageByIdAsync(string messageId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "messages/"+ (messageId==null? "" : System.Uri.EscapeDataString(messageId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// fetch a specific message
		/// Use the **messageId** to fetch a message that's been sent from/to your account within the last 30 days.
		/// 
		/// GetMessageById messages/{messageId}
		/// </summary>
		/// <param name="messageId">When you sent the original message, this is the UUID that was returned in the response. Use this ID to fetch, update or delete a message with the appropriate endpoints. 
		///
		///Incoming messages are also assigned a messageId. Use this ID with GET/ messages/{messageId} to fetch the message later.
		///
		/// Min length: 36
		/// Max length: 36
		// </param>
		/// <returns>A 200 response means the call has been successful.
		///</returns>
		public async Task<MessageGet> GetMessageByIdAsync(string messageId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "messages/"+ (messageId==null? "" : System.Uri.EscapeDataString(messageId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MessageGet>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// update message tags
		/// Use the **messageId** to update the tag(s) assigned to a message. You can use this endpoint any time, even after your message has been delivered.
		/// 
		/// UpdateMessageTags messages/{messageId}
		/// </summary>
		/// <param name="messageId">When you sent the original message, this is the UUID that was returned in the call response. Use this ID to fetch, update or delete a message with the appropriate endpoints.
		///
		/// Min length: 36
		/// Max length: 36
		// </param>
		public async Task UpdateMessageTagsAsync(string messageId, MessageTags requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "messages/"+ (messageId==null? "" : System.Uri.EscapeDataString(messageId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// update a message
		/// Need to update a message that's scheduled for sending? You can change any of the below parameters, as long as the message hasn't been sent yet. This request body will override the original POST/ messages call.
		/// 
		/// UpdateMessageById messages/{messageId}
		/// </summary>
		/// <param name="messageId">When you sent the original message, this is the UUID that was returned in the call response. Use this ID to fetch, update or delete a message with the appropriate endpoints.
		///
		/// Min length: 36
		/// Max length: 36
		// </param>
		/// <returns>A 200 response means the call has been successful.
		///</returns>
		public async Task<MessageUpdate> UpdateMessageByIdAsync(string messageId, MessagePut requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "messages/"+ (messageId==null? "" : System.Uri.EscapeDataString(messageId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MessageUpdate>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// fetch all reports
		/// Fetch details of all reports recently generated for your account. Use it to check the status of a report, plus fetch the report ID, status, report type and expiry date.
		/// 
		/// GetReports reports
		/// </summary>
		/// <returns>A 200 OK response means the call has been successful. Details of any report(s) generated for your account will be returned in the response.
		///</returns>
		public async Task<object> GetReportsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "reports";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<object>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// submit a request for a messages report
		/// Request a CSV report of messages (both incoming and outgoing) that have been sent to/from your account within the last three months. You can request details for a specific timeframe, and filter your messages by tags, recipient number or Virtual Number.
		/// 
		/// A 201 Created means your report has been queued for generation. Make a note of the reportId returned in the response. You'll need this to check the status of your report and fetch your download link with GET reports/{reportId}. If you supplied a reportCallbackUrl in the request we'll also notify it when your report is ready for download.
		/// 
		/// Once your report is generated, it will be available for download for one week. The expiry date is returned in the response.
		/// 
		/// MessagesReport reports/messages
		/// </summary>
		public async Task MessagesReportAsync(MessagesReportPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "reports/messages";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// fetch a specific report
		/// Fetch a download link for a report generated with POST /reports/{reportId} using the **reportId** returned in the response. Once ready, your report will be available for download for one week.
		/// 
		/// GetReport reports/{reportId}
		/// </summary>
		/// <param name="reportId">Use the reportId returned in the POST /reports/{reportType} response.
		///
		/// Min length: 36
		/// Max length: 36
		// </param>
		/// <returns>A 200 OK response means the call has been successful. Your download link (reportUrl) will be returned in the response.
		///</returns>
		public async Task<GetReportReturn> GetReportAsync(string reportId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "reports/"+ (reportId==null? "" : System.Uri.EscapeDataString(reportId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetReportReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// fetch all virtual numbers
		/// Use this endpoint to fetch all Virtual Numbers currently assigned to your account.
		/// 
		/// GetNumbers virtual-numbers
		/// </summary>
		/// <param name="limit">Tell us how many results you want us to return, up to a maximum of 50.
		///
		/// Minimum: 1
		/// Maximum: 50
		// </param>
		/// <param name="offset">Use the offset to navigate between the response results. An offset of 0 will display the first page of results, and so on.
		///
		/// Minimum: 0
		/// Maximum: 999999
		// </param>
		/// <param name="filter">Filter your Virtual Numbers by tag or by number.</param>
		/// <returns>A 200 OK response means your request has been successful. Your Virtual Number(s) will be returned in the response body.
		///</returns>
		public async Task<string> GetNumbersAsync(int limit, int offset, string filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "virtual-numbers?limit="+limit+"&offset="+offset+"&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// assign a virtual number
		/// When a recipient receives your message, you can choose whether they'll see a privateNumber, Virtual Number or senderName (paid plans only) in the **from** field. If you want to use a Virtual Number, use this endpoint to assign one. Free Trial users can assign one Virtual Number, and those on a paid plan can assign up to 100.
		/// 
		/// Virtual Numbers that have not sent a message in 30 days (Free Trial) or sent/received a message in 18 months (paid plans) will be automatically unassigned from your account. You can check the **lastUse** date of your Virtual Number at any time using GET /virtual-numbers/{virtual-number}.
		/// 
		/// Note that Virtual Numbers used in v2 of the Messaging API cannot be used to send messages in v3. Please assign a new Virtual Number instead.
		/// 
		/// AssignNumber virtual-numbers
		/// </summary>
		public async Task AssignNumberAsync(NumberPost requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "virtual-numbers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// delete a virtual number
		/// Use **virtual-number** to remove a Virtual Number that's been assigned to your account.
		/// 
		/// DeleteNumber virtual-numbers/{virtual_number}
		/// </summary>
		/// <param name="virtual_number">Write the Virtual Number here, using national format (e.g. 0412345678).
		///
		/// Min length: 10
		/// Max length: 10
		// </param>
		public async Task DeleteNumberAsync(string virtual_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "virtual-numbers/{virtual_number}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// fetch a virtual number
		/// Fetch the tags, replyCallbackUrl and lastUse date for a Virtual Number.
		/// GetVirtualNumber virtual-numbers/{virtual_number}
		/// </summary>
		/// <param name="virtual_number">Write the Virtual Number here, using national format (e.g. 0412345678).
		///
		/// Min length: 10
		/// Max length: 10
		// </param>
		/// <returns>A 200 OK response means your request has been successful.
		///</returns>
		public async Task<Virtual_number> GetVirtualNumberAsync(string virtual_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "virtual-numbers/{virtual_number}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Virtual_number>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// update a virtual number
		/// Use **virtual-number** to update the tags and/or replyCallbackUrl of a Virtual Number.
		/// 
		/// This request body will override the original POST/ virtual-numbers call.
		/// 
		/// UpdateNumber virtual-numbers/{virtual_number}
		/// </summary>
		/// <param name="virtual_number">Write the Virtual Number here, using national format (e.g. 0412345678).
		///
		/// Min length: 10
		/// Max length: 10
		// </param>
		/// <returns>A 200 OK response means metadata for the Virtual Number has been successfully updated.
		///</returns>
		public async Task<Virtual_number> UpdateNumberAsync(string virtual_number, NumberPut requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "virtual-numbers/{virtual_number}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Virtual_number>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get recipient optouts list
		/// Use this endpoint to fetch any mobile number(s) that have opted out of receiving messages from a Virtual Number assigned to your account.
		/// 
		/// Recipients can opt out at any time by sending a message with industry standard keywords such as STOP, STOPALL, UNSUBSCRIBE, QUIT, END and CANCEL.
		/// 
		/// GetRecipientOptouts virtual-numbers/{virtual_number}/optouts
		/// </summary>
		/// <param name="limit">Tell us how many results you want us to return, up to a maximum of 50.
		///
		/// Minimum: 1
		/// Maximum: 50
		// </param>
		/// <param name="offset">Use the offset to navigate between the response results. An offset of 0 will display the first page of results, and so on.
		///
		/// Minimum: 0
		/// Maximum: 999999
		// </param>
		/// <param name="virtual_number">Write the Virtual Number here, using national format (e.g. 0412345678).
		///
		/// Min length: 10
		/// Max length: 10
		// </param>
		/// <returns>Successful Response</returns>
		public async Task<string> GetRecipientOptoutsAsync(int limit, int offset, string virtual_number, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "virtual-numbers/{virtual_number}/optouts?limit="+limit+"&offset="+offset;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public class HealthCheckReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	public enum GetMessagesStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="queued")]
		queued = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sent")]
		sent = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="delivered")]
		delivered = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="expired")]
		expired = 3,
	}
	
	public class GetMessagesReturn
	{
		
		/// <summary>
		/// The paginated results of your request. To fetch the next set of results, send another request and provide the succeeding offset value.
		///
		/// Minimum items: 1
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="messages")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public MessageGet[] Messages { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="paging")]
		public GetMessagesReturnPaging Paging { get; set; }
	}
	
	public class GetMessagesReturnPaging
	{
		
		/// <summary>
		/// The last page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastPage")]
		public string LastPage { get; set; }
		
		/// <summary>
		/// The next page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPage")]
		public string NextPage { get; set; }
		
		/// <summary>
		/// The previous page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="previousPage")]
		public string PreviousPage { get; set; }
		
		/// <summary>
		/// The total number of pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalCount")]
		public System.Nullable<System.Double> TotalCount { get; set; }
	}
	
	public class MessagesReportPostBody
	{
		
		/// <summary>
		/// Type the end date (inclusive) of your reporting period here.
		///
		///Your endDate must be a date in the past, and less than three months from your startDate. Use ISO format(yyyy-mm-dd).
		///
		/// Required
		/// Min length: 10
		/// Max length: 10
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endDate")]
		[System.ComponentModel.DataAnnotations.MinLength(10)]
		[System.ComponentModel.DataAnnotations.MaxLength(10)]
		public System.DateOnly EndDate { get; set; }
		
		/// <summary>
		/// Filter your messages report by:
		///  * tag - use one of the tags assigned to your message(s)
		///  * number - either the Virtual Number used to send the message, or the Recipient Number the message was sent to.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filter")]
		public string Filter { get; set; }
		
		/// <summary>
		/// Tell us the callbackUrl you want us to notify when your report is ready for download.
		///
		///Sample callback response:
		///
		///<pre><code class="language-sh">{
		///  "reportId":"1520b774-46b0-4415-a05f-7bcb1c032c59",
		///  "reportStatus":"completed",
		///  "timestamp":"2022-11-10T05:06:42.823Z"
		///}</code></pre>
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reportCallbackUrl")]
		public string ReportCallbackUrl { get; set; }
		
		/// <summary>
		/// Set the time period you want to generate a report for by typing the start date (inclusive) here.
		///
		///Note that we only retain data for three months, so please ensure your startDate is not more than three months old.
		///
		///Use ISO format(yyyy-mm-dd), e.g. 2019-08-24.
		///
		/// Required
		/// Min length: 10
		/// Max length: 10
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startDate")]
		[System.ComponentModel.DataAnnotations.MinLength(10)]
		[System.ComponentModel.DataAnnotations.MaxLength(10)]
		public System.DateOnly StartDate { get; set; }
	}
	
	public class GetReportReturn
	{
		
		/// <summary>
		/// The UUID assigned to your report.
		///
		/// Min length: 36
		/// Max length: 36
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reportId")]
		[System.ComponentModel.DataAnnotations.MinLength(36)]
		[System.ComponentModel.DataAnnotations.MaxLength(36)]
		public string ReportId { get; set; }
		
		/// <summary>
		/// The status of the report. It will be either: 
		///      * **queued** – the report is in the queue for generation. 
		///      * **completed** – the report is ready for download. 
		///      * **failed** – the report failed to generate. Please try again.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reportStatus")]
		public string ReportStatus { get; set; }
		
		/// <summary>
		/// Use this link to download your CSV file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reportUrl")]
		public string ReportUrl { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
