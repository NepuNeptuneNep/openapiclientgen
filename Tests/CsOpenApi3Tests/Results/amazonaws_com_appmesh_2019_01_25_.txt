//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateGatewayRouteOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gatewayRoute")]
		public GatewayRouteData GatewayRoute { get; set; }
	}
	
	/// <summary>
	/// An object that represents a gateway route returned by a describe operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GatewayRouteData
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gatewayRouteName")]
		public string GatewayRouteName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshName")]
		public string MeshName { get; set; }
		
		/// <summary>
		/// An object that represents metadata for a resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public ResourceMetadata Metadata { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public GatewayRouteSpec Spec { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public GatewayRouteStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualGatewayName")]
		public string VirtualGatewayName { get; set; }
	}
	
	/// <summary>
	/// An object that represents metadata for a resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceMetadata
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lastUpdatedAt")]
		public System.DateTimeOffset LastUpdatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshOwner")]
		public string MeshOwner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceOwner")]
		public string ResourceOwner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="uid")]
		public string Uid { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public int Version { get; set; }
	}
	
	/// <summary>
	/// An object that represents a gateway route specification. Specify one gateway route type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GatewayRouteSpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="grpcRoute")]
		public GrpcGatewayRoute GrpcRoute { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="http2Route")]
		public HttpGatewayRoute Http2Route { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="httpRoute")]
		public HttpGatewayRoute HttpRoute { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public System.Nullable<System.Int32> Priority { get; set; }
	}
	
	/// <summary>
	/// An object that represents a gRPC gateway route.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GrpcGatewayRoute
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action")]
		public GrpcGatewayRouteAction Action { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="match")]
		public GrpcGatewayRouteMatch Match { get; set; }
	}
	
	/// <summary>
	/// An object that represents the action to take if a match is determined.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GrpcGatewayRouteAction
	{
		
		[System.Runtime.Serialization.DataMember(Name="rewrite")]
		public GrpcGatewayRouteRewrite Rewrite { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public GatewayRouteTarget Target { get; set; }
	}
	
	/// <summary>
	/// An object that represents the gateway route to rewrite.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GrpcGatewayRouteRewrite
	{
		
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public GatewayRouteHostnameRewrite Hostname { get; set; }
	}
	
	/// <summary>
	/// An object representing the gateway route host name to rewrite.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GatewayRouteHostnameRewrite
	{
		
		[System.Runtime.Serialization.DataMember(Name="defaultTargetHostname")]
		public DefaultGatewayRouteRewrite DefaultTargetHostname { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DefaultGatewayRouteRewrite
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ENABLED")]
		ENABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DISABLED")]
		DISABLED = 1,
	}
	
	/// <summary>
	/// An object that represents a gateway route target.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GatewayRouteTarget
	{
		
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualService")]
		public GatewayRouteVirtualService VirtualService { get; set; }
	}
	
	/// <summary>
	/// An object that represents the virtual service that traffic is routed to.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GatewayRouteVirtualService
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualServiceName")]
		public string VirtualServiceName { get; set; }
	}
	
	/// <summary>
	/// An object that represents the criteria for determining a request match.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GrpcGatewayRouteMatch
	{
		
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public GatewayRouteHostnameMatch Hostname { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public GrpcGatewayRouteMetadata[] Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="serviceName")]
		public string ServiceName { get; set; }
	}
	
	/// <summary>
	/// An object representing the gateway route host name to match.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GatewayRouteHostnameMatch
	{
		
		[System.Runtime.Serialization.DataMember(Name="exact")]
		public string Exact { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="suffix")]
		public string Suffix { get; set; }
	}
	
	/// <summary>
	/// An object representing the metadata of the gateway route.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GrpcGatewayRouteMetadata
	{
		
		[System.Runtime.Serialization.DataMember(Name="invert")]
		public System.Nullable<System.Boolean> Invert { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="match")]
		public GrpcMetadataMatchMethod Match { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// An object representing the method header to be matched.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GrpcMetadataMatchMethod
	{
		
		[System.Runtime.Serialization.DataMember(Name="exact")]
		public string Exact { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
		
		/// <summary>
		/// An object that represents the range of values to match on. The first character of the range is included in the range, though the last character is not. For example, if the range specified were 1-100, only values 1-99 would be matched.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="range")]
		public MatchRange Range { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regex")]
		public string Regex { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="suffix")]
		public string Suffix { get; set; }
	}
	
	/// <summary>
	/// An object that represents the range of values to match on. The first character of the range is included in the range, though the last character is not. For example, if the range specified were 1-100, only values 1-99 would be matched.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MatchRange
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="end")]
		public int End { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start")]
		public int Start { get; set; }
	}
	
	/// <summary>
	/// An object that represents an HTTP gateway route.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpGatewayRoute
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action")]
		public HttpGatewayRouteAction Action { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="match")]
		public HttpGatewayRouteMatch Match { get; set; }
	}
	
	/// <summary>
	/// An object that represents the action to take if a match is determined.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpGatewayRouteAction
	{
		
		[System.Runtime.Serialization.DataMember(Name="rewrite")]
		public HttpGatewayRouteRewrite Rewrite { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public GatewayRouteTarget Target { get; set; }
	}
	
	/// <summary>
	/// An object representing the gateway route to rewrite.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpGatewayRouteRewrite
	{
		
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public GatewayRouteHostnameRewrite Hostname { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public HttpGatewayRoutePathRewrite Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public HttpGatewayRoutePrefixRewrite Prefix { get; set; }
	}
	
	/// <summary>
	/// An object that represents the path to rewrite.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpGatewayRoutePathRewrite
	{
		
		[System.Runtime.Serialization.DataMember(Name="exact")]
		public string Exact { get; set; }
	}
	
	/// <summary>
	/// An object representing the beginning characters of the route to rewrite.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpGatewayRoutePrefixRewrite
	{
		
		[System.Runtime.Serialization.DataMember(Name="defaultPrefix")]
		public DefaultGatewayRouteRewrite DefaultPrefix { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// An object that represents the criteria for determining a request match.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpGatewayRouteMatch
	{
		
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public HttpGatewayRouteHeader[] Headers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public GatewayRouteHostnameMatch Hostname { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="method")]
		public HttpMethod_ Method { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public HttpPathMatch Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="queryParameters")]
		public HttpQueryParameter[] QueryParameters { get; set; }
	}
	
	/// <summary>
	/// An object that represents the HTTP header in the gateway route.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpGatewayRouteHeader
	{
		
		[System.Runtime.Serialization.DataMember(Name="invert")]
		public System.Nullable<System.Boolean> Invert { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="match")]
		public HeaderMatchMethod Match { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// An object that represents the method and value to match with the header value sent in a request. Specify one match method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HeaderMatchMethod
	{
		
		[System.Runtime.Serialization.DataMember(Name="exact")]
		public string Exact { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="range")]
		public MatchRange Range { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regex")]
		public string Regex { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="suffix")]
		public string Suffix { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum HttpMethod_
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GET")]
		GET = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HEAD")]
		HEAD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="POST")]
		POST = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PUT")]
		PUT = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETE")]
		DELETE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CONNECT")]
		CONNECT = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OPTIONS")]
		OPTIONS = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TRACE")]
		TRACE = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PATCH")]
		PATCH = 8,
	}
	
	/// <summary>
	/// An object representing the path to match in the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpPathMatch
	{
		
		[System.Runtime.Serialization.DataMember(Name="exact")]
		public string Exact { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regex")]
		public string Regex { get; set; }
	}
	
	/// <summary>
	/// An object that represents the query parameter in the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpQueryParameter
	{
		
		[System.Runtime.Serialization.DataMember(Name="match")]
		public QueryParameterMatch Match { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// An object representing the query parameter to match.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class QueryParameterMatch
	{
		
		[System.Runtime.Serialization.DataMember(Name="exact")]
		public string Exact { get; set; }
	}
	
	/// <summary>
	/// An object that represents the current status of a gateway route.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GatewayRouteStatus
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public GatewayRouteStatusCode Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum GatewayRouteStatusCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INACTIVE")]
		INACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETED")]
		DELETED = 2,
	}
	
	/// <summary>
	/// Optional metadata that you apply to a resource to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagRef
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotFoundException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BadRequestException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConflictException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TooManyRequestsException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ForbiddenException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServiceUnavailableException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InternalServerErrorException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LimitExceededException
	{
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateMeshOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mesh")]
		public MeshData Mesh { get; set; }
	}
	
	/// <summary>
	/// An object that represents a service mesh returned by a describe operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MeshData
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshName")]
		public string MeshName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public ResourceMetadata Metadata { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public MeshSpec Spec { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public MeshStatus Status { get; set; }
	}
	
	/// <summary>
	/// An object that represents the specification of a service mesh.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MeshSpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="egressFilter")]
		public EgressFilter EgressFilter { get; set; }
		
		/// <summary>
		/// An object that represents the service discovery information for a service mesh.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceDiscovery")]
		public MeshServiceDiscovery ServiceDiscovery { get; set; }
	}
	
	/// <summary>
	/// An object that represents the egress filter rules for a service mesh.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EgressFilter
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public EgressFilterType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum EgressFilterType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ALLOW_ALL")]
		ALLOW_ALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DROP_ALL")]
		DROP_ALL = 1,
	}
	
	/// <summary>
	/// An object that represents the service discovery information for a service mesh.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MeshServiceDiscovery
	{
		
		[System.Runtime.Serialization.DataMember(Name="ipPreference")]
		public IpPreference IpPreference { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum IpPreference
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IPv6_PREFERRED")]
		IPv6_PREFERRED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IPv4_PREFERRED")]
		IPv4_PREFERRED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IPv4_ONLY")]
		IPv4_ONLY = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IPv6_ONLY")]
		IPv6_ONLY = 3,
	}
	
	/// <summary>
	/// An object that represents the status of a service mesh.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MeshStatus
	{
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public GatewayRouteStatusCode Status { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateRouteOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="route")]
		public RouteData Route { get; set; }
	}
	
	/// <summary>
	/// An object that represents a route returned by a describe operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouteData
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshName")]
		public string MeshName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public ResourceMetadata Metadata { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="routeName")]
		public string RouteName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public RouteSpec Spec { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public RouteStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualRouterName")]
		public string VirtualRouterName { get; set; }
	}
	
	/// <summary>
	/// An object that represents a route specification. Specify one route type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouteSpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="grpcRoute")]
		public GrpcRoute GrpcRoute { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="http2Route")]
		public HttpRoute Http2Route { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="httpRoute")]
		public HttpRoute HttpRoute { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public System.Nullable<System.Int32> Priority { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tcpRoute")]
		public TcpRoute TcpRoute { get; set; }
	}
	
	/// <summary>
	/// An object that represents a gRPC route type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GrpcRoute
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action")]
		public GrpcRouteAction Action { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="match")]
		public GrpcRouteMatch Match { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="retryPolicy")]
		public GrpcRetryPolicy RetryPolicy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public GrpcTimeout Timeout { get; set; }
	}
	
	/// <summary>
	/// An object that represents the action to take if a match is determined.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GrpcRouteAction
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="weightedTargets")]
		public WeightedTarget[] WeightedTargets { get; set; }
	}
	
	/// <summary>
	/// An object that represents a target and its relative weight. Traffic is distributed across targets according to their relative weight. For example, a weighted target with a relative weight of 50 receives five times as much traffic as one with a relative weight of 10. The total weight for all targets combined must be less than or equal to 100.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class WeightedTarget
	{
		
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualNode")]
		public string VirtualNode { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="weight")]
		public int Weight { get; set; }
	}
	
	/// <summary>
	/// An object that represents the criteria for determining a request match.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GrpcRouteMatch
	{
		
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public GrpcRouteMetadata[] Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="methodName")]
		public string MethodName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="serviceName")]
		public string ServiceName { get; set; }
	}
	
	/// <summary>
	/// An object that represents the match metadata for the route.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GrpcRouteMetadata
	{
		
		[System.Runtime.Serialization.DataMember(Name="invert")]
		public System.Nullable<System.Boolean> Invert { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="match")]
		public GrpcRouteMetadataMatchMethod Match { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// An object that represents the match method. Specify one of the match values.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GrpcRouteMetadataMatchMethod
	{
		
		[System.Runtime.Serialization.DataMember(Name="exact")]
		public string Exact { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="range")]
		public MatchRange Range { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regex")]
		public string Regex { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="suffix")]
		public string Suffix { get; set; }
	}
	
	/// <summary>
	/// An object that represents a retry policy. Specify at least one value for at least one of the types of <code>RetryEvents</code>, a value for <code>maxRetries</code>, and a value for <code>perRetryTimeout</code>. Both <code>server-error</code> and <code>gateway-error</code> under <code>httpRetryEvents</code> include the Envoy <code>reset</code> policy. For more information on the <code>reset</code> policy, see the <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on">Envoy documentation</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GrpcRetryPolicy
	{
		
		[System.Runtime.Serialization.DataMember(Name="grpcRetryEvents")]
		public GrpcRetryPolicyEvent[] GrpcRetryEvents { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="httpRetryEvents")]
		public string[] HttpRetryEvents { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxRetries")]
		public int MaxRetries { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="perRetryTimeout")]
		public Duration PerRetryTimeout { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tcpRetryEvents")]
		public TcpRetryPolicyEvent[] TcpRetryEvents { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum GrpcRetryPolicyEvent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cancelled")]
		cancelled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="deadline-exceeded")]
		deadlineMinusexceeded = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="internal")]
		_internal = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="resource-exhausted")]
		resourceMinusexhausted = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unavailable")]
		unavailable = 4,
	}
	
	/// <summary>
	/// An object that represents a duration of time.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Duration
	{
		
		[System.Runtime.Serialization.DataMember(Name="unit")]
		public DurationUnit Unit { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Int32> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DurationUnit
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="s")]
		s = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ms")]
		ms = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TcpRetryPolicyEvent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="connection-error")]
		connectionMinuserror = 0,
	}
	
	/// <summary>
	/// An object that represents types of timeouts. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GrpcTimeout
	{
		
		[System.Runtime.Serialization.DataMember(Name="idle")]
		public Duration Idle { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="perRequest")]
		public Duration PerRequest { get; set; }
	}
	
	/// <summary>
	/// An object that represents an HTTP or HTTP/2 route type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpRoute
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action")]
		public HttpRouteAction Action { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="match")]
		public HttpRouteMatch Match { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="retryPolicy")]
		public HttpRetryPolicy RetryPolicy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public HttpTimeout Timeout { get; set; }
	}
	
	/// <summary>
	/// An object that represents the action to take if a match is determined.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpRouteAction
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="weightedTargets")]
		public WeightedTarget[] WeightedTargets { get; set; }
	}
	
	/// <summary>
	/// An object that represents the requirements for a route to match HTTP requests for a virtual router.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpRouteMatch
	{
		
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public HttpRouteHeader[] Headers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="method")]
		public HttpMethod_ Method { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public HttpPathMatch Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="queryParameters")]
		public HttpQueryParameter[] QueryParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="scheme")]
		public HttpScheme Scheme { get; set; }
	}
	
	/// <summary>
	/// An object that represents the HTTP header in the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpRouteHeader
	{
		
		[System.Runtime.Serialization.DataMember(Name="invert")]
		public System.Nullable<System.Boolean> Invert { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="match")]
		public HeaderMatchMethod Match { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum HttpScheme
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http")]
		http = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="https")]
		https = 1,
	}
	
	/// <summary>
	/// An object that represents a retry policy. Specify at least one value for at least one of the types of <code>RetryEvents</code>, a value for <code>maxRetries</code>, and a value for <code>perRetryTimeout</code>. Both <code>server-error</code> and <code>gateway-error</code> under <code>httpRetryEvents</code> include the Envoy <code>reset</code> policy. For more information on the <code>reset</code> policy, see the <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on">Envoy documentation</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpRetryPolicy
	{
		
		[System.Runtime.Serialization.DataMember(Name="httpRetryEvents")]
		public string[] HttpRetryEvents { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxRetries")]
		public int MaxRetries { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="perRetryTimeout")]
		public Duration PerRetryTimeout { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tcpRetryEvents")]
		public TcpRetryPolicyEvent[] TcpRetryEvents { get; set; }
	}
	
	/// <summary>
	/// An object that represents types of timeouts. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpTimeout
	{
		
		[System.Runtime.Serialization.DataMember(Name="idle")]
		public Duration Idle { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="perRequest")]
		public Duration PerRequest { get; set; }
	}
	
	/// <summary>
	/// An object that represents a TCP route type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TcpRoute
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action")]
		public TcpRouteAction Action { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="match")]
		public TcpRouteMatch Match { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public TcpTimeout Timeout { get; set; }
	}
	
	/// <summary>
	/// An object that represents the action to take if a match is determined.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TcpRouteAction
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="weightedTargets")]
		public WeightedTarget[] WeightedTargets { get; set; }
	}
	
	/// <summary>
	/// An object representing the TCP route to match.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TcpRouteMatch
	{
		
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
	}
	
	/// <summary>
	/// An object that represents types of timeouts. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TcpTimeout
	{
		
		[System.Runtime.Serialization.DataMember(Name="idle")]
		public Duration Idle { get; set; }
	}
	
	/// <summary>
	/// An object that represents the current status of a route.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouteStatus
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public GatewayRouteStatusCode Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateVirtualGatewayOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualGateway")]
		public VirtualGatewayData VirtualGateway { get; set; }
	}
	
	/// <summary>
	/// An object that represents a virtual gateway returned by a describe operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayData
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshName")]
		public string MeshName { get; set; }
		
		/// <summary>
		/// An object that represents metadata for a resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public ResourceMetadata Metadata { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public VirtualGatewaySpec Spec { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public VirtualGatewayStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualGatewayName")]
		public string VirtualGatewayName { get; set; }
	}
	
	/// <summary>
	/// An object that represents the specification of a service mesh resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewaySpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="backendDefaults")]
		public VirtualGatewayBackendDefaults BackendDefaults { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="listeners")]
		public VirtualGatewayListener[] Listeners { get; set; }
		
		/// <summary>
		/// An object that represents logging information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logging")]
		public VirtualGatewayLogging Logging { get; set; }
	}
	
	/// <summary>
	/// An object that represents the default properties for a backend.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayBackendDefaults
	{
		
		[System.Runtime.Serialization.DataMember(Name="clientPolicy")]
		public VirtualGatewayClientPolicy ClientPolicy { get; set; }
	}
	
	/// <summary>
	/// An object that represents a client policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayClientPolicy
	{
		
		[System.Runtime.Serialization.DataMember(Name="tls")]
		public VirtualGatewayClientPolicyTls Tls { get; set; }
	}
	
	/// <summary>
	/// An object that represents a Transport Layer Security (TLS) client policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayClientPolicyTls
	{
		
		[System.Runtime.Serialization.DataMember(Name="certificate")]
		public VirtualGatewayClientTlsCertificate Certificate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enforce")]
		public System.Nullable<System.Boolean> Enforce { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ports")]
		public System.Nullable<System.Int32> Ports { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="validation")]
		public VirtualGatewayTlsValidationContext Validation { get; set; }
	}
	
	/// <summary>
	/// An object that represents the virtual gateway's client's Transport Layer Security (TLS) certificate.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayClientTlsCertificate
	{
		
		[System.Runtime.Serialization.DataMember(Name="file")]
		public VirtualGatewayListenerTlsFileCertificate File { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sds")]
		public VirtualGatewayListenerTlsSdsCertificate Sds { get; set; }
	}
	
	/// <summary>
	/// An object that represents a local file certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html#virtual-node-tls-prerequisites">Transport Layer Security (TLS)</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayListenerTlsFileCertificate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateChain")]
		public string CertificateChain { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="privateKey")]
		public string PrivateKey { get; set; }
	}
	
	/// <summary>
	/// An object that represents the virtual gateway's listener's Secret Discovery Service certificate.The proxy must be configured with a local SDS provider via a Unix Domain Socket. See App Mesh<a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html">TLS documentation</a> for more info. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayListenerTlsSdsCertificate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secretName")]
		public string SecretName { get; set; }
	}
	
	/// <summary>
	/// An object that represents a Transport Layer Security (TLS) validation context.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayTlsValidationContext
	{
		
		[System.Runtime.Serialization.DataMember(Name="subjectAlternativeNames")]
		public SubjectAlternativeNames SubjectAlternativeNames { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trust")]
		public VirtualGatewayTlsValidationContextTrust Trust { get; set; }
	}
	
	/// <summary>
	/// An object that represents the subject alternative names secured by the certificate.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubjectAlternativeNames
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="match")]
		public SubjectAlternativeNameMatchers Match { get; set; }
	}
	
	/// <summary>
	/// An object that represents the methods by which a subject alternative name on a peer Transport Layer Security (TLS) certificate can be matched.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubjectAlternativeNameMatchers
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="exact")]
		public string[] Exact { get; set; }
	}
	
	/// <summary>
	/// An object that represents a Transport Layer Security (TLS) validation context trust.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayTlsValidationContextTrust
	{
		
		[System.Runtime.Serialization.DataMember(Name="acm")]
		public VirtualGatewayTlsValidationContextAcmTrust Acm { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="file")]
		public VirtualGatewayTlsValidationContextFileTrust File { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sds")]
		public VirtualGatewayTlsValidationContextSdsTrust Sds { get; set; }
	}
	
	/// <summary>
	/// An object that represents a Transport Layer Security (TLS) validation context trust for an Certificate Manager certificate.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayTlsValidationContextAcmTrust
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateAuthorityArns")]
		public string[] CertificateAuthorityArns { get; set; }
	}
	
	/// <summary>
	/// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayTlsValidationContextFileTrust
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateChain")]
		public string CertificateChain { get; set; }
	}
	
	/// <summary>
	/// An object that represents a virtual gateway's listener's Transport Layer Security (TLS) Secret Discovery Service validation context trust. The proxy must be configured with a local SDS provider via a Unix Domain Socket. See App Mesh <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html">TLS documentation</a> for more info.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayTlsValidationContextSdsTrust
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secretName")]
		public string SecretName { get; set; }
	}
	
	/// <summary>
	/// An object that represents a listener for a virtual gateway.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayListener
	{
		
		[System.Runtime.Serialization.DataMember(Name="connectionPool")]
		public VirtualGatewayConnectionPool ConnectionPool { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="healthCheck")]
		public VirtualGatewayHealthCheckPolicy HealthCheck { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portMapping")]
		public VirtualGatewayPortMapping PortMapping { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tls")]
		public VirtualGatewayListenerTls Tls { get; set; }
	}
	
	/// <summary>
	/// <p>An object that represents the type of virtual gateway connection pool.</p> <p>Only one protocol is used at a time and should be the same protocol as the one chosen under port mapping.</p> <p>If not present the default value for <code>maxPendingRequests</code> is <code>2147483647</code>.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayConnectionPool
	{
		
		[System.Runtime.Serialization.DataMember(Name="grpc")]
		public VirtualGatewayGrpcConnectionPool Grpc { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="http")]
		public VirtualGatewayHttpConnectionPool Http { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="http2")]
		public VirtualGatewayHttp2ConnectionPool Http2 { get; set; }
	}
	
	/// <summary>
	/// An object that represents a type of connection pool.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayGrpcConnectionPool
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxRequests")]
		public int MaxRequests { get; set; }
	}
	
	/// <summary>
	/// An object that represents a type of connection pool.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayHttpConnectionPool
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxConnections")]
		public int MaxConnections { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxPendingRequests")]
		public System.Nullable<System.Int32> MaxPendingRequests { get; set; }
	}
	
	/// <summary>
	/// An object that represents a type of connection pool.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayHttp2ConnectionPool
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxRequests")]
		public int MaxRequests { get; set; }
	}
	
	/// <summary>
	/// An object that represents the health check policy for a virtual gateway's listener.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayHealthCheckPolicy
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="healthyThreshold")]
		public int HealthyThreshold { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="intervalMillis")]
		public int IntervalMillis { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public VirtualGatewayPortProtocol Protocol { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeoutMillis")]
		public int TimeoutMillis { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="unhealthyThreshold")]
		public int UnhealthyThreshold { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum VirtualGatewayPortProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http")]
		http = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http2")]
		http2 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="grpc")]
		grpc = 2,
	}
	
	/// <summary>
	/// An object that represents a port mapping.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayPortMapping
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public VirtualGatewayPortProtocol Protocol { get; set; }
	}
	
	/// <summary>
	/// An object that represents the Transport Layer Security (TLS) properties for a listener.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayListenerTls
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificate")]
		public VirtualGatewayListenerTlsCertificate Certificate { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public VirtualGatewayListenerTlsMode Mode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="validation")]
		public VirtualGatewayListenerTlsValidationContext Validation { get; set; }
	}
	
	/// <summary>
	/// An object that represents a listener's Transport Layer Security (TLS) certificate.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayListenerTlsCertificate
	{
		
		[System.Runtime.Serialization.DataMember(Name="acm")]
		public VirtualGatewayListenerTlsAcmCertificate Acm { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="file")]
		public VirtualGatewayListenerTlsFileCertificate File { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sds")]
		public VirtualGatewayListenerTlsSdsCertificate Sds { get; set; }
	}
	
	/// <summary>
	/// An object that represents an Certificate Manager certificate.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayListenerTlsAcmCertificate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateArn")]
		public string CertificateArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum VirtualGatewayListenerTlsMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="STRICT")]
		STRICT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PERMISSIVE")]
		PERMISSIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DISABLED")]
		DISABLED = 2,
	}
	
	/// <summary>
	/// An object that represents a virtual gateway's listener's Transport Layer Security (TLS) validation context.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayListenerTlsValidationContext
	{
		
		[System.Runtime.Serialization.DataMember(Name="subjectAlternativeNames")]
		public SubjectAlternativeNames SubjectAlternativeNames { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trust")]
		public VirtualGatewayListenerTlsValidationContextTrust Trust { get; set; }
	}
	
	/// <summary>
	/// An object that represents a virtual gateway's listener's Transport Layer Security (TLS) validation context trust.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayListenerTlsValidationContextTrust
	{
		
		[System.Runtime.Serialization.DataMember(Name="file")]
		public VirtualGatewayTlsValidationContextFileTrust File { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sds")]
		public VirtualGatewayTlsValidationContextSdsTrust Sds { get; set; }
	}
	
	/// <summary>
	/// An object that represents logging information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayLogging
	{
		
		[System.Runtime.Serialization.DataMember(Name="accessLog")]
		public VirtualGatewayAccessLog AccessLog { get; set; }
	}
	
	/// <summary>
	/// The access log configuration for a virtual gateway.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayAccessLog
	{
		
		[System.Runtime.Serialization.DataMember(Name="file")]
		public VirtualGatewayFileAccessLog File { get; set; }
	}
	
	/// <summary>
	/// An object that represents an access log file.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayFileAccessLog
	{
		
		[System.Runtime.Serialization.DataMember(Name="format")]
		public LoggingFormat Format { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// An object that represents the format for the logs.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LoggingFormat
	{
		
		[System.Runtime.Serialization.DataMember(Name="json")]
		public JsonFormatRef[] Json { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	/// <summary>
	/// An object that represents the key value pairs for the JSON.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JsonFormatRef
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// An object that represents the status of the mesh resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayStatus
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public GatewayRouteStatusCode Status { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateVirtualNodeOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualNode")]
		public VirtualNodeData VirtualNode { get; set; }
	}
	
	/// <summary>
	/// An object that represents a virtual node returned by a describe operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualNodeData
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshName")]
		public string MeshName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public ResourceMetadata Metadata { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public VirtualNodeSpec Spec { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public VirtualNodeStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualNodeName")]
		public string VirtualNodeName { get; set; }
	}
	
	/// <summary>
	/// An object that represents the specification of a virtual node.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualNodeSpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="backendDefaults")]
		public BackendDefaults BackendDefaults { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="backends")]
		public Backend[] Backends { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="listeners")]
		public Listener[] Listeners { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="logging")]
		public Logging Logging { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="serviceDiscovery")]
		public ServiceDiscovery ServiceDiscovery { get; set; }
	}
	
	/// <summary>
	/// An object that represents the default properties for a backend.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendDefaults
	{
		
		[System.Runtime.Serialization.DataMember(Name="clientPolicy")]
		public ClientPolicy ClientPolicy { get; set; }
	}
	
	/// <summary>
	/// An object that represents a client policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClientPolicy
	{
		
		[System.Runtime.Serialization.DataMember(Name="tls")]
		public ClientPolicyTls Tls { get; set; }
	}
	
	/// <summary>
	/// A reference to an object that represents a Transport Layer Security (TLS) client policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClientPolicyTls
	{
		
		[System.Runtime.Serialization.DataMember(Name="certificate")]
		public ClientTlsCertificate Certificate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enforce")]
		public System.Nullable<System.Boolean> Enforce { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ports")]
		public System.Nullable<System.Int32> Ports { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="validation")]
		public TlsValidationContext Validation { get; set; }
	}
	
	/// <summary>
	/// An object that represents the client's certificate.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClientTlsCertificate
	{
		
		[System.Runtime.Serialization.DataMember(Name="file")]
		public ListenerTlsFileCertificate File { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sds")]
		public ListenerTlsSdsCertificate Sds { get; set; }
	}
	
	/// <summary>
	/// An object that represents a local file certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html#virtual-node-tls-prerequisites">Transport Layer Security (TLS)</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListenerTlsFileCertificate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateChain")]
		public string CertificateChain { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="privateKey")]
		public string PrivateKey { get; set; }
	}
	
	/// <summary>
	/// An object that represents the listener's Secret Discovery Service certificate. The proxy must be configured with a local SDS provider via a Unix Domain Socket. See App Mesh <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html">TLS documentation</a> for more info.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListenerTlsSdsCertificate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secretName")]
		public string SecretName { get; set; }
	}
	
	/// <summary>
	/// An object that represents how the proxy will validate its peer during Transport Layer Security (TLS) negotiation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TlsValidationContext
	{
		
		[System.Runtime.Serialization.DataMember(Name="subjectAlternativeNames")]
		public SubjectAlternativeNames SubjectAlternativeNames { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trust")]
		public TlsValidationContextTrust Trust { get; set; }
	}
	
	/// <summary>
	/// An object that represents a Transport Layer Security (TLS) validation context trust.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TlsValidationContextTrust
	{
		
		[System.Runtime.Serialization.DataMember(Name="acm")]
		public TlsValidationContextAcmTrust Acm { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="file")]
		public TlsValidationContextFileTrust File { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sds")]
		public TlsValidationContextSdsTrust Sds { get; set; }
	}
	
	/// <summary>
	/// An object that represents a Transport Layer Security (TLS) validation context trust for an Certificate Manager certificate.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TlsValidationContextAcmTrust
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateAuthorityArns")]
		public string[] CertificateAuthorityArns { get; set; }
	}
	
	/// <summary>
	/// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TlsValidationContextFileTrust
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateChain")]
		public string CertificateChain { get; set; }
	}
	
	/// <summary>
	/// An object that represents a Transport Layer Security (TLS) Secret Discovery Service validation context trust. The proxy must be configured with a local SDS provider via a Unix Domain Socket. See App Mesh <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html">TLS documentation</a> for more info.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TlsValidationContextSdsTrust
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secretName")]
		public string SecretName { get; set; }
	}
	
	/// <summary>
	/// An object that represents the backends that a virtual node is expected to send outbound traffic to.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Backend
	{
		
		[System.Runtime.Serialization.DataMember(Name="virtualService")]
		public VirtualServiceBackend VirtualService { get; set; }
	}
	
	/// <summary>
	/// An object that represents a virtual service backend for a virtual node.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualServiceBackend
	{
		
		[System.Runtime.Serialization.DataMember(Name="clientPolicy")]
		public ClientPolicy ClientPolicy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualServiceName")]
		public string VirtualServiceName { get; set; }
	}
	
	/// <summary>
	/// An object that represents a listener for a virtual node.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Listener
	{
		
		[System.Runtime.Serialization.DataMember(Name="connectionPool")]
		public VirtualNodeConnectionPool ConnectionPool { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="healthCheck")]
		public HealthCheckPolicy HealthCheck { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="outlierDetection")]
		public OutlierDetection OutlierDetection { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portMapping")]
		public PortMapping PortMapping { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public ListenerTimeout Timeout { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tls")]
		public ListenerTls Tls { get; set; }
	}
	
	/// <summary>
	/// <p>An object that represents the type of virtual node connection pool.</p> <p>Only one protocol is used at a time and should be the same protocol as the one chosen under port mapping.</p> <p>If not present the default value for <code>maxPendingRequests</code> is <code>2147483647</code>.</p> <p/>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualNodeConnectionPool
	{
		
		[System.Runtime.Serialization.DataMember(Name="grpc")]
		public VirtualNodeGrpcConnectionPool Grpc { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="http")]
		public VirtualNodeHttpConnectionPool Http { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="http2")]
		public VirtualNodeHttp2ConnectionPool Http2 { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tcp")]
		public VirtualNodeTcpConnectionPool Tcp { get; set; }
	}
	
	/// <summary>
	/// An object that represents a type of connection pool.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualNodeGrpcConnectionPool
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxRequests")]
		public int MaxRequests { get; set; }
	}
	
	/// <summary>
	/// An object that represents a type of connection pool.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualNodeHttpConnectionPool
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxConnections")]
		public int MaxConnections { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxPendingRequests")]
		public System.Nullable<System.Int32> MaxPendingRequests { get; set; }
	}
	
	/// <summary>
	/// An object that represents a type of connection pool.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualNodeHttp2ConnectionPool
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxRequests")]
		public int MaxRequests { get; set; }
	}
	
	/// <summary>
	/// An object that represents a type of connection pool.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualNodeTcpConnectionPool
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxConnections")]
		public int MaxConnections { get; set; }
	}
	
	/// <summary>
	/// An object that represents the health check policy for a virtual node's listener.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthCheckPolicy
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="healthyThreshold")]
		public int HealthyThreshold { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="intervalMillis")]
		public int IntervalMillis { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public PortProtocol Protocol { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeoutMillis")]
		public int TimeoutMillis { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="unhealthyThreshold")]
		public int UnhealthyThreshold { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PortProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http")]
		http = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="tcp")]
		tcp = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http2")]
		http2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="grpc")]
		grpc = 3,
	}
	
	/// <summary>
	/// An object that represents the outlier detection for a virtual node's listener.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OutlierDetection
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="baseEjectionDuration")]
		public Duration BaseEjectionDuration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="interval")]
		public Duration Interval { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxEjectionPercent")]
		public int MaxEjectionPercent { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxServerErrors")]
		public int MaxServerErrors { get; set; }
	}
	
	/// <summary>
	/// An object that represents a port mapping.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PortMapping
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public PortProtocol Protocol { get; set; }
	}
	
	/// <summary>
	/// An object that represents timeouts for different protocols.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListenerTimeout
	{
		
		[System.Runtime.Serialization.DataMember(Name="grpc")]
		public GrpcTimeout Grpc { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="http")]
		public HttpTimeout Http { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="http2")]
		public HttpTimeout Http2 { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tcp")]
		public TcpTimeout Tcp { get; set; }
	}
	
	/// <summary>
	/// An object that represents the Transport Layer Security (TLS) properties for a listener.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListenerTls
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificate")]
		public ListenerTlsCertificate Certificate { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public VirtualGatewayListenerTlsMode Mode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="validation")]
		public ListenerTlsValidationContext Validation { get; set; }
	}
	
	/// <summary>
	/// An object that represents a listener's Transport Layer Security (TLS) certificate.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListenerTlsCertificate
	{
		
		[System.Runtime.Serialization.DataMember(Name="acm")]
		public ListenerTlsAcmCertificate Acm { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="file")]
		public ListenerTlsFileCertificate File { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sds")]
		public ListenerTlsSdsCertificate Sds { get; set; }
	}
	
	/// <summary>
	/// An object that represents an Certificate Manager certificate.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListenerTlsAcmCertificate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateArn")]
		public string CertificateArn { get; set; }
	}
	
	/// <summary>
	/// An object that represents a listener's Transport Layer Security (TLS) validation context.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListenerTlsValidationContext
	{
		
		[System.Runtime.Serialization.DataMember(Name="subjectAlternativeNames")]
		public SubjectAlternativeNames SubjectAlternativeNames { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trust")]
		public ListenerTlsValidationContextTrust Trust { get; set; }
	}
	
	/// <summary>
	/// An object that represents a listener's Transport Layer Security (TLS) validation context trust.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListenerTlsValidationContextTrust
	{
		
		[System.Runtime.Serialization.DataMember(Name="file")]
		public TlsValidationContextFileTrust File { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sds")]
		public TlsValidationContextSdsTrust Sds { get; set; }
	}
	
	/// <summary>
	/// An object that represents the logging information for a virtual node.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Logging
	{
		
		[System.Runtime.Serialization.DataMember(Name="accessLog")]
		public AccessLog AccessLog { get; set; }
	}
	
	/// <summary>
	/// An object that represents the access logging information for a virtual node.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AccessLog
	{
		
		[System.Runtime.Serialization.DataMember(Name="file")]
		public FileAccessLog File { get; set; }
	}
	
	/// <summary>
	/// An object that represents an access log file.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FileAccessLog
	{
		
		[System.Runtime.Serialization.DataMember(Name="format")]
		public LoggingFormat Format { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// An object that represents the service discovery information for a virtual node.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServiceDiscovery
	{
		
		[System.Runtime.Serialization.DataMember(Name="awsCloudMap")]
		public AwsCloudMapServiceDiscovery AwsCloudMap { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dns")]
		public DnsServiceDiscovery Dns { get; set; }
	}
	
	/// <summary>
	/// <p>An object that represents the Cloud Map service discovery information for your virtual node.</p> <note> <p>Cloud Map is not available in the eu-south-1 Region.</p> </note>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AwsCloudMapServiceDiscovery
	{
		
		[System.Runtime.Serialization.DataMember(Name="attributes")]
		public AwsCloudMapInstanceAttribute[] Attributes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ipPreference")]
		public IpPreference IpPreference { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="namespaceName")]
		public string NamespaceName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serviceName")]
		public string ServiceName { get; set; }
	}
	
	/// <summary>
	/// <p>An object that represents the Cloud Map attribute information for your virtual node.</p> <note> <p>Cloud Map is not available in the eu-south-1 Region.</p> </note>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AwsCloudMapInstanceAttribute
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// An object that represents the DNS service discovery information for your virtual node.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DnsServiceDiscovery
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ipPreference")]
		public IpPreference IpPreference { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="responseType")]
		public DnsResponseType ResponseType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DnsResponseType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LOADBALANCER")]
		LOADBALANCER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ENDPOINTS")]
		ENDPOINTS = 1,
	}
	
	/// <summary>
	/// An object that represents the current status of the virtual node.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualNodeStatus
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public GatewayRouteStatusCode Status { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateVirtualRouterOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualRouter")]
		public VirtualRouterData VirtualRouter { get; set; }
	}
	
	/// <summary>
	/// An object that represents a virtual router returned by a describe operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualRouterData
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshName")]
		public string MeshName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public ResourceMetadata Metadata { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public VirtualRouterSpec Spec { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public VirtualRouterStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualRouterName")]
		public string VirtualRouterName { get; set; }
	}
	
	/// <summary>
	/// An object that represents the specification of a virtual router.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualRouterSpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="listeners")]
		public VirtualRouterListener[] Listeners { get; set; }
	}
	
	/// <summary>
	/// An object that represents a virtual router listener.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualRouterListener
	{
		
		/// <summary>
		/// An object that represents a port mapping.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portMapping")]
		public PortMapping PortMapping { get; set; }
	}
	
	/// <summary>
	/// An object that represents the status of a virtual router. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualRouterStatus
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public GatewayRouteStatusCode Status { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateVirtualServiceOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualService")]
		public VirtualServiceData VirtualService { get; set; }
	}
	
	/// <summary>
	/// An object that represents a virtual service returned by a describe operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualServiceData
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshName")]
		public string MeshName { get; set; }
		
		/// <summary>
		/// An object that represents metadata for a resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public ResourceMetadata Metadata { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public VirtualServiceSpec Spec { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public VirtualServiceStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualServiceName")]
		public string VirtualServiceName { get; set; }
	}
	
	/// <summary>
	/// An object that represents the specification of a virtual service.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualServiceSpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="provider")]
		public VirtualServiceProvider Provider { get; set; }
	}
	
	/// <summary>
	/// An object that represents the provider for a virtual service.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualServiceProvider
	{
		
		[System.Runtime.Serialization.DataMember(Name="virtualNode")]
		public VirtualNodeServiceProvider VirtualNode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="virtualRouter")]
		public VirtualRouterServiceProvider VirtualRouter { get; set; }
	}
	
	/// <summary>
	/// An object that represents a virtual node service provider.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualNodeServiceProvider
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualNodeName")]
		public string VirtualNodeName { get; set; }
	}
	
	/// <summary>
	/// An object that represents a virtual node service provider.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualRouterServiceProvider
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualRouterName")]
		public string VirtualRouterName { get; set; }
	}
	
	/// <summary>
	/// An object that represents the status of a virtual service.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualServiceStatus
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public GatewayRouteStatusCode Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteGatewayRouteOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gatewayRoute")]
		public GatewayRouteData GatewayRoute { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceInUseException
	{
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteMeshOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mesh")]
		public MeshData Mesh { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteRouteOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="route")]
		public RouteData Route { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteVirtualGatewayOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualGateway")]
		public VirtualGatewayData VirtualGateway { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteVirtualNodeOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualNode")]
		public VirtualNodeData VirtualNode { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteVirtualRouterOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualRouter")]
		public VirtualRouterData VirtualRouter { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteVirtualServiceOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualService")]
		public VirtualServiceData VirtualService { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeGatewayRouteOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gatewayRoute")]
		public GatewayRouteData GatewayRoute { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeMeshOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mesh")]
		public MeshData Mesh { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeRouteOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="route")]
		public RouteData Route { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeVirtualGatewayOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualGateway")]
		public VirtualGatewayData VirtualGateway { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeVirtualNodeOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualNode")]
		public VirtualNodeData VirtualNode { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeVirtualRouterOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualRouter")]
		public VirtualRouterData VirtualRouter { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeVirtualServiceOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualService")]
		public VirtualServiceData VirtualService { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListGatewayRoutesOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gatewayRoutes")]
		public GatewayRouteRef[] GatewayRoutes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// An object that represents a gateway route returned by a list operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GatewayRouteRef
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gatewayRouteName")]
		public string GatewayRouteName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lastUpdatedAt")]
		public System.DateTimeOffset LastUpdatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshName")]
		public string MeshName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshOwner")]
		public string MeshOwner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceOwner")]
		public string ResourceOwner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public int Version { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualGatewayName")]
		public string VirtualGatewayName { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListMeshesOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshes")]
		public MeshRef[] Meshes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// An object that represents a service mesh returned by a list operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MeshRef
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lastUpdatedAt")]
		public System.DateTimeOffset LastUpdatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshName")]
		public string MeshName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshOwner")]
		public string MeshOwner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceOwner")]
		public string ResourceOwner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public int Version { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListRoutesOutput
	{
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="routes")]
		public RouteRef[] Routes { get; set; }
	}
	
	/// <summary>
	/// An object that represents a route returned by a list operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouteRef
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lastUpdatedAt")]
		public System.DateTimeOffset LastUpdatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshName")]
		public string MeshName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshOwner")]
		public string MeshOwner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceOwner")]
		public string ResourceOwner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="routeName")]
		public string RouteName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public int Version { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualRouterName")]
		public string VirtualRouterName { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceOutput
	{
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagRef[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListVirtualGatewaysOutput
	{
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualGateways")]
		public VirtualGatewayRef[] VirtualGateways { get; set; }
	}
	
	/// <summary>
	/// An object that represents a virtual gateway returned by a list operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualGatewayRef
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lastUpdatedAt")]
		public System.DateTimeOffset LastUpdatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshName")]
		public string MeshName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshOwner")]
		public string MeshOwner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceOwner")]
		public string ResourceOwner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public int Version { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualGatewayName")]
		public string VirtualGatewayName { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListVirtualNodesOutput
	{
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualNodes")]
		public VirtualNodeRef[] VirtualNodes { get; set; }
	}
	
	/// <summary>
	/// An object that represents a virtual node returned by a list operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualNodeRef
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lastUpdatedAt")]
		public System.DateTimeOffset LastUpdatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshName")]
		public string MeshName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshOwner")]
		public string MeshOwner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceOwner")]
		public string ResourceOwner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public int Version { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualNodeName")]
		public string VirtualNodeName { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListVirtualRoutersOutput
	{
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualRouters")]
		public VirtualRouterRef[] VirtualRouters { get; set; }
	}
	
	/// <summary>
	/// An object that represents a virtual router returned by a list operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualRouterRef
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lastUpdatedAt")]
		public System.DateTimeOffset LastUpdatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshName")]
		public string MeshName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshOwner")]
		public string MeshOwner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceOwner")]
		public string ResourceOwner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public int Version { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualRouterName")]
		public string VirtualRouterName { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListVirtualServicesOutput
	{
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualServices")]
		public VirtualServiceRef[] VirtualServices { get; set; }
	}
	
	/// <summary>
	/// An object that represents a virtual service returned by a list operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VirtualServiceRef
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lastUpdatedAt")]
		public System.DateTimeOffset LastUpdatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshName")]
		public string MeshName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshOwner")]
		public string MeshOwner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceOwner")]
		public string ResourceOwner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public int Version { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualServiceName")]
		public string VirtualServiceName { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagResourceOutput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TooManyTagsException
	{
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UntagResourceOutput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateGatewayRouteOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gatewayRoute")]
		public GatewayRouteData GatewayRoute { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateMeshOutput
	{
		
		/// <summary>
		/// An object that represents a service mesh returned by a describe operation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mesh")]
		public MeshData Mesh { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateRouteOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="route")]
		public RouteData Route { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateVirtualGatewayOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualGateway")]
		public VirtualGatewayData VirtualGateway { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateVirtualNodeOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualNode")]
		public VirtualNodeData VirtualNode { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateVirtualRouterOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualRouter")]
		public VirtualRouterData VirtualRouter { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateVirtualServiceOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualService")]
		public VirtualServiceData VirtualService { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateGatewayRouteInput
	{
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gatewayRouteName")]
		public string GatewayRouteName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public GatewayRouteSpec Spec { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagRef[] Tags { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateMeshInput
	{
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshName")]
		public string MeshName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public MeshSpec Spec { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagRef[] Tags { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateRouteInput
	{
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="routeName")]
		public string RouteName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public RouteSpec Spec { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagRef[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateVirtualGatewayInput
	{
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public VirtualGatewaySpec Spec { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagRef[] Tags { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualGatewayName")]
		public string VirtualGatewayName { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateVirtualNodeInput
	{
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public VirtualNodeSpec Spec { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagRef[] Tags { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualNodeName")]
		public string VirtualNodeName { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateVirtualRouterInput
	{
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public VirtualRouterSpec Spec { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagRef[] Tags { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualRouterName")]
		public string VirtualRouterName { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateVirtualServiceInput
	{
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public VirtualServiceSpec Spec { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagRef[] Tags { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualServiceName")]
		public string VirtualServiceName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteGatewayRouteInput
	{
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteMeshInput
	{
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteRouteInput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteVirtualGatewayInput
	{
	}
	
	/// <summary>
	/// Deletes a virtual node input.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteVirtualNodeInput
	{
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteVirtualRouterInput
	{
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteVirtualServiceInput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeGatewayRouteInput
	{
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeMeshInput
	{
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeRouteInput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeVirtualGatewayInput
	{
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeVirtualNodeInput
	{
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeVirtualRouterInput
	{
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeVirtualServiceInput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListGatewayRoutesInput
	{
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListMeshesInput
	{
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListRoutesInput
	{
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceInput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListVirtualGatewaysInput
	{
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListVirtualNodesInput
	{
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListVirtualRoutersInput
	{
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListVirtualServicesInput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ListenerTlsMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="STRICT")]
		STRICT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PERMISSIVE")]
		PERMISSIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DISABLED")]
		DISABLED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MeshStatusCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INACTIVE")]
		INACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETED")]
		DELETED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum RouteStatusCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INACTIVE")]
		INACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETED")]
		DELETED = 2,
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagResourceInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagRef[] Tags { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UntagResourceInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tagKeys")]
		public string[] TagKeys { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateGatewayRouteInput
	{
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public GatewayRouteSpec Spec { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateMeshInput
	{
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public MeshSpec Spec { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateRouteInput
	{
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public RouteSpec Spec { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateVirtualGatewayInput
	{
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public VirtualGatewaySpec Spec { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateVirtualNodeInput
	{
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public VirtualNodeSpec Spec { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateVirtualRouterInput
	{
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public VirtualRouterSpec Spec { get; set; }
	}
	
	/// <summary>
	/// <zonbook></zonbook><xhtml></xhtml>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateVirtualServiceInput
	{
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public VirtualServiceSpec Spec { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum VirtualGatewayStatusCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INACTIVE")]
		INACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETED")]
		DELETED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum VirtualNodeStatusCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INACTIVE")]
		INACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETED")]
		DELETED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum VirtualRouterStatusCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INACTIVE")]
		INACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETED")]
		DELETED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum VirtualServiceStatusCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INACTIVE")]
		INACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETED")]
		DELETED = 2,
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// <p>Creates a gateway route.</p> <p>A gateway route is attached to a virtual gateway and routes traffic to an existing virtual service. If a route matches a request, it can distribute traffic to a target virtual service.</p> <p>For more information about gateway routes, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/gateway-routes.html">Gateway routes</a>.</p>
		/// CreateGatewayRoute v20190125/meshes/{meshName}/virtualGateway/{virtualGatewayName}/gatewayRoutes
		/// </summary>
		/// <param name="meshName">The name of the service mesh to create the gateway route in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="virtualGatewayName">The name of the virtual gateway to associate the gateway route with. If the virtual gateway is in a shared mesh, then you must be the owner of the virtual gateway resource.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<CreateGatewayRouteOutput> CreateGatewayRouteAsync(string meshName, string meshOwner, string virtualGatewayName, CreateGatewayRoutePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualGateway/"+ (virtualGatewayName==null? "" : System.Uri.EscapeDataString(virtualGatewayName))+"/gatewayRoutes&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateGatewayRouteOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of existing gateway routes that are associated to a virtual gateway.
		/// ListGatewayRoutes v20190125/meshes/{meshName}/virtualGateway/{virtualGatewayName}/gatewayRoutes
		/// </summary>
		/// <param name="limit">The maximum number of results returned by <code>ListGatewayRoutes</code> in paginated output. When you use this parameter, <code>ListGatewayRoutes</code> returns only <code>limit</code> results in a single page along with a <code>nextToken</code> response element. You can see the remaining results of the initial request by sending another <code>ListGatewayRoutes</code> request with the returned <code>nextToken</code> value. This value can be between 1 and 100. If you don't use this parameter, <code>ListGatewayRoutes</code> returns up to 100 results and a <code>nextToken</code> value if applicable.
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="meshName">The name of the service mesh to list gateway routes in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="nextToken">The <code>nextToken</code> value returned from a previous paginated <code>ListGatewayRoutes</code> request where <code>limit</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>nextToken</code> value.</param>
		/// <param name="virtualGatewayName">The name of the virtual gateway to list gateway routes in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<ListGatewayRoutesOutput> ListGatewayRoutesAsync(int limit, string meshName, string meshOwner, string nextToken, string virtualGatewayName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualGateway/"+ (virtualGatewayName==null? "" : System.Uri.EscapeDataString(virtualGatewayName))+"/gatewayRoutes?limit="+limit+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListGatewayRoutesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a service mesh.</p> <p> A service mesh is a logical boundary for network traffic between services that are represented by resources within the mesh. After you create your service mesh, you can create virtual services, virtual nodes, virtual routers, and routes to distribute traffic between the applications in your mesh.</p> <p>For more information about service meshes, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/meshes.html">Service meshes</a>.</p>
		/// CreateMesh v20190125/meshes
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateMeshOutput> CreateMeshAsync(CreateMeshPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateMeshOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of existing service meshes.
		/// ListMeshes v20190125/meshes
		/// </summary>
		/// <param name="limit">The maximum number of results returned by <code>ListMeshes</code> in paginated output. When you use this parameter, <code>ListMeshes</code> returns only <code>limit</code> results in a single page along with a <code>nextToken</code> response element. You can see the remaining results of the initial request by sending another <code>ListMeshes</code> request with the returned <code>nextToken</code> value. This value can be between 1 and 100. If you don't use this parameter, <code>ListMeshes</code> returns up to 100 results and a <code>nextToken</code> value if applicable.
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="nextToken"><p>The <code>nextToken</code> value returned from a previous paginated <code>ListMeshes</code> request where <code>limit</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>nextToken</code> value.</p> <note> <p>This token should be treated as an opaque identifier that is used only to retrieve the next items in a list and not for other programmatic purposes.</p> </note></param>
		/// <returns>Success</returns>
		public async Task<ListMeshesOutput> ListMeshesAsync(int limit, string nextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes?limit="+limit+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListMeshesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a route that is associated with a virtual router.</p> <p> You can route several different protocols and define a retry policy for a route. Traffic can be routed to one or more virtual nodes.</p> <p>For more information about routes, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/routes.html">Routes</a>.</p>
		/// CreateRoute v20190125/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes
		/// </summary>
		/// <param name="meshName">The name of the service mesh to create the route in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="virtualRouterName">The name of the virtual router in which to create the route. If the virtual router is in a shared mesh, then you must be the owner of the virtual router resource.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<CreateRouteOutput> CreateRouteAsync(string meshName, string meshOwner, string virtualRouterName, CreateRoutePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualRouter/"+ (virtualRouterName==null? "" : System.Uri.EscapeDataString(virtualRouterName))+"/routes&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateRouteOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of existing routes in a service mesh.
		/// ListRoutes v20190125/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes
		/// </summary>
		/// <param name="limit">The maximum number of results returned by <code>ListRoutes</code> in paginated output. When you use this parameter, <code>ListRoutes</code> returns only <code>limit</code> results in a single page along with a <code>nextToken</code> response element. You can see the remaining results of the initial request by sending another <code>ListRoutes</code> request with the returned <code>nextToken</code> value. This value can be between 1 and 100. If you don't use this parameter, <code>ListRoutes</code> returns up to 100 results and a <code>nextToken</code> value if applicable.
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="meshName">The name of the service mesh to list routes in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="nextToken">The <code>nextToken</code> value returned from a previous paginated <code>ListRoutes</code> request where <code>limit</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>nextToken</code> value.</param>
		/// <param name="virtualRouterName">The name of the virtual router to list routes in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<ListRoutesOutput> ListRoutesAsync(int limit, string meshName, string meshOwner, string nextToken, string virtualRouterName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualRouter/"+ (virtualRouterName==null? "" : System.Uri.EscapeDataString(virtualRouterName))+"/routes?limit="+limit+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListRoutesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a virtual gateway.</p> <p>A virtual gateway allows resources outside your mesh to communicate to resources that are inside your mesh. The virtual gateway represents an Envoy proxy running in an Amazon ECS task, in a Kubernetes service, or on an Amazon EC2 instance. Unlike a virtual node, which represents an Envoy running with an application, a virtual gateway represents Envoy deployed by itself.</p> <p>For more information about virtual gateways, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html">Virtual gateways</a>. </p>
		/// CreateVirtualGateway v20190125/meshes/{meshName}/virtualGateways
		/// </summary>
		/// <param name="meshName">The name of the service mesh to create the virtual gateway in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <returns>Success</returns>
		public async Task<CreateVirtualGatewayOutput> CreateVirtualGatewayAsync(string meshName, string meshOwner, CreateVirtualGatewayPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualGateways&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateVirtualGatewayOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of existing virtual gateways in a service mesh.
		/// ListVirtualGateways v20190125/meshes/{meshName}/virtualGateways
		/// </summary>
		/// <param name="limit">The maximum number of results returned by <code>ListVirtualGateways</code> in paginated output. When you use this parameter, <code>ListVirtualGateways</code> returns only <code>limit</code> results in a single page along with a <code>nextToken</code> response element. You can see the remaining results of the initial request by sending another <code>ListVirtualGateways</code> request with the returned <code>nextToken</code> value. This value can be between 1 and 100. If you don't use this parameter, <code>ListVirtualGateways</code> returns up to 100 results and a <code>nextToken</code> value if applicable.
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="meshName">The name of the service mesh to list virtual gateways in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="nextToken">The <code>nextToken</code> value returned from a previous paginated <code>ListVirtualGateways</code> request where <code>limit</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>nextToken</code> value.</param>
		/// <returns>Success</returns>
		public async Task<ListVirtualGatewaysOutput> ListVirtualGatewaysAsync(int limit, string meshName, string meshOwner, string nextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualGateways?limit="+limit+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListVirtualGatewaysOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a virtual node within a service mesh.</p> <p> A virtual node acts as a logical pointer to a particular task group, such as an Amazon ECS service or a Kubernetes deployment. When you create a virtual node, you can specify the service discovery information for your task group, and whether the proxy running in a task group will communicate with other proxies using Transport Layer Security (TLS).</p> <p>You define a <code>listener</code> for any inbound traffic that your virtual node expects. Any virtual service that your virtual node expects to communicate to is specified as a <code>backend</code>.</p> <p>The response metadata for your new virtual node contains the <code>arn</code> that is associated with the virtual node. Set this value to the full ARN; for example, <code>arn:aws:appmesh:us-west-2:123456789012:myMesh/default/virtualNode/myApp</code>) as the <code>APPMESH_RESOURCE_ARN</code> environment variable for your task group's Envoy proxy container in your task definition or pod spec. This is then mapped to the <code>node.id</code> and <code>node.cluster</code> Envoy parameters.</p> <note> <p>By default, App Mesh uses the name of the resource you specified in <code>APPMESH_RESOURCE_ARN</code> when Envoy is referring to itself in metrics and traces. You can override this behavior by setting the <code>APPMESH_RESOURCE_CLUSTER</code> environment variable with your own name.</p> </note> <p>For more information about virtual nodes, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_nodes.html">Virtual nodes</a>. You must be using <code>1.15.0</code> or later of the Envoy image when setting these variables. For more information aboutApp Mesh Envoy variables, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/envoy.html">Envoy image</a> in the App Mesh User Guide.</p>
		/// CreateVirtualNode v20190125/meshes/{meshName}/virtualNodes
		/// </summary>
		/// <param name="meshName">The name of the service mesh to create the virtual node in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <returns>Success</returns>
		public async Task<CreateVirtualNodeOutput> CreateVirtualNodeAsync(string meshName, string meshOwner, CreateVirtualNodePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualNodes&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateVirtualNodeOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of existing virtual nodes.
		/// ListVirtualNodes v20190125/meshes/{meshName}/virtualNodes
		/// </summary>
		/// <param name="limit">The maximum number of results returned by <code>ListVirtualNodes</code> in paginated output. When you use this parameter, <code>ListVirtualNodes</code> returns only <code>limit</code> results in a single page along with a <code>nextToken</code> response element. You can see the remaining results of the initial request by sending another <code>ListVirtualNodes</code> request with the returned <code>nextToken</code> value. This value can be between 1 and 100. If you don't use this parameter, <code>ListVirtualNodes</code> returns up to 100 results and a <code>nextToken</code> value if applicable.
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="meshName">The name of the service mesh to list virtual nodes in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="nextToken">The <code>nextToken</code> value returned from a previous paginated <code>ListVirtualNodes</code> request where <code>limit</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>nextToken</code> value.</param>
		/// <returns>Success</returns>
		public async Task<ListVirtualNodesOutput> ListVirtualNodesAsync(int limit, string meshName, string meshOwner, string nextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualNodes?limit="+limit+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListVirtualNodesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a virtual router within a service mesh.</p> <p>Specify a <code>listener</code> for any inbound traffic that your virtual router receives. Create a virtual router for each protocol and port that you need to route. Virtual routers handle traffic for one or more virtual services within your mesh. After you create your virtual router, create and associate routes for your virtual router that direct incoming requests to different virtual nodes.</p> <p>For more information about virtual routers, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_routers.html">Virtual routers</a>.</p>
		/// CreateVirtualRouter v20190125/meshes/{meshName}/virtualRouters
		/// </summary>
		/// <param name="meshName">The name of the service mesh to create the virtual router in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <returns>Success</returns>
		public async Task<CreateVirtualRouterOutput> CreateVirtualRouterAsync(string meshName, string meshOwner, CreateVirtualRouterPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualRouters&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateVirtualRouterOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of existing virtual routers in a service mesh.
		/// ListVirtualRouters v20190125/meshes/{meshName}/virtualRouters
		/// </summary>
		/// <param name="limit">The maximum number of results returned by <code>ListVirtualRouters</code> in paginated output. When you use this parameter, <code>ListVirtualRouters</code> returns only <code>limit</code> results in a single page along with a <code>nextToken</code> response element. You can see the remaining results of the initial request by sending another <code>ListVirtualRouters</code> request with the returned <code>nextToken</code> value. This value can be between 1 and 100. If you don't use this parameter, <code>ListVirtualRouters</code> returns up to 100 results and a <code>nextToken</code> value if applicable.
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="meshName">The name of the service mesh to list virtual routers in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="nextToken">The <code>nextToken</code> value returned from a previous paginated <code>ListVirtualRouters</code> request where <code>limit</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>nextToken</code> value.</param>
		/// <returns>Success</returns>
		public async Task<ListVirtualRoutersOutput> ListVirtualRoutersAsync(int limit, string meshName, string meshOwner, string nextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualRouters?limit="+limit+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListVirtualRoutersOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a virtual service within a service mesh.</p> <p>A virtual service is an abstraction of a real service that is provided by a virtual node directly or indirectly by means of a virtual router. Dependent services call your virtual service by its <code>virtualServiceName</code>, and those requests are routed to the virtual node or virtual router that is specified as the provider for the virtual service.</p> <p>For more information about virtual services, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_services.html">Virtual services</a>.</p>
		/// CreateVirtualService v20190125/meshes/{meshName}/virtualServices
		/// </summary>
		/// <param name="meshName">The name of the service mesh to create the virtual service in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <returns>Success</returns>
		public async Task<CreateVirtualServiceOutput> CreateVirtualServiceAsync(string meshName, string meshOwner, CreateVirtualServicePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualServices&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateVirtualServiceOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of existing virtual services in a service mesh.
		/// ListVirtualServices v20190125/meshes/{meshName}/virtualServices
		/// </summary>
		/// <param name="limit">The maximum number of results returned by <code>ListVirtualServices</code> in paginated output. When you use this parameter, <code>ListVirtualServices</code> returns only <code>limit</code> results in a single page along with a <code>nextToken</code> response element. You can see the remaining results of the initial request by sending another <code>ListVirtualServices</code> request with the returned <code>nextToken</code> value. This value can be between 1 and 100. If you don't use this parameter, <code>ListVirtualServices</code> returns up to 100 results and a <code>nextToken</code> value if applicable.
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="meshName">The name of the service mesh to list virtual services in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="nextToken">The <code>nextToken</code> value returned from a previous paginated <code>ListVirtualServices</code> request where <code>limit</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>nextToken</code> value.</param>
		/// <returns>Success</returns>
		public async Task<ListVirtualServicesOutput> ListVirtualServicesAsync(int limit, string meshName, string meshOwner, string nextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualServices?limit="+limit+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListVirtualServicesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes an existing gateway route.
		/// DeleteGatewayRoute v20190125/meshes/{meshName}/virtualGateway/{virtualGatewayName}/gatewayRoutes/{gatewayRouteName}
		/// </summary>
		/// <param name="gatewayRouteName">The name of the gateway route to delete.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshName">The name of the service mesh to delete the gateway route from.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="virtualGatewayName">The name of the virtual gateway to delete the route from.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<DeleteGatewayRouteOutput> DeleteGatewayRouteAsync(string gatewayRouteName, string meshName, string meshOwner, string virtualGatewayName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualGateway/"+ (virtualGatewayName==null? "" : System.Uri.EscapeDataString(virtualGatewayName))+"/gatewayRoutes/"+ (gatewayRouteName==null? "" : System.Uri.EscapeDataString(gatewayRouteName))+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteGatewayRouteOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes an existing gateway route.
		/// DescribeGatewayRoute v20190125/meshes/{meshName}/virtualGateway/{virtualGatewayName}/gatewayRoutes/{gatewayRouteName}
		/// </summary>
		/// <param name="gatewayRouteName">The name of the gateway route to describe.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshName">The name of the service mesh that the gateway route resides in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="virtualGatewayName">The name of the virtual gateway that the gateway route is associated with.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<DescribeGatewayRouteOutput> DescribeGatewayRouteAsync(string gatewayRouteName, string meshName, string meshOwner, string virtualGatewayName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualGateway/"+ (virtualGatewayName==null? "" : System.Uri.EscapeDataString(virtualGatewayName))+"/gatewayRoutes/"+ (gatewayRouteName==null? "" : System.Uri.EscapeDataString(gatewayRouteName))+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeGatewayRouteOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an existing gateway route that is associated to a specified virtual gateway in a service mesh.
		/// UpdateGatewayRoute v20190125/meshes/{meshName}/virtualGateway/{virtualGatewayName}/gatewayRoutes/{gatewayRouteName}
		/// </summary>
		/// <param name="gatewayRouteName">The name of the gateway route to update.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshName">The name of the service mesh that the gateway route resides in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="virtualGatewayName">The name of the virtual gateway that the gateway route is associated with.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<UpdateGatewayRouteOutput> UpdateGatewayRouteAsync(string gatewayRouteName, string meshName, string meshOwner, string virtualGatewayName, UpdateGatewayRoutePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualGateway/"+ (virtualGatewayName==null? "" : System.Uri.EscapeDataString(virtualGatewayName))+"/gatewayRoutes/"+ (gatewayRouteName==null? "" : System.Uri.EscapeDataString(gatewayRouteName))+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateGatewayRouteOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes an existing service mesh.</p> <p>You must delete all resources (virtual services, routes, virtual routers, and virtual nodes) in the service mesh before you can delete the mesh itself.</p>
		/// DeleteMesh v20190125/meshes/{meshName}
		/// </summary>
		/// <param name="meshName">The name of the service mesh to delete.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<DeleteMeshOutput> DeleteMeshAsync(string meshName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteMeshOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes an existing service mesh.
		/// DescribeMesh v20190125/meshes/{meshName}
		/// </summary>
		/// <param name="meshName">The name of the service mesh to describe.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <returns>Success</returns>
		public async Task<DescribeMeshOutput> DescribeMeshAsync(string meshName, string meshOwner, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeMeshOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an existing service mesh.
		/// UpdateMesh v20190125/meshes/{meshName}
		/// </summary>
		/// <param name="meshName">The name of the service mesh to update.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<UpdateMeshOutput> UpdateMeshAsync(string meshName, UpdateMeshPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateMeshOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes an existing route.
		/// DeleteRoute v20190125/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}
		/// </summary>
		/// <param name="meshName">The name of the service mesh to delete the route in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="routeName">The name of the route to delete.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="virtualRouterName">The name of the virtual router to delete the route in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<DeleteRouteOutput> DeleteRouteAsync(string meshName, string meshOwner, string routeName, string virtualRouterName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualRouter/"+ (virtualRouterName==null? "" : System.Uri.EscapeDataString(virtualRouterName))+"/routes/"+ (routeName==null? "" : System.Uri.EscapeDataString(routeName))+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteRouteOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes an existing route.
		/// DescribeRoute v20190125/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}
		/// </summary>
		/// <param name="meshName">The name of the service mesh that the route resides in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="routeName">The name of the route to describe.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="virtualRouterName">The name of the virtual router that the route is associated with.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<DescribeRouteOutput> DescribeRouteAsync(string meshName, string meshOwner, string routeName, string virtualRouterName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualRouter/"+ (virtualRouterName==null? "" : System.Uri.EscapeDataString(virtualRouterName))+"/routes/"+ (routeName==null? "" : System.Uri.EscapeDataString(routeName))+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeRouteOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an existing route for a specified service mesh and virtual router.
		/// UpdateRoute v20190125/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}
		/// </summary>
		/// <param name="meshName">The name of the service mesh that the route resides in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="routeName">The name of the route to update.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="virtualRouterName">The name of the virtual router that the route is associated with.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<UpdateRouteOutput> UpdateRouteAsync(string meshName, string meshOwner, string routeName, string virtualRouterName, UpdateRoutePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualRouter/"+ (virtualRouterName==null? "" : System.Uri.EscapeDataString(virtualRouterName))+"/routes/"+ (routeName==null? "" : System.Uri.EscapeDataString(routeName))+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateRouteOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes an existing virtual gateway. You cannot delete a virtual gateway if any gateway routes are associated to it.
		/// DeleteVirtualGateway v20190125/meshes/{meshName}/virtualGateways/{virtualGatewayName}
		/// </summary>
		/// <param name="meshName">The name of the service mesh to delete the virtual gateway from.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="virtualGatewayName">The name of the virtual gateway to delete.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<DeleteVirtualGatewayOutput> DeleteVirtualGatewayAsync(string meshName, string meshOwner, string virtualGatewayName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualGateways/"+ (virtualGatewayName==null? "" : System.Uri.EscapeDataString(virtualGatewayName))+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteVirtualGatewayOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes an existing virtual gateway.
		/// DescribeVirtualGateway v20190125/meshes/{meshName}/virtualGateways/{virtualGatewayName}
		/// </summary>
		/// <param name="meshName">The name of the service mesh that the gateway route resides in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="virtualGatewayName">The name of the virtual gateway to describe.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<DescribeVirtualGatewayOutput> DescribeVirtualGatewayAsync(string meshName, string meshOwner, string virtualGatewayName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualGateways/"+ (virtualGatewayName==null? "" : System.Uri.EscapeDataString(virtualGatewayName))+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeVirtualGatewayOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an existing virtual gateway in a specified service mesh.
		/// UpdateVirtualGateway v20190125/meshes/{meshName}/virtualGateways/{virtualGatewayName}
		/// </summary>
		/// <param name="meshName">The name of the service mesh that the virtual gateway resides in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="virtualGatewayName">The name of the virtual gateway to update.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<UpdateVirtualGatewayOutput> UpdateVirtualGatewayAsync(string meshName, string meshOwner, string virtualGatewayName, UpdateVirtualGatewayPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualGateways/"+ (virtualGatewayName==null? "" : System.Uri.EscapeDataString(virtualGatewayName))+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateVirtualGatewayOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes an existing virtual node.</p> <p>You must delete any virtual services that list a virtual node as a service provider before you can delete the virtual node itself.</p>
		/// DeleteVirtualNode v20190125/meshes/{meshName}/virtualNodes/{virtualNodeName}
		/// </summary>
		/// <param name="meshName">The name of the service mesh to delete the virtual node in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="virtualNodeName">The name of the virtual node to delete.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<DeleteVirtualNodeOutput> DeleteVirtualNodeAsync(string meshName, string meshOwner, string virtualNodeName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualNodes/"+ (virtualNodeName==null? "" : System.Uri.EscapeDataString(virtualNodeName))+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteVirtualNodeOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes an existing virtual node.
		/// DescribeVirtualNode v20190125/meshes/{meshName}/virtualNodes/{virtualNodeName}
		/// </summary>
		/// <param name="meshName">The name of the service mesh that the virtual node resides in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="virtualNodeName">The name of the virtual node to describe.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<DescribeVirtualNodeOutput> DescribeVirtualNodeAsync(string meshName, string meshOwner, string virtualNodeName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualNodes/"+ (virtualNodeName==null? "" : System.Uri.EscapeDataString(virtualNodeName))+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeVirtualNodeOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an existing virtual node in a specified service mesh.
		/// UpdateVirtualNode v20190125/meshes/{meshName}/virtualNodes/{virtualNodeName}
		/// </summary>
		/// <param name="meshName">The name of the service mesh that the virtual node resides in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="virtualNodeName">The name of the virtual node to update.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<UpdateVirtualNodeOutput> UpdateVirtualNodeAsync(string meshName, string meshOwner, string virtualNodeName, UpdateVirtualNodePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualNodes/"+ (virtualNodeName==null? "" : System.Uri.EscapeDataString(virtualNodeName))+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateVirtualNodeOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes an existing virtual router.</p> <p>You must delete any routes associated with the virtual router before you can delete the router itself.</p>
		/// DeleteVirtualRouter v20190125/meshes/{meshName}/virtualRouters/{virtualRouterName}
		/// </summary>
		/// <param name="meshName">The name of the service mesh to delete the virtual router in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="virtualRouterName">The name of the virtual router to delete.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<DeleteVirtualRouterOutput> DeleteVirtualRouterAsync(string meshName, string meshOwner, string virtualRouterName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualRouters/"+ (virtualRouterName==null? "" : System.Uri.EscapeDataString(virtualRouterName))+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteVirtualRouterOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes an existing virtual router.
		/// DescribeVirtualRouter v20190125/meshes/{meshName}/virtualRouters/{virtualRouterName}
		/// </summary>
		/// <param name="meshName">The name of the service mesh that the virtual router resides in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="virtualRouterName">The name of the virtual router to describe.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<DescribeVirtualRouterOutput> DescribeVirtualRouterAsync(string meshName, string meshOwner, string virtualRouterName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualRouters/"+ (virtualRouterName==null? "" : System.Uri.EscapeDataString(virtualRouterName))+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeVirtualRouterOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an existing virtual router in a specified service mesh.
		/// UpdateVirtualRouter v20190125/meshes/{meshName}/virtualRouters/{virtualRouterName}
		/// </summary>
		/// <param name="meshName">The name of the service mesh that the virtual router resides in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="virtualRouterName">The name of the virtual router to update.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <returns>Success</returns>
		public async Task<UpdateVirtualRouterOutput> UpdateVirtualRouterAsync(string meshName, string meshOwner, string virtualRouterName, UpdateVirtualRouterPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualRouters/"+ (virtualRouterName==null? "" : System.Uri.EscapeDataString(virtualRouterName))+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateVirtualRouterOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes an existing virtual service.
		/// DeleteVirtualService v20190125/meshes/{meshName}/virtualServices/{virtualServiceName}
		/// </summary>
		/// <param name="meshName">The name of the service mesh to delete the virtual service in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="virtualServiceName">The name of the virtual service to delete.</param>
		/// <returns>Success</returns>
		public async Task<DeleteVirtualServiceOutput> DeleteVirtualServiceAsync(string meshName, string meshOwner, string virtualServiceName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualServices/"+ (virtualServiceName==null? "" : System.Uri.EscapeDataString(virtualServiceName))+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteVirtualServiceOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes an existing virtual service.
		/// DescribeVirtualService v20190125/meshes/{meshName}/virtualServices/{virtualServiceName}
		/// </summary>
		/// <param name="meshName">The name of the service mesh that the virtual service resides in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="virtualServiceName">The name of the virtual service to describe.</param>
		/// <returns>Success</returns>
		public async Task<DescribeVirtualServiceOutput> DescribeVirtualServiceAsync(string meshName, string meshOwner, string virtualServiceName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualServices/"+ (virtualServiceName==null? "" : System.Uri.EscapeDataString(virtualServiceName))+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeVirtualServiceOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an existing virtual service in a specified service mesh.
		/// UpdateVirtualService v20190125/meshes/{meshName}/virtualServices/{virtualServiceName}
		/// </summary>
		/// <param name="meshName">The name of the service mesh that the virtual service resides in.
		/// Min length: 1
		/// Max length: 255
		// </param>
		/// <param name="meshOwner">The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.
		/// Min length: 12
		/// Max length: 12
		// </param>
		/// <param name="virtualServiceName">The name of the virtual service to update.</param>
		/// <returns>Success</returns>
		public async Task<UpdateVirtualServiceOutput> UpdateVirtualServiceAsync(string meshName, string meshOwner, string virtualServiceName, UpdateVirtualServicePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/meshes/"+ (meshName==null? "" : System.Uri.EscapeDataString(meshName))+"/virtualServices/"+ (virtualServiceName==null? "" : System.Uri.EscapeDataString(virtualServiceName))+"&meshOwner=" + (meshOwner==null? "" : System.Uri.EscapeDataString(meshOwner));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateVirtualServiceOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List the tags for an App Mesh resource.
		/// ListTagsForResource v20190125/tags#resourceArn
		/// </summary>
		/// <param name="limit">The maximum number of tag results returned by <code>ListTagsForResource</code> in paginated output. When this parameter is used, <code>ListTagsForResource</code> returns only <code>limit</code> results in a single page along with a <code>nextToken</code> response element. You can see the remaining results of the initial request by sending another <code>ListTagsForResource</code> request with the returned <code>nextToken</code> value. This value can be between 1 and 100. If you don't use this parameter, <code>ListTagsForResource</code> returns up to 100 results and a <code>nextToken</code> value if applicable.
		/// Minimum: 1
		/// Maximum: 50
		// </param>
		/// <param name="nextToken">The <code>nextToken</code> value returned from a previous paginated <code>ListTagsForResource</code> request where <code>limit</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>nextToken</code> value.</param>
		/// <param name="resourceArn">The Amazon Resource Name (ARN) that identifies the resource to list the tags for.</param>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceOutput> ListTagsForResourceAsync(int limit, string nextToken, string resourceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/tags#resourceArn?limit="+limit+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&resourceArn=" + (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListTagsForResourceOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Associates the specified tags to a resource with the specified <code>resourceArn</code>. If existing tags on a resource aren't specified in the request parameters, they aren't changed. When a resource is deleted, the tags associated with that resource are also deleted.
		/// TagResource v20190125/tag#resourceArn
		/// </summary>
		/// <param name="resourceArn">The Amazon Resource Name (ARN) of the resource to add tags to.</param>
		/// <returns>Success</returns>
		public async Task<TagResourceOutput> TagResourceAsync(string resourceArn, TagResourcePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/tag#resourceArn?resourceArn=" + (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TagResourceOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes specified tags from a resource.
		/// UntagResource v20190125/untag#resourceArn
		/// </summary>
		/// <param name="resourceArn">The Amazon Resource Name (ARN) of the resource to delete tags from.</param>
		/// <returns>Success</returns>
		public async Task<UntagResourceOutput> UntagResourceAsync(string resourceArn, UntagResourcePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v20190125/untag#resourceArn?resourceArn=" + (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UntagResourceOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	public class CreateGatewayRoutePutBody
	{
		
		/// <summary>
		/// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// The name to use for the gateway route.
		/// Required
		/// Min length: 1
		/// Max length: 255
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gatewayRouteName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		public string GatewayRouteName { get; set; }
		
		/// <summary>
		/// An object that represents a gateway route specification. Specify one gateway route type.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public CreateGatewayRoutePutBodySpec Spec { get; set; }
		
		/// <summary>
		/// Optional metadata that you can apply to the gateway route to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
		/// Minimum items: 0
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public TagRef[] Tags { get; set; }
	}
	
	public class CreateGatewayRoutePutBodySpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="grpcRoute")]
		public GrpcGatewayRoute GrpcRoute { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="http2Route")]
		public HttpGatewayRoute Http2Route { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="httpRoute")]
		public HttpGatewayRoute HttpRoute { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public System.Nullable<System.Int32> Priority { get; set; }
	}
	
	public class CreateMeshPutBody
	{
		
		/// <summary>
		/// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// The name to use for the service mesh.
		/// Required
		/// Min length: 1
		/// Max length: 255
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="meshName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		public string MeshName { get; set; }
		
		/// <summary>
		/// An object that represents the specification of a service mesh.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public CreateMeshPutBodySpec Spec { get; set; }
		
		/// <summary>
		/// Optional metadata that you can apply to the service mesh to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
		/// Minimum items: 0
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public TagRef[] Tags { get; set; }
	}
	
	public class CreateMeshPutBodySpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="egressFilter")]
		public EgressFilter EgressFilter { get; set; }
		
		/// <summary>
		/// An object that represents the service discovery information for a service mesh.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceDiscovery")]
		public MeshServiceDiscovery ServiceDiscovery { get; set; }
	}
	
	public class CreateRoutePutBody
	{
		
		/// <summary>
		/// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// The name to use for the route.
		/// Required
		/// Min length: 1
		/// Max length: 255
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="routeName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		public string RouteName { get; set; }
		
		/// <summary>
		/// An object that represents a route specification. Specify one route type.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public CreateRoutePutBodySpec Spec { get; set; }
		
		/// <summary>
		/// Optional metadata that you can apply to the route to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
		/// Minimum items: 0
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public TagRef[] Tags { get; set; }
	}
	
	public class CreateRoutePutBodySpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="grpcRoute")]
		public GrpcRoute GrpcRoute { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="http2Route")]
		public HttpRoute Http2Route { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="httpRoute")]
		public HttpRoute HttpRoute { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public System.Nullable<System.Int32> Priority { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tcpRoute")]
		public TcpRoute TcpRoute { get; set; }
	}
	
	public class CreateVirtualGatewayPutBody
	{
		
		/// <summary>
		/// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// An object that represents the specification of a service mesh resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public CreateVirtualGatewayPutBodySpec Spec { get; set; }
		
		/// <summary>
		/// Optional metadata that you can apply to the virtual gateway to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
		/// Minimum items: 0
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public TagRef[] Tags { get; set; }
		
		/// <summary>
		/// The name to use for the virtual gateway.
		/// Required
		/// Min length: 1
		/// Max length: 255
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualGatewayName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		public string VirtualGatewayName { get; set; }
	}
	
	public class CreateVirtualGatewayPutBodySpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="backendDefaults")]
		public VirtualGatewayBackendDefaults BackendDefaults { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="listeners")]
		public VirtualGatewayListener[] Listeners { get; set; }
		
		/// <summary>
		/// An object that represents logging information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logging")]
		public VirtualGatewayLogging Logging { get; set; }
	}
	
	public class CreateVirtualNodePutBody
	{
		
		/// <summary>
		/// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// An object that represents the specification of a virtual node.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public CreateVirtualNodePutBodySpec Spec { get; set; }
		
		/// <summary>
		/// Optional metadata that you can apply to the virtual node to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
		/// Minimum items: 0
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public TagRef[] Tags { get; set; }
		
		/// <summary>
		/// The name to use for the virtual node.
		/// Required
		/// Min length: 1
		/// Max length: 255
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualNodeName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		public string VirtualNodeName { get; set; }
	}
	
	public class CreateVirtualNodePutBodySpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="backendDefaults")]
		public BackendDefaults BackendDefaults { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="backends")]
		public Backend[] Backends { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="listeners")]
		public Listener[] Listeners { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="logging")]
		public Logging Logging { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="serviceDiscovery")]
		public ServiceDiscovery ServiceDiscovery { get; set; }
	}
	
	public class CreateVirtualRouterPutBody
	{
		
		/// <summary>
		/// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// An object that represents the specification of a virtual router.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public CreateVirtualRouterPutBodySpec Spec { get; set; }
		
		/// <summary>
		/// Optional metadata that you can apply to the virtual router to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
		/// Minimum items: 0
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public TagRef[] Tags { get; set; }
		
		/// <summary>
		/// The name to use for the virtual router.
		/// Required
		/// Min length: 1
		/// Max length: 255
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualRouterName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		public string VirtualRouterName { get; set; }
	}
	
	public class CreateVirtualRouterPutBodySpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="listeners")]
		public VirtualRouterListener[] Listeners { get; set; }
	}
	
	public class CreateVirtualServicePutBody
	{
		
		/// <summary>
		/// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// An object that represents the specification of a virtual service.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public CreateVirtualServicePutBodySpec Spec { get; set; }
		
		/// <summary>
		/// Optional metadata that you can apply to the virtual service to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
		/// Minimum items: 0
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public TagRef[] Tags { get; set; }
		
		/// <summary>
		/// The name to use for the virtual service.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualServiceName")]
		public string VirtualServiceName { get; set; }
	}
	
	public class CreateVirtualServicePutBodySpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="provider")]
		public VirtualServiceProvider Provider { get; set; }
	}
	
	public class UpdateGatewayRoutePutBody
	{
		
		/// <summary>
		/// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// An object that represents a gateway route specification. Specify one gateway route type.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public UpdateGatewayRoutePutBodySpec Spec { get; set; }
	}
	
	public class UpdateGatewayRoutePutBodySpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="grpcRoute")]
		public GrpcGatewayRoute GrpcRoute { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="http2Route")]
		public HttpGatewayRoute Http2Route { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="httpRoute")]
		public HttpGatewayRoute HttpRoute { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public System.Nullable<System.Int32> Priority { get; set; }
	}
	
	public class UpdateMeshPutBody
	{
		
		/// <summary>
		/// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// An object that represents the specification of a service mesh.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public UpdateMeshPutBodySpec Spec { get; set; }
	}
	
	public class UpdateMeshPutBodySpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="egressFilter")]
		public EgressFilter EgressFilter { get; set; }
		
		/// <summary>
		/// An object that represents the service discovery information for a service mesh.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceDiscovery")]
		public MeshServiceDiscovery ServiceDiscovery { get; set; }
	}
	
	public class UpdateRoutePutBody
	{
		
		/// <summary>
		/// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// An object that represents a route specification. Specify one route type.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public UpdateRoutePutBodySpec Spec { get; set; }
	}
	
	public class UpdateRoutePutBodySpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="grpcRoute")]
		public GrpcRoute GrpcRoute { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="http2Route")]
		public HttpRoute Http2Route { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="httpRoute")]
		public HttpRoute HttpRoute { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public System.Nullable<System.Int32> Priority { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tcpRoute")]
		public TcpRoute TcpRoute { get; set; }
	}
	
	public class UpdateVirtualGatewayPutBody
	{
		
		/// <summary>
		/// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// An object that represents the specification of a service mesh resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public UpdateVirtualGatewayPutBodySpec Spec { get; set; }
	}
	
	public class UpdateVirtualGatewayPutBodySpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="backendDefaults")]
		public VirtualGatewayBackendDefaults BackendDefaults { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="listeners")]
		public VirtualGatewayListener[] Listeners { get; set; }
		
		/// <summary>
		/// An object that represents logging information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logging")]
		public VirtualGatewayLogging Logging { get; set; }
	}
	
	public class UpdateVirtualNodePutBody
	{
		
		/// <summary>
		/// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// An object that represents the specification of a virtual node.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public UpdateVirtualNodePutBodySpec Spec { get; set; }
	}
	
	public class UpdateVirtualNodePutBodySpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="backendDefaults")]
		public BackendDefaults BackendDefaults { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="backends")]
		public Backend[] Backends { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="listeners")]
		public Listener[] Listeners { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="logging")]
		public Logging Logging { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="serviceDiscovery")]
		public ServiceDiscovery ServiceDiscovery { get; set; }
	}
	
	public class UpdateVirtualRouterPutBody
	{
		
		/// <summary>
		/// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// An object that represents the specification of a virtual router.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public UpdateVirtualRouterPutBodySpec Spec { get; set; }
	}
	
	public class UpdateVirtualRouterPutBodySpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="listeners")]
		public VirtualRouterListener[] Listeners { get; set; }
	}
	
	public class UpdateVirtualServicePutBody
	{
		
		/// <summary>
		/// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// An object that represents the specification of a virtual service.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="spec")]
		public UpdateVirtualServicePutBodySpec Spec { get; set; }
	}
	
	public class UpdateVirtualServicePutBodySpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="provider")]
		public VirtualServiceProvider Provider { get; set; }
	}
	
	public class TagResourcePutBody
	{
		
		/// <summary>
		/// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
		/// Required
		/// Minimum items: 0
		/// Maximum items: 50
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public TagRef[] Tags { get; set; }
	}
	
	public class UntagResourcePutBody
	{
		
		/// <summary>
		/// The keys of the tags to be removed.
		/// Required
		/// Minimum items: 0
		/// Maximum items: 50
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tagKeys")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string[] TagKeys { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
