//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchGetFindingsResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="failedFindings")]
		public BatchGetFindingsError[] FailedFindings { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="findings")]
		public Finding[] Findings { get; set; }
	}
	
	/// <summary>
	/// Contains information about the error that caused a finding to fail to be retrieved.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchGetFindingsError
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="errorCode")]
		public ErrorCode ErrorCode { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="findingId")]
		public string FindingId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scanName")]
		public string ScanName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ErrorCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DUPLICATE_IDENTIFIER")]
		DUPLICATE_IDENTIFIER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ITEM_DOES_NOT_EXIST")]
		ITEM_DOES_NOT_EXIST = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INTERNAL_ERROR")]
		INTERNAL_ERROR = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INVALID_FINDING_ID")]
		INVALID_FINDING_ID = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INVALID_SCAN_NAME")]
		INVALID_SCAN_NAME = 4,
	}
	
	/// <summary>
	/// Information about a finding that was detected in your code.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Finding
	{
		
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="detectorId")]
		public string DetectorId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="detectorName")]
		public string DetectorName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="detectorTags")]
		public string[] DetectorTags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="generatorId")]
		public string GeneratorId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="remediation")]
		public Remediation Remediation { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public Resource Resource { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ruleId")]
		public string RuleId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="severity")]
		public Severity Severity { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Status Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="vulnerability")]
		public Vulnerability Vulnerability { get; set; }
	}
	
	/// <summary>
	/// Information about how to remediate a finding.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Remediation
	{
		
		[System.Runtime.Serialization.DataMember(Name="recommendation")]
		public Recommendation Recommendation { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="suggestedFixes")]
		public SuggestedFix[] SuggestedFixes { get; set; }
	}
	
	/// <summary>
	/// Information about the recommended course of action to remediate a finding.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Recommendation
	{
		
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Information about the suggested code fix to remediate a finding.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SuggestedFix
	{
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
	}
	
	/// <summary>
	/// Information about a resource, such as an Amazon S3 bucket or AWS Lambda function, that contains a finding.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Resource
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subResourceId")]
		public string SubResourceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Severity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Critical")]
		Critical = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="High")]
		High = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Medium")]
		Medium = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Low")]
		Low = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Info")]
		Info = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Status
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Closed")]
		Closed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Open")]
		Open = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All")]
		All = 2,
	}
	
	/// <summary>
	/// Information about a security vulnerability that Amazon CodeGuru Security detected.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Vulnerability
	{
		
		[System.Runtime.Serialization.DataMember(Name="filePath")]
		public FilePath FilePath { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="itemCount")]
		public System.Nullable<System.Int32> ItemCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="referenceUrls")]
		public string[] ReferenceUrls { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="relatedVulnerabilities")]
		public string[] RelatedVulnerabilities { get; set; }
	}
	
	/// <summary>
	/// Information about the location of security vulnerabilities that Amazon CodeGuru Security detected in your code.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilePath
	{
		
		[System.Runtime.Serialization.DataMember(Name="codeSnippet")]
		public CodeLine[] CodeSnippet { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endLine")]
		public System.Nullable<System.Int32> EndLine { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="startLine")]
		public System.Nullable<System.Int32> StartLine { get; set; }
	}
	
	/// <summary>
	/// The line of code where a finding was detected.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CodeLine
	{
		
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Int32> Number { get; set; }
	}
	
	/// <summary>
	/// An object that contains information about a finding and the scan that generated it. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FindingIdentifier
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="findingId")]
		public string FindingId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scanName")]
		public string ScanName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InternalServerException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ThrottlingException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ValidationException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AccessDeniedException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateScanResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceId")]
		public ResourceId ResourceId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runId")]
		public string RunId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scanName")]
		public string ScanName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="scanNameArn")]
		public string ScanNameArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scanState")]
		public ScanState ScanState { get; set; }
	}
	
	/// <summary>
	/// The identifier for a resource object that contains resources where a finding was detected.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceId
	{
		
		[System.Runtime.Serialization.DataMember(Name="codeArtifactId")]
		public string CodeArtifactId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ScanState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="InProgress")]
		InProgress = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Successful")]
		Successful = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Failed")]
		Failed = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConflictException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceNotFoundException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateUploadUrlResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="codeArtifactId")]
		public string CodeArtifactId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requestHeaders")]
		public RequestHeaderMap RequestHeaders { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="s3Url")]
		public string S3Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RequestHeaderMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetAccountConfigurationResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="encryptionConfig")]
		public EncryptionConfig EncryptionConfig { get; set; }
	}
	
	/// <summary>
	/// Information about account-level configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EncryptionConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="kmsKeyArn")]
		public string KmsKeyArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetFindingsResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="findings")]
		public Finding[] Findings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetMetricsSummaryResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="metricsSummary")]
		public MetricsSummary MetricsSummary { get; set; }
	}
	
	/// <summary>
	/// Information about summary metrics in an account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MetricsSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="categoriesWithMostFindings")]
		public CategoryWithFindingNum[] CategoriesWithMostFindings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="date")]
		public System.DateTimeOffset Date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="openFindings")]
		public FindingMetricsValuePerSeverity OpenFindings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="scansWithMostOpenCriticalFindings")]
		public ScanNameWithFindingNum[] ScansWithMostOpenCriticalFindings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="scansWithMostOpenFindings")]
		public ScanNameWithFindingNum[] ScansWithMostOpenFindings { get; set; }
	}
	
	/// <summary>
	/// Information about a finding category with open findings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CategoryWithFindingNum
	{
		
		[System.Runtime.Serialization.DataMember(Name="categoryName")]
		public string CategoryName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="findingNumber")]
		public System.Nullable<System.Int32> FindingNumber { get; set; }
	}
	
	/// <summary>
	/// The severity of the issue in the code that generated a finding.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FindingMetricsValuePerSeverity
	{
		
		[System.Runtime.Serialization.DataMember(Name="critical")]
		public System.Nullable<System.Double> Critical { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="high")]
		public System.Nullable<System.Double> High { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="info")]
		public System.Nullable<System.Double> Info { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="low")]
		public System.Nullable<System.Double> Low { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="medium")]
		public System.Nullable<System.Double> Medium { get; set; }
	}
	
	/// <summary>
	/// Information about a scan with open findings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScanNameWithFindingNum
	{
		
		[System.Runtime.Serialization.DataMember(Name="findingNumber")]
		public System.Nullable<System.Int32> FindingNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="scanName")]
		public string ScanName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetScanResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analysisType")]
		public AnalysisType AnalysisType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="numberOfRevisions")]
		public System.Nullable<System.Int32> NumberOfRevisions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runId")]
		public string RunId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scanName")]
		public string ScanName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="scanNameArn")]
		public string ScanNameArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scanState")]
		public ScanState ScanState { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AnalysisType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Security")]
		Security = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="All")]
		All = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListFindingsMetricsResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="findingsMetrics")]
		public AccountFindingsMetric[] FindingsMetrics { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// A summary of findings metrics in an account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AccountFindingsMetric
	{
		
		[System.Runtime.Serialization.DataMember(Name="closedFindings")]
		public FindingMetricsValuePerSeverity ClosedFindings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="date")]
		public System.DateTimeOffset Date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="meanTimeToClose")]
		public FindingMetricsValuePerSeverity MeanTimeToClose { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="newFindings")]
		public FindingMetricsValuePerSeverity NewFindings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="openFindings")]
		public FindingMetricsValuePerSeverity OpenFindings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListScansResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="summaries")]
		public ScanSummary[] Summaries { get; set; }
	}
	
	/// <summary>
	/// Information about a scan. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScanSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runId")]
		public string RunId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scanName")]
		public string ScanName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="scanNameArn")]
		public string ScanNameArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scanState")]
		public ScanState ScanState { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagMap Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagResourceResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UntagResourceResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateAccountConfigurationResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="encryptionConfig")]
		public EncryptionConfig EncryptionConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchGetFindingsRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="findingIdentifiers")]
		public FindingIdentifier[] FindingIdentifiers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ScanType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Standard")]
		Standard = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Express")]
		Express = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateScanRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="analysisType")]
		public AnalysisType AnalysisType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceId")]
		public ResourceId ResourceId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scanName")]
		public string ScanName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="scanType")]
		public ScanType ScanType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagMap Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateUploadUrlRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scanName")]
		public string ScanName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetAccountConfigurationRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetFindingsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetMetricsSummaryRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetScanRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListFindingsMetricsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListScansRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagResourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagMap Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UntagResourceRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateAccountConfigurationRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="encryptionConfig")]
		public EncryptionConfig EncryptionConfig { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Returns a list of all requested findings.
		/// BatchGetFindings batchGetFindings
		/// </summary>
		/// <returns>Success</returns>
		public async Task<BatchGetFindingsResponse> BatchGetFindingsAsync(BatchGetFindingsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "batchGetFindings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BatchGetFindingsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Use to create a scan using code uploaded to an S3 bucket.
		/// CreateScan scans
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateScanResponse> CreateScanAsync(CreateScanPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "scans";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateScanResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of all the standard scans in an account. Does not return express scans.
		/// ListScans scans
		/// </summary>
		/// <param name="maxResults">The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the <code>nextToken</code> element is returned in the response. Use <code>nextToken</code> in a subsequent request to retrieve additional results.
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="nextToken">A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request. For subsequent calls, use the <code>nextToken</code> value returned from the previous request to continue listing results after the first page.
		/// Min length: 1
		/// Max length: 2048
		// </param>
		/// <returns>Success</returns>
		public async Task<ListScansResponse> ListScansAsync(int maxResults, string nextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "scans?maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListScansResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Generates a pre-signed URL and request headers used to upload a code resource.</p> <p>You can upload your code resource to the URL and add the request headers using any HTTP client.</p>
		/// CreateUploadUrl uploadUrl
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateUploadUrlResponse> CreateUploadUrlAsync(CreateUploadUrlPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "uploadUrl";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateUploadUrlResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Use to get account level configuration.
		/// GetAccountConfiguration accountConfiguration/get
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetAccountConfigurationResponse> GetAccountConfigurationAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accountConfiguration/get";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetAccountConfigurationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of all findings generated by a particular scan.
		/// GetFindings findings/{scanName}
		/// </summary>
		/// <param name="maxResults">The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the <code>nextToken</code> element is returned in the response. Use <code>nextToken</code> in a subsequent request to retrieve additional results.
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="nextToken">A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request. For subsequent calls, use the <code>nextToken</code> value returned from the previous request to continue listing results after the first page.
		/// Min length: 1
		/// Max length: 2048
		// </param>
		/// <param name="scanName">The name of the scan you want to retrieve findings from.
		/// Min length: 1
		/// Max length: 140
		// </param>
		/// <param name="status">The status of the findings you want to get. Pass either <code>Open</code>, <code>Closed</code>, or <code>All</code>.</param>
		/// <returns>Success</returns>
		public async Task<GetFindingsResponse> GetFindingsAsync(int maxResults, string nextToken, string scanName, Status status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "findings/"+ (scanName==null? "" : System.Uri.EscapeDataString(scanName))+"?maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&status=" + status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetFindingsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns top level metrics about an account from a specified date, including number of open findings, the categories with most findings, the scans with most open findings, and scans with most open critical findings.
		/// GetMetricsSummary metrics/summary#date
		/// </summary>
		/// <param name="date">The date you want to retrieve summary metrics from, rounded to the nearest day. The date must be within the past two years since metrics data is only stored for two years. If a date outside of this range is passed, the response will be empty.</param>
		/// <returns>Success</returns>
		public async Task<GetMetricsSummaryResponse> GetMetricsSummaryAsync(System.DateTimeOffset date, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "metrics/summary#date?date=" + date.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetMetricsSummaryResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns details about a scan, including whether or not a scan has completed.
		/// GetScan scans/{scanName}
		/// </summary>
		/// <param name="runId">UUID that identifies the individual scan run you want to view details about. You retrieve this when you call the <code>CreateScan</code> operation. Defaults to the latest scan run if missing.</param>
		/// <param name="scanName">The name of the scan you want to view details about.
		/// Min length: 1
		/// Max length: 140
		// </param>
		/// <returns>Success</returns>
		public async Task<GetScanResponse> GetScanAsync(string runId, string scanName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "scans/"+ (scanName==null? "" : System.Uri.EscapeDataString(scanName))+"?runId=" + (runId==null? "" : System.Uri.EscapeDataString(runId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetScanResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns metrics about all findings in an account within a specified time range.
		/// ListFindingsMetrics metrics/findings#endDate&startDate
		/// </summary>
		/// <param name="endDate">The end date of the interval which you want to retrieve metrics from.</param>
		/// <param name="maxResults">The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the <code>nextToken</code> element is returned in the response. Use <code>nextToken</code> in a subsequent request to retrieve additional results.
		/// Minimum: 1
		/// Maximum: 1000
		// </param>
		/// <param name="nextToken">A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request. For subsequent calls, use the <code>nextToken</code> value returned from the previous request to continue listing results after the first page.
		/// Min length: 1
		/// Max length: 2048
		// </param>
		/// <param name="startDate">The start date of the interval which you want to retrieve metrics from.</param>
		/// <returns>Success</returns>
		public async Task<ListFindingsMetricsResponse> ListFindingsMetricsAsync(System.DateTimeOffset endDate, int maxResults, string nextToken, System.DateTimeOffset startDate, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "metrics/findings#endDate&startDate?endDate=" + endDate.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&startDate=" + startDate.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListFindingsMetricsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of all tags associated with a scan.
		/// ListTagsForResource tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">The ARN of the <code>ScanName</code> object. You can retrieve this ARN by calling <code>ListScans</code> or <code>GetScan</code>.
		/// Min length: 1
		/// Max length: 300
		// </param>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceResponse> ListTagsForResourceAsync(string resourceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListTagsForResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Use to add one or more tags to an existing scan.
		/// TagResource tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">The ARN of the <code>ScanName</code> object. You can retrieve this ARN by calling <code>ListScans</code> or <code>GetScan</code>.
		/// Min length: 1
		/// Max length: 300
		// </param>
		public async Task TagResourceAsync(string resourceArn, TagResourcePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Use to remove one or more tags from an existing scan.
		/// UntagResource tags/{resourceArn}#tagKeys
		/// </summary>
		/// <param name="resourceArn">The ARN of the <code>ScanName</code> object. You can retrieve this ARN by calling <code>ListScans</code> or <code>GetScan</code>.
		/// Min length: 1
		/// Max length: 300
		// </param>
		/// <param name="tagKeys">A list of keys for each tag you want to remove from a scan.
		/// Minimum items: 0
		/// Maximum items: 200
		// </param>
		public async Task UntagResourceAsync(string resourceArn, string[] tagKeys, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn))+"#tagKeys&"+string.Join("&", tagKeys.Select(z => $"tagKeys={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Use to update account-level configuration with an encryption key.
		/// UpdateAccountConfiguration updateAccountConfiguration
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateAccountConfigurationResponse> UpdateAccountConfigurationAsync(UpdateAccountConfigurationPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "updateAccountConfiguration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateAccountConfigurationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	public class BatchGetFindingsPostBody
	{
		
		/// <summary>
		/// A list of finding identifiers. Each identifier consists of a <code>scanName</code> and a <code>findingId</code>. You retrieve the <code>findingId</code> when you call <code>GetFindings</code>.
		/// Required
		/// Minimum items: 1
		/// Maximum items: 25
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="findingIdentifiers")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(25)]
		public FindingIdentifier[] FindingIdentifiers { get; set; }
	}
	
	public class CreateScanPostBody
	{
		
		/// <summary>
		/// The type of analysis you want CodeGuru Security to perform in the scan, either <code>Security</code> or <code>All</code>. The <code>Security</code> type only generates findings related to security. The <code>All</code> type generates both security findings and quality findings. Defaults to <code>Security</code> type if missing.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="analysisType")]
		public AnalysisType AnalysisType { get; set; }
		
		/// <summary>
		/// The idempotency token for the request. Amazon CodeGuru Security uses this value to prevent the accidental creation of duplicate scans if there are failures and retries.
		/// Min length: 1
		/// Max length: 64
		/// Pattern: ^[\S]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientToken")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[\S]+$")]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// The identifier for a resource object that contains resources where a finding was detected.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceId")]
		public CreateScanPostBodyResourceId ResourceId { get; set; }
		
		/// <summary>
		/// The unique name that CodeGuru Security uses to track revisions across multiple scans of the same resource. Only allowed for a <code>STANDARD</code> scan type. If not specified, it will be auto generated. 
		/// Required
		/// Min length: 1
		/// Max length: 140
		/// Pattern: ^[a-zA-Z0-9-_$:.]*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scanName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(140)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9-_$:.]*$")]
		public string ScanName { get; set; }
		
		/// <summary>
		/// <p>The type of scan, either <code>Standard</code> or <code>Express</code>. Defaults to <code>Standard</code> type if missing.</p> <p> <code>Express</code> scans run on limited resources and use a limited set of detectors to analyze your code in near-real time. <code>Standard</code> scans have standard resource limits and use the full set of detectors to analyze your code.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scanType")]
		public ScanType ScanType { get; set; }
		
		/// <summary>
		/// <p>An array of key-value pairs used to tag a scan. A tag is a custom attribute label with two parts:</p> <ul> <li> <p>A tag key. For example, <code>CostCenter</code>, <code>Environment</code>, or <code>Secret</code>. Tag keys are case sensitive.</p> </li> <li> <p>An optional tag value field. For example, <code>111122223333</code>, <code>Production</code>, or a team name. Omitting the tag value is the same as using an empty string. Tag values are case sensitive.</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public class CreateScanPostBodyResourceId
	{
		
		[System.Runtime.Serialization.DataMember(Name="codeArtifactId")]
		public string CodeArtifactId { get; set; }
	}
	
	public class CreateUploadUrlPostBody
	{
		
		/// <summary>
		/// The name of the scan that will use the uploaded resource. CodeGuru Security uses the unique scan name to track revisions across multiple scans of the same resource. Use this <code>scanName</code> when you call <code>CreateScan</code> on the code resource you upload to this URL.
		/// Required
		/// Min length: 1
		/// Max length: 140
		/// Pattern: ^[a-zA-Z0-9-_$:.]*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scanName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(140)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9-_$:.]*$")]
		public string ScanName { get; set; }
	}
	
	public class TagResourcePostBody
	{
		
		/// <summary>
		/// <p>An array of key-value pairs used to tag an existing scan. A tag is a custom attribute label with two parts:</p> <ul> <li> <p>A tag key. For example, <code>CostCenter</code>, <code>Environment</code>, or <code>Secret</code>. Tag keys are case sensitive.</p> </li> <li> <p>An optional tag value field. For example, <code>111122223333</code>, <code>Production</code>, or a team name. Omitting the tag value is the same as using an empty string. Tag values are case sensitive.</p> </li> </ul>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public class UpdateAccountConfigurationPutBody
	{
		
		/// <summary>
		/// Information about account-level configuration.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="encryptionConfig")]
		public UpdateAccountConfigurationPutBodyEncryptionConfig EncryptionConfig { get; set; }
	}
	
	public class UpdateAccountConfigurationPutBodyEncryptionConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="kmsKeyArn")]
		public string KmsKeyArn { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
