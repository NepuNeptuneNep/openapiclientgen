//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigureLogsForChannelResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LogType[] LogTypes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum LogType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AS_RUN")]
		AS_RUN = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigureLogsForPlaybackConfigurationResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int PercentEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PlaybackConfigurationName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateChannelResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelState ChannelState { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SlateSource FillerSlate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModifiedTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ResponseOutputItem[] Outputs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PlaybackMode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Tier { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ChannelState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RUNNING")]
		RUNNING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="STOPPED")]
		STOPPED = 1,
	}
	
	/// <summary>
	/// Slate VOD source configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SlateSource
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VodSourceName { get; set; }
	}
	
	/// <summary>
	/// The output item response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResponseOutputItem
	{
		
		[System.Runtime.Serialization.DataMember()]
		public DashPlaylistSettings DashPlaylistSettings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HlsPlaylistSettings HlsPlaylistSettings { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ManifestName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PlaybackUrl { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceGroup { get; set; }
	}
	
	/// <summary>
	/// Dash manifest configuration parameters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DashPlaylistSettings
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ManifestWindowSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MinBufferTimeSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MinUpdatePeriodSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SuggestedPresentationDelaySeconds { get; set; }
	}
	
	/// <summary>
	/// HLS playlist configuration parameters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HlsPlaylistSettings
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AdMarkupType[] AdMarkupType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ManifestWindowSeconds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AdMarkupType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DATERANGE")]
		DATERANGE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SCTE35_ENHANCED")]
		SCTE35_ENHANCED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class @__mapOf__string
	{
	}
	
	/// <summary>
	/// The output configuration for this channel.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RequestOutputItem
	{
		
		[System.Runtime.Serialization.DataMember()]
		public DashPlaylistSettings DashPlaylistSettings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HlsPlaylistSettings HlsPlaylistSettings { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ManifestName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceGroup { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateLiveSourceResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HttpPackageConfiguration[] HttpPackageConfigurations { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModifiedTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LiveSourceName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	/// <summary>
	/// The HTTP package configuration properties for the requested VOD source.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpPackageConfiguration
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceGroup { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Type Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DASH")]
		DASH = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HLS")]
		HLS = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreatePrefetchScheduleResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PrefetchConsumption Consumption { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PlaybackConfigurationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PrefetchRetrieval Retrieval { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StreamId { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains settings that determine how and when that MediaTailor places prefetched ads into upcoming ad breaks.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PrefetchConsumption
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AvailMatchingCriteria[] AvailMatchingCriteria { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset EndTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset StartTime { get; set; }
	}
	
	/// <summary>
	/// <p>MediaTailor only places (consumes) prefetched ads if the ad break meets the criteria defined by the dynamic variables. This gives you granular control over which ad break to place the prefetched ads into.</p> <p>As an example, let's say that you set <code>DynamicVariable</code> to <code>scte.event_id</code> and <code>Operator</code> to <code>EQUALS</code>, and your playback configuration has an ADS URL of <code>https://my.ads.server.com/path?&amp;podId=[scte.avail_num]&amp;event=[scte.event_id]&amp;duration=[session.avail_duration_secs]</code>. And the prefetch request to the ADS contains these values <code>https://my.ads.server.com/path?&amp;podId=3&amp;event=my-awesome-event&amp;duration=30</code>. MediaTailor will only insert the prefetched ads into the ad break if has a SCTE marker with an event id of <code>my-awesome-event</code>, since it must match the event id that MediaTailor uses to query the ADS.</p> <p>You can specify up to five <code>AvailMatchingCriteria</code>. If you specify multiple <code>AvailMatchingCriteria</code>, MediaTailor combines them to match using a logical <code>AND</code>. You can model logical <code>OR</code> combinations by creating multiple prefetch schedules.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AvailMatchingCriteria
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DynamicVariable { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Operator Operator { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Operator
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="EQUALS")]
		EQUALS = 0,
	}
	
	/// <summary>
	/// A complex type that contains settings governing when MediaTailor prefetches ads, and which dynamic variables that MediaTailor includes in the request to the ad decision server.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PrefetchRetrieval
	{
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string DynamicVariables { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset EndTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset StartTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateProgramResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AdBreak[] AdBreaks { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClipRange ClipRange { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DurationMillis { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LiveSourceName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ProgramName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ScheduledStartTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VodSourceName { get; set; }
	}
	
	/// <summary>
	/// Ad break configuration parameters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AdBreak
	{
		
		[System.Runtime.Serialization.DataMember()]
		public KeyValuePair[] AdBreakMetadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MessageType MessageType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> OffsetMillis { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SlateSource Slate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SpliceInsertMessage SpliceInsertMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TimeSignalMessage TimeSignalMessage { get; set; }
	}
	
	/// <summary>
	/// For <code>SCTE35_ENHANCED</code> output, defines a key and corresponding value. MediaTailor generates these pairs within the <code>EXT-X-ASSET</code>tag.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KeyValuePair
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MessageType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SPLICE_INSERT")]
		SPLICE_INSERT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TIME_SIGNAL")]
		TIME_SIGNAL = 1,
	}
	
	/// <summary>
	/// Splice insert message configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SpliceInsertMessage
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AvailNum { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AvailsExpected { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SpliceEventId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> UniqueProgramId { get; set; }
	}
	
	/// <summary>
	/// <p>The SCTE-35 <code>time_signal</code> message can be sent with one or more <code>segmentation_descriptor</code> messages. A <code>time_signal</code> message can be sent only if a single <code>segmentation_descriptor</code> message is sent.</p> <p>The <code>time_signal</code> message contains only the <code>splice_time</code> field which is constructed using a given presentation timestamp. When sending a <code>time_signal</code> message, the <code>splice_command_type</code> field in the <code>splice_info_section</code> message is set to 6 (0x06).</p> <p>See the <code>time_signal()</code> table of the 2022 SCTE-35 specification for more information.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TimeSignalMessage
	{
		
		[System.Runtime.Serialization.DataMember()]
		public SegmentationDescriptor[] SegmentationDescriptors { get; set; }
	}
	
	/// <summary>
	/// <p>The <code>segmentation_descriptor</code> message can contain advanced metadata fields, like content identifiers, to convey a wide range of information about the ad break. MediaTailor writes the ad metadata in the egress manifest as part of the <code>EXT-X-DATERANGE</code> or <code>EventStream</code> ad marker's SCTE-35 data.</p> <p> <code>segmentation_descriptor</code> messages must be sent with the <code>time_signal</code> message type.</p> <p>See the <code>segmentation_descriptor()</code> table of the 2022 SCTE-35 specification for more information.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SegmentationDescriptor
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SegmentNum { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SegmentationEventId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SegmentationTypeId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SegmentationUpid { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SegmentationUpidType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SegmentsExpected { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SubSegmentNum { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SubSegmentsExpected { get; set; }
	}
	
	/// <summary>
	/// Clip range configuration for the VOD source associated with the program.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClipRange
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int EndOffsetMillis { get; set; }
	}
	
	/// <summary>
	/// Program transition configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Transition
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DurationMillis { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RelativePosition RelativePosition { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RelativeProgram { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ScheduledStartTimeMillis { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum RelativePosition
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BEFORE_PROGRAM")]
		BEFORE_PROGRAM = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AFTER_PROGRAM")]
		AFTER_PROGRAM = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateSourceLocationResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AccessConfiguration AccessConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DefaultSegmentDeliveryConfiguration DefaultSegmentDeliveryConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HttpConfiguration HttpConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModifiedTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SegmentDeliveryConfiguration[] SegmentDeliveryConfigurations { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	/// <summary>
	/// Access configuration parameters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AccessConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AccessType AccessType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SecretsManagerAccessTokenConfiguration SecretsManagerAccessTokenConfiguration { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AccessType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="S3_SIGV4")]
		S3_SIGV4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SECRETS_MANAGER_ACCESS_TOKEN")]
		SECRETS_MANAGER_ACCESS_TOKEN = 1,
	}
	
	/// <summary>
	/// AWS Secrets Manager access token configuration parameters. For information about Secrets Manager access token authentication, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-access-configuration-access-token.html">Working with AWS Secrets Manager access token authentication</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecretsManagerAccessTokenConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string HeaderName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SecretArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SecretStringKey { get; set; }
	}
	
	/// <summary>
	/// The optional configuration for a server that serves segments. Use this if you want the segment delivery server to be different from the source location server. For example, you can configure your source location server to be an origination server, such as MediaPackage, and the segment delivery server to be a content delivery network (CDN), such as CloudFront. If you don't specify a segment delivery server, then the source location server is used.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DefaultSegmentDeliveryConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BaseUrl { get; set; }
	}
	
	/// <summary>
	/// The HTTP configuration for the source location.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpConfiguration
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BaseUrl { get; set; }
	}
	
	/// <summary>
	/// The segment delivery configuration settings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SegmentDeliveryConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BaseUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateVodSourceResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HttpPackageConfiguration[] HttpPackageConfigurations { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModifiedTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VodSourceName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteChannelResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteChannelPolicyResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteLiveSourceResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeletePlaybackConfigurationResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeletePrefetchScheduleResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteProgramResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteSourceLocationResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteVodSourceResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeChannelResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelState ChannelState { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SlateSource FillerSlate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModifiedTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public LogConfigurationForChannel LogConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ResponseOutputItem[] Outputs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PlaybackMode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Tier { get; set; }
	}
	
	/// <summary>
	/// The log configuration for the channel.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LogConfigurationForChannel
	{
		
		[System.Runtime.Serialization.DataMember()]
		public LogType[] LogTypes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeLiveSourceResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HttpPackageConfiguration[] HttpPackageConfigurations { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModifiedTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LiveSourceName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeProgramResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AdBreak[] AdBreaks { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClipRange ClipRange { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DurationMillis { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LiveSourceName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ProgramName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ScheduledStartTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VodSourceName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeSourceLocationResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AccessConfiguration AccessConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DefaultSegmentDeliveryConfiguration DefaultSegmentDeliveryConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HttpConfiguration HttpConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModifiedTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SegmentDeliveryConfiguration[] SegmentDeliveryConfigurations { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeVodSourceResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HttpPackageConfiguration[] HttpPackageConfigurations { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModifiedTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VodSourceName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetChannelPolicyResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Policy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetChannelScheduleResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ScheduleEntry[] Items { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// The properties for a schedule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScheduleEntry
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ApproximateDurationSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ApproximateStartTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ChannelName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LiveSourceName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ProgramName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ScheduleAdBreak[] ScheduleAdBreaks { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ScheduleEntryType ScheduleEntryType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VodSourceName { get; set; }
	}
	
	/// <summary>
	/// The schedule's ad break properties.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScheduleAdBreak
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ApproximateDurationSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ApproximateStartTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VodSourceName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ScheduleEntryType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PROGRAM")]
		PROGRAM = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FILLER_SLATE")]
		FILLER_SLATE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetPlaybackConfigurationResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AdDecisionServerUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AvailSuppression AvailSuppression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Bumper Bumper { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CdnConfiguration CdnConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationAliasesResponse ConfigurationAliases { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DashConfiguration DashConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HlsConfiguration HlsConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LivePreRollConfiguration LivePreRollConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LogConfiguration LogConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ManifestProcessingRules ManifestProcessingRules { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PersonalizationThresholdSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PlaybackConfigurationArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PlaybackEndpointPrefix { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SessionInitializationEndpointPrefix { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SlateAdUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TranscodeProfileName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VideoContentSourceUrl { get; set; }
	}
	
	/// <summary>
	/// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AvailSuppression
	{
		
		[System.Runtime.Serialization.DataMember()]
		public FillPolicy FillPolicy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Mode Mode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum FillPolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FULL_AVAIL_ONLY")]
		FULL_AVAIL_ONLY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PARTIAL_AVAIL")]
		PARTIAL_AVAIL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Mode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OFF")]
		OFF = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BEHIND_LIVE_EDGE")]
		BEHIND_LIVE_EDGE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AFTER_LIVE_EDGE")]
		AFTER_LIVE_EDGE = 2,
	}
	
	/// <summary>
	/// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Bumper
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string EndUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StartUrl { get; set; }
	}
	
	/// <summary>
	/// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CdnConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AdSegmentUrlPrefix { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ContentSegmentUrlPrefix { get; set; }
	}
	
	/// <summary>
	/// The predefined aliases for dynamic variables.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigurationAliasesResponse
	{
	}
	
	/// <summary>
	/// The configuration for DASH content.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DashConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ManifestEndpointPrefix { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string MpdLocation { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public OriginManifestType OriginManifestType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum OriginManifestType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SINGLE_PERIOD")]
		SINGLE_PERIOD = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MULTI_PERIOD")]
		MULTI_PERIOD = 1,
	}
	
	/// <summary>
	/// The configuration for HLS content.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HlsConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ManifestEndpointPrefix { get; set; }
	}
	
	/// <summary>
	/// The configuration for pre-roll ad insertion.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LivePreRollConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AdDecisionServerUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxDurationSeconds { get; set; }
	}
	
	/// <summary>
	/// Returns Amazon CloudWatch log settings for a playback configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LogConfiguration
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int PercentEnabled { get; set; }
	}
	
	/// <summary>
	/// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ManifestProcessingRules
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AdMarkerPassthrough AdMarkerPassthrough { get; set; }
	}
	
	/// <summary>
	/// <p>For HLS, when set to <code>true</code>, MediaTailor passes through <code>EXT-X-CUE-IN</code>, <code>EXT-X-CUE-OUT</code>, and <code>EXT-X-SPLICEPOINT-SCTE35</code> ad markers from the origin manifest to the MediaTailor personalized manifest.</p> <p>No logic is applied to these ad markers. For example, if <code>EXT-X-CUE-OUT</code> has a value of <code>60</code>, but no ads are filled for that ad break, MediaTailor will not set the value to <code>0</code>.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AdMarkerPassthrough
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetPrefetchScheduleResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PrefetchConsumption Consumption { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PlaybackConfigurationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PrefetchRetrieval Retrieval { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StreamId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListAlertsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Alert[] Items { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Alert configuration parameters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Alert
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AlertCode { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AlertMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AlertCategory Category { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModifiedTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] RelatedResourceArns { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AlertCategory
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SCHEDULING_ERROR")]
		SCHEDULING_ERROR = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PLAYBACK_WARNING")]
		PLAYBACK_WARNING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INFO")]
		INFO = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Channel[] Items { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// The configuration parameters for a channel. For information about MediaTailor channels, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-channels.html">Working with channels</a> in the <i>MediaTailor User Guide</i>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Channel
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ChannelName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ChannelState { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SlateSource FillerSlate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModifiedTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public LogConfigurationForChannel LogConfiguration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ResponseOutputItem[] Outputs { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PlaybackMode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Tier { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListLiveSourcesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public LiveSource[] Items { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Live source configuration parameters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LiveSource
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HttpPackageConfiguration[] HttpPackageConfigurations { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModifiedTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string LiveSourceName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListPlaybackConfigurationsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public PlaybackConfiguration[] Items { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// A playback configuration. For information about MediaTailor configurations, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/configurations.html">Working with configurations in AWS Elemental MediaTailor</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlaybackConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AdDecisionServerUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AvailSuppression AvailSuppression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Bumper Bumper { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CdnConfiguration CdnConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationAliasesResponse ConfigurationAliases { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DashConfiguration DashConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HlsConfiguration HlsConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LivePreRollConfiguration LivePreRollConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LogConfiguration LogConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ManifestProcessingRules ManifestProcessingRules { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PersonalizationThresholdSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PlaybackConfigurationArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PlaybackEndpointPrefix { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SessionInitializationEndpointPrefix { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SlateAdUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TranscodeProfileName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VideoContentSourceUrl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListPrefetchSchedulesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public PrefetchSchedule[] Items { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// A prefetch schedule allows you to tell MediaTailor to fetch and prepare certain ads before an ad break happens. For more information about ad prefetching, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/prefetching-ads.html">Using ad prefetching</a> in the <i>MediaTailor User Guide</i>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PrefetchSchedule
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PrefetchConsumption Consumption { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PlaybackConfigurationName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PrefetchRetrieval Retrieval { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StreamId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListSourceLocationsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public SourceLocation[] Items { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// A source location is a container for sources. For more information about source locations, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-source-locations.html">Working with source locations</a> in the <i>MediaTailor User Guide</i>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SourceLocation
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AccessConfiguration AccessConfiguration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DefaultSegmentDeliveryConfiguration DefaultSegmentDeliveryConfiguration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HttpConfiguration HttpConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModifiedTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SegmentDeliveryConfiguration[] SegmentDeliveryConfigurations { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BadRequestException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListVodSourcesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public VodSource[] Items { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// VOD source configuration parameters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VodSource
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HttpPackageConfiguration[] HttpPackageConfigurations { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModifiedTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string VodSourceName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutChannelPolicyResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutPlaybackConfigurationResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AdDecisionServerUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AvailSuppression AvailSuppression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Bumper Bumper { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CdnConfiguration CdnConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationAliasesResponse ConfigurationAliases { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DashConfiguration DashConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HlsConfiguration HlsConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LivePreRollConfiguration LivePreRollConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LogConfiguration LogConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ManifestProcessingRules ManifestProcessingRules { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PersonalizationThresholdSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PlaybackConfigurationArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PlaybackEndpointPrefix { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SessionInitializationEndpointPrefix { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SlateAdUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TranscodeProfileName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VideoContentSourceUrl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StartChannelResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StopChannelResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateChannelResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelState ChannelState { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SlateSource FillerSlate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModifiedTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ResponseOutputItem[] Outputs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PlaybackMode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Tier { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateLiveSourceResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HttpPackageConfiguration[] HttpPackageConfigurations { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModifiedTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LiveSourceName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateProgramResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AdBreak[] AdBreaks { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClipRange ClipRange { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DurationMillis { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LiveSourceName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ProgramName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ScheduledStartTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VodSourceName { get; set; }
	}
	
	/// <summary>
	/// Program transition configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateProgramTransition
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DurationMillis { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ScheduledStartTimeMillis { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateSourceLocationResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AccessConfiguration AccessConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DefaultSegmentDeliveryConfiguration DefaultSegmentDeliveryConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HttpConfiguration HttpConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModifiedTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SegmentDeliveryConfiguration[] SegmentDeliveryConfigurations { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateVodSourceResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HttpPackageConfiguration[] HttpPackageConfigurations { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModifiedTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VodSourceName { get; set; }
	}
	
	/// <summary>
	/// The predefined aliases for dynamic variables.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigurationAliasesRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigureLogsForChannelRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ChannelName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public LogType[] LogTypes { get; set; }
	}
	
	/// <summary>
	/// Configures Amazon CloudWatch log settings for a playback configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigureLogsForPlaybackConfigurationRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int PercentEnabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PlaybackConfigurationName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PlaybackMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LOOP")]
		LOOP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LINEAR")]
		LINEAR = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Tier
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BASIC")]
		BASIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="STANDARD")]
		STANDARD = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateChannelRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public SlateSource FillerSlate { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RequestOutputItem[] Outputs { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PlaybackMode PlaybackMode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tier Tier { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateLiveSourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HttpPackageConfiguration[] HttpPackageConfigurations { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreatePrefetchScheduleRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PrefetchConsumption Consumption { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PrefetchRetrieval Retrieval { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StreamId { get; set; }
	}
	
	/// <summary>
	/// Schedule configuration parameters. A channel must be stopped before changes can be made to the schedule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScheduleConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ClipRange ClipRange { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Transition Transition { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateProgramRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AdBreak[] AdBreaks { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LiveSourceName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ScheduleConfiguration ScheduleConfiguration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VodSourceName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateSourceLocationRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AccessConfiguration AccessConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DefaultSegmentDeliveryConfiguration DefaultSegmentDeliveryConfiguration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HttpConfiguration HttpConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SegmentDeliveryConfiguration[] SegmentDeliveryConfigurations { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateVodSourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HttpPackageConfiguration[] HttpPackageConfigurations { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	/// <summary>
	/// The configuration for DASH PUT operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DashConfigurationForPut
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string MpdLocation { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public OriginManifestType OriginManifestType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteChannelPolicyRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteChannelRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteLiveSourceRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeletePlaybackConfigurationRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeletePrefetchScheduleRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteProgramRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteSourceLocationRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteVodSourceRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeChannelRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeLiveSourceRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeProgramRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeSourceLocationRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeVodSourceRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetChannelPolicyRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetChannelScheduleRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetPlaybackConfigurationRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetPrefetchScheduleRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListAlertsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListLiveSourcesRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListPlaybackConfigurationsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListPrefetchSchedulesRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StreamId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListSourceLocationsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListVodSourcesRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutChannelPolicyRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Policy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutPlaybackConfigurationRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AdDecisionServerUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AvailSuppression AvailSuppression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Bumper Bumper { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CdnConfiguration CdnConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationAliasesRequest ConfigurationAliases { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DashConfigurationForPut DashConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LivePreRollConfiguration LivePreRollConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ManifestProcessingRules ManifestProcessingRules { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PersonalizationThresholdSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SlateAdUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TranscodeProfileName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VideoContentSourceUrl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StartChannelRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StopChannelRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagResourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UntagResourceRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateChannelRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public SlateSource FillerSlate { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RequestOutputItem[] Outputs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateLiveSourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HttpPackageConfiguration[] HttpPackageConfigurations { get; set; }
	}
	
	/// <summary>
	/// Schedule configuration parameters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateProgramScheduleConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ClipRange ClipRange { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateProgramTransition Transition { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateProgramRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AdBreak[] AdBreaks { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UpdateProgramScheduleConfiguration ScheduleConfiguration { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateSourceLocationRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AccessConfiguration AccessConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DefaultSegmentDeliveryConfiguration DefaultSegmentDeliveryConfiguration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HttpConfiguration HttpConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SegmentDeliveryConfiguration[] SegmentDeliveryConfigurations { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateVodSourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HttpPackageConfiguration[] HttpPackageConfigurations { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Configures Amazon CloudWatch log settings for a channel.
		/// ConfigureLogsForChannel configureLogs/channel
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ConfigureLogsForChannelResponse> ConfigureLogsForChannelAsync(ConfigureLogsForChannelPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "configureLogs/channel";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ConfigureLogsForChannelResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Amazon CloudWatch log settings for a playback configuration.
		/// ConfigureLogsForPlaybackConfiguration configureLogs/playbackConfiguration
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ConfigureLogsForPlaybackConfigurationResponse> ConfigureLogsForPlaybackConfigurationAsync(ConfigureLogsForPlaybackConfigurationPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "configureLogs/playbackConfiguration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ConfigureLogsForPlaybackConfigurationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a channel. For information about MediaTailor channels, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-channels.html">Working with channels</a> in the <i>MediaTailor User Guide</i>.
		/// CreateChannel channel/{ChannelName}
		/// </summary>
		/// <param name="ChannelName">The name of the channel.</param>
		/// <returns>Success</returns>
		public async Task<CreateChannelResponse> CreateChannelAsync(string ChannelName, CreateChannelPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channel/"+ (ChannelName==null? "" : System.Uri.EscapeDataString(ChannelName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateChannelResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a channel. For information about MediaTailor channels, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-channels.html">Working with channels</a> in the <i>MediaTailor User Guide</i>.
		/// DeleteChannel channel/{ChannelName}
		/// </summary>
		/// <param name="ChannelName">The name of the channel.</param>
		/// <returns>Success</returns>
		public async Task<DeleteChannelResponse> DeleteChannelAsync(string ChannelName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channel/"+ (ChannelName==null? "" : System.Uri.EscapeDataString(ChannelName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteChannelResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes a channel. For information about MediaTailor channels, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-channels.html">Working with channels</a> in the <i>MediaTailor User Guide</i>.
		/// DescribeChannel channel/{ChannelName}
		/// </summary>
		/// <param name="ChannelName">The name of the channel.</param>
		/// <returns>Success</returns>
		public async Task<DescribeChannelResponse> DescribeChannelAsync(string ChannelName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channel/"+ (ChannelName==null? "" : System.Uri.EscapeDataString(ChannelName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeChannelResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a channel. For information about MediaTailor channels, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-channels.html">Working with channels</a> in the <i>MediaTailor User Guide</i>.
		/// UpdateChannel channel/{ChannelName}
		/// </summary>
		/// <param name="ChannelName">The name of the channel.</param>
		/// <returns>Success</returns>
		public async Task<UpdateChannelResponse> UpdateChannelAsync(string ChannelName, UpdateChannelPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channel/"+ (ChannelName==null? "" : System.Uri.EscapeDataString(ChannelName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateChannelResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// The live source configuration.
		/// CreateLiveSource sourceLocation/{SourceLocationName}/liveSource/{LiveSourceName}
		/// </summary>
		/// <param name="LiveSourceName">The name of the live source.</param>
		/// <param name="SourceLocationName">The name of the source location.</param>
		/// <returns>Success</returns>
		public async Task<CreateLiveSourceResponse> CreateLiveSourceAsync(string LiveSourceName, string SourceLocationName, CreateLiveSourcePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sourceLocation/"+ (SourceLocationName==null? "" : System.Uri.EscapeDataString(SourceLocationName))+"/liveSource/"+ (LiveSourceName==null? "" : System.Uri.EscapeDataString(LiveSourceName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateLiveSourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// The live source to delete.
		/// DeleteLiveSource sourceLocation/{SourceLocationName}/liveSource/{LiveSourceName}
		/// </summary>
		/// <param name="LiveSourceName">The name of the live source.</param>
		/// <param name="SourceLocationName">The name of the source location associated with this Live Source.</param>
		/// <returns>Success</returns>
		public async Task<DeleteLiveSourceResponse> DeleteLiveSourceAsync(string LiveSourceName, string SourceLocationName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sourceLocation/"+ (SourceLocationName==null? "" : System.Uri.EscapeDataString(SourceLocationName))+"/liveSource/"+ (LiveSourceName==null? "" : System.Uri.EscapeDataString(LiveSourceName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteLiveSourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The live source to describe.
		/// DescribeLiveSource sourceLocation/{SourceLocationName}/liveSource/{LiveSourceName}
		/// </summary>
		/// <param name="LiveSourceName">The name of the live source.</param>
		/// <param name="SourceLocationName">The name of the source location associated with this Live Source.</param>
		/// <returns>Success</returns>
		public async Task<DescribeLiveSourceResponse> DescribeLiveSourceAsync(string LiveSourceName, string SourceLocationName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sourceLocation/"+ (SourceLocationName==null? "" : System.Uri.EscapeDataString(SourceLocationName))+"/liveSource/"+ (LiveSourceName==null? "" : System.Uri.EscapeDataString(LiveSourceName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeLiveSourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a live source's configuration.
		/// UpdateLiveSource sourceLocation/{SourceLocationName}/liveSource/{LiveSourceName}
		/// </summary>
		/// <param name="LiveSourceName">The name of the live source.</param>
		/// <param name="SourceLocationName">The name of the source location associated with this Live Source.</param>
		/// <returns>Success</returns>
		public async Task<UpdateLiveSourceResponse> UpdateLiveSourceAsync(string LiveSourceName, string SourceLocationName, UpdateLiveSourcePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sourceLocation/"+ (SourceLocationName==null? "" : System.Uri.EscapeDataString(SourceLocationName))+"/liveSource/"+ (LiveSourceName==null? "" : System.Uri.EscapeDataString(LiveSourceName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateLiveSourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a prefetch schedule for a playback configuration. A prefetch schedule allows you to tell MediaTailor to fetch and prepare certain ads before an ad break happens. For more information about ad prefetching, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/prefetching-ads.html">Using ad prefetching</a> in the <i>MediaTailor User Guide</i>.
		/// CreatePrefetchSchedule prefetchSchedule/{PlaybackConfigurationName}/{Name}
		/// </summary>
		/// <param name="Name">The name to assign to the schedule request.</param>
		/// <param name="PlaybackConfigurationName">The name to assign to the playback configuration.</param>
		/// <returns>Success</returns>
		public async Task<CreatePrefetchScheduleResponse> CreatePrefetchScheduleAsync(string Name, string PlaybackConfigurationName, CreatePrefetchSchedulePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "prefetchSchedule/"+ (PlaybackConfigurationName==null? "" : System.Uri.EscapeDataString(PlaybackConfigurationName))+"/"+ (Name==null? "" : System.Uri.EscapeDataString(Name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreatePrefetchScheduleResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a prefetch schedule for a specific playback configuration. If you call <code>DeletePrefetchSchedule</code> on an expired prefetch schedule, MediaTailor returns an HTTP 404 status code. For more information about ad prefetching, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/prefetching-ads.html">Using ad prefetching</a> in the <i>MediaTailor User Guide</i>.
		/// DeletePrefetchSchedule prefetchSchedule/{PlaybackConfigurationName}/{Name}
		/// </summary>
		/// <param name="Name">The name of the prefetch schedule. If the action is successful, the service sends back an HTTP 204 response with an empty HTTP body.</param>
		/// <param name="PlaybackConfigurationName">The name of the playback configuration for this prefetch schedule.</param>
		public async Task DeletePrefetchScheduleAsync(string Name, string PlaybackConfigurationName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "prefetchSchedule/"+ (PlaybackConfigurationName==null? "" : System.Uri.EscapeDataString(PlaybackConfigurationName))+"/"+ (Name==null? "" : System.Uri.EscapeDataString(Name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a prefetch schedule for a playback configuration. A prefetch schedule allows you to tell MediaTailor to fetch and prepare certain ads before an ad break happens. For more information about ad prefetching, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/prefetching-ads.html">Using ad prefetching</a> in the <i>MediaTailor User Guide</i>.
		/// GetPrefetchSchedule prefetchSchedule/{PlaybackConfigurationName}/{Name}
		/// </summary>
		/// <param name="Name">The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.</param>
		/// <param name="PlaybackConfigurationName">Returns information about the prefetch schedule for a specific playback configuration. If you call <code>GetPrefetchSchedule</code> on an expired prefetch schedule, MediaTailor returns an HTTP 404 status code.</param>
		/// <returns>Success</returns>
		public async Task<GetPrefetchScheduleResponse> GetPrefetchScheduleAsync(string Name, string PlaybackConfigurationName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "prefetchSchedule/"+ (PlaybackConfigurationName==null? "" : System.Uri.EscapeDataString(PlaybackConfigurationName))+"/"+ (Name==null? "" : System.Uri.EscapeDataString(Name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetPrefetchScheduleResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a program within a channel. For information about programs, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-programs.html">Working with programs</a> in the <i>MediaTailor User Guide</i>.
		/// CreateProgram channel/{ChannelName}/program/{ProgramName}
		/// </summary>
		/// <param name="ChannelName">The name of the channel for this Program.</param>
		/// <param name="ProgramName">The name of the Program.</param>
		/// <returns>Success</returns>
		public async Task<CreateProgramResponse> CreateProgramAsync(string ChannelName, string ProgramName, CreateProgramPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channel/"+ (ChannelName==null? "" : System.Uri.EscapeDataString(ChannelName))+"/program/"+ (ProgramName==null? "" : System.Uri.EscapeDataString(ProgramName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateProgramResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a program within a channel. For information about programs, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-programs.html">Working with programs</a> in the <i>MediaTailor User Guide</i>.
		/// DeleteProgram channel/{ChannelName}/program/{ProgramName}
		/// </summary>
		/// <param name="ChannelName">The name of the channel.</param>
		/// <param name="ProgramName">The name of the program.</param>
		/// <returns>Success</returns>
		public async Task<DeleteProgramResponse> DeleteProgramAsync(string ChannelName, string ProgramName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channel/"+ (ChannelName==null? "" : System.Uri.EscapeDataString(ChannelName))+"/program/"+ (ProgramName==null? "" : System.Uri.EscapeDataString(ProgramName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteProgramResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes a program within a channel. For information about programs, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-programs.html">Working with programs</a> in the <i>MediaTailor User Guide</i>.
		/// DescribeProgram channel/{ChannelName}/program/{ProgramName}
		/// </summary>
		/// <param name="ChannelName">The name of the channel associated with this Program.</param>
		/// <param name="ProgramName">The name of the program.</param>
		/// <returns>Success</returns>
		public async Task<DescribeProgramResponse> DescribeProgramAsync(string ChannelName, string ProgramName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channel/"+ (ChannelName==null? "" : System.Uri.EscapeDataString(ChannelName))+"/program/"+ (ProgramName==null? "" : System.Uri.EscapeDataString(ProgramName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeProgramResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a program within a channel.
		/// UpdateProgram channel/{ChannelName}/program/{ProgramName}
		/// </summary>
		/// <param name="ChannelName">The name of the channel for this Program.</param>
		/// <param name="ProgramName">The name of the Program.</param>
		/// <returns>Success</returns>
		public async Task<UpdateProgramResponse> UpdateProgramAsync(string ChannelName, string ProgramName, UpdateProgramPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channel/"+ (ChannelName==null? "" : System.Uri.EscapeDataString(ChannelName))+"/program/"+ (ProgramName==null? "" : System.Uri.EscapeDataString(ProgramName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateProgramResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a source location. A source location is a container for sources. For more information about source locations, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-source-locations.html">Working with source locations</a> in the <i>MediaTailor User Guide</i>.
		/// CreateSourceLocation sourceLocation/{SourceLocationName}
		/// </summary>
		/// <param name="SourceLocationName">The name associated with the source location.</param>
		/// <returns>Success</returns>
		public async Task<CreateSourceLocationResponse> CreateSourceLocationAsync(string SourceLocationName, CreateSourceLocationPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sourceLocation/"+ (SourceLocationName==null? "" : System.Uri.EscapeDataString(SourceLocationName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateSourceLocationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a source location. A source location is a container for sources. For more information about source locations, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-source-locations.html">Working with source locations</a> in the <i>MediaTailor User Guide</i>.
		/// DeleteSourceLocation sourceLocation/{SourceLocationName}
		/// </summary>
		/// <param name="SourceLocationName">The name of the source location.</param>
		/// <returns>Success</returns>
		public async Task<DeleteSourceLocationResponse> DeleteSourceLocationAsync(string SourceLocationName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sourceLocation/"+ (SourceLocationName==null? "" : System.Uri.EscapeDataString(SourceLocationName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteSourceLocationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes a source location. A source location is a container for sources. For more information about source locations, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-source-locations.html">Working with source locations</a> in the <i>MediaTailor User Guide</i>.
		/// DescribeSourceLocation sourceLocation/{SourceLocationName}
		/// </summary>
		/// <param name="SourceLocationName">The name of the source location.</param>
		/// <returns>Success</returns>
		public async Task<DescribeSourceLocationResponse> DescribeSourceLocationAsync(string SourceLocationName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sourceLocation/"+ (SourceLocationName==null? "" : System.Uri.EscapeDataString(SourceLocationName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeSourceLocationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a source location. A source location is a container for sources. For more information about source locations, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-source-locations.html">Working with source locations</a> in the <i>MediaTailor User Guide</i>.
		/// UpdateSourceLocation sourceLocation/{SourceLocationName}
		/// </summary>
		/// <param name="SourceLocationName">The name of the source location.</param>
		/// <returns>Success</returns>
		public async Task<UpdateSourceLocationResponse> UpdateSourceLocationAsync(string SourceLocationName, UpdateSourceLocationPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sourceLocation/"+ (SourceLocationName==null? "" : System.Uri.EscapeDataString(SourceLocationName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateSourceLocationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// The VOD source configuration parameters.
		/// CreateVodSource sourceLocation/{SourceLocationName}/vodSource/{VodSourceName}
		/// </summary>
		/// <param name="SourceLocationName">The name of the source location for this VOD source.</param>
		/// <param name="VodSourceName">The name associated with the VOD source.&gt;</param>
		/// <returns>Success</returns>
		public async Task<CreateVodSourceResponse> CreateVodSourceAsync(string SourceLocationName, string VodSourceName, CreateVodSourcePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sourceLocation/"+ (SourceLocationName==null? "" : System.Uri.EscapeDataString(SourceLocationName))+"/vodSource/"+ (VodSourceName==null? "" : System.Uri.EscapeDataString(VodSourceName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateVodSourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// The video on demand (VOD) source to delete.
		/// DeleteVodSource sourceLocation/{SourceLocationName}/vodSource/{VodSourceName}
		/// </summary>
		/// <param name="SourceLocationName">The name of the source location associated with this VOD Source.</param>
		/// <param name="VodSourceName">The name of the VOD source.</param>
		/// <returns>Success</returns>
		public async Task<DeleteVodSourceResponse> DeleteVodSourceAsync(string SourceLocationName, string VodSourceName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sourceLocation/"+ (SourceLocationName==null? "" : System.Uri.EscapeDataString(SourceLocationName))+"/vodSource/"+ (VodSourceName==null? "" : System.Uri.EscapeDataString(VodSourceName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteVodSourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Provides details about a specific video on demand (VOD) source in a specific source location.
		/// DescribeVodSource sourceLocation/{SourceLocationName}/vodSource/{VodSourceName}
		/// </summary>
		/// <param name="SourceLocationName">The name of the source location associated with this VOD Source.</param>
		/// <param name="VodSourceName">The name of the VOD Source.</param>
		/// <returns>Success</returns>
		public async Task<DescribeVodSourceResponse> DescribeVodSourceAsync(string SourceLocationName, string VodSourceName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sourceLocation/"+ (SourceLocationName==null? "" : System.Uri.EscapeDataString(SourceLocationName))+"/vodSource/"+ (VodSourceName==null? "" : System.Uri.EscapeDataString(VodSourceName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeVodSourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a VOD source's configuration.
		/// UpdateVodSource sourceLocation/{SourceLocationName}/vodSource/{VodSourceName}
		/// </summary>
		/// <param name="SourceLocationName">The name of the source location associated with this VOD Source.</param>
		/// <param name="VodSourceName">The name of the VOD source.</param>
		/// <returns>Success</returns>
		public async Task<UpdateVodSourceResponse> UpdateVodSourceAsync(string SourceLocationName, string VodSourceName, UpdateVodSourcePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sourceLocation/"+ (SourceLocationName==null? "" : System.Uri.EscapeDataString(SourceLocationName))+"/vodSource/"+ (VodSourceName==null? "" : System.Uri.EscapeDataString(VodSourceName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateVodSourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// The channel policy to delete.
		/// DeleteChannelPolicy channel/{ChannelName}/policy
		/// </summary>
		/// <param name="ChannelName">The name of the channel associated with this channel policy.</param>
		/// <returns>Success</returns>
		public async Task<DeleteChannelPolicyResponse> DeleteChannelPolicyAsync(string ChannelName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channel/"+ (ChannelName==null? "" : System.Uri.EscapeDataString(ChannelName))+"/policy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteChannelPolicyResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the channel's IAM policy. IAM policies are used to control access to your channel.
		/// GetChannelPolicy channel/{ChannelName}/policy
		/// </summary>
		/// <param name="ChannelName">The name of the channel associated with this Channel Policy.</param>
		/// <returns>Success</returns>
		public async Task<GetChannelPolicyResponse> GetChannelPolicyAsync(string ChannelName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channel/"+ (ChannelName==null? "" : System.Uri.EscapeDataString(ChannelName))+"/policy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetChannelPolicyResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an IAM policy for the channel. IAM policies are used to control access to your channel.
		/// PutChannelPolicy channel/{ChannelName}/policy
		/// </summary>
		/// <param name="ChannelName">The channel name associated with this Channel Policy.</param>
		/// <returns>Success</returns>
		public async Task<PutChannelPolicyResponse> PutChannelPolicyAsync(string ChannelName, PutChannelPolicyPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channel/"+ (ChannelName==null? "" : System.Uri.EscapeDataString(ChannelName))+"/policy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PutChannelPolicyResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a playback configuration. For information about MediaTailor configurations, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/configurations.html">Working with configurations in AWS Elemental MediaTailor</a>.
		/// DeletePlaybackConfiguration playbackConfiguration/{Name}
		/// </summary>
		/// <param name="Name">The name of the playback configuration.</param>
		public async Task DeletePlaybackConfigurationAsync(string Name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "playbackConfiguration/"+ (Name==null? "" : System.Uri.EscapeDataString(Name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a playback configuration. For information about MediaTailor configurations, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/configurations.html">Working with configurations in AWS Elemental MediaTailor</a>.
		/// GetPlaybackConfiguration playbackConfiguration/{Name}
		/// </summary>
		/// <param name="Name">The identifier for the playback configuration.</param>
		/// <returns>Success</returns>
		public async Task<GetPlaybackConfigurationResponse> GetPlaybackConfigurationAsync(string Name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "playbackConfiguration/"+ (Name==null? "" : System.Uri.EscapeDataString(Name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetPlaybackConfigurationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves information about your channel's schedule.
		/// GetChannelSchedule channel/{ChannelName}/schedule
		/// </summary>
		/// <param name="ChannelName">The name of the channel associated with this Channel Schedule.</param>
		/// <param name="durationMinutes">The duration in minutes of the channel schedule.</param>
		/// <param name="maxResults">The maximum number of channel schedules that you want MediaTailor to return in response to the current request. If there are more than <code>MaxResults</code> channel schedules, use the value of <code>NextToken</code> in the response to get the next page of results.</param>
		/// <param name="nextToken"><p>(Optional) If the playback configuration has more than <code>MaxResults</code> channel schedules, use <code>NextToken</code> to get the second and subsequent pages of results.</p> <p>For the first <code>GetChannelScheduleRequest</code> request, omit this value.</p> <p>For the second and subsequent requests, get the value of <code>NextToken</code> from the previous response and specify that value for <code>NextToken</code> in the request.</p> <p>If the previous response didn't include a <code>NextToken</code> element, there are no more channel schedules to get.</p></param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<GetChannelScheduleResponse> GetChannelScheduleAsync(string ChannelName, string durationMinutes, int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channel/"+ (ChannelName==null? "" : System.Uri.EscapeDataString(ChannelName))+"/schedule&durationMinutes=" + (durationMinutes==null? "" : System.Uri.EscapeDataString(durationMinutes))+"&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetChannelScheduleResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the alerts that are associated with a MediaTailor channel assembly resource.
		/// ListAlerts alerts#resourceArn
		/// </summary>
		/// <param name="maxResults">The maximum number of alerts that you want MediaTailor to return in response to the current request. If there are more than <code>MaxResults</code> alerts, use the value of <code>NextToken</code> in the response to get the next page of results.</param>
		/// <param name="nextToken">Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</param>
		/// <param name="resourceArn">The Amazon Resource Name (ARN) of the resource.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListAlertsResponse> ListAlertsAsync(int maxResults, string nextToken, string resourceArn, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "alerts#resourceArn?maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&resourceArn=" + (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListAlertsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves information about the channels that are associated with the current AWS account.
		/// ListChannels channels
		/// </summary>
		/// <param name="maxResults">The maximum number of channels that you want MediaTailor to return in response to the current request. If there are more than <code>MaxResults</code> channels, use the value of <code>NextToken</code> in the response to get the next page of results.</param>
		/// <param name="nextToken">Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListChannelsResponse> ListChannelsAsync(int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels?maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListChannelsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the live sources contained in a source location. A source represents a piece of content.
		/// ListLiveSources sourceLocation/{SourceLocationName}/liveSources
		/// </summary>
		/// <param name="maxResults">The maximum number of live sources that you want MediaTailor to return in response to the current request. If there are more than <code>MaxResults</code> live sources, use the value of <code>NextToken</code> in the response to get the next page of results.</param>
		/// <param name="nextToken">Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</param>
		/// <param name="SourceLocationName">The name of the source location associated with this Live Sources list.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListLiveSourcesResponse> ListLiveSourcesAsync(int maxResults, string nextToken, string SourceLocationName, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sourceLocation/"+ (SourceLocationName==null? "" : System.Uri.EscapeDataString(SourceLocationName))+"/liveSources?maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListLiveSourcesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves existing playback configurations. For information about MediaTailor configurations, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/configurations.html">Working with Configurations in AWS Elemental MediaTailor</a>.
		/// ListPlaybackConfigurations playbackConfigurations
		/// </summary>
		/// <param name="MaxResults">The maximum number of playback configurations that you want MediaTailor to return in response to the current request. If there are more than <code>MaxResults</code> playback configurations, use the value of <code>NextToken</code> in the response to get the next page of results.</param>
		/// <param name="NextToken">Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</param>
		/// <returns>Success</returns>
		public async Task<ListPlaybackConfigurationsResponse> ListPlaybackConfigurationsAsync(int MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "playbackConfigurations?MaxResults="+MaxResults+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListPlaybackConfigurationsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the prefetch schedules for a playback configuration.
		/// ListPrefetchSchedules prefetchSchedule/{PlaybackConfigurationName}
		/// </summary>
		/// <param name="PlaybackConfigurationName">Retrieves the prefetch schedule(s) for a specific playback configuration.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListPrefetchSchedulesResponse> ListPrefetchSchedulesAsync(string PlaybackConfigurationName, string MaxResults, string NextToken, ListPrefetchSchedulesPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "prefetchSchedule/"+ (PlaybackConfigurationName==null? "" : System.Uri.EscapeDataString(PlaybackConfigurationName))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListPrefetchSchedulesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the source locations for a channel. A source location defines the host server URL, and contains a list of sources.
		/// ListSourceLocations sourceLocations
		/// </summary>
		/// <param name="maxResults"> The maximum number of source locations that you want MediaTailor to return in response to the current request. If there are more than <code>MaxResults</code> source locations, use the value of <code>NextToken</code> in the response to get the next page of results.</param>
		/// <param name="nextToken">Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListSourceLocationsResponse> ListSourceLocationsAsync(int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sourceLocations?maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListSourceLocationsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// A list of tags that are associated with this resource. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.
		/// ListTagsForResource tags/{ResourceArn}
		/// </summary>
		/// <param name="ResourceArn">The Amazon Resource Name (ARN) associated with this resource.</param>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceResponse> ListTagsForResourceAsync(string ResourceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (ResourceArn==null? "" : System.Uri.EscapeDataString(ResourceArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListTagsForResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The resource to tag. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.
		/// TagResource tags/{ResourceArn}
		/// </summary>
		/// <param name="ResourceArn">The Amazon Resource Name (ARN) associated with the resource.</param>
		public async Task TagResourceAsync(string ResourceArn, TagResourcePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (ResourceArn==null? "" : System.Uri.EscapeDataString(ResourceArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the VOD sources contained in a source location. A source represents a piece of content.
		/// ListVodSources sourceLocation/{SourceLocationName}/vodSources
		/// </summary>
		/// <param name="maxResults"> The maximum number of VOD sources that you want MediaTailor to return in response to the current request. If there are more than <code>MaxResults</code> VOD sources, use the value of <code>NextToken</code> in the response to get the next page of results.</param>
		/// <param name="nextToken">Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.</param>
		/// <param name="SourceLocationName">The name of the source location associated with this VOD Source list.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListVodSourcesResponse> ListVodSourcesAsync(int maxResults, string nextToken, string SourceLocationName, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sourceLocation/"+ (SourceLocationName==null? "" : System.Uri.EscapeDataString(SourceLocationName))+"/vodSources?maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListVodSourcesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a playback configuration. For information about MediaTailor configurations, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/configurations.html">Working with configurations in AWS Elemental MediaTailor</a>.
		/// PutPlaybackConfiguration playbackConfiguration
		/// </summary>
		/// <returns>Success</returns>
		public async Task<PutPlaybackConfigurationResponse> PutPlaybackConfigurationAsync(PutPlaybackConfigurationPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "playbackConfiguration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PutPlaybackConfigurationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Starts a channel. For information about MediaTailor channels, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-channels.html">Working with channels</a> in the <i>MediaTailor User Guide</i>.
		/// StartChannel channel/{ChannelName}/start
		/// </summary>
		/// <param name="ChannelName">The name of the channel.</param>
		/// <returns>Success</returns>
		public async Task<StartChannelResponse> StartChannelAsync(string ChannelName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channel/"+ (ChannelName==null? "" : System.Uri.EscapeDataString(ChannelName))+"/start";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StartChannelResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Stops a channel. For information about MediaTailor channels, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-channels.html">Working with channels</a> in the <i>MediaTailor User Guide</i>.
		/// StopChannel channel/{ChannelName}/stop
		/// </summary>
		/// <param name="ChannelName">The name of the channel.</param>
		/// <returns>Success</returns>
		public async Task<StopChannelResponse> StopChannelAsync(string ChannelName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channel/"+ (ChannelName==null? "" : System.Uri.EscapeDataString(ChannelName))+"/stop";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StopChannelResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The resource to untag.
		/// UntagResource tags/{ResourceArn}#tagKeys
		/// </summary>
		/// <param name="ResourceArn">The Amazon Resource Name (ARN) of the resource to untag.</param>
		/// <param name="tagKeys">The tag keys associated with the resource.</param>
		public async Task UntagResourceAsync(string ResourceArn, string[] tagKeys, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags/"+ (ResourceArn==null? "" : System.Uri.EscapeDataString(ResourceArn))+"#tagKeys&"+string.Join("&", tagKeys.Select(z => $"tagKeys={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public class ConfigureLogsForChannelPutBody
	{
		
		/// <summary>
		/// The name of the channel.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ChannelName { get; set; }
		
		/// <summary>
		/// The types of logs to collect.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public LogType[] LogTypes { get; set; }
	}
	
	public class ConfigureLogsForPlaybackConfigurationPutBody
	{
		
		/// <summary>
		/// <p>The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account. For example, if your playback configuration has 1000 sessions and percentEnabled is set to <code>60</code>, MediaTailor sends logs for 600 of the sessions to CloudWatch Logs. MediaTailor decides at random which of the playback configuration sessions to send logs for. If you want to view logs for a specific session, you can use the <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/debug-log-mode.html">debug log mode</a>.</p> <p>Valid values: <code>0</code> - <code>100</code> </p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int PercentEnabled { get; set; }
		
		/// <summary>
		/// The name of the playback configuration.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PlaybackConfigurationName { get; set; }
	}
	
	public class CreateChannelPostBody
	{
		
		/// <summary>
		/// Slate VOD source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateChannelPostBodyFillerSlate FillerSlate { get; set; }
		
		/// <summary>
		/// An object that represents an object in the CreateChannel request.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RequestOutputItem[] Outputs { get; set; }
		
		/// <summary>
		/// <p>The type of playback mode to use for this channel.</p> <p> <code>LINEAR</code> - The programs in the schedule play once back-to-back in the schedule.</p> <p> <code>LOOP</code> - The programs in the schedule play back-to-back in an endless loop. When the last program in the schedule stops playing, playback loops back to the first program in the schedule.</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PlaybackMode PlaybackMode { get; set; }
		
		/// <summary>
		/// The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
		
		/// <summary>
		/// The tier of the channel.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Tier Tier { get; set; }
	}
	
	public class CreateChannelPostBodyFillerSlate
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VodSourceName { get; set; }
	}
	
	public class UpdateChannelPutBody
	{
		
		/// <summary>
		/// Slate VOD source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateChannelPutBodyFillerSlate FillerSlate { get; set; }
		
		/// <summary>
		/// An object that represents an object in the CreateChannel request.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RequestOutputItem[] Outputs { get; set; }
	}
	
	public class UpdateChannelPutBodyFillerSlate
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VodSourceName { get; set; }
	}
	
	public class CreateLiveSourcePostBody
	{
		
		/// <summary>
		/// The VOD source's HTTP package configuration settings.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HttpPackageConfiguration[] HttpPackageConfigurations { get; set; }
		
		/// <summary>
		/// The tags to assign to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public class UpdateLiveSourcePutBody
	{
		
		/// <summary>
		/// The VOD source's HTTP package configuration settings.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HttpPackageConfiguration[] HttpPackageConfigurations { get; set; }
	}
	
	public class CreatePrefetchSchedulePostBody
	{
		
		/// <summary>
		/// A complex type that contains settings that determine how and when that MediaTailor places prefetched ads into upcoming ad breaks.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreatePrefetchSchedulePostBodyConsumption Consumption { get; set; }
		
		/// <summary>
		/// A complex type that contains settings governing when MediaTailor prefetches ads, and which dynamic variables that MediaTailor includes in the request to the ad decision server.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreatePrefetchSchedulePostBodyRetrieval Retrieval { get; set; }
		
		/// <summary>
		/// An optional stream identifier that MediaTailor uses to prefetch ads for multiple streams that use the same playback configuration. If <code>StreamId</code> is specified, MediaTailor returns all of the prefetch schedules with an exact match on <code>StreamId</code>. If not specified, MediaTailor returns all of the prefetch schedules for the playback configuration, regardless of <code>StreamId</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string StreamId { get; set; }
	}
	
	public class CreatePrefetchSchedulePostBodyConsumption
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AvailMatchingCriteria[] AvailMatchingCriteria { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset EndTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset StartTime { get; set; }
	}
	
	public class CreatePrefetchSchedulePostBodyRetrieval
	{
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string DynamicVariables { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset EndTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset StartTime { get; set; }
	}
	
	public class CreateProgramPostBody
	{
		
		/// <summary>
		/// The ad break configuration settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AdBreak[] AdBreaks { get; set; }
		
		/// <summary>
		/// The name of the LiveSource for this Program.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string LiveSourceName { get; set; }
		
		/// <summary>
		/// Schedule configuration parameters. A channel must be stopped before changes can be made to the schedule.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateProgramPostBodyScheduleConfiguration ScheduleConfiguration { get; set; }
		
		/// <summary>
		/// The name of the source location.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SourceLocationName { get; set; }
		
		/// <summary>
		/// The name that's used to refer to a VOD source.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string VodSourceName { get; set; }
	}
	
	public class CreateProgramPostBodyScheduleConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ClipRange ClipRange { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Transition Transition { get; set; }
	}
	
	public class UpdateProgramPutBody
	{
		
		/// <summary>
		/// The ad break configuration settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AdBreak[] AdBreaks { get; set; }
		
		/// <summary>
		/// Schedule configuration parameters.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UpdateProgramPutBodyScheduleConfiguration ScheduleConfiguration { get; set; }
	}
	
	public class UpdateProgramPutBodyScheduleConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ClipRange ClipRange { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateProgramTransition Transition { get; set; }
	}
	
	public class CreateSourceLocationPostBody
	{
		
		/// <summary>
		/// Access configuration parameters.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateSourceLocationPostBodyAccessConfiguration AccessConfiguration { get; set; }
		
		/// <summary>
		/// The optional configuration for a server that serves segments. Use this if you want the segment delivery server to be different from the source location server. For example, you can configure your source location server to be an origination server, such as MediaPackage, and the segment delivery server to be a content delivery network (CDN), such as CloudFront. If you don't specify a segment delivery server, then the source location server is used.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateSourceLocationPostBodyDefaultSegmentDeliveryConfiguration DefaultSegmentDeliveryConfiguration { get; set; }
		
		/// <summary>
		/// The HTTP configuration for the source location.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CreateSourceLocationPostBodyHttpConfiguration HttpConfiguration { get; set; }
		
		/// <summary>
		/// A list of the segment delivery configurations associated with this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public SegmentDeliveryConfiguration[] SegmentDeliveryConfigurations { get; set; }
		
		/// <summary>
		/// The tags to assign to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public class CreateSourceLocationPostBodyAccessConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AccessType AccessType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SecretsManagerAccessTokenConfiguration SecretsManagerAccessTokenConfiguration { get; set; }
	}
	
	public class CreateSourceLocationPostBodyDefaultSegmentDeliveryConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BaseUrl { get; set; }
	}
	
	public class CreateSourceLocationPostBodyHttpConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BaseUrl { get; set; }
	}
	
	public class UpdateSourceLocationPutBody
	{
		
		/// <summary>
		/// Access configuration parameters.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateSourceLocationPutBodyAccessConfiguration AccessConfiguration { get; set; }
		
		/// <summary>
		/// The optional configuration for a server that serves segments. Use this if you want the segment delivery server to be different from the source location server. For example, you can configure your source location server to be an origination server, such as MediaPackage, and the segment delivery server to be a content delivery network (CDN), such as CloudFront. If you don't specify a segment delivery server, then the source location server is used.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateSourceLocationPutBodyDefaultSegmentDeliveryConfiguration DefaultSegmentDeliveryConfiguration { get; set; }
		
		/// <summary>
		/// The HTTP configuration for the source location.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UpdateSourceLocationPutBodyHttpConfiguration HttpConfiguration { get; set; }
		
		/// <summary>
		/// A list of the segment delivery configurations associated with this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public SegmentDeliveryConfiguration[] SegmentDeliveryConfigurations { get; set; }
	}
	
	public class UpdateSourceLocationPutBodyAccessConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AccessType AccessType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SecretsManagerAccessTokenConfiguration SecretsManagerAccessTokenConfiguration { get; set; }
	}
	
	public class UpdateSourceLocationPutBodyDefaultSegmentDeliveryConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BaseUrl { get; set; }
	}
	
	public class UpdateSourceLocationPutBodyHttpConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BaseUrl { get; set; }
	}
	
	public class CreateVodSourcePostBody
	{
		
		/// <summary>
		/// The VOD source's HTTP package configuration settings.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HttpPackageConfiguration[] HttpPackageConfigurations { get; set; }
		
		/// <summary>
		/// The tags to assign to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public class UpdateVodSourcePutBody
	{
		
		/// <summary>
		/// The VOD source's HTTP package configuration settings.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HttpPackageConfiguration[] HttpPackageConfigurations { get; set; }
	}
	
	public class PutChannelPolicyPutBody
	{
		
		/// <summary>
		/// Adds an IAM role that determines the permissions of your channel.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Policy { get; set; }
	}
	
	public class ListPrefetchSchedulesPostBody
	{
		
		/// <summary>
		/// The maximum number of prefetch schedules that you want MediaTailor to return in response to the current request. If there are more than <code>MaxResults</code> prefetch schedules, use the value of <code>NextToken</code> in the response to get the next page of results.
		/// Minimum: 1
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 100)]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		/// <summary>
		/// <p>(Optional) If the playback configuration has more than <code>MaxResults</code> prefetch schedules, use <code>NextToken</code> to get the second and subsequent pages of results.</p> <p> For the first <code>ListPrefetchSchedulesRequest</code> request, omit this value.</p> <p> For the second and subsequent requests, get the value of <code>NextToken</code> from the previous response and specify that value for <code>NextToken</code> in the request.</p> <p> If the previous response didn't include a <code>NextToken</code> element, there are no more prefetch schedules to get.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// An optional filtering parameter whereby MediaTailor filters the prefetch schedules to include only specific streams.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string StreamId { get; set; }
	}
	
	public class TagResourcePostBody
	{
		
		/// <summary>
		/// The tags to assign to the resource. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public class PutPlaybackConfigurationPutBody
	{
		
		/// <summary>
		/// The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string AdDecisionServerUrl { get; set; }
		
		/// <summary>
		/// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Suppression</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PutPlaybackConfigurationPutBodyAvailSuppression AvailSuppression { get; set; }
		
		/// <summary>
		/// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html">Bumpers</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PutPlaybackConfigurationPutBodyBumper Bumper { get; set; }
		
		/// <summary>
		/// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PutPlaybackConfigurationPutBodyCdnConfiguration CdnConfiguration { get; set; }
		
		/// <summary>
		/// The predefined aliases for dynamic variables.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, @__mapOf__string> ConfigurationAliases { get; set; }
		
		/// <summary>
		/// The configuration for DASH PUT operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PutPlaybackConfigurationPutBodyDashConfiguration DashConfiguration { get; set; }
		
		/// <summary>
		/// The configuration for pre-roll ad insertion.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PutPlaybackConfigurationPutBodyLivePreRollConfiguration LivePreRollConfiguration { get; set; }
		
		/// <summary>
		/// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PutPlaybackConfigurationPutBodyManifestProcessingRules ManifestProcessingRules { get; set; }
		
		/// <summary>
		/// The identifier for the playback configuration.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to <i>ad replacement</i> in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html">Ad Behavior in AWS Elemental MediaTailor</a>.
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> PersonalizationThresholdSeconds { get; set; }
		
		/// <summary>
		/// The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID configurations. For VPAID, the slate is required because MediaTailor provides it in the slots that are designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string SlateAdUrl { get; set; }
		
		/// <summary>
		/// The tags to assign to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html">Tagging AWS Elemental MediaTailor Resources</a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
		
		/// <summary>
		/// The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string TranscodeProfileName { get; set; }
		
		/// <summary>
		/// The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string VideoContentSourceUrl { get; set; }
	}
	
	public class PutPlaybackConfigurationPutBodyAvailSuppression
	{
		
		[System.Runtime.Serialization.DataMember()]
		public FillPolicy FillPolicy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Mode Mode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	public class PutPlaybackConfigurationPutBodyBumper
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string EndUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StartUrl { get; set; }
	}
	
	public class PutPlaybackConfigurationPutBodyCdnConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AdSegmentUrlPrefix { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ContentSegmentUrlPrefix { get; set; }
	}
	
	public class PutPlaybackConfigurationPutBodyDashConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string MpdLocation { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public OriginManifestType OriginManifestType { get; set; }
	}
	
	public class PutPlaybackConfigurationPutBodyLivePreRollConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AdDecisionServerUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxDurationSeconds { get; set; }
	}
	
	public class PutPlaybackConfigurationPutBodyManifestProcessingRules
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AdMarkerPassthrough AdMarkerPassthrough { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
