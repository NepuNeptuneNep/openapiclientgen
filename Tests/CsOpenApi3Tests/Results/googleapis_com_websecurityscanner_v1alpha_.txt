//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Scan authentication configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Authentication
	{
		
		/// <summary>
		/// Describes authentication configuration that uses a custom account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customAccount")]
		public CustomAccount CustomAccount { get; set; }
		
		/// <summary>
		/// Describes authentication configuration that uses a Google account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="googleAccount")]
		public GoogleAccount GoogleAccount { get; set; }
	}
	
	/// <summary>
	/// Describes authentication configuration that uses a custom account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CustomAccount
	{
		
		/// <summary>
		/// Required. The login form URL of the website.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loginUrl")]
		public string LoginUrl { get; set; }
		
		/// <summary>
		/// Required. Input only. The password of the custom account. The credential is stored encrypted and not returned in any response nor included in audit logs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Required. The user name of the custom account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// Describes authentication configuration that uses a Google account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleAccount
	{
		
		/// <summary>
		/// Required. Input only. The password of the Google account. The credential is stored encrypted and not returned in any response nor included in audit logs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Required. The user name of the Google account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// A CrawledUrl resource represents a URL that was crawled during a ScanRun. Web Security Scanner Service crawls the web applications, following all links within the scope of sites, to find the URLs to test against.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CrawledUrl
	{
		
		/// <summary>
		/// Output only. The body of the request that was used to visit the URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Output only. The http method of the request that was used to visit the URL, in uppercase.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpMethod")]
		public string HttpMethod { get; set; }
		
		/// <summary>
		/// Output only. The URL that was crawled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Empty
	{
	}
	
	/// <summary>
	/// A Finding resource represents a vulnerability instance identified during a ScanRun.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Finding
	{
		
		/// <summary>
		/// The body of the request that triggered the vulnerability.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// The description of the vulnerability.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The URL where the browser lands when the vulnerability is detected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="finalUrl")]
		public string FinalUrl { get; set; }
		
		/// <summary>
		/// The type of the Finding.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="findingType")]
		public System.Nullable<FindingFindingType> FindingType { get; set; }
		
		/// <summary>
		/// If the vulnerability was originated from nested IFrame, the immediate parent IFrame is reported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="frameUrl")]
		public string FrameUrl { get; set; }
		
		/// <summary>
		/// The URL produced by the server-side fuzzer and used in the request that triggered the vulnerability.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fuzzedUrl")]
		public string FuzzedUrl { get; set; }
		
		/// <summary>
		/// The http method of the request that triggered the vulnerability, in uppercase.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpMethod")]
		public string HttpMethod { get; set; }
		
		/// <summary>
		/// The resource name of the Finding. The name follows the format of 'projects/{projectId}/scanConfigs/{scanConfigId}/scanruns/{scanRunId}/findings/{findingId}'. The finding IDs are generated by the system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Information reported for an outdated library.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outdatedLibrary")]
		public OutdatedLibrary OutdatedLibrary { get; set; }
		
		/// <summary>
		/// The URL containing human-readable payload that user can leverage to reproduce the vulnerability.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reproductionUrl")]
		public string ReproductionUrl { get; set; }
		
		/// <summary>
		/// The tracking ID uniquely identifies a vulnerability instance across multiple ScanRuns.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trackingId")]
		public string TrackingId { get; set; }
		
		/// <summary>
		/// Information regarding any resource causing the vulnerability such as JavaScript sources, image, audio files, etc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="violatingResource")]
		public ViolatingResource ViolatingResource { get; set; }
		
		/// <summary>
		/// Information about vulnerable or missing HTTP Headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vulnerableHeaders")]
		public VulnerableHeaders VulnerableHeaders { get; set; }
		
		/// <summary>
		/// Information about vulnerable request parameters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vulnerableParameters")]
		public VulnerableParameters VulnerableParameters { get; set; }
		
		/// <summary>
		/// Information reported for an XSS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xss")]
		public Xss Xss { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum FindingFindingType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FINDING_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MIXED_CONTENT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OUTDATED_LIBRARY = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ROSETTA_FLASH = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		XSS_CALLBACK = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		XSS_ERROR = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLEAR_TEXT_PASSWORD = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID_CONTENT_TYPE = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		XSS_ANGULAR_CALLBACK = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID_HEADER = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MISSPELLED_SECURITY_HEADER_NAME = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MISMATCHING_SECURITY_HEADER_VALUES = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCESSIBLE_GIT_REPOSITORY = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCESSIBLE_SVN_REPOSITORY = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCESSIBLE_ENV_FILE = 14,
	}
	
	/// <summary>
	/// Information reported for an outdated library.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OutdatedLibrary
	{
		
		/// <summary>
		/// URLs to learn more information about the vulnerabilities in the library.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="learnMoreUrls")]
		public string[] LearnMoreUrls { get; set; }
		
		/// <summary>
		/// The name of the outdated library.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="libraryName")]
		public string LibraryName { get; set; }
		
		/// <summary>
		/// The version number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Information regarding any resource causing the vulnerability such as JavaScript sources, image, audio files, etc.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ViolatingResource
	{
		
		/// <summary>
		/// The MIME type of this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentType")]
		public string ContentType { get; set; }
		
		/// <summary>
		/// URL of this violating resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceUrl")]
		public string ResourceUrl { get; set; }
	}
	
	/// <summary>
	/// Information about vulnerable or missing HTTP Headers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VulnerableHeaders
	{
		
		/// <summary>
		/// List of vulnerable headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Header[] Headers { get; set; }
		
		/// <summary>
		/// List of missing headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="missingHeaders")]
		public Header[] MissingHeaders { get; set; }
	}
	
	/// <summary>
	/// Describes a HTTP Header.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Header
	{
		
		/// <summary>
		/// Header name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Header value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Information about vulnerable request parameters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VulnerableParameters
	{
		
		/// <summary>
		/// The vulnerable parameter names.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parameterNames")]
		public string[] ParameterNames { get; set; }
	}
	
	/// <summary>
	/// Information reported for an XSS.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Xss
	{
		
		/// <summary>
		/// An error message generated by a javascript breakage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorMessage")]
		public string ErrorMessage { get; set; }
		
		/// <summary>
		/// Stack traces leading to the point where the XSS occurred.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stackTraces")]
		public string[] StackTraces { get; set; }
	}
	
	/// <summary>
	/// A FindingTypeStats resource represents stats regarding a specific FindingType of Findings under a given ScanRun.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FindingTypeStats
	{
		
		/// <summary>
		/// The count of findings belonging to this finding type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="findingCount")]
		public System.Nullable<System.Int32> FindingCount { get; set; }
		
		/// <summary>
		/// The finding type associated with the stats.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="findingType")]
		public FindingFindingType FindingType { get; set; }
	}
	
	/// <summary>
	/// Response for the `ListCrawledUrls` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListCrawledUrlsResponse
	{
		
		/// <summary>
		/// The list of CrawledUrls returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="crawledUrls")]
		public CrawledUrl[] CrawledUrls { get; set; }
		
		/// <summary>
		/// Token to retrieve the next page of results, or empty if there are no more results in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// Response for the `ListFindingTypeStats` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListFindingTypeStatsResponse
	{
		
		/// <summary>
		/// The list of FindingTypeStats returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="findingTypeStats")]
		public FindingTypeStats[] FindingTypeStats { get; set; }
	}
	
	/// <summary>
	/// Response for the `ListFindings` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListFindingsResponse
	{
		
		/// <summary>
		/// The list of Findings returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="findings")]
		public Finding[] Findings { get; set; }
		
		/// <summary>
		/// Token to retrieve the next page of results, or empty if there are no more results in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// Response for the `ListScanConfigs` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListScanConfigsResponse
	{
		
		/// <summary>
		/// Token to retrieve the next page of results, or empty if there are no more results in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The list of ScanConfigs returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scanConfigs")]
		public ScanConfig[] ScanConfigs { get; set; }
	}
	
	/// <summary>
	/// A ScanConfig resource contains the configurations to launch a scan. next id: 12
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ScanConfig
	{
		
		/// <summary>
		/// Scan authentication configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public Authentication Authentication { get; set; }
		
		/// <summary>
		/// The excluded URL patterns as described in https://cloud.google.com/security-command-center/docs/how-to-use-web-security-scanner#excluding_urls
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blacklistPatterns")]
		public string[] BlacklistPatterns { get; set; }
		
		/// <summary>
		/// Required. The user provided display name of the ScanConfig.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// A ScanRun is a output-only resource representing an actual run of the scan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latestRun")]
		public ScanRun LatestRun { get; set; }
		
		/// <summary>
		/// The maximum QPS during scanning. A valid value ranges from 5 to 20 inclusively. If the field is unspecified or its value is set 0, server will default to 15. Other values outside of [5, 20] range will be rejected with INVALID_ARGUMENT error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxQps")]
		public System.Nullable<System.Int32> MaxQps { get; set; }
		
		/// <summary>
		/// The resource name of the ScanConfig. The name follows the format of 'projects/{projectId}/scanConfigs/{scanConfigId}'. The ScanConfig IDs are generated by the system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Scan schedule configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public Schedule Schedule { get; set; }
		
		/// <summary>
		/// Required. The starting URLs from which the scanner finds site pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startingUrls")]
		public string[] StartingUrls { get; set; }
		
		/// <summary>
		/// Set of Google Cloud platforms targeted by the scan. If empty, APP_ENGINE will be used as a default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetPlatforms")]
		public string[] TargetPlatforms { get; set; }
		
		/// <summary>
		/// The user agent used during scanning.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userAgent")]
		public System.Nullable<ScanConfigUserAgent> UserAgent { get; set; }
	}
	
	/// <summary>
	/// A ScanRun is a output-only resource representing an actual run of the scan.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ScanRun
	{
		
		/// <summary>
		/// The time at which the ScanRun reached termination state - that the ScanRun is either finished or stopped by user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// The execution state of the ScanRun.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executionState")]
		public System.Nullable<ScanRunExecutionState> ExecutionState { get; set; }
		
		/// <summary>
		/// Whether the scan run has found any vulnerabilities.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasVulnerabilities")]
		public System.Nullable<System.Boolean> HasVulnerabilities { get; set; }
		
		/// <summary>
		/// The resource name of the ScanRun. The name follows the format of 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'. The ScanRun IDs are generated by the system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The percentage of total completion ranging from 0 to 100. If the scan is in queue, the value is 0. If the scan is running, the value ranges from 0 to 100. If the scan is finished, the value is 100.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="progressPercent")]
		public System.Nullable<System.Int32> ProgressPercent { get; set; }
		
		/// <summary>
		/// The result state of the ScanRun. This field is only available after the execution state reaches "FINISHED".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resultState")]
		public System.Nullable<ScanRunResultState> ResultState { get; set; }
		
		/// <summary>
		/// The time at which the ScanRun started.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
		
		/// <summary>
		/// The number of URLs crawled during this ScanRun. If the scan is in progress, the value represents the number of URLs crawled up to now.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlsCrawledCount")]
		public string UrlsCrawledCount { get; set; }
		
		/// <summary>
		/// The number of URLs tested during this ScanRun. If the scan is in progress, the value represents the number of URLs tested up to now. The number of URLs tested is usually larger than the number URLS crawled because typically a crawled URL is tested with multiple test payloads.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlsTestedCount")]
		public string UrlsTestedCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ScanRunExecutionState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXECUTION_STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		QUEUED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SCANNING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FINISHED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ScanRunResultState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESULT_STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCESS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KILLED = 3,
	}
	
	/// <summary>
	/// Scan schedule configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Schedule
	{
		
		/// <summary>
		/// Required. The duration of time between executions in days.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="intervalDurationDays")]
		public System.Nullable<System.Int32> IntervalDurationDays { get; set; }
		
		/// <summary>
		/// A timestamp indicates when the next run will be scheduled. The value is refreshed by the server after each run. If unspecified, it will default to current server time, which means the scan will be scheduled to start immediately.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleTime")]
		public string ScheduleTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ScanConfigUserAgent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USER_AGENT_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CHROME_LINUX = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CHROME_ANDROID = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SAFARI_IPHONE = 3,
	}
	
	/// <summary>
	/// Response for the `ListScanRuns` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListScanRunsResponse
	{
		
		/// <summary>
		/// Token to retrieve the next page of results, or empty if there are no more results in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The list of ScanRuns returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scanRuns")]
		public ScanRun[] ScanRuns { get; set; }
	}
	
	/// <summary>
	/// Request for the `StartScanRun` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StartScanRunRequest
	{
	}
	
	/// <summary>
	/// Request for the `StopScanRun` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StopScanRunRequest
	{
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Deletes an existing ScanConfig and its child resources.
		/// Websecurityscanner_projects_scanConfigs_delete v1alpha/{name}
		/// </summary>
		/// <param name="name">Required. The resource name of the ScanConfig to be deleted. The name follows the format of 'projects/{projectId}/scanConfigs/{scanConfigId}'.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Websecurityscanner_projects_scanConfigs_deleteAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1alpha/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Empty>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a Finding.
		/// Websecurityscanner_projects_scanConfigs_scanRuns_findings_get v1alpha/{name}
		/// </summary>
		/// <param name="name">Required. The resource name of the Finding to be returned. The name follows the format of 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}/findings/{findingId}'.</param>
		/// <returns>Successful response</returns>
		public async Task<Finding> Websecurityscanner_projects_scanConfigs_scanRuns_findings_getAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1alpha/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Finding>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a ScanConfig. This method support partial update of a ScanConfig.
		/// Websecurityscanner_projects_scanConfigs_patch v1alpha/{name}
		/// </summary>
		/// <param name="name">The resource name of the ScanConfig. The name follows the format of 'projects/{projectId}/scanConfigs/{scanConfigId}'. The ScanConfig IDs are generated by the system.</param>
		/// <param name="updateMask">Required. The update mask applies to the resource. For the `FieldMask` definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask</param>
		/// <returns>Successful response</returns>
		public async Task<ScanConfig> Websecurityscanner_projects_scanConfigs_patchAsync(string name, string updateMask, ScanConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1alpha/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ScanConfig>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Start a ScanRun according to the given ScanConfig.
		/// Websecurityscanner_projects_scanConfigs_start v1alpha/{name}:start
		/// </summary>
		/// <param name="name">Required. The resource name of the ScanConfig to be used. The name follows the format of 'projects/{projectId}/scanConfigs/{scanConfigId}'.</param>
		/// <returns>Successful response</returns>
		public async Task<ScanRun> Websecurityscanner_projects_scanConfigs_startAsync(string name, StartScanRunRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1alpha/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":start";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ScanRun>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Stops a ScanRun. The stopped ScanRun is returned.
		/// Websecurityscanner_projects_scanConfigs_scanRuns_stop v1alpha/{name}:stop
		/// </summary>
		/// <param name="name">Required. The resource name of the ScanRun to be stopped. The name follows the format of 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.</param>
		/// <returns>Successful response</returns>
		public async Task<ScanRun> Websecurityscanner_projects_scanConfigs_scanRuns_stopAsync(string name, StopScanRunRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1alpha/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":stop";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ScanRun>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List CrawledUrls under a given ScanRun.
		/// Websecurityscanner_projects_scanConfigs_scanRuns_crawledUrls_list v1alpha/{parent}/crawledUrls
		/// </summary>
		/// <param name="parent">Required. The parent resource name, which should be a scan run resource name in the format 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.</param>
		/// <param name="pageSize">The maximum number of CrawledUrls to return, can be limited by server. If not specified or not positive, the implementation will select a reasonable value.</param>
		/// <param name="pageToken">A token identifying a page of results to be returned. This should be a `next_page_token` value returned from a previous List request. If unspecified, the first page of results is returned.</param>
		/// <returns>Successful response</returns>
		public async Task<ListCrawledUrlsResponse> Websecurityscanner_projects_scanConfigs_scanRuns_crawledUrls_listAsync(string parent, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1alpha/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/crawledUrls&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListCrawledUrlsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all FindingTypeStats under a given ScanRun.
		/// Websecurityscanner_projects_scanConfigs_scanRuns_findingTypeStats_list v1alpha/{parent}/findingTypeStats
		/// </summary>
		/// <param name="parent">Required. The parent resource name, which should be a scan run resource name in the format 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.</param>
		/// <returns>Successful response</returns>
		public async Task<ListFindingTypeStatsResponse> Websecurityscanner_projects_scanConfigs_scanRuns_findingTypeStats_listAsync(string parent, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1alpha/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/findingTypeStats";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListFindingTypeStatsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List Findings under a given ScanRun.
		/// Websecurityscanner_projects_scanConfigs_scanRuns_findings_list v1alpha/{parent}/findings
		/// </summary>
		/// <param name="parent">Required. The parent resource name, which should be a scan run resource name in the format 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.</param>
		/// <param name="filter">Required. The filter expression. The expression must be in the format: . Supported field: 'finding_type'. Supported operator: '='.</param>
		/// <param name="pageSize">The maximum number of Findings to return, can be limited by server. If not specified or not positive, the implementation will select a reasonable value.</param>
		/// <param name="pageToken">A token identifying a page of results to be returned. This should be a `next_page_token` value returned from a previous List request. If unspecified, the first page of results is returned.</param>
		/// <returns>Successful response</returns>
		public async Task<ListFindingsResponse> Websecurityscanner_projects_scanConfigs_scanRuns_findings_listAsync(string parent, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1alpha/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/findings&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListFindingsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists ScanConfigs under a given project.
		/// Websecurityscanner_projects_scanConfigs_list v1alpha/{parent}/scanConfigs
		/// </summary>
		/// <param name="parent">Required. The parent resource name, which should be a project resource name in the format 'projects/{projectId}'.</param>
		/// <param name="pageSize">The maximum number of ScanConfigs to return, can be limited by server. If not specified or not positive, the implementation will select a reasonable value.</param>
		/// <param name="pageToken">A token identifying a page of results to be returned. This should be a `next_page_token` value returned from a previous List request. If unspecified, the first page of results is returned.</param>
		/// <returns>Successful response</returns>
		public async Task<ListScanConfigsResponse> Websecurityscanner_projects_scanConfigs_listAsync(string parent, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1alpha/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/scanConfigs&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListScanConfigsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new ScanConfig.
		/// Websecurityscanner_projects_scanConfigs_create v1alpha/{parent}/scanConfigs
		/// </summary>
		/// <param name="parent">Required. The parent resource name where the scan is created, which should be a project resource name in the format 'projects/{projectId}'.</param>
		/// <returns>Successful response</returns>
		public async Task<ScanConfig> Websecurityscanner_projects_scanConfigs_createAsync(string parent, ScanConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1alpha/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/scanConfigs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ScanConfig>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists ScanRuns under a given ScanConfig, in descending order of ScanRun stop time.
		/// Websecurityscanner_projects_scanConfigs_scanRuns_list v1alpha/{parent}/scanRuns
		/// </summary>
		/// <param name="parent">Required. The parent resource name, which should be a scan resource name in the format 'projects/{projectId}/scanConfigs/{scanConfigId}'.</param>
		/// <param name="pageSize">The maximum number of ScanRuns to return, can be limited by server. If not specified or not positive, the implementation will select a reasonable value.</param>
		/// <param name="pageToken">A token identifying a page of results to be returned. This should be a `next_page_token` value returned from a previous List request. If unspecified, the first page of results is returned.</param>
		/// <returns>Successful response</returns>
		public async Task<ListScanRunsResponse> Websecurityscanner_projects_scanConfigs_scanRuns_listAsync(string parent, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1alpha/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/scanRuns&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListScanRunsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
