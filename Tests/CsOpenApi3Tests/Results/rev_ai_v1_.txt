//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Rev.ai Account Model
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Account
	{
		
		/// <summary>
		/// Amount of Rev.ai API credits remaining in seconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="balance_seconds")]
		public System.Nullable<System.Int32> Balance_seconds { get; set; }
		
		/// <summary>
		/// Email of developer account
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
	}
	
	public class DescriptionlessJobOptions
	{
	}
	
	public class Job
	{
	}
	
	public class SubmitJobMediaUrlOptions
	{
	}
	
	public class SubmitJobOptions
	{
	}
	
	/// <summary>
	/// Rev.ai Transcript Model
	///***
	///Note: properties are not displayed in the returned object if they are null
	///
	///Jobs with skip_diarization set to true will only show a single speaker for the entire duration of the transcript.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Transcript
	{
		
		[System.Runtime.Serialization.DataMember(Name="monologues")]
		public TranscriptMonologues[] TranscriptMonologues { get; set; }
	}
	
	public class TranscriptMonologues
	{
		
		/// <summary>
		/// Array of transcript elements
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="elements")]
		public TranscriptMonologuesElements[] TranscriptMonologuesElements { get; set; }
		
		/// <summary>
		/// Id of the speaker of the monologue
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="speaker")]
		public System.Nullable<System.Int32> Speaker { get; set; }
	}
	
	public class TranscriptMonologuesElements
	{
		
		/// <summary>
		/// Confidence score of the provided value. If the element `type` is `punct` or `unknown`, confidence will be `null`
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confidence")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> Confidence { get; set; }
		
		/// <summary>
		/// The timestamp of the beginning of the element relative to the beginning of the audio in seconds (centisecond precision)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ts")]
		public System.Nullable<System.Double> Ts { get; set; }
		
		/// <summary>
		/// The timestamp of the end of the element relative to the beginning of the audio in seconds (centisecond precision)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ts_end")]
		public System.Nullable<System.Double> Ts_end { get; set; }
		
		/// <summary>
		/// Type of transcript element. If Rev.ai was unable to determine the spoken word, the `type` will be `unknown`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<TranscriptMonologuesElementsType> Type { get; set; }
		
		/// <summary>
		/// Value of the transcript element.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum TranscriptMonologuesElementsType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		text = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		punct = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unknown = 2,
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Get Account
		/// Get the developer's account information
		/// GetAccount account
		/// </summary>
		/// <returns>Rev.ai Account</returns>
		public async Task<Account> GetAccountAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Account>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get List of Jobs
		/// Gets a list of transcription jobs submitted within the last 30 days in reverse chronological order up to the provided `limit` number of jobs per call. **Note:** Jobs older than 30 days will not be listed. Pagination is supported via passing the last job `id` from a previous call into `starting_after`.
		/// GetListOfJobs jobs
		/// </summary>
		/// <param name="limit">Limits the number of jobs returned, default is 100, max is 1000</param>
		/// <param name="starting_after">If specified, returns transcription jobs submitted before the job with this id, exclusive (job with this id is not included)</param>
		/// <returns>List of Rev.ai Transcription Jobs</returns>
		public async Task<Job[]> GetListOfJobsAsync(int limit, string starting_after, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs?limit="+limit+"&starting_after=" + (starting_after==null? "" : System.Uri.EscapeDataString(starting_after));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Job[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Submit Transcription Job
		/// Starts an asynchronous job to transcribe speech-to-text for a media file. Media files can be specified in two ways, either by including a public url to the media in the transcription job `options` or by uploading a local file as part of a multipart/form request.
		/// SubmitTranscriptionJob jobs
		/// </summary>
		/// <param name="requestBody">Transcription Job Options</param>
		/// <returns>Transcription Job Details</returns>
		public async Task<Job> SubmitTranscriptionJobAsync(SubmitJobMediaUrlOptions requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Job>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete Job by Id
		/// Deletes a transcription job. All data related to the job, such as input media and transcript, will be permanently deleted. A job can only be deleted once it's completed (either with success or failure).
		/// DeleteJobById jobs/{id}
		/// </summary>
		public async Task DeleteJobByIdAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Job By Id
		/// Returns information about a transcription job
		/// GetJobById jobs/{id}
		/// </summary>
		/// <returns>Transcription Job Details</returns>
		public async Task<Job> GetJobByIdAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Job>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Captions
		/// Returns the caption output for a transcription job. We currently support SubRip (SRT) and Web Video Text Tracks (VTT) output.
		/// Caption output format can be specified in the `Accept` header. Returns SRT by default.
		/// ***
		/// Note: For streaming jobs, transient failure of our storage during a live session may prevent the final hypothesis elements from saving properly, resulting in an incomplete caption file. This is rare, but not impossible.
		/// 
		/// GetCaptions jobs/{id}/captions
		/// </summary>
		/// <param name="speaker_channel">Identifies which channel of the job output to caption. Default is `null` which works only for jobs with no `speaker_channels_count` provided during job submission.</param>
		/// <returns>Rev.ai API Captions
		///***
		///Note: Caption output format is required in the Accept header. The supported headers are `application/x-subrip` and `text/vtt`.
		///([SRT](https://en.wikipedia.org/wiki/SubRip))
		///</returns>
		public async Task GetCaptionsAsync(int speaker_channel, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs/{id}/captions?speaker_channel="+speaker_channel;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Transcript By Id
		/// Returns the transcript for a completed transcription job. Transcript can be returned as either JSON or plaintext format. Transcript output format can be specified in the `Accept` header. Returns JSON by default.
		/// ***
		/// Note: For streaming jobs, transient failure of our storage during a live session may prevent the final hypothesis elements from saving properly, resulting in an incomplete transcript. This is rare, but not impossible. To guarantee 100% completeness, we recommend capturing all final hypothesis when you receive them on the client.
		/// 
		/// GetTranscriptById jobs/{id}/transcript
		/// </summary>
		/// <returns>Rev.ai API Transcript
		///***
		///Note: Transcript output format is required in the Accept header. Output can either be in Rev's JSON format or plaintext.
		///</returns>
		public async Task GetTranscriptByIdAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs/{id}/transcript";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum GetCaptionsAccept
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="application/x-subrip")]
		application_xMinussubrip = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="text/vtt")]
		text_vtt = 1,
	}
	
	public enum GetTranscriptByIdAccept
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="application/vnd.rev.transcript.v1.0+json")]
		application_vnd_rev_transcript_v1_0Plusjson = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="text/plain")]
		text_plain = 1,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
