//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class A_page_of_results
	{
		
		/// <summary>
		/// Number of this page of results
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public System.Nullable<System.Int32> Page { get; set; }
		
		/// <summary>
		/// Total number of pages of results
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pages")]
		public System.Nullable<System.Int32> Pages { get; set; }
		
		/// <summary>
		/// Number of items per page of results
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public System.Nullable<System.Int32> Per_page { get; set; }
		
		/// <summary>
		/// Total number of results
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AbstractPropertyValue
	{
		
		/// <summary>
		/// predicate (attribute) part
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pred")]
		public string Pred { get; set; }
		
		/// <summary>
		/// value part
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="val")]
		public string Val { get; set; }
		
		/// <summary>
		/// Xrefs provenance for property-value
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xrefs")]
		public string[] Xrefs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AnnotationExtension
	{
		
		/// <summary>
		/// Extension interpreted as OWL expression (r1 some r2 some .. some filler).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filler")]
		public NamedObject Filler { get; set; }
		
		/// <summary>
		/// Relationship type. If more than one value, interpreted as chain
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relation_chain")]
		public Relation[] Relation_chain { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Relation : NamedObject
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Association
	{
		
		/// <summary>
		/// An indirect association is a join between two or more direct assocations, e.g. gene to disease via ortholog. We record the full set of associations as a graph object
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="evidence_graph")]
		public Graph Evidence_graph { get; set; }
		
		/// <summary>
		/// Evidence types (ECO classes)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="evidence_types")]
		public EntityReference[] Evidence_types { get; set; }
		
		/// <summary>
		/// Association/annotation unique ID
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// True if association is negated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="negated")]
		public System.Nullable<System.Boolean> Negated { get; set; }
		
		/// <summary>
		/// Object (sensu RDF), aka target, e.g. HP:0000448, MP:0002109, DOID:14330
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="object")]
		public BioObjectCore Object { get; set; }
		
		/// <summary>
		/// Equivalent identifiers to object node
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="object_eq")]
		public string[] Object_eq { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="object_extensions")]
		public string[] Object_extensions { get; set; }
		
		/// <summary>
		/// Provider of association, e.g. Orphanet, ClinVar
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provided_by")]
		public string[] Provided_by { get; set; }
		
		/// <summary>
		/// Publications supporting association, extracted from evidence graph
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publications")]
		public EntityReference[] Publications { get; set; }
		
		/// <summary>
		/// Qualifier on the association
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="qualifiers")]
		public string[] Qualifiers { get; set; }
		
		/// <summary>
		/// Relationship type connecting subject and object
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="relation")]
		public RelationRef Relation { get; set; }
		
		/// <summary>
		/// Objects mapped to a slim
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slim")]
		public string[] Slim { get; set; }
		
		/// <summary>
		/// Subject of association (what it is about), e.g. ClinVar:nnn, MGI:1201606
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subject")]
		public BioObjectCore Subject { get; set; }
		
		/// <summary>
		/// Equivalent identifiers to subject node
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subject_eq")]
		public string[] Subject_eq { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subject_extensions")]
		public string[] Subject_extensions { get; set; }
		
		/// <summary>
		/// Type of association, e.g. gene-phenotype
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Graph
	{
		
		/// <summary>
		/// All edges in graph
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="edges")]
		public Edge[] Edges { get; set; }
		
		/// <summary>
		/// All nodes in graph
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodes")]
		public Node[] Nodes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Edge
	{
		
		/// <summary>
		/// metadata about the Edge
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public string Meta { get; set; }
		
		/// <summary>
		/// Object (target) Node ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="obj")]
		public string Obj { get; set; }
		
		/// <summary>
		/// Predicate (relation) ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pred")]
		public string Pred { get; set; }
		
		/// <summary>
		/// Subject (source) Node ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sub")]
		public string Sub { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Node
	{
		
		/// <summary>
		/// ID or CURIE e.g. MGI:1201606
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// RDFS Label
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class EntityReference
	{
		
		/// <summary>
		/// ID or CURIE e.g. MGI:1201606
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// RDFS Label
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AssociationResults : SearchResult
	{
		
		/// <summary>
		/// Complete representation of full association object, plus evidence
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="associations")]
		public Association[] Associations { get; set; }
		
		/// <summary>
		/// Compact representation in which objects (e.g. phenotypes) are collected for subject-predicate pairs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="compact_associations")]
		public CompactAssociationSet[] Compact_associations { get; set; }
		
		/// <summary>
		/// List of distinct objects used
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objects")]
		public string[] Objects { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CompactAssociationSet
	{
		
		/// <summary>
		/// List of O, for a given (S,R) pair, yielding (S,R,O) triples. E.g. list of MPs for (MGI:nnn, has_phenotype)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objects")]
		public string[] Objects { get; set; }
		
		/// <summary>
		/// Relationship type connecting subject and object list
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="relation")]
		public string Relation { get; set; }
		
		/// <summary>
		/// Subject of association (what it is about), e.g. MGI:1201606
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subject")]
		public string Subject { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AutocompleteResult
	{
		
		/// <summary>
		/// node categories
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string[] Category { get; set; }
		
		/// <summary>
		/// Equivalent IDs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="equivalent_ids")]
		public string[] Equivalent_ids { get; set; }
		
		/// <summary>
		/// True if highlight can be interpreted as html, else False
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="has_highlight")]
		public System.Nullable<System.Boolean> Has_highlight { get; set; }
		
		/// <summary>
		/// solr highlight
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="highlight")]
		public string Highlight { get; set; }
		
		/// <summary>
		/// curie formatted id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// primary label (rdfs:label)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string[] Label { get; set; }
		
		/// <summary>
		/// matched part of document (may be primary label, synonym, id, etc)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="match")]
		public string Match { get; set; }
		
		/// <summary>
		/// taxon as NCBITaxon curie
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="taxon")]
		public string Taxon { get; set; }
		
		/// <summary>
		/// taxon label
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="taxon_label")]
		public string Taxon_label { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AutocompleteResults
	{
		
		/// <summary>
		/// list of AutocompleteResult docs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="docs")]
		public AutocompleteResult[] Docs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BioObject : NamedObject
	{
		
		/// <summary>
		/// association counts
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="association_counts")]
		public string Association_counts { get; set; }
		
		/// <summary>
		/// Taxon to which the object belongs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="taxon")]
		public Taxon Taxon { get; set; }
		
		/// <summary>
		/// Database cross-references. These are usually CURIEs, but may also be URLs. E.g. ENSEMBL:ENSG00000099940 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xrefs")]
		public string[] Xrefs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Taxon
	{
		
		/// <summary>
		/// CURIE ID, e.g. NCBITaxon:9606
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// RDFS Label
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BioObjectCore : NamedObjectCore
	{
		
		/// <summary>
		/// Taxon to which the object belongs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="taxon")]
		public Taxon Taxon { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CompareInput
	{
		
		/// <summary>
		/// list of query profiles
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="query_ids")]
		public string[] Query_ids { get; set; }
		
		/// <summary>
		/// list of ids
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reference_ids")]
		public string[] Reference_ids { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class D2PAssociation : Association
	{
		
		/// <summary>
		/// Frequency of phenotype in patients with disease
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="frequency")]
		public EntityReference Frequency { get; set; }
		
		/// <summary>
		/// Onset of phenotype in disease process
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="onset")]
		public EntityReference Onset { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class D2PAssociationResults : SearchResult
	{
		
		/// <summary>
		/// Complete representation of full disease to phenotype association, plus evidence
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="associations")]
		public D2PAssociation[] Associations { get; set; }
		
		/// <summary>
		/// Compact representation in which objects (e.g. phenotypes) are collected for subject-predicate pairs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="compact_associations")]
		public CompactAssociationSet[] Compact_associations { get; set; }
		
		/// <summary>
		/// List of distinct objects used
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objects")]
		public string[] Objects { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class EntityAnnotationResult
	{
		
		[System.ComponentModel.DefaultValue("The content from which the entities are extracted from")]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; } = "The content from which the entities are extracted from";
		
		/// <summary>
		/// A marked-up span of text
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="spans")]
		public Span[] Spans { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Span
	{
		
		/// <summary>
		/// end of span text relative to content
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end")]
		public System.Nullable<System.Int32> End { get; set; }
		
		/// <summary>
		/// start of span text relative to content
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start")]
		public System.Nullable<System.Int32> Start { get; set; }
		
		/// <summary>
		/// span text
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// A token or entity extracted from the span text
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="token")]
		public Token[] Token { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Token
	{
		
		/// <summary>
		/// entity categories
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="categories")]
		public string[] Categories { get; set; }
		
		/// <summary>
		/// The CURIE for the entity or token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// terms
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="terms")]
		public string[] Terms { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Feature
	{
		
		/// <summary>
		/// curie formatted id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// is the feature present
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPresent")]
		public System.Nullable<System.Boolean> IsPresent { get; set; }
		
		/// <summary>
		/// curie formatted id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// feature type (only phenotype supported)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IcNode : Node
	{
		
		/// <summary>
		/// Information content
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> IC { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LayAutocomplete
	{
		
		/// <summary>
		/// solr highlight
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="highlight")]
		public string Highlight { get; set; }
		
		/// <summary>
		/// curie formatted id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// primary label (rdfs:label)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// matched synonym
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matched_synonym")]
		public string Matched_synonym { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LayResults
	{
		
		/// <summary>
		/// list of AutocompleteResult docs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public LayAutocomplete[] Results { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NamedObject : NamedObjectCore
	{
		
		[System.Runtime.Serialization.DataMember(Name="consider")]
		public string[] Consider { get; set; }
		
		/// <summary>
		/// True if the node is deprecated/obsoleted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public System.Nullable<System.Boolean> Deprecated { get; set; }
		
		/// <summary>
		/// Descriptive text for the entity. For ontology classes, this will be a definition.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="replaced_by")]
		public string[] Replaced_by { get; set; }
		
		/// <summary>
		/// list of synonyms or alternate labels
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="synonyms")]
		public SynonymPropertyValue[] Synonyms { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="types")]
		public string[] Types { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SynonymPropertyValue : AbstractPropertyValue
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NamedObjectCore
	{
		
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string[] Category { get; set; }
		
		/// <summary>
		/// ID or CURIE e.g. MGI:1201606
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// IRI
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iri")]
		public string Iri { get; set; }
		
		/// <summary>
		/// RDFS Label
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Page_of_variant_sets : A_page_of_results
	{
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Variant_set[] Items { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Variant_set
	{
		
		/// <summary>
		/// Article content
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="category_id")]
		public System.Nullable<System.Int32> Category_id { get; set; }
		
		/// <summary>
		/// The unique identifier of a variant set
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pub_date")]
		public System.Nullable<System.DateTimeOffset> Pub_date { get; set; }
		
		/// <summary>
		/// Article title
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PairwiseMatch
	{
		
		/// <summary>
		/// lowest common subsumer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lcs")]
		public IcNode Lcs { get; set; }
		
		/// <summary>
		/// match id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="match")]
		public IcNode Match { get; set; }
		
		/// <summary>
		/// reference id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reference")]
		public IcNode Reference { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RelationRef : NamedObjectCore
	{
		
		/// <summary>
		/// is relation inverted
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inverse")]
		public System.Nullable<System.Boolean> Inverse { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SearchResult
	{
		
		/// <summary>
		/// solr docs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="docs")]
		public string[] Docs { get; set; }
		
		/// <summary>
		/// Mapping between field names and association counts
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="facet_counts")]
		public string Facet_counts { get; set; }
		
		/// <summary>
		/// Mapping between id and solr highlight
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="highlighting")]
		public string Highlighting { get; set; }
		
		/// <summary>
		/// total number of associations matching query
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numFound")]
		public System.Nullable<System.Int32> NumFound { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Seq : BioObject
	{
		
		/// <summary>
		/// one of: DNA, RNA or AA
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alphabet")]
		public string Alphabet { get; set; }
		
		/// <summary>
		/// checksum
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="md5checksum")]
		public string Md5checksum { get; set; }
		
		/// <summary>
		/// string representing sequence of residues
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="residues")]
		public string Residues { get; set; }
		
		/// <summary>
		/// length of sequence
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seqlen")]
		public string Seqlen { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SequenceFeature : BioObject
	{
		
		[System.Runtime.Serialization.DataMember(Name="homology_associations")]
		public Association[] Homology_associations { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="locations")]
		public SequenceLocation[] Locations { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seq")]
		public Seq Seq { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SequenceLocation : BioObject
	{
		
		[System.Runtime.Serialization.DataMember(Name="end")]
		public SequencePosition End { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="phase")]
		public System.Nullable<System.Int32> Phase { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="score")]
		public System.Nullable<System.Int32> Score { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="start")]
		public SequencePosition Start { get; set; }
		
		/// <summary>
		/// Strand direction: 1=='+', -1=='-', 0 or null infers unknown.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="strand")]
		public System.Nullable<System.Int32> Strand { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SequencePosition
	{
		
		[System.Runtime.Serialization.DataMember(Name="position")]
		public System.Nullable<System.Int32> Position { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reference")]
		public string Reference { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SimMatch : TypedNode
	{
		
		[System.Runtime.Serialization.DataMember(Name="pairwise_match")]
		public string[] Pairwise_match { get; set; }
		
		/// <summary>
		/// rank
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rank")]
		public string Rank { get; set; }
		
		/// <summary>
		/// sim score
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="score")]
		public System.Nullable<System.Double> Score { get; set; }
		
		/// <summary>
		/// p-value
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="significance")]
		public string Significance { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SimMetadata
	{
		
		/// <summary>
		/// max IC
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="max_max_ic")]
		public System.Nullable<System.Double> Max_max_ic { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SimQuery
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="negated_ids")]
		public string[] Negated_ids { get; set; }
		
		/// <summary>
		/// reference individual or class (eg gene, disease)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reference")]
		public TypedNode Reference { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="target_ids")]
		public string[] Target_ids { get; set; }
		
		/// <summary>
		/// list of unresolved ids
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unresolved_ids")]
		public string[] Unresolved_ids { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SimResult
	{
		
		[System.Runtime.Serialization.DataMember(Name="matches")]
		public string[] Matches { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public SimMetadata Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="query")]
		public SimQuery Query { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SufficiencyOutput
	{
		
		/// <summary>
		/// categorical score
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="categorical_score")]
		public System.Nullable<System.Double> Categorical_score { get; set; }
		
		/// <summary>
		/// scaled score
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scaled_score")]
		public System.Nullable<System.Double> Scaled_score { get; set; }
		
		/// <summary>
		/// simple score
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="simple_score")]
		public System.Nullable<System.Double> Simple_score { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SufficiencyPostInput
	{
		
		/// <summary>
		/// list of features
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="features")]
		public Feature[] Features { get; set; }
		
		/// <summary>
		/// curie formatted id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TypedNode : Node
	{
		
		/// <summary>
		/// taxon
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="taxon")]
		public Node Taxon { get; set; }
		
		/// <summary>
		/// node type (eg phenotype, disease)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Mme
	{
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Returns associations connecting two entities
		/// Given two entities (e.g. a particular gene and a particular disease), if these two entities
		/// are connected (directly or indirectly), then return the association objects describing
		/// the connection.
		/// Get_associations_between association/between/{subject}/{object}
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults[]> Get_associations_betweenAsync(int rows, int start, string evidence, bool unselect_evidence, bool exclude_automatic_assertions, bool use_compact_associations, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "association/between/{subject}/{object}?rows="+rows+"&start="+start+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&use_compact_associations="+use_compact_associations;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of matching associations for a given subject category
		/// Get_association_by_subject_category_search association/find/{subject_category}
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="subject_taxon">Subject taxon ID, e.g. NCBITaxon:9606 (Includes inferred associations, by default)</param>
		/// <param name="object_taxon">Object taxon ID, e.g. NCBITaxon:10090 (Includes inferred associations, by default)</param>
		/// <param name="relation">Filter by relation CURIE, e.g. RO:0002200 (has_phenotype), RO:0002607 (is marker for), RO:HOM0000017 (orthologous to), etc.</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults[]> Get_association_by_subject_category_searchAsync(int rows, int start, string evidence, bool unselect_evidence, bool exclude_automatic_assertions, bool use_compact_associations, string subject_taxon, string object_taxon, string relation, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "association/find/{subject_category}?rows="+rows+"&start="+start+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&use_compact_associations="+use_compact_associations+"&subject_taxon=" + (subject_taxon==null? "" : System.Uri.EscapeDataString(subject_taxon))+"&object_taxon=" + (object_taxon==null? "" : System.Uri.EscapeDataString(object_taxon))+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of matching associations between a given subject and object category
		/// Get_association_by_subject_and_object_category_search association/find/{subject_category}/{object_category}
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="subject">Subject CURIE</param>
		/// <param name="_object">Object CURIE</param>
		/// <param name="subject_taxon">Subject taxon ID, e.g. NCBITaxon:9606 (Includes inferred associations, by default)</param>
		/// <param name="object_taxon">Object taxon ID, e.g. NCBITaxon:10090 (Includes inferred associations, by default)</param>
		/// <param name="relation">Filter by relation CURIE, e.g. RO:0002200 (has_phenotype), RO:0002607 (is marker for), RO:HOM0000017 (orthologous to), etc.</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults[]> Get_association_by_subject_and_object_category_searchAsync(int rows, int start, string evidence, bool unselect_evidence, bool exclude_automatic_assertions, bool use_compact_associations, string subject, string _object, string subject_taxon, string object_taxon, string relation, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "association/find/{subject_category}/{object_category}?rows="+rows+"&start="+start+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&use_compact_associations="+use_compact_associations+"&subject=" + (subject==null? "" : System.Uri.EscapeDataString(subject))+"&object=" + (_object==null? "" : System.Uri.EscapeDataString(_object))+"&subject_taxon=" + (subject_taxon==null? "" : System.Uri.EscapeDataString(subject_taxon))+"&object_taxon=" + (object_taxon==null? "" : System.Uri.EscapeDataString(object_taxon))+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of matching associations starting from a given subject (source)
		/// Get_associations_from association/from/{subject}
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="object_taxon">Object taxon ID, e.g. NCBITaxon:10090 (Includes inferred associations, by default)</param>
		/// <param name="relation">Filter by relation CURIE, e.g. RO:0002200 (has_phenotype), RO:0002607 (is marker for), RO:HOM0000017 (orthologous to), etc.</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults[]> Get_associations_fromAsync(int rows, int start, string evidence, bool unselect_evidence, bool exclude_automatic_assertions, bool use_compact_associations, string object_taxon, string relation, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "association/from/{subject}?rows="+rows+"&start="+start+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&use_compact_associations="+use_compact_associations+"&object_taxon=" + (object_taxon==null? "" : System.Uri.EscapeDataString(object_taxon))+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of matching associations pointing to a given object (target)
		/// Get_associations_to association/to/{object}
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults[]> Get_associations_toAsync(int rows, int start, string evidence, bool unselect_evidence, bool exclude_automatic_assertions, bool use_compact_associations, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "association/to/{object}?rows="+rows+"&start="+start+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&use_compact_associations="+use_compact_associations;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of matching associations of a given type
		/// Get_association_by_subject_and_assoc_type association/type/{association_type}
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="subject">Subject CURIE</param>
		/// <param name="_object">Object CURIE</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults[]> Get_association_by_subject_and_assoc_typeAsync(int rows, int start, string evidence, bool unselect_evidence, bool exclude_automatic_assertions, bool use_compact_associations, string subject, string _object, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "association/type/{association_type}?rows="+rows+"&start="+start+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&use_compact_associations="+use_compact_associations+"&subject=" + (subject==null? "" : System.Uri.EscapeDataString(subject))+"&object=" + (_object==null? "" : System.Uri.EscapeDataString(_object));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns the association with a given identifier
		/// An association connects, at a minimum, two things, designated subject and object,
		/// via some relationship. Associations also include evidence, provenance etc.
		/// Get_association_object association/{id}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<AssociationResults[]> Get_association_objectAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "association/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns genes associated with a given anatomy
		/// Get_anatomy_gene_associations bioentity/anatomy/{id}/genes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_anatomy_gene_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/anatomy/{id}/genes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns gene IDs for all genes associated with a given anatomy, filtered by taxon
		/// For example, + NCBITaxon:10090 (mouse)
		/// Get_anatomy_gene_by_taxon_associations bioentity/anatomy/{id}/genes/{taxid}
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task Get_anatomy_gene_by_taxon_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/anatomy/{id}/genes/{taxid}?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns diseases associated with a case
		/// Get_case_disease_associations bioentity/case/{id}/diseases
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_case_disease_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/case/{id}/diseases?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns genotypes associated with a case
		/// Get_case_genotype_associations bioentity/case/{id}/genotypes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_case_genotype_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/case/{id}/genotypes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns models associated with a case
		/// Get_case_model_associations bioentity/case/{id}/models
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_case_model_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/case/{id}/models?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns phenotypes associated with a case
		/// Get_case_phenotype_associations bioentity/case/{id}/phenotypes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_case_phenotype_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/case/{id}/phenotypes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns variants associated with a case
		/// Get_case_variant_associations bioentity/case/{id}/variants
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_case_variant_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/case/{id}/variants?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns cases associated with a disease
		/// Get_disease_case_associations bioentity/disease/{id}/cases
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_disease_case_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/disease/{id}/cases?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns genes associated with a disease
		/// Get_disease_gene_associations bioentity/disease/{id}/genes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <param name="association_type">Additional filters: causal, non_causal, both</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_disease_gene_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Get_disease_gene_associationsAssociation_type association_type, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/disease/{id}/genes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&association_type=" + association_type;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns genotypes associated with a disease
		/// Get_disease_genotype_associations bioentity/disease/{id}/genotypes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_disease_genotype_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/disease/{id}/genotypes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns associations to models of the disease
		/// In the association object returned, the subject will be the disease, and the object will be the model.
		/// The model may be a gene or genetic element.
		/// 
		/// If the query disease is a general class, the association subject may be to a specific disease.
		/// 
		/// In some cases the association will be *direct*, for example if a paper asserts a genotype is a model of a disease.
		/// 
		/// In other cases, the association will be *indirect*, for
		/// example, chaining over orthology. In these cases the chain
		/// will be reflected in the *evidence graph*
		/// 
		/// * TODO: provide hook into owlsim for dynamic computation of models by similarity
		/// Get_disease_model_associations bioentity/disease/{id}/models
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_disease_model_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/disease/{id}/models?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns associations to models of the disease constrained by taxon
		/// See /disease/<id>/models route for full details
		/// Get_disease_model_taxon_associations bioentity/disease/{id}/models/{taxon}
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_disease_model_taxon_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/disease/{id}/models/{taxon}?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns pathways associated with a disease
		/// Get_disease_pathway_associations bioentity/disease/{id}/pathways
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_disease_pathway_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/disease/{id}/pathways?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns phenotypes associated with disease
		/// Get_disease_phenotype_associations bioentity/disease/{id}/phenotypes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<D2PAssociationResults> Get_disease_phenotype_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/disease/{id}/phenotypes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<D2PAssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns publications associated with a disease
		/// Get_disease_publication_associations bioentity/disease/{id}/publications
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_disease_publication_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/disease/{id}/publications?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns substances associated with a disease
		/// e.g. drugs or small molecules used to treat
		/// Get_disease_substance_associations bioentity/disease/{id}/treatment
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task Get_disease_substance_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/disease/{id}/treatment?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns variants associated with a disease
		/// Get_disease_variant_associations bioentity/disease/{id}/variants
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_disease_variant_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/disease/{id}/variants?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns annotations associated to a function term
		/// Get_function_associations bioentity/function/{id}
		/// </summary>
		/// <param name="start">beginning row</param>
		/// <param name="rows">number of rows</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <returns>Success</returns>
		public async Task Get_function_associationsAsync(int start, int rows, string[] evidence, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/function/{id}?start="+start+"&rows="+rows+"&"+string.Join("&", evidence.Select(z => $"evidence={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns genes associated to a GO term
		/// Get_function_gene_associations bioentity/function/{id}/genes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <param name="relationship_type">relationship type ('involved_in', 'involved_in_regulation_of' or 'acts_upstream_of_or_within')</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_function_gene_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Get_function_gene_associationsRelationship_type relationship_type, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/function/{id}/genes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&relationship_type=" + relationship_type;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns publications associated to a GO term
		/// Get_function_publication_associations bioentity/function/{id}/publications
		/// </summary>
		/// <param name="start">beginning row</param>
		/// <param name="rows">number of rows</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <returns>Success</returns>
		public async Task Get_function_publication_associationsAsync(int start, int rows, string[] evidence, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/function/{id}/publications?start="+start+"&rows="+rows+"&"+string.Join("&", evidence.Select(z => $"evidence={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns taxons associated to a GO term
		/// Get_function_taxon_associations bioentity/function/{id}/taxons
		/// </summary>
		/// <param name="start">beginning row</param>
		/// <param name="rows">number of rows</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <returns>Success</returns>
		public async Task Get_function_taxon_associationsAsync(int start, int rows, string[] evidence, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/function/{id}/taxons?start="+start+"&rows="+rows+"&"+string.Join("&", evidence.Select(z => $"evidence={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns anatomical entities associated with a gene
		/// Get_gene_anatomy_associations bioentity/gene/{id}/anatomy
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_gene_anatomy_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/gene/{id}/anatomy?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns cases associated with a gene
		/// Get_gene_case_associations bioentity/gene/{id}/cases
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_gene_case_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/gene/{id}/cases?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns diseases associated with gene
		/// Get_gene_disease_associations bioentity/gene/{id}/diseases
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <param name="association_type">Additional filters: causal, non_causal, both</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_gene_disease_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Get_disease_gene_associationsAssociation_type association_type, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/gene/{id}/diseases?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&association_type=" + association_type;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns expression events for a gene
		/// Get_gene_expression_associations bioentity/gene/{id}/expression/anatomy
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_gene_expression_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/gene/{id}/expression/anatomy?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns function associations for a gene
		/// IMPLEMENTATION DETAILS
		/// ----------------------
		/// 
		/// Note: currently this is implemented as a query to the GO/AmiGO solr instance.
		/// This directly supports IDs such as:
		/// 
		/// - ZFIN e.g. ZFIN:ZDB-GENE-050417-357
		/// 
		/// Note that the AmiGO GOlr natively stores MGI annotations to MGI:MGI:nn. However,
		/// the standard for biolink is MGI:nnnn, so you should use this (will be transparently
		/// mapped to legacy ID)
		/// 
		/// Additionally, for some species such as Human, GO has the annotation attached to the UniProt ID.
		/// Again, this should be transparently handled; e.g. you can use NCBIGene:6469, and this will be
		/// mapped behind the scenes for querying.
		/// Get_gene_function_associations bioentity/gene/{id}/function
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_gene_function_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/gene/{id}/function?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns genotypes associated with a gene
		/// Get_gene_genotype_associations bioentity/gene/{id}/genotypes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_gene_genotype_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/gene/{id}/genotypes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns homologs for a gene
		/// Get_gene_homolog_associations bioentity/gene/{id}/homologs
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">Taxon CURIE of homolog, e.g. NCBITaxon:9606 (Can be an ancestral node in the ontology; includes inferred associations by default)</param>
		/// <param name="homology_type">P (paralog), O (Ortholog) or LDO (least-diverged ortholog)</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_gene_homolog_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, string[] taxon, Get_gene_homolog_associationsHomology_type homology_type, bool direct_taxon, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/gene/{id}/homologs?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&homology_type=" + homology_type+"&direct_taxon="+direct_taxon;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns interactions for a gene
		/// Get_gene_interactions bioentity/gene/{id}/interactions
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_gene_interactionsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/gene/{id}/interactions?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns models associated with a gene
		/// Get_gene_model_associations bioentity/gene/{id}/models
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_gene_model_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/gene/{id}/models?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return diseases associated with orthologs of a gene
		/// Get_gene_ortholog_disease_associations bioentity/gene/{id}/ortholog/diseases
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_gene_ortholog_disease_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/gene/{id}/ortholog/diseases?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return phenotypes associated with orthologs for a gene
		/// Get_gene_ortholog_phenotype_associations bioentity/gene/{id}/ortholog/phenotypes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_gene_ortholog_phenotype_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/gene/{id}/ortholog/phenotypes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns pathways associated with gene
		/// Get_gene_pathway_associations bioentity/gene/{id}/pathways
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_gene_pathway_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/gene/{id}/pathways?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns phenotypes associated with gene
		/// Get_gene_phenotype_associations bioentity/gene/{id}/phenotypes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_gene_phenotype_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/gene/{id}/phenotypes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns publications associated with a gene
		/// Get_gene_publication_associations bioentity/gene/{id}/publications
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_gene_publication_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/gene/{id}/publications?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns variants associated with a gene
		/// Get_gene_variant_associations bioentity/gene/{id}/variants
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_gene_variant_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/gene/{id}/variants?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns cases associated with a genotype
		/// Get_genotype_case_associations bioentity/genotype/{id}/cases
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_genotype_case_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/genotype/{id}/cases?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns diseases associated with a genotype
		/// Get_genotype_disease_associations bioentity/genotype/{id}/diseases
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_genotype_disease_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/genotype/{id}/diseases?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns genes associated with a genotype
		/// Get_genotype_gene_associations bioentity/genotype/{id}/genes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_genotype_gene_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/genotype/{id}/genes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns genotypes-genotype associations
		/// Genotypes may be related to one another according to the GENO model
		/// Get_genotype_genotype_associations bioentity/genotype/{id}/genotypes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_genotype_genotype_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/genotype/{id}/genotypes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns models associated with a genotype
		/// Get_genotype_model_associations bioentity/genotype/{id}/models
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_genotype_model_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/genotype/{id}/models?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns phenotypes associated with a genotype
		/// Get_genotype_phenotype_associations bioentity/genotype/{id}/phenotypes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_genotype_phenotype_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/genotype/{id}/phenotypes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns publications associated with a genotype
		/// Get_genotype_publication_associations bioentity/genotype/{id}/publications
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_genotype_publication_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/genotype/{id}/publications?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns genotypes-variant associations
		/// Get_genotype_variant_associations bioentity/genotype/{id}/variants
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_genotype_variant_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/genotype/{id}/variants?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns associations to GO terms for a gene
		/// Get_goterm_gene_associations bioentity/goterm/{id}/genes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="relationship_type">relationship type ('involved_in', 'involved_in_regulation_of' or 'acts_upstream_of_or_within')</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_goterm_gene_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Get_function_gene_associationsRelationship_type relationship_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/goterm/{id}/genes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&relationship_type=" + relationship_type;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns cases associated with a model
		/// Get_model_case_associations bioentity/model/{id}/cases
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_model_case_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/model/{id}/cases?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns diseases associated with a model
		/// Get_model_disease_associations bioentity/model/{id}/diseases
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_model_disease_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/model/{id}/diseases?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns genes associated with a model
		/// Get_model_gene_associations bioentity/model/{id}/genes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_model_gene_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/model/{id}/genes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns genotypes associated with a model
		/// Get_model_genotype_associations bioentity/model/{id}/genotypes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_model_genotype_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/model/{id}/genotypes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns phenotypes associated with a model
		/// Get_model_phenotype_associations bioentity/model/{id}/phenotypes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_model_phenotype_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/model/{id}/phenotypes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns publications associated with a model
		/// Get_model_publication_associations bioentity/model/{id}/publications
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_model_publication_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/model/{id}/publications?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns variants associated with a model
		/// Get_model_variant_associations bioentity/model/{id}/variants
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_model_variant_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/model/{id}/variants?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns diseases associated with a pathway
		/// Get_pathway_disease_associations bioentity/pathway/{id}/diseases
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_pathway_disease_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/pathway/{id}/diseases?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns genes associated with a pathway
		/// Get_pathway_gene_associations bioentity/pathway/{id}/genes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_pathway_gene_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/pathway/{id}/genes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns phenotypes associated with a pathway
		/// Get_pathway_phenotype_associations bioentity/pathway/{id}/phenotypes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_pathway_phenotype_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/pathway/{id}/phenotypes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns anatomical entities associated with a phenotype
		/// Example IDs:
		/// 
		/// * MP:0008521 abnormal Bowman membrane
		/// Get_phenotype_anatomy_associations bioentity/phenotype/{id}/anatomy
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task<NamedObject[]> Get_phenotype_anatomy_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/phenotype/{id}/anatomy?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<NamedObject[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns cases associated with a phenotype
		/// Get_phenotype_case_associations bioentity/phenotype/{id}/cases
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_phenotype_case_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/phenotype/{id}/cases?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns diseases associated with a phenotype
		/// Get_phenotype_disease_associations bioentity/phenotype/{id}/diseases
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<D2PAssociationResults> Get_phenotype_disease_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/phenotype/{id}/diseases?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<D2PAssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns gene IDs for all genes associated with a given phenotype, filtered by taxon
		/// For example, MP:0001569 + NCBITaxon:10090 (mouse)
		/// Get_phenotype_gene_by_taxon_associations bioentity/phenotype/{id}/gene/{taxid}/ids
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task Get_phenotype_gene_by_taxon_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/phenotype/{id}/gene/{taxid}/ids?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns genes associated with a phenotype
		/// Get_phenotype_gene_associations bioentity/phenotype/{id}/genes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_phenotype_gene_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/phenotype/{id}/genes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns genotypes associated with a phenotype
		/// Get_phenotype_genotype_associations bioentity/phenotype/{id}/genotypes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_phenotype_genotype_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/phenotype/{id}/genotypes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns pathways associated with a phenotype
		/// Get_phenotype_pathway_associations bioentity/phenotype/{id}/pathways
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_phenotype_pathway_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/phenotype/{id}/pathways?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns publications associated with a phenotype
		/// Get_phenotype_publication_associations bioentity/phenotype/{id}/publications
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_phenotype_publication_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/phenotype/{id}/publications?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns variants associated with a phenotype
		/// Get_phenotype_variant_associations bioentity/phenotype/{id}/variants
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_phenotype_variant_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/phenotype/{id}/variants?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns diseases associated with a publication
		/// Get_publication_disease_associations bioentity/publication/{id}/diseases
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_publication_disease_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/publication/{id}/diseases?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns genes associated with a publication
		/// Get_publication_gene_associations bioentity/publication/{id}/genes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_publication_gene_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/publication/{id}/genes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns genotypes associated with a publication
		/// Get_publication_genotype_associations bioentity/publication/{id}/genotypes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_publication_genotype_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/publication/{id}/genotypes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns models associated with a publication
		/// Get_publication_model_associations bioentity/publication/{id}/models
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_publication_model_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/publication/{id}/models?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns phenotypes associated with a publication
		/// Get_publication_phenotype_associations bioentity/publication/{id}/phenotypes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_publication_phenotype_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/publication/{id}/phenotypes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns variants associated with a publication
		/// Get_publication_variant_associations bioentity/publication/{id}/variants
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_publication_variant_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/publication/{id}/variants?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns associations between an activity and process and the specified substance
		/// Examples relationships:
		/// 
		/// * substance is a metabolite of a process
		/// * substance is synthesized by a process
		/// * substance is modified by an activity
		/// * substance elicits a response program/pathway
		/// * substance is transported by activity or pathway
		/// 
		/// For example, CHEBI:40036 (amitrole)
		/// Get_substance_participant_in_associations bioentity/substance/{id}/participant_in
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task<Association[]> Get_substance_participant_in_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/substance/{id}/participant_in?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Association[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns associations between given drug and roles
		/// Roles may be human-oriented (e.g. pesticide) or molecular (e.g. enzyme inhibitor)
		/// Get_substance_role_associations bioentity/substance/{id}/roles
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task<Association[]> Get_substance_role_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/substance/{id}/roles?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Association[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns substances associated with a disease
		/// e.g. drugs or small molecules used to treat
		/// Get_substance_treats_associations bioentity/substance/{id}/treats
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task Get_substance_treats_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/substance/{id}/treats?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns cases associated with a variant
		/// Get_variant_case_associations bioentity/variant/{id}/cases
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_variant_case_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/variant/{id}/cases?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns diseases associated with a variant
		/// Get_variant_disease_associations bioentity/variant/{id}/diseases
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_variant_disease_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/variant/{id}/diseases?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns genes associated with a variant
		/// Get_variant_gene_associations bioentity/variant/{id}/genes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_variant_gene_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/variant/{id}/genes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns genotypes associated with a variant
		/// Get_variant_genotype_associations bioentity/variant/{id}/genotypes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_variant_genotype_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/variant/{id}/genotypes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns models associated with a variant
		/// Get_variant_model_associations bioentity/variant/{id}/models
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_variant_model_associationsAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/variant/{id}/models?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns phenotypes associated with a variant
		/// Get_variant_phenotype_associations bioentity/variant/{id}/phenotypes
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_variant_phenotype_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/variant/{id}/phenotypes?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns publications associated with a variant
		/// Get_variant_publication_associations bioentity/variant/{id}/publications
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_variant_publication_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/variant/{id}/publications?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns basic info on object of any type
		/// Get_generic_object bioentity/{id}
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <returns>Success</returns>
		public async Task<BioObject> Get_generic_objectAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/{id}?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<BioObject>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns associations for an entity regardless of the type
		/// Get_generic_associations bioentity/{id}/associations
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="taxon">One or more taxon CURIE to filter associations by subject taxon; includes inferred associations by default</param>
		/// <param name="direct_taxon">Set true to exclude inferred taxa</param>
		/// <param name="relation">A relation CURIE to filter associations</param>
		/// <param name="sort">Sorting responses <field> <desc,asc></param>
		/// <param name="q">Query string to filter documents</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults> Get_generic_associationsAsync(
					int rows, 
					int start, 
					bool facet, 
					string[] facet_fields, 
					bool unselect_evidence, 
					bool exclude_automatic_assertions, 
					bool fetch_objects, 
					bool use_compact_associations, 
					string[] slim, 
					string evidence, 
					bool direct, 
					string[] taxon, 
					bool direct_taxon, 
					string relation, 
					string sort, 
					string q, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/{id}/associations?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&direct_taxon="+direct_taxon+"&relation=" + (relation==null? "" : System.Uri.EscapeDataString(relation))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return basic info on an object for a given type
		/// Get_generic_object_by_type bioentity/{type}/{id}
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <param name="facet">Enable faceting</param>
		/// <param name="facet_fields">Fields to facet on</param>
		/// <param name="unselect_evidence">If true, excludes evidence objects in response</param>
		/// <param name="exclude_automatic_assertions">If true, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="fetch_objects">If true, returns a distinct set of association.objects (typically ontology terms). This appears at the top level of the results payload</param>
		/// <param name="use_compact_associations">If true, returns results in compact associations format</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default) or a specific publication or other supporting object, e.g. ZFIN:ZDB-PUB-060503-2</param>
		/// <param name="direct">Set true to only include direct associations, and false to include inferred (via subclass or subclass|part of), default=False</param>
		/// <param name="get_association_counts">Get association counts</param>
		/// <param name="distinct_counts">Get distinct counts for associations (to be used in conjunction with 'get_association_counts' parameter)</param>
		/// <returns>Success</returns>
		public async Task Get_generic_object_by_typeAsync(int rows, int start, bool facet, string[] facet_fields, bool unselect_evidence, bool exclude_automatic_assertions, bool fetch_objects, bool use_compact_associations, string[] slim, string evidence, bool direct, bool get_association_counts, bool distinct_counts, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentity/{type}/{id}?rows="+rows+"&start="+start+"&facet="+facet+"&"+string.Join("&", facet_fields.Select(z => $"facet_fields={System.Uri.EscapeDataString(z.ToString())}"))+"&unselect_evidence="+unselect_evidence+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&fetch_objects="+fetch_objects+"&use_compact_associations="+use_compact_associations+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence))+"&direct="+direct+"&get_association_counts="+get_association_counts+"&distinct_counts="+distinct_counts;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns compact associations for a given input set
		/// Get_entity_set_associations bioentityset/associations
		/// </summary>
		/// <param name="subject">Entity ids to be examined, e.g. NCBIGene:9342, NCBIGene:7227, NCBIGene:8131, NCBIGene:157570, NCBIGene:51164, NCBIGene:6689, NCBIGene:6387</param>
		/// <param name="background">Entity ids in background set, e.g. NCBIGene:84570, NCBIGene:3630; used in over-representation tests</param>
		/// <param name="object_category">E.g. phenotype, function</param>
		/// <param name="object_slim">Slim or subset to which the descriptors are to be mapped, NOT IMPLEMENTED</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults[]> Get_entity_set_associationsAsync(string[] subject, string[] background, string object_category, string object_slim, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentityset/associations?"+string.Join("&", subject.Select(z => $"subject={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", background.Select(z => $"background={System.Uri.EscapeDataString(z.ToString())}"))+"&object_category=" + (object_category==null? "" : System.Uri.EscapeDataString(object_category))+"&object_slim=" + (object_slim==null? "" : System.Uri.EscapeDataString(object_slim));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Summary statistics for objects associated
		/// Get_entity_set_summary bioentityset/descriptor/counts
		/// </summary>
		/// <param name="subject">Entity ids to be examined, e.g. NCBIGene:9342, NCBIGene:7227, NCBIGene:8131, NCBIGene:157570, NCBIGene:51164, NCBIGene:6689, NCBIGene:6387</param>
		/// <param name="background">Entity ids in background set, e.g. NCBIGene:84570, NCBIGene:3630; used in over-representation tests</param>
		/// <param name="object_category">E.g. phenotype, function</param>
		/// <param name="object_slim">Slim or subset to which the descriptors are to be mapped, NOT IMPLEMENTED</param>
		/// <returns>Success</returns>
		public async Task Get_entity_set_summaryAsync(string[] subject, string[] background, string object_category, string object_slim, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentityset/descriptor/counts?"+string.Join("&", subject.Select(z => $"subject={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", background.Select(z => $"background={System.Uri.EscapeDataString(z.ToString())}"))+"&object_category=" + (object_category==null? "" : System.Uri.EscapeDataString(object_category))+"&object_slim=" + (object_slim==null? "" : System.Uri.EscapeDataString(object_slim));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// TODO Graph object spanning all entities
		/// Get_entity_set_graph_resource bioentityset/graph
		/// </summary>
		/// <param name="subject">Entity ids to be examined, e.g. NCBIGene:9342, NCBIGene:7227, NCBIGene:8131, NCBIGene:157570, NCBIGene:51164, NCBIGene:6689, NCBIGene:6387</param>
		/// <param name="background">Entity ids in background set, e.g. NCBIGene:84570, NCBIGene:3630; used in over-representation tests</param>
		/// <param name="object_category">E.g. phenotype, function</param>
		/// <param name="object_slim">Slim or subset to which the descriptors are to be mapped, NOT IMPLEMENTED</param>
		/// <returns>Success</returns>
		public async Task Get_entity_set_graph_resourceAsync(string[] subject, string[] background, string object_category, string object_slim, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentityset/graph?"+string.Join("&", subject.Select(z => $"subject={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", background.Select(z => $"background={System.Uri.EscapeDataString(z.ToString())}"))+"&object_category=" + (object_category==null? "" : System.Uri.EscapeDataString(object_category))+"&object_slim=" + (object_slim==null? "" : System.Uri.EscapeDataString(object_slim));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns homology associations for a given input set of genes
		/// Get_entity_set_homologs bioentityset/homologs/
		/// </summary>
		/// <param name="subject">Entity ids to be examined, e.g. NCBIGene:9342, NCBIGene:7227, NCBIGene:8131, NCBIGene:157570, NCBIGene:51164, NCBIGene:6689, NCBIGene:6387</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults[]> Get_entity_set_homologsAsync(string[] subject, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentityset/homologs/?"+string.Join("&", subject.Select(z => $"subject={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Summary statistics for objects associated
		/// Get_over_representation bioentityset/overrepresentation
		/// </summary>
		/// <param name="object_category">E.g. phenotype, function</param>
		/// <param name="subject">Entity ids to be examined, e.g. NCBIGene:9342, NCBIGene:7227, NCBIGene:8131, NCBIGene:157570, NCBIGene:51164, NCBIGene:6689, NCBIGene:6387</param>
		/// <param name="background">Entity ids in background set, e.g. NCBIGene:84570, NCBIGene:3630; used in over-representation tests</param>
		/// <param name="subject_category">Default: gene. Other types may be used e.g. disease but statistics may not make sense</param>
		/// <param name="max_p_value">Exclude results with p-value greater than this</param>
		/// <param name="ontology">ontology id. Must be obo id. Examples: go, mp, hp, uberon (optional: will be inferred if left blank)</param>
		/// <param name="taxon">must be NCBITaxon CURIE. Example: NCBITaxon:9606</param>
		/// <returns>Success</returns>
		public async Task Get_over_representationAsync(string object_category, string[] subject, string[] background, string subject_category, string max_p_value, string ontology, string taxon, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentityset/overrepresentation?object_category=" + (object_category==null? "" : System.Uri.EscapeDataString(object_category))+"&"+string.Join("&", subject.Select(z => $"subject={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", background.Select(z => $"background={System.Uri.EscapeDataString(z.ToString())}"))+"&subject_category=" + (subject_category==null? "" : System.Uri.EscapeDataString(subject_category))+"&max_p_value=" + (max_p_value==null? "" : System.Uri.EscapeDataString(max_p_value))+"&ontology=" + (ontology==null? "" : System.Uri.EscapeDataString(ontology))+"&taxon=" + (taxon==null? "" : System.Uri.EscapeDataString(taxon));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// For a given gene(s), summarize its annotations over a defined set of slim
		/// Get_entity_set_anatomy_slimmer bioentityset/slimmer/anatomy
		/// </summary>
		/// <param name="subject">Entity ids to be examined, e.g. NCBIGene:9342, NCBIGene:7227, NCBIGene:8131, NCBIGene:157570, NCBIGene:51164, NCBIGene:6689, NCBIGene:6387</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID (IMPLEMENTED) or subset ID (TODO)</param>
		/// <param name="exclude_automatic_assertions">If set, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <returns>Success</returns>
		public async Task Get_entity_set_anatomy_slimmerAsync(string[] subject, string[] slim, bool exclude_automatic_assertions, int rows, int start, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentityset/slimmer/anatomy?"+string.Join("&", subject.Select(z => $"subject={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&rows="+rows+"&start="+start;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// For a given gene(s), summarize its annotations over a defined set of slim
		/// Get_entity_set_function_slimmer bioentityset/slimmer/function
		/// </summary>
		/// <param name="relationship_type">relationship type ('involved_in' or 'acts_upstream_of_or_within')</param>
		/// <param name="subject">Entity ids to be examined, e.g. NCBIGene:9342, NCBIGene:7227, NCBIGene:8131, NCBIGene:157570, NCBIGene:51164, NCBIGene:6689, NCBIGene:6387</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID (IMPLEMENTED) or subset ID (TODO)</param>
		/// <param name="exclude_automatic_assertions">If set, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <returns>Success</returns>
		public async Task Get_entity_set_function_slimmerAsync(Get_entity_set_function_slimmerRelationship_type relationship_type, string[] subject, string[] slim, bool exclude_automatic_assertions, int rows, int start, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentityset/slimmer/function?relationship_type=" + relationship_type+"&"+string.Join("&", subject.Select(z => $"subject={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&rows="+rows+"&start="+start;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// For a given gene(s), summarize its annotations over a defined set of slim
		/// Get_entity_set_phenotype_slimmer bioentityset/slimmer/phenotype
		/// </summary>
		/// <param name="subject">Entity ids to be examined, e.g. NCBIGene:9342, NCBIGene:7227, NCBIGene:8131, NCBIGene:157570, NCBIGene:51164, NCBIGene:6689, NCBIGene:6387</param>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID (IMPLEMENTED) or subset ID (TODO)</param>
		/// <param name="exclude_automatic_assertions">If set, excludes associations that involve IEAs (ECO:0000501)</param>
		/// <param name="rows">number of rows</param>
		/// <param name="start">beginning row</param>
		/// <returns>Success</returns>
		public async Task Get_entity_set_phenotype_slimmerAsync(string[] subject, string[] slim, bool exclude_automatic_assertions, int rows, int start, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "bioentityset/slimmer/phenotype?"+string.Join("&", subject.Select(z => $"subject={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"))+"&exclude_automatic_assertions="+exclude_automatic_assertions+"&rows="+rows+"&start="+start;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of models
		/// Get_activity_collection cam/activity
		/// </summary>
		/// <param name="title">string to search for in title of model</param>
		/// <param name="contributor">string to search for in contributor of model</param>
		/// <returns>Success</returns>
		public async Task Get_activity_collectionAsync(string title, string contributor, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cam/activity?title=" + (title==null? "" : System.Uri.EscapeDataString(title))+"&contributor=" + (contributor==null? "" : System.Uri.EscapeDataString(contributor));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of matches
		/// Get_instance_object cam/instance/{id}
		/// </summary>
		/// <param name="title">string to search for in title of model</param>
		/// <param name="contributor">string to search for in contributor of model</param>
		/// <returns>Success</returns>
		public async Task<Association[]> Get_instance_objectAsync(string title, string contributor, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cam/instance/{id}?title=" + (title==null? "" : System.Uri.EscapeDataString(title))+"&contributor=" + (contributor==null? "" : System.Uri.EscapeDataString(contributor));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Association[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of all instances
		/// Get_model_instances cam/instances
		/// </summary>
		/// <returns>Success</returns>
		public async Task Get_model_instancesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cam/instances";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of ALL models
		/// Get_model_collection cam/model
		/// </summary>
		/// <returns>Success</returns>
		public async Task Get_model_collectionAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cam/model";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of all contributors across all models
		/// Get_model_contributors cam/model/contributors
		/// </summary>
		/// <returns>Success</returns>
		public async Task Get_model_contributorsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cam/model/contributors";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of all properties used across all models
		/// Get_model_properties cam/model/properties
		/// </summary>
		/// <param name="title">string to search for in title of model</param>
		/// <param name="contributor">string to search for in contributor of model</param>
		/// <returns>Success</returns>
		public async Task Get_model_propertiesAsync(string title, string contributor, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cam/model/properties?title=" + (title==null? "" : System.Uri.EscapeDataString(title))+"&contributor=" + (contributor==null? "" : System.Uri.EscapeDataString(contributor));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list property-values for all models
		/// Get_model_property_values cam/model/property_values
		/// </summary>
		/// <param name="title">string to search for in title of model</param>
		/// <param name="contributor">string to search for in contributor of model</param>
		/// <returns>Success</returns>
		public async Task Get_model_property_valuesAsync(string title, string contributor, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cam/model/property_values?title=" + (title==null? "" : System.Uri.EscapeDataString(title))+"&contributor=" + (contributor==null? "" : System.Uri.EscapeDataString(contributor));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of models matching query
		/// Get_model_query cam/model/query
		/// </summary>
		/// <param name="title">string to search for in title of model</param>
		/// <param name="contributor">string to search for in contributor of model</param>
		/// <returns>Success</returns>
		public async Task Get_model_queryAsync(string title, string contributor, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cam/model/query?title=" + (title==null? "" : System.Uri.EscapeDataString(title))+"&contributor=" + (contributor==null? "" : System.Uri.EscapeDataString(contributor));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns a complete model
		/// Get_model_object cam/model/{id}
		/// </summary>
		/// <returns>Success</returns>
		public async Task Get_model_objectAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cam/model/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of models
		/// Get_physical_interaction cam/physical_interaction
		/// </summary>
		/// <param name="title">string to search for in title of model</param>
		/// <param name="contributor">string to search for in contributor of model</param>
		/// <returns>Success</returns>
		public async Task Get_physical_interactionAsync(string title, string contributor, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cam/physical_interaction?title=" + (title==null? "" : System.Uri.EscapeDataString(title))+"&contributor=" + (contributor==null? "" : System.Uri.EscapeDataString(contributor));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns evidence graph object for a given association
		/// Note that every association is assumed to have a unique ID
		/// Get_evidence_graph_object evidence/graph/{id}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Graph[]> Get_evidence_graph_objectAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "evidence/graph/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Graph[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns evidence as a association_results object given an association
		/// Note that every association is assumed to have a unique ID
		/// Get_evidence_graph_table evidence/graph/{id}/table
		/// </summary>
		/// <param name="is_publication">If true, considers dc:source as edge</param>
		/// <returns>Success</returns>
		public async Task<AssociationResults[]> Get_evidence_graph_tableAsync(bool is_publication, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "evidence/graph/{id}/table?is_publication="+is_publication;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of matches
		/// Get_features_within_resource genome/features/within/{build}/{reference}/{begin}/{end}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<SequenceFeature[]> Get_features_within_resourceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "genome/features/within/{build}/{reference}/{begin}/{end}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<SequenceFeature[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns edges emanating from a given node
		/// Get_edge_resource graph/edges/from/{id}
		/// </summary>
		/// <param name="depth">How far to traverse for neighbors</param>
		/// <param name="direction">Which direction to traverse (used only if relationship_type is defined)</param>
		/// <param name="relationship_type">Relationship type to traverse</param>
		/// <param name="entail">Include sub-properties and equivalent properties</param>
		/// <param name="graph">Which monarch graph to query</param>
		/// <returns>Success</returns>
		public async Task<Graph[]> Get_edge_resourceAsync(int depth, Get_edge_resourceDirection direction, string[] relationship_type, bool entail, Get_edge_resourceGraph graph, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "graph/edges/from/{id}?depth="+depth+"&direction=" + direction+"&"+string.Join("&", relationship_type.Select(z => $"relationship_type={System.Uri.EscapeDataString(z.ToString())}"))+"&entail="+entail+"&graph=" + graph;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Graph[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns a graph node
		/// A node is an abstract representation of some kind of entity. The entity may be a physical thing such as a patient,
		/// a molecular entity such as a gene or protein, or a conceptual entity such as a class from an ontology.
		/// Get_node_resource graph/node/{id}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<BioObject[]> Get_node_resourceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "graph/node/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<BioObject[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// TODO maps a list of identifiers from a source to a target
		/// Get_identifier_mapper identifier/mapper/{source}/{target}/
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Association[]> Get_identifier_mapperAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "identifier/mapper/{source}/{target}/";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Association[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of prefixes
		/// Get_prefix_collection identifier/prefixes/
		/// </summary>
		/// <returns>Success</returns>
		public async Task Get_prefix_collectionAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "identifier/prefixes/";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns contracted URI
		/// Get_prefix_contract identifier/prefixes/contract/{uri}
		/// </summary>
		/// <returns>Success</returns>
		public async Task Get_prefix_contractAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "identifier/prefixes/contract/{uri}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns expanded URI
		/// Get_prefix_expand identifier/prefixes/expand/{id}
		/// </summary>
		/// <returns>Success</returns>
		public async Task Get_prefix_expandAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "identifier/prefixes/expand/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of matches
		/// Get_pedigree individual/pedigree/{id}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Association[]> Get_pedigreeAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "individual/pedigree/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Association[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of matches
		/// Get_individual individual/{id}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Association[]> Get_individualAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "individual/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Association[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Bulk download of case associations
		/// NOTE: this route has a limiter on it, you may be restricted in the number of downloads per hour. Use carefully.
		/// Get_mart_case_associations_resource mart/case/{object_category}/{taxon}
		/// </summary>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <returns>Success</returns>
		public async Task Get_mart_case_associations_resourceAsync(string[] slim, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mart/case/{object_category}/{taxon}?"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Bulk download of disease associations
		/// NOTE: this route has a limiter on it, you may be restricted in the number of downloads per hour. Use carefully.
		/// Get_mart_disease_associations_resource mart/disease/{object_category}/{taxon}
		/// </summary>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <returns>Success</returns>
		public async Task Get_mart_disease_associations_resourceAsync(string[] slim, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mart/disease/{object_category}/{taxon}?"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Bulk download of gene associations
		/// NOTE: this route has a limiter on it, you may be restricted in the number of downloads per hour. Use carefully.
		/// Get_mart_gene_associations_resource mart/gene/{object_category}/{taxon}
		/// </summary>
		/// <param name="slim">Map objects up (slim) to a higher level category. Value can be ontology class ID or subset ID</param>
		/// <returns>Success</returns>
		public async Task Get_mart_gene_associations_resourceAsync(string[] slim, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mart/gene/{object_category}/{taxon}?"+string.Join("&", slim.Select(z => $"slim={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Bulk download of orthologs
		/// Get_mart_ortholog_associations_resource mart/ortholog/{taxon1}/{taxon2}
		/// </summary>
		/// <returns>Success</returns>
		public async Task Get_mart_ortholog_associations_resourceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mart/ortholog/{taxon1}/{taxon2}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Bulk download of paralogs
		/// Get_mart_paralog_associations_resource mart/paralog/{taxon1}/{taxon2}
		/// </summary>
		/// <returns>Success</returns>
		public async Task Get_mart_paralog_associations_resourceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mart/paralog/{taxon1}/{taxon2}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get metadata for all datasets from SciGraph
		/// Get_metadata_for_datasets metadata/datasets
		/// </summary>
		/// <returns>Success</returns>
		public async Task Get_metadata_for_datasetsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "metadata/datasets";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Match a patient to diseases based on their phenotypes
		/// Post_disease_mme mme/disease
		/// </summary>
		/// <returns>Success</returns>
		public async Task Post_disease_mmeAsync(Mme requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mme/disease";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Match a patient to fruit fly genes based on similar phenotypes
		/// Post_fly_mme mme/fly
		/// </summary>
		/// <returns>Success</returns>
		public async Task Post_fly_mmeAsync(Mme requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mme/fly";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Match a patient to mouse genes based on similar phenotypes
		/// Post_mouse_mme mme/mouse
		/// </summary>
		/// <returns>Success</returns>
		public async Task Post_mouse_mmeAsync(Mme requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mme/mouse";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Match a patient to nematode genes based on similar phenotypes
		/// Post_nematode_mme mme/nematode
		/// </summary>
		/// <returns>Success</returns>
		public async Task Post_nematode_mmeAsync(Mme requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mme/nematode";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Match a patient to zebrafish genes based on similar phenotypes
		/// Post_zebrafish_mme mme/zebrafish
		/// </summary>
		/// <returns>Success</returns>
		public async Task Post_zebrafish_mmeAsync(Mme requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "mme/zebrafish";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Annotate a given text using SciGraph annotator
		/// Get_annotate nlp/annotate/
		/// </summary>
		/// <param name="content">The text content to annotate</param>
		/// <param name="include_category">Categories to include for annotation</param>
		/// <param name="exclude_category">Categories to exclude for annotation</param>
		/// <param name="min_length">The minimum number of characters in the annotated entity</param>
		/// <param name="longest_only">Should only the longest entity be returned for an overlapping group</param>
		/// <param name="include_abbreviation">Should abbreviations be included</param>
		/// <param name="include_acronym">Should acronyms be included</param>
		/// <param name="include_numbers">Should numbers be included</param>
		/// <returns>Success</returns>
		public async Task Get_annotateAsync(string content, string[] include_category, string[] exclude_category, string min_length, bool longest_only, bool include_abbreviation, bool include_acronym, bool include_numbers, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nlp/annotate/?content=" + (content==null? "" : System.Uri.EscapeDataString(content))+"&"+string.Join("&", include_category.Select(z => $"include_category={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", exclude_category.Select(z => $"exclude_category={System.Uri.EscapeDataString(z.ToString())}"))+"&min_length=" + (min_length==null? "" : System.Uri.EscapeDataString(min_length))+"&longest_only="+longest_only+"&include_abbreviation="+include_abbreviation+"&include_acronym="+include_acronym+"&include_numbers="+include_numbers;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Annotate a given text using SciGraph annotator
		/// Post_annotate nlp/annotate/
		/// </summary>
		/// <param name="content">The text content to annotate</param>
		/// <param name="include_category">Categories to include for annotation</param>
		/// <param name="exclude_category">Categories to exclude for annotation</param>
		/// <param name="min_length">The minimum number of characters in the annotated entity</param>
		/// <param name="longest_only">Should only the longest entity be returned for an overlapping group</param>
		/// <param name="include_abbreviation">Should abbreviations be included</param>
		/// <param name="include_acronym">Should acronyms be included</param>
		/// <param name="include_numbers">Should numbers be included</param>
		/// <returns>Success</returns>
		public async Task Post_annotateAsync(string content, string[] include_category, string[] exclude_category, string min_length, bool longest_only, bool include_abbreviation, bool include_acronym, bool include_numbers, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nlp/annotate/?content=" + (content==null? "" : System.Uri.EscapeDataString(content))+"&"+string.Join("&", include_category.Select(z => $"include_category={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", exclude_category.Select(z => $"exclude_category={System.Uri.EscapeDataString(z.ToString())}"))+"&min_length=" + (min_length==null? "" : System.Uri.EscapeDataString(min_length))+"&longest_only="+longest_only+"&include_abbreviation="+include_abbreviation+"&include_acronym="+include_acronym+"&include_numbers="+include_numbers;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Annotate a given content using SciGraph annotator and get all entities from content
		/// Get_annotate_entities nlp/annotate/entities
		/// </summary>
		/// <param name="content">The text content to annotate</param>
		/// <param name="include_category">Categories to include for annotation</param>
		/// <param name="exclude_category">Categories to exclude for annotation</param>
		/// <param name="min_length">The minimum number of characters in the annotated entity</param>
		/// <param name="longest_only">Should only the longest entity be returned for an overlapping group</param>
		/// <param name="include_abbreviation">Should abbreviations be included</param>
		/// <param name="include_acronym">Should acronyms be included</param>
		/// <param name="include_numbers">Should numbers be included</param>
		/// <returns>Success</returns>
		public async Task<EntityAnnotationResult> Get_annotate_entitiesAsync(string content, string[] include_category, string[] exclude_category, string min_length, bool longest_only, bool include_abbreviation, bool include_acronym, bool include_numbers, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nlp/annotate/entities?content=" + (content==null? "" : System.Uri.EscapeDataString(content))+"&"+string.Join("&", include_category.Select(z => $"include_category={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", exclude_category.Select(z => $"exclude_category={System.Uri.EscapeDataString(z.ToString())}"))+"&min_length=" + (min_length==null? "" : System.Uri.EscapeDataString(min_length))+"&longest_only="+longest_only+"&include_abbreviation="+include_abbreviation+"&include_acronym="+include_acronym+"&include_numbers="+include_numbers;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<EntityAnnotationResult>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Annotate a given content using SciGraph annotator and get all entities from content
		/// Post_annotate_entities nlp/annotate/entities
		/// </summary>
		/// <param name="content">The text content to annotate</param>
		/// <param name="include_category">Categories to include for annotation</param>
		/// <param name="exclude_category">Categories to exclude for annotation</param>
		/// <param name="min_length">The minimum number of characters in the annotated entity</param>
		/// <param name="longest_only">Should only the longest entity be returned for an overlapping group</param>
		/// <param name="include_abbreviation">Should abbreviations be included</param>
		/// <param name="include_acronym">Should acronyms be included</param>
		/// <param name="include_numbers">Should numbers be included</param>
		/// <returns>Success</returns>
		public async Task<EntityAnnotationResult> Post_annotate_entitiesAsync(string content, string[] include_category, string[] exclude_category, string min_length, bool longest_only, bool include_abbreviation, bool include_acronym, bool include_numbers, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "nlp/annotate/entities?content=" + (content==null? "" : System.Uri.EscapeDataString(content))+"&"+string.Join("&", include_category.Select(z => $"include_category={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", exclude_category.Select(z => $"exclude_category={System.Uri.EscapeDataString(z.ToString())}"))+"&min_length=" + (min_length==null? "" : System.Uri.EscapeDataString(min_length))+"&longest_only="+longest_only+"&include_abbreviation="+include_abbreviation+"&include_acronym="+include_acronym+"&include_numbers="+include_numbers;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<EntityAnnotationResult>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Fetches a map from CURIEs/IDs to labels
		/// Get_ontol_identifier_resource ontol/identifier/
		/// </summary>
		/// <param name="label">List of labels</param>
		/// <returns>Success</returns>
		public async Task Get_ontol_identifier_resourceAsync(string[] label, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ontol/identifier/?"+string.Join("&", label.Select(z => $"label={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Fetches a map from CURIEs/IDs to labels
		/// Takes 'label' list argument either as a querystring argument or as a key
		/// in the POST body when content-type is application/json.
		/// Post_ontol_identifier_resource ontol/identifier/
		/// </summary>
		/// <param name="label">List of labels</param>
		/// <returns>Success</returns>
		public async Task Post_ontol_identifier_resourceAsync(string[] label, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ontol/identifier/?"+string.Join("&", label.Select(z => $"label={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns information content (IC) for a set of relevant ontology classes
		/// ```
		/// IC = -log2( freq(t) / popSize )
		/// ```
		/// 
		/// Here the frequency and population is calculated for a particular dataset:
		/// e.g. all human disease-phenotype associations
		/// Get_information_content_resource ontol/information_content/{subject_category}/{object_category}/{subject_taxon}
		/// </summary>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)
		///                    or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.
		///                    </param>
		/// <returns>Success</returns>
		public async Task Get_information_content_resourceAsync(string evidence, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ontol/information_content/{subject_category}/{object_category}/{subject_taxon}?evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Fetches a map from CURIEs/IDs to labels
		/// Get_ontol_labeler_resource ontol/labeler/
		/// </summary>
		/// <param name="id">List of ids</param>
		/// <returns>Success</returns>
		public async Task Get_ontol_labeler_resourceAsync(string[] id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ontol/labeler/?"+string.Join("&", id.Select(z => $"id={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Extract a subgraph from an ontology
		/// Get_extract_ontology_subgraph_resource ontol/subgraph/{ontology}/{node}
		/// </summary>
		/// <param name="cnode">Additional classes</param>
		/// <param name="include_ancestors">Include Ancestors</param>
		/// <param name="include_descendants">Include Descendants</param>
		/// <param name="relation">Additional classes</param>
		/// <param name="include_meta">Include metadata in response</param>
		/// <returns>Success</returns>
		public async Task Get_extract_ontology_subgraph_resourceAsync(string[] cnode, bool include_ancestors, bool include_descendants, string[] relation, bool include_meta, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ontol/subgraph/{ontology}/{node}?"+string.Join("&", cnode.Select(z => $"cnode={System.Uri.EscapeDataString(z.ToString())}"))+"&include_ancestors="+include_ancestors+"&include_descendants="+include_descendants+"&"+string.Join("&", relation.Select(z => $"relation={System.Uri.EscapeDataString(z.ToString())}"))+"&include_meta="+include_meta;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Extract a subgraph from an ontology
		/// Post_extract_ontology_subgraph_resource ontol/subgraph/{ontology}/{node}
		/// </summary>
		/// <param name="cnode">Additional classes</param>
		/// <param name="include_ancestors">Include Ancestors</param>
		/// <param name="include_descendants">Include Descendants</param>
		/// <param name="relation">Additional classes</param>
		/// <param name="include_meta">Include metadata in response</param>
		/// <returns>Success</returns>
		public async Task Post_extract_ontology_subgraph_resourceAsync(string[] cnode, bool include_ancestors, bool include_descendants, string[] relation, bool include_meta, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ontol/subgraph/{ontology}/{node}?"+string.Join("&", cnode.Select(z => $"cnode={System.Uri.EscapeDataString(z.ToString())}"))+"&include_ancestors="+include_ancestors+"&include_descendants="+include_descendants+"&"+string.Join("&", relation.Select(z => $"relation={System.Uri.EscapeDataString(z.ToString())}"))+"&include_meta="+include_meta;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns the ancestor ontology terms shared by two ontology terms
		/// Get_ontology_terms_shared_ancestor ontology/shared/{subject}/{object}
		/// </summary>
		/// <returns>Success</returns>
		public async Task Get_ontology_terms_shared_ancestorAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ontology/shared/{subject}/{object}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns meta data of an ontology subset (slim)
		/// Get_ontology_subset ontology/subset/{id}
		/// </summary>
		/// <returns>Success</returns>
		public async Task Get_ontology_subsetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ontology/subset/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns meta data of an ontology term
		/// Get_ontology_term ontology/term/{id}
		/// </summary>
		/// <returns>Success</returns>
		public async Task Get_ontology_termAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ontology/term/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns graph of an ontology term
		/// Get_ontology_term_graph ontology/term/{id}/graph
		/// </summary>
		/// <param name="graph_type">graph type ('topology_graph', 'regulates_transitivity_graph' or 'neighborhood_graph')</param>
		/// <returns>Success</returns>
		public async Task Get_ontology_term_graphAsync(Get_ontology_term_graphGraph_type graph_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ontology/term/{id}/graph?graph_type=" + graph_type;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Extract a subgraph from an ontology term
		/// Get_ontology_term_subgraph ontology/term/{id}/subgraph
		/// </summary>
		/// <param name="cnode">Additional classes</param>
		/// <param name="include_ancestors">Include Ancestors</param>
		/// <param name="include_descendants">Include Descendants</param>
		/// <param name="relation">Additional classes</param>
		/// <param name="include_meta">Include metadata in response</param>
		/// <returns>Success</returns>
		public async Task Get_ontology_term_subgraphAsync(string[] cnode, bool include_ancestors, bool include_descendants, string[] relation, bool include_meta, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ontology/term/{id}/subgraph?"+string.Join("&", cnode.Select(z => $"cnode={System.Uri.EscapeDataString(z.ToString())}"))+"&include_ancestors="+include_ancestors+"&include_descendants="+include_descendants+"&"+string.Join("&", relation.Select(z => $"relation={System.Uri.EscapeDataString(z.ToString())}"))+"&include_meta="+include_meta;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns subsets (slims) associated to an ontology term
		/// Get_ontology_term_subsets ontology/term/{id}/subsets
		/// </summary>
		/// <returns>Success</returns>
		public async Task Get_ontology_term_subsetsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ontology/term/{id}/subsets";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Placeholder - use OWLery for now
		/// Get_dl_query owl/ontology/dlquery/{query}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Association[]> Get_dl_queryAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "owl/ontology/dlquery/{query}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Association[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Placeholder - use direct SPARQL endpoint for now
		/// Get_sparql_query owl/ontology/sparql/{query}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Association[]> Get_sparql_queryAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "owl/ontology/sparql/{query}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Association[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get pairwise similarity
		/// Get_pair_sim_jaccard_resource pair/sim/jaccard/{id1}/{id2}
		/// </summary>
		/// <param name="object_category">e.g. disease, phenotype, gene. Two subjects will be compared based on overlap between associations to objects in this category</param>
		/// <returns>Success</returns>
		public async Task Get_pair_sim_jaccard_resourceAsync(string object_category, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pair/sim/jaccard/{id1}/{id2}?object_category=" + (object_category==null? "" : System.Uri.EscapeDataString(object_category));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// All relations used plus count of associations
		/// Get_relation_usage_resource relation/usage/
		/// </summary>
		/// <param name="subject_taxon">SUBJECT TAXON id, e.g. NCBITaxon:9606. Includes inferred by default</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)
		///                    or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.
		///                    </param>
		/// <returns>Success</returns>
		public async Task<AssociationResults[]> Get_relation_usage_resourceAsync(string subject_taxon, string evidence, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "relation/usage/?subject_taxon=" + (subject_taxon==null? "" : System.Uri.EscapeDataString(subject_taxon))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// All relations used plus count of associations
		/// Get_relation_usage_between_resource relation/usage/between/{subject_category}/{object_category}
		/// </summary>
		/// <param name="subject_taxon">SUBJECT TAXON id, e.g. NCBITaxon:9606. Includes inferred by default</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)
		///                    or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.
		///                    </param>
		/// <returns>Success</returns>
		public async Task<AssociationResults[]> Get_relation_usage_between_resourceAsync(string subject_taxon, string evidence, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "relation/usage/between/{subject_category}/{object_category}?subject_taxon=" + (subject_taxon==null? "" : System.Uri.EscapeDataString(subject_taxon))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Relation usage count for all subj x obj category combinations
		/// Get_relation_usage_pivot_resource relation/usage/pivot
		/// </summary>
		/// <param name="subject_taxon">SUBJECT TAXON id, e.g. NCBITaxon:9606. Includes inferred by default</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)
		///                    or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.
		///                    </param>
		/// <returns>Success</returns>
		public async Task<AssociationResults[]> Get_relation_usage_pivot_resourceAsync(string subject_taxon, string evidence, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "relation/usage/pivot?subject_taxon=" + (subject_taxon==null? "" : System.Uri.EscapeDataString(subject_taxon))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Relation usage count for all subj x obj category combinations, showing label
		/// Get_relation_usage_pivot_label_resource relation/usage/pivot/label
		/// </summary>
		/// <param name="subject_taxon">SUBJECT TAXON id, e.g. NCBITaxon:9606. Includes inferred by default</param>
		/// <param name="evidence">Object id, e.g. ECO:0000501 (for IEA; Includes inferred by default)
		///                    or a specific publication or other supporting ibject, e.g. ZFIN:ZDB-PUB-060503-2.
		///                    </param>
		/// <returns>Success</returns>
		public async Task<AssociationResults[]> Get_relation_usage_pivot_label_resourceAsync(string subject_taxon, string evidence, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "relation/usage/pivot/label?subject_taxon=" + (subject_taxon==null? "" : System.Uri.EscapeDataString(subject_taxon))+"&evidence=" + (evidence==null? "" : System.Uri.EscapeDataString(evidence));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AssociationResults[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of matching concepts or entities using lexical search
		/// Get_autocomplete search/entity/autocomplete/{term}
		/// </summary>
		/// <param name="fq">fq string passed directly to solr, note that multiple filters will be combined with an AND operator. Combining fq_string with other parameters may result in unexpected behavior.</param>
		/// <param name="category">e.g. gene, disease</param>
		/// <param name="prefix">ontology prefix: HP, -MONDO</param>
		/// <param name="include_eqs">Include equivalent ids in prefix filter</param>
		/// <param name="boost_fx">boost function e.g. pow(edges,0.334)</param>
		/// <param name="boost_q">boost query e.g. category:genotype^-10</param>
		/// <param name="taxon">taxon filter, eg NCBITaxon:9606, includes inferred taxa</param>
		/// <param name="rows">number of rows</param>
		/// <param name="start">row number to start from</param>
		/// <param name="highlight_class">highlight class</param>
		/// <param name="min_match">minimum should match parameter, see solr docs for details</param>
		/// <param name="exclude_groups">Exclude grouping classes (classes with subclasses)</param>
		/// <param name="minimal_tokenizer">set to true to use the minimal tokenizer, good for variants and genotypes</param>
		/// <returns>Success</returns>
		public async Task<AutocompleteResults> Get_autocompleteAsync(string[] fq, string[] category, string[] prefix, bool include_eqs, string[] boost_fx, string[] boost_q, string[] taxon, int rows, string start, string highlight_class, string min_match, bool exclude_groups, bool minimal_tokenizer, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "search/entity/autocomplete/{term}?"+string.Join("&", fq.Select(z => $"fq={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", category.Select(z => $"category={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", prefix.Select(z => $"prefix={System.Uri.EscapeDataString(z.ToString())}"))+"&include_eqs="+include_eqs+"&"+string.Join("&", boost_fx.Select(z => $"boost_fx={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", boost_q.Select(z => $"boost_q={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&rows="+rows+"&start=" + (start==null? "" : System.Uri.EscapeDataString(start))+"&highlight_class=" + (highlight_class==null? "" : System.Uri.EscapeDataString(highlight_class))+"&min_match=" + (min_match==null? "" : System.Uri.EscapeDataString(min_match))+"&exclude_groups="+exclude_groups+"&minimal_tokenizer="+minimal_tokenizer;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AutocompleteResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of matching concepts or entities using lexical search
		/// Get_search_hpo_entities search/entity/hpo-pl/{term}
		/// </summary>
		/// <param name="rows">number of rows</param>
		/// <param name="start">row number to start from</param>
		/// <param name="phenotype_group">phenotype group id</param>
		/// <param name="phenotype_group_label">phenotype group label</param>
		/// <param name="anatomical_system">anatomical system id</param>
		/// <param name="anatomical_system_label">anatomical system label</param>
		/// <param name="highlight_class">highlight class</param>
		/// <returns>Success</returns>
		public async Task<LayResults> Get_search_hpo_entitiesAsync(int rows, string start, string phenotype_group, string phenotype_group_label, string anatomical_system, string anatomical_system_label, string highlight_class, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "search/entity/hpo-pl/{term}?rows="+rows+"&start=" + (start==null? "" : System.Uri.EscapeDataString(start))+"&phenotype_group=" + (phenotype_group==null? "" : System.Uri.EscapeDataString(phenotype_group))+"&phenotype_group_label=" + (phenotype_group_label==null? "" : System.Uri.EscapeDataString(phenotype_group_label))+"&anatomical_system=" + (anatomical_system==null? "" : System.Uri.EscapeDataString(anatomical_system))+"&anatomical_system_label=" + (anatomical_system_label==null? "" : System.Uri.EscapeDataString(anatomical_system_label))+"&highlight_class=" + (highlight_class==null? "" : System.Uri.EscapeDataString(highlight_class));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<LayResults>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of matching concepts or entities using lexical search
		/// Get_search_entities search/entity/{term}
		/// </summary>
		/// <param name="fq">fq string passed directly to solr, note that multiple filters will be combined with an AND operator. Combining fq_string with other parameters may result in unexpected behavior.</param>
		/// <param name="category">e.g. gene, disease</param>
		/// <param name="prefix">ontology prefix: HP, -MONDO</param>
		/// <param name="include_eqs">Include equivalent ids in prefix filter</param>
		/// <param name="boost_fx">boost function e.g. pow(edges,0.334)</param>
		/// <param name="boost_q">boost query e.g. category:genotype^-10</param>
		/// <param name="taxon">taxon filter, eg NCBITaxon:9606, includes inferred taxa</param>
		/// <param name="rows">number of rows</param>
		/// <param name="start">row number to start from</param>
		/// <param name="highlight_class">highlight class</param>
		/// <param name="min_match">minimum should match parameter, see solr docs for details</param>
		/// <param name="exclude_groups">Exclude grouping classes (classes with subclasses)</param>
		/// <param name="minimal_tokenizer">set to true to use the minimal tokenizer, good for variants and genotypes</param>
		/// <returns>Success</returns>
		public async Task<SearchResult> Get_search_entitiesAsync(string[] fq, string[] category, string[] prefix, bool include_eqs, string[] boost_fx, string[] boost_q, string[] taxon, int rows, string start, string highlight_class, string min_match, bool exclude_groups, bool minimal_tokenizer, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "search/entity/{term}?"+string.Join("&", fq.Select(z => $"fq={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", category.Select(z => $"category={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", prefix.Select(z => $"prefix={System.Uri.EscapeDataString(z.ToString())}"))+"&include_eqs="+include_eqs+"&"+string.Join("&", boost_fx.Select(z => $"boost_fx={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", boost_q.Select(z => $"boost_q={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", taxon.Select(z => $"taxon={System.Uri.EscapeDataString(z.ToString())}"))+"&rows="+rows+"&start=" + (start==null? "" : System.Uri.EscapeDataString(start))+"&highlight_class=" + (highlight_class==null? "" : System.Uri.EscapeDataString(highlight_class))+"&min_match=" + (min_match==null? "" : System.Uri.EscapeDataString(min_match))+"&exclude_groups="+exclude_groups+"&minimal_tokenizer="+minimal_tokenizer;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<SearchResult>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Compare a reference profile vs one profiles
		/// Get_sim_compare sim/compare
		/// </summary>
		/// <param name="is_feature_set">set to true if *all* input ids are phenotypic features, else set to false</param>
		/// <param name="metric">Metric for computing similarity</param>
		/// <param name="ref_id">A phenotype or identifier that is composed of phenotypes (eg disease, gene)</param>
		/// <param name="query_id">A phenotype or identifier that is composed of phenotypes (eg disease, gene)</param>
		/// <returns>Success</returns>
		public async Task<SimResult> Get_sim_compareAsync(bool is_feature_set, Get_sim_compareMetric metric, string[] ref_id, string[] query_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sim/compare?is_feature_set="+is_feature_set+"&metric=" + metric+"&"+string.Join("&", ref_id.Select(z => $"ref_id={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", query_id.Select(z => $"query_id={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<SimResult>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Compare a reference profile vs one or more profiles
		/// Post_sim_compare sim/compare
		/// </summary>
		/// <returns>Success</returns>
		public async Task<SimResult> Post_sim_compareAsync(CompareInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sim/compare";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<SimResult>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get annotation score
		/// Get_annotation_score sim/score
		/// </summary>
		/// <param name="id">Phenotype identifier (eg HP:0004935)</param>
		/// <param name="absent_id">absent phenotype (eg HP:0002828)</param>
		/// <returns>Success</returns>
		public async Task<SufficiencyOutput> Get_annotation_scoreAsync(string[] id, string[] absent_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sim/score?"+string.Join("&", id.Select(z => $"id={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", absent_id.Select(z => $"absent_id={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<SufficiencyOutput>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get annotation score
		/// Post_annotation_score sim/score
		/// </summary>
		/// <returns>Success</returns>
		public async Task<SufficiencyOutput> Post_annotation_scoreAsync(SufficiencyPostInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sim/score";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<SufficiencyOutput>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Search for phenotypically similar diseases or model genes
		/// Get_sim_search sim/search
		/// </summary>
		/// <param name="is_feature_set">set to true if *all* input ids are phenotypic features, else set to false</param>
		/// <param name="metric">Metric for computing similarity</param>
		/// <param name="id">A phenotype or identifier that is composed of phenotypes (eg disease, gene)</param>
		/// <param name="limit">number of rows, max 500</param>
		/// <param name="taxon">ncbi taxon id</param>
		/// <returns>Success</returns>
		public async Task<SimResult> Get_sim_searchAsync(bool is_feature_set, Get_sim_compareMetric metric, string[] id, int limit, string taxon, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sim/search?is_feature_set="+is_feature_set+"&metric=" + metric+"&"+string.Join("&", id.Select(z => $"id={System.Uri.EscapeDataString(z.ToString())}"))+"&limit="+limit+"&taxon=" + (taxon==null? "" : System.Uri.EscapeDataString(taxon));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<SimResult>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of variant sets
		/// Get_variant_sets_collection variation/set/
		/// </summary>
		/// <param name="page">Page number</param>
		/// <param name="per_page">Results per page {error_msg}</param>
		/// <returns>Success</returns>
		public async Task<Page_of_variant_sets> Get_variant_sets_collectionAsync(int page, Get_variant_sets_collectionPer_page per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "variation/set/?page="+page+"&per_page="+per_page;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Page_of_variant_sets>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Creates a new variant set
		/// Post_variant_sets_collection variation/set/
		/// </summary>
		/// <returns>Success</returns>
		public async Task Post_variant_sets_collectionAsync(Variant_set requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "variation/set/";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of matches
		/// Get_variant_analyze variation/set/analyze/{id}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Association[]> Get_variant_analyzeAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "variation/set/analyze/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Association[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns list of variant sets from a specified time period
		/// Get_variant_sets_archive_collection variation/set/archive/{year}/{month}/{day}
		/// </summary>
		/// <param name="page">Page number</param>
		/// <param name="per_page">Results per page {error_msg}</param>
		/// <returns>Success</returns>
		public async Task<Page_of_variant_sets> Get_variant_sets_archive_collectionAsync(int page, Get_variant_sets_archive_collectionPer_page per_page, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "variation/set/archive/{year}/{month}/{day}?page="+page+"&per_page="+per_page;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Page_of_variant_sets>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Deletes variant set
		/// Delete_variant_set_item variation/set/{id}
		/// </summary>
		public async Task Delete_variant_set_itemAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "variation/set/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns a variant set
		/// Get_variant_set_item variation/set/{id}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Variant_set> Get_variant_set_itemAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "variation/set/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Variant_set>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates a variant set
		/// Put_variant_set_item variation/set/{id}
		/// </summary>
		public async Task Put_variant_set_itemAsync(Variant_set requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "variation/set/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
	}
	
	public enum Get_disease_gene_associationsAssociation_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		causal = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		non_causal = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		both = 2,
	}
	
	public enum Get_function_gene_associationsRelationship_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		involved_in = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		involved_in_regulation_of = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		acts_upstream_of_or_within = 2,
	}
	
	public enum Get_gene_homolog_associationsHomology_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		P = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		O = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LDO = 2,
	}
	
	public enum Get_entity_set_function_slimmerRelationship_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		involved_in = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		acts_upstream_of_or_within = 1,
	}
	
	public enum Get_edge_resourceDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INCOMING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OUTGOING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BOTH = 2,
	}
	
	public enum Get_edge_resourceGraph
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		data = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ontology = 1,
	}
	
	public enum Get_ontology_term_graphGraph_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		topology_graph = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		regulates_transitivity_graph = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		neighborhood_graph = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		neighborhood_limited_graph = 3,
	}
	
	public enum Get_sim_compareMetric
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		phenodigm = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		jaccard = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		simGIC = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		resnik = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		symmetric_resnik = 4,
	}
	
	public enum Get_variant_sets_collectionPer_page
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_10 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_20 = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_30 = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_40 = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_50 = 50,
	}
	
	public enum Get_variant_sets_archive_collectionPer_page
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_10 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_20 = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_30 = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_40 = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		_50 = 50,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
