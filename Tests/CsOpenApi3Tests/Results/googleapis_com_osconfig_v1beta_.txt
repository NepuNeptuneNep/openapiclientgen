//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Represents a single Apt package repository. This repository is added to a repo file that is stored at `/etc/apt/sources.list.d/google_osconfig.list`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AptRepository
	{
		
		/// <summary>
		/// Type of archive files in this repository. The default behavior is DEB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="archiveType")]
		public System.Nullable<AptRepositoryArchiveType> ArchiveType { get; set; }
		
		/// <summary>
		/// Required. List of components for this repository. Must contain at least one item.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="components")]
		public string[] Components { get; set; }
		
		/// <summary>
		/// Required. Distribution of this repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="distribution")]
		public string Distribution { get; set; }
		
		/// <summary>
		/// URI of the key file for this repository. The agent maintains a keyring at `/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg` containing all the keys in any applied guest policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gpgKey")]
		public string GpgKey { get; set; }
		
		/// <summary>
		/// Required. URI for this repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AptRepositoryArchiveType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ARCHIVE_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEB = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEB_SRC = 2,
	}
	
	/// <summary>
	/// Apt patching is completed by executing `apt-get update && apt-get upgrade`. Additional options can be set to control how this is executed.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AptSettings
	{
		
		/// <summary>
		/// List of packages to exclude from update. These packages will be excluded
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="excludes")]
		public string[] Excludes { get; set; }
		
		/// <summary>
		/// An exclusive list of packages to be updated. These are the only packages that will be updated. If these packages are not installed, they will be ignored. This field cannot be specified with any other patch configuration fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclusivePackages")]
		public string[] ExclusivePackages { get; set; }
		
		/// <summary>
		/// By changing the type to DIST, the patching is performed using `apt-get dist-upgrade` instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<AptSettingsType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AptSettingsType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DIST = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPGRADE = 2,
	}
	
	/// <summary>
	/// An assignment represents the group or groups of VM instances that the policy applies to. If an assignment is empty, it applies to all VM instances. Otherwise, the targeted VM instances must meet all the criteria specified. So if both labels and zones are specified, the policy applies to VM instances with those labels and in those zones.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Assignment
	{
		
		/// <summary>
		/// Targets instances matching at least one of these label sets. This allows an assignment to target disparate groups, for example "env=prod or env=staging".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupLabels")]
		public AssignmentGroupLabel[] GroupLabels { get; set; }
		
		/// <summary>
		/// Targets VM instances whose name starts with one of these prefixes. Like labels, this is another way to group VM instances when targeting configs, for example prefix="prod-". Only supported for project-level policies.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceNamePrefixes")]
		public string[] InstanceNamePrefixes { get; set; }
		
		/// <summary>
		/// Targets any of the instances specified. Instances are specified by their URI in the form `zones/[ZONE]/instances/[INSTANCE_NAME]`. Instance targeting is uncommon and is supported to facilitate the management of changes by the instance or to target specific VM instances for development and testing. Only supported for project-level policies and must reference instances within this project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public string[] Instances { get; set; }
		
		/// <summary>
		/// Targets VM instances matching at least one of the following OS types. VM instances must match all supplied criteria for a given OsType to be included.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osTypes")]
		public AssignmentOsType[] OsTypes { get; set; }
		
		/// <summary>
		/// Targets instances in any of these zones. Leave empty to target instances in any zone. Zonal targeting is uncommon and is supported to facilitate the management of changes by zone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zones")]
		public string[] Zones { get; set; }
	}
	
	/// <summary>
	/// Represents a group of VM intances that can be identified as having all these labels, for example "env=prod and app=web".
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AssignmentGroupLabel
	{
		
		/// <summary>
		/// Google Compute Engine instance labels that must be present for an instance to be included in this assignment group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
	}
	
	/// <summary>
	/// Defines the criteria for selecting VM Instances by OS type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AssignmentOsType
	{
		
		/// <summary>
		/// Targets VM instances with OS Inventory enabled and having the following OS architecture.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osArchitecture")]
		public string OsArchitecture { get; set; }
		
		/// <summary>
		/// Targets VM instances with OS Inventory enabled and having the following OS short name, for example "debian" or "windows".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osShortName")]
		public string OsShortName { get; set; }
		
		/// <summary>
		/// Targets VM instances with OS Inventory enabled and having the following following OS version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osVersion")]
		public string OsVersion { get; set; }
	}
	
	/// <summary>
	/// Message for canceling a patch job.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CancelPatchJobRequest
	{
	}
	
	/// <summary>
	/// The effective guest policy that applies to a VM instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class EffectiveGuestPolicy
	{
		
		/// <summary>
		/// List of package repository configurations assigned to the VM instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="packageRepositories")]
		public EffectiveGuestPolicySourcedPackageRepository[] PackageRepositories { get; set; }
		
		/// <summary>
		/// List of package configurations assigned to the VM instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="packages")]
		public EffectiveGuestPolicySourcedPackage[] Packages { get; set; }
		
		/// <summary>
		/// List of recipes assigned to the VM instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="softwareRecipes")]
		public EffectiveGuestPolicySourcedSoftwareRecipe[] SoftwareRecipes { get; set; }
	}
	
	/// <summary>
	/// A guest policy package repository including its source.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class EffectiveGuestPolicySourcedPackageRepository
	{
		
		/// <summary>
		/// A package repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="packageRepository")]
		public PackageRepository PackageRepository { get; set; }
		
		/// <summary>
		/// Name of the guest policy providing this config.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
	}
	
	/// <summary>
	/// A package repository.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PackageRepository
	{
		
		/// <summary>
		/// Represents a single Apt package repository. This repository is added to a repo file that is stored at `/etc/apt/sources.list.d/google_osconfig.list`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apt")]
		public AptRepository Apt { get; set; }
		
		/// <summary>
		/// Represents a Goo package repository. These is added to a repo file that is stored at C:/ProgramData/GooGet/repos/google_osconfig.repo.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="goo")]
		public GooRepository Goo { get; set; }
		
		/// <summary>
		/// Represents a single Yum package repository. This repository is added to a repo file that is stored at `/etc/yum.repos.d/google_osconfig.repo`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="yum")]
		public YumRepository Yum { get; set; }
		
		/// <summary>
		/// Represents a single Zypper package repository. This repository is added to a repo file that is stored at `/etc/zypp/repos.d/google_osconfig.repo`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zypper")]
		public ZypperRepository Zypper { get; set; }
	}
	
	/// <summary>
	/// Represents a Goo package repository. These is added to a repo file that is stored at C:/ProgramData/GooGet/repos/google_osconfig.repo.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GooRepository
	{
		
		/// <summary>
		/// Required. The name of the repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required. The url of the repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Represents a single Yum package repository. This repository is added to a repo file that is stored at `/etc/yum.repos.d/google_osconfig.repo`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class YumRepository
	{
		
		/// <summary>
		/// Required. The location of the repository directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="baseUrl")]
		public string BaseUrl { get; set; }
		
		/// <summary>
		/// The display name of the repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// URIs of GPG keys.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gpgKeys")]
		public string[] GpgKeys { get; set; }
		
		/// <summary>
		/// Required. A one word, unique name for this repository. This is the `repo id` in the Yum config file and also the `display_name` if `display_name` is omitted. This id is also used as the unique identifier when checking for guest policy conflicts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	/// <summary>
	/// Represents a single Zypper package repository. This repository is added to a repo file that is stored at `/etc/zypp/repos.d/google_osconfig.repo`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ZypperRepository
	{
		
		/// <summary>
		/// Required. The location of the repository directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="baseUrl")]
		public string BaseUrl { get; set; }
		
		/// <summary>
		/// The display name of the repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// URIs of GPG keys.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gpgKeys")]
		public string[] GpgKeys { get; set; }
		
		/// <summary>
		/// Required. A one word, unique name for this repository. This is the `repo id` in the zypper config file and also the `display_name` if `display_name` is omitted. This id is also used as the unique identifier when checking for guest policy conflicts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	/// <summary>
	/// A guest policy package including its source.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class EffectiveGuestPolicySourcedPackage
	{
		
		/// <summary>
		/// Package is a reference to the software package to be installed or removed. The agent on the VM instance uses the system package manager to apply the config. These are the commands that the agent uses to install or remove packages. Apt install: `apt-get update && apt-get -y install package1 package2 package3` remove: `apt-get -y remove package1 package2 package3` Yum install: `yum -y install package1 package2 package3` remove: `yum -y remove package1 package2 package3` Zypper install: `zypper install package1 package2 package3` remove: `zypper rm package1 package2` Googet install: `googet -noconfirm install package1 package2 package3` remove: `googet -noconfirm remove package1 package2 package3`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="package")]
		public Package Package { get; set; }
		
		/// <summary>
		/// Name of the guest policy providing this config.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
	}
	
	/// <summary>
	/// Package is a reference to the software package to be installed or removed. The agent on the VM instance uses the system package manager to apply the config. These are the commands that the agent uses to install or remove packages. Apt install: `apt-get update && apt-get -y install package1 package2 package3` remove: `apt-get -y remove package1 package2 package3` Yum install: `yum -y install package1 package2 package3` remove: `yum -y remove package1 package2 package3` Zypper install: `zypper install package1 package2 package3` remove: `zypper rm package1 package2` Googet install: `googet -noconfirm install package1 package2 package3` remove: `googet -noconfirm remove package1 package2 package3`
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Package
	{
		
		/// <summary>
		/// The desired_state the agent should maintain for this package. The default is to ensure the package is installed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="desiredState")]
		public System.Nullable<PackageDesiredState> DesiredState { get; set; }
		
		/// <summary>
		/// Type of package manager that can be used to install this package. If a system does not have the package manager, the package is not installed or removed no error message is returned. By default, or if you specify `ANY`, the agent attempts to install and remove this package using the default package manager. This is useful when creating a policy that applies to different types of systems. The default behavior is ANY.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="manager")]
		public System.Nullable<PackageManager> Manager { get; set; }
		
		/// <summary>
		/// Required. The name of the package. A package is uniquely identified for conflict validation by checking the package name and the manager(s) that the package targets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PackageDesiredState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DESIRED_STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INSTALLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REMOVED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PackageManager
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MANAGER_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		APT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		YUM = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ZYPPER = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GOO = 5,
	}
	
	/// <summary>
	/// A guest policy recipe including its source.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class EffectiveGuestPolicySourcedSoftwareRecipe
	{
		
		/// <summary>
		/// A software recipe is a set of instructions for installing and configuring a piece of software. It consists of a set of artifacts that are downloaded, and a set of steps that install, configure, and/or update the software. Recipes support installing and updating software from artifacts in the following formats: Zip archive, Tar archive, Windows MSI, Debian package, and RPM package. Additionally, recipes support executing a script (either defined in a file or directly in this api) in bash, sh, cmd, and powershell. Updating a software recipe If a recipe is assigned to an instance and there is a recipe with the same name but a lower version already installed and the assigned state of the recipe is `UPDATED`, then the recipe is updated to the new version. Script Working Directories Each script or execution step is run in its own temporary directory which is deleted after completing the step.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="softwareRecipe")]
		public SoftwareRecipe SoftwareRecipe { get; set; }
		
		/// <summary>
		/// Name of the guest policy providing this config.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
	}
	
	/// <summary>
	/// A software recipe is a set of instructions for installing and configuring a piece of software. It consists of a set of artifacts that are downloaded, and a set of steps that install, configure, and/or update the software. Recipes support installing and updating software from artifacts in the following formats: Zip archive, Tar archive, Windows MSI, Debian package, and RPM package. Additionally, recipes support executing a script (either defined in a file or directly in this api) in bash, sh, cmd, and powershell. Updating a software recipe If a recipe is assigned to an instance and there is a recipe with the same name but a lower version already installed and the assigned state of the recipe is `UPDATED`, then the recipe is updated to the new version. Script Working Directories Each script or execution step is run in its own temporary directory which is deleted after completing the step.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SoftwareRecipe
	{
		
		/// <summary>
		/// Resources available to be used in the steps in the recipe.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="artifacts")]
		public SoftwareRecipeArtifact[] Artifacts { get; set; }
		
		/// <summary>
		/// Default is INSTALLED. The desired state the agent should maintain for this recipe. INSTALLED: The software recipe is installed on the instance but won't be updated to new versions. UPDATED: The software recipe is installed on the instance. The recipe is updated to a higher version, if a higher version of the recipe is assigned to this instance. REMOVE: Remove is unsupported for software recipes and attempts to create or update a recipe to the REMOVE state is rejected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="desiredState")]
		public PackageDesiredState DesiredState { get; set; }
		
		/// <summary>
		/// Actions to be taken for installing this recipe. On failure it stops executing steps and does not attempt another installation. Any steps taken (including partially completed steps) are not rolled back.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="installSteps")]
		public SoftwareRecipeStep[] InstallSteps { get; set; }
		
		/// <summary>
		/// Required. Unique identifier for the recipe. Only one recipe with a given name is installed on an instance. Names are also used to identify resources which helps to determine whether guest policies have conflicts. This means that requests to create multiple recipes with the same name and version are rejected since they could potentially have conflicting assignments.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Actions to be taken for updating this recipe. On failure it stops executing steps and does not attempt another update for this recipe. Any steps taken (including partially completed steps) are not rolled back.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateSteps")]
		public SoftwareRecipeStep[] UpdateSteps { get; set; }
		
		/// <summary>
		/// The version of this software recipe. Version can be up to 4 period separated numbers (e.g. 12.34.56.78).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Specifies a resource to be used in the recipe.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SoftwareRecipeArtifact
	{
		
		/// <summary>
		/// Defaults to false. When false, recipes are subject to validations based on the artifact type: Remote: A checksum must be specified, and only protocols with transport-layer security are permitted. GCS: An object generation number must be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowInsecure")]
		public System.Nullable<System.Boolean> AllowInsecure { get; set; }
		
		/// <summary>
		/// Specifies an artifact available as a Google Cloud Storage object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gcs")]
		public SoftwareRecipeArtifactGcs Gcs { get; set; }
		
		/// <summary>
		/// Required. Id of the artifact, which the installation and update steps of this recipe can reference. Artifacts in a recipe cannot have the same id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Specifies an artifact available via some URI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remote")]
		public SoftwareRecipeArtifactRemote Remote { get; set; }
	}
	
	/// <summary>
	/// Specifies an artifact available as a Google Cloud Storage object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SoftwareRecipeArtifactGcs
	{
		
		/// <summary>
		/// Bucket of the Google Cloud Storage object. Given an example URL: `https://storage.googleapis.com/my-bucket/foo/bar#1234567` this value would be `my-bucket`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bucket")]
		public string Bucket { get; set; }
		
		/// <summary>
		/// Must be provided if allow_insecure is false. Generation number of the Google Cloud Storage object. `https://storage.googleapis.com/my-bucket/foo/bar#1234567` this value would be `1234567`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="generation")]
		public string Generation { get; set; }
		
		/// <summary>
		/// Name of the Google Cloud Storage object. As specified [here] (https://cloud.google.com/storage/docs/naming#objectnames) Given an example URL: `https://storage.googleapis.com/my-bucket/foo/bar#1234567` this value would be `foo/bar`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="object")]
		public string Object { get; set; }
	}
	
	/// <summary>
	/// Specifies an artifact available via some URI.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SoftwareRecipeArtifactRemote
	{
		
		/// <summary>
		/// Must be provided if `allow_insecure` is `false`. SHA256 checksum in hex format, to compare to the checksum of the artifact. If the checksum is not empty and it doesn't match the artifact then the recipe installation fails before running any of the steps.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="checksum")]
		public string Checksum { get; set; }
		
		/// <summary>
		/// URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
	}
	
	/// <summary>
	/// An action that can be taken as part of installing or updating a recipe.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SoftwareRecipeStep
	{
		
		/// <summary>
		/// Extracts an archive of the type specified in the specified directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="archiveExtraction")]
		public SoftwareRecipeStepExtractArchive ArchiveExtraction { get; set; }
		
		/// <summary>
		/// Installs a deb via dpkg.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dpkgInstallation")]
		public SoftwareRecipeStepInstallDpkg DpkgInstallation { get; set; }
		
		/// <summary>
		/// Copies the artifact to the specified path on the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileCopy")]
		public SoftwareRecipeStepCopyFile FileCopy { get; set; }
		
		/// <summary>
		/// Executes an artifact or local file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileExec")]
		public SoftwareRecipeStepExecFile FileExec { get; set; }
		
		/// <summary>
		/// Installs an MSI file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="msiInstallation")]
		public SoftwareRecipeStepInstallMsi MsiInstallation { get; set; }
		
		/// <summary>
		/// Installs an rpm file via the rpm utility.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rpmInstallation")]
		public SoftwareRecipeStepInstallRpm RpmInstallation { get; set; }
		
		/// <summary>
		/// Runs a script through an interpreter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scriptRun")]
		public SoftwareRecipeStepRunScript ScriptRun { get; set; }
	}
	
	/// <summary>
	/// Extracts an archive of the type specified in the specified directory.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SoftwareRecipeStepExtractArchive
	{
		
		/// <summary>
		/// Required. The id of the relevant artifact in the recipe.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="artifactId")]
		public string ArtifactId { get; set; }
		
		/// <summary>
		/// Directory to extract archive to. Defaults to `/` on Linux or `C:\` on Windows.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public string Destination { get; set; }
		
		/// <summary>
		/// Required. The type of the archive to extract.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<SoftwareRecipeStepExtractArchiveType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SoftwareRecipeStepExtractArchiveType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ARCHIVE_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TAR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TAR_GZIP = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TAR_BZIP = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TAR_LZMA = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TAR_XZ = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ZIP = 6,
	}
	
	/// <summary>
	/// Installs a deb via dpkg.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SoftwareRecipeStepInstallDpkg
	{
		
		/// <summary>
		/// Required. The id of the relevant artifact in the recipe.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="artifactId")]
		public string ArtifactId { get; set; }
	}
	
	/// <summary>
	/// Copies the artifact to the specified path on the instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SoftwareRecipeStepCopyFile
	{
		
		/// <summary>
		/// Required. The id of the relevant artifact in the recipe.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="artifactId")]
		public string ArtifactId { get; set; }
		
		/// <summary>
		/// Required. The absolute path on the instance to put the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public string Destination { get; set; }
		
		/// <summary>
		/// Whether to allow this step to overwrite existing files. If this is false and the file already exists the file is not overwritten and the step is considered a success. Defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="overwrite")]
		public System.Nullable<System.Boolean> Overwrite { get; set; }
		
		/// <summary>
		/// Consists of three octal digits which represent, in order, the permissions of the owner, group, and other users for the file (similarly to the numeric mode used in the linux chmod utility). Each digit represents a three bit number with the 4 bit corresponding to the read permissions, the 2 bit corresponds to the write bit, and the one bit corresponds to the execute permission. Default behavior is 755. Below are some examples of permissions and their associated values: read, write, and execute: 7 read and execute: 5 read and write: 6 read only: 4
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public string Permissions { get; set; }
	}
	
	/// <summary>
	/// Executes an artifact or local file.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SoftwareRecipeStepExecFile
	{
		
		/// <summary>
		/// Defaults to [0]. A list of possible return values that the program can return to indicate a success.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedExitCodes")]
		public int[] AllowedExitCodes { get; set; }
		
		/// <summary>
		/// Arguments to be passed to the provided executable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="args")]
		public string[] Args { get; set; }
		
		/// <summary>
		/// The id of the relevant artifact in the recipe.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="artifactId")]
		public string ArtifactId { get; set; }
		
		/// <summary>
		/// The absolute path of the file on the local filesystem.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localPath")]
		public string LocalPath { get; set; }
	}
	
	/// <summary>
	/// Installs an MSI file.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SoftwareRecipeStepInstallMsi
	{
		
		/// <summary>
		/// Return codes that indicate that the software installed or updated successfully. Behaviour defaults to [0]
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedExitCodes")]
		public int[] AllowedExitCodes { get; set; }
		
		/// <summary>
		/// Required. The id of the relevant artifact in the recipe.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="artifactId")]
		public string ArtifactId { get; set; }
		
		/// <summary>
		/// The flags to use when installing the MSI defaults to ["/i"] (i.e. the install flag).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="flags")]
		public string[] Flags { get; set; }
	}
	
	/// <summary>
	/// Installs an rpm file via the rpm utility.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SoftwareRecipeStepInstallRpm
	{
		
		/// <summary>
		/// Required. The id of the relevant artifact in the recipe.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="artifactId")]
		public string ArtifactId { get; set; }
	}
	
	/// <summary>
	/// Runs a script through an interpreter.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SoftwareRecipeStepRunScript
	{
		
		/// <summary>
		/// Return codes that indicate that the software installed or updated successfully. Behaviour defaults to [0]
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedExitCodes")]
		public int[] AllowedExitCodes { get; set; }
		
		/// <summary>
		/// The script interpreter to use to run the script. If no interpreter is specified the script is executed directly, which likely only succeed for scripts with [shebang lines](https://en.wikipedia.org/wiki/Shebang_\(Unix\)).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interpreter")]
		public System.Nullable<SoftwareRecipeStepRunScriptInterpreter> Interpreter { get; set; }
		
		/// <summary>
		/// Required. The shell script to be executed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="script")]
		public string Script { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SoftwareRecipeStepRunScriptInterpreter
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERPRETER_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHELL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POWERSHELL = 2,
	}
	
	/// <summary>
	/// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Empty
	{
	}
	
	/// <summary>
	/// A step that runs an executable for a PatchJob.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ExecStep
	{
		
		/// <summary>
		/// Common configurations for an ExecStep.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linuxExecStepConfig")]
		public ExecStepConfig LinuxExecStepConfig { get; set; }
		
		/// <summary>
		/// Common configurations for an ExecStep.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="windowsExecStepConfig")]
		public ExecStepConfig WindowsExecStepConfig { get; set; }
	}
	
	/// <summary>
	/// Common configurations for an ExecStep.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ExecStepConfig
	{
		
		/// <summary>
		/// Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedSuccessCodes")]
		public int[] AllowedSuccessCodes { get; set; }
		
		/// <summary>
		/// Google Cloud Storage object representation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gcsObject")]
		public GcsObject GcsObject { get; set; }
		
		/// <summary>
		/// The script interpreter to use to run the script. If no interpreter is specified the script will be executed directly, which will likely only succeed for scripts with [shebang lines] (https://en.wikipedia.org/wiki/Shebang_\(Unix\)).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interpreter")]
		public System.Nullable<ExecStepConfigInterpreter> Interpreter { get; set; }
		
		/// <summary>
		/// An absolute path to the executable on the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localPath")]
		public string LocalPath { get; set; }
	}
	
	/// <summary>
	/// Google Cloud Storage object representation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GcsObject
	{
		
		/// <summary>
		/// Required. Bucket of the Google Cloud Storage object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bucket")]
		public string Bucket { get; set; }
		
		/// <summary>
		/// Required. Generation number of the Google Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="generationNumber")]
		public string GenerationNumber { get; set; }
		
		/// <summary>
		/// Required. Name of the Google Cloud Storage object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="object")]
		public string Object { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ExecStepConfigInterpreter
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERPRETER_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHELL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POWERSHELL = 3,
	}
	
	/// <summary>
	/// A request message to initiate patching across Compute Engine instances.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ExecutePatchJobRequest
	{
		
		/// <summary>
		/// Description of the patch job. Length of the description is limited to 1024 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Display name for this patch job. This does not have to be unique.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// If this patch is a dry-run only, instances are contacted but will do nothing.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dryRun")]
		public System.Nullable<System.Boolean> DryRun { get; set; }
		
		/// <summary>
		/// Duration of the patch job. After the duration ends, the patch job times out.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public string Duration { get; set; }
		
		/// <summary>
		/// A filter to target VM instances for patching. The targeted VMs must meet all criteria specified. So if both labels and zones are specified, the patch job targets only VMs with those labels and in those zones.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceFilter")]
		public PatchInstanceFilter InstanceFilter { get; set; }
		
		/// <summary>
		/// Patch configuration specifications. Contains details on how to apply the patch(es) to a VM instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchConfig")]
		public PatchConfig PatchConfig { get; set; }
		
		/// <summary>
		/// Patch rollout configuration specifications. Contains details on the concurrency control when applying patch(es) to all targeted VMs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rollout")]
		public PatchRollout Rollout { get; set; }
	}
	
	/// <summary>
	/// A filter to target VM instances for patching. The targeted VMs must meet all criteria specified. So if both labels and zones are specified, the patch job targets only VMs with those labels and in those zones.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PatchInstanceFilter
	{
		
		/// <summary>
		/// Target all VM instances in the project. If true, no other criteria is permitted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="all")]
		public System.Nullable<System.Boolean> All { get; set; }
		
		/// <summary>
		/// Targets VM instances matching at least one of these label sets. This allows targeting of disparate groups, for example "env=prod or env=staging".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupLabels")]
		public PatchInstanceFilterGroupLabel[] GroupLabels { get; set; }
		
		/// <summary>
		/// Targets VMs whose name starts with one of these prefixes. Similar to labels, this is another way to group VMs when targeting configs, for example prefix="prod-".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceNamePrefixes")]
		public string[] InstanceNamePrefixes { get; set; }
		
		/// <summary>
		/// Targets any of the VM instances specified. Instances are specified by their URI in the form `zones/[ZONE]/instances/[INSTANCE_NAME]`, `projects/[PROJECT_ID]/zones/[ZONE]/instances/[INSTANCE_NAME]`, or `https://www.googleapis.com/compute/v1/projects/[PROJECT_ID]/zones/[ZONE]/instances/[INSTANCE_NAME]`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public string[] Instances { get; set; }
		
		/// <summary>
		/// Targets VM instances in ANY of these zones. Leave empty to target VM instances in any zone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zones")]
		public string[] Zones { get; set; }
	}
	
	/// <summary>
	/// Represents a group of VMs that can be identified as having all these labels, for example "env=prod and app=web".
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PatchInstanceFilterGroupLabel
	{
		
		/// <summary>
		/// Compute Engine instance labels that must be present for a VM instance to be targeted by this filter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
	}
	
	/// <summary>
	/// Patch configuration specifications. Contains details on how to apply the patch(es) to a VM instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PatchConfig
	{
		
		/// <summary>
		/// Apt patching is completed by executing `apt-get update && apt-get upgrade`. Additional options can be set to control how this is executed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apt")]
		public AptSettings Apt { get; set; }
		
		/// <summary>
		/// Googet patching is performed by running `googet update`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="goo")]
		public GooSettings Goo { get; set; }
		
		/// <summary>
		/// Allows the patch job to run on Managed instance groups (MIGs).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="migInstancesAllowed")]
		public System.Nullable<System.Boolean> MigInstancesAllowed { get; set; }
		
		/// <summary>
		/// A step that runs an executable for a PatchJob.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postStep")]
		public ExecStep PostStep { get; set; }
		
		/// <summary>
		/// A step that runs an executable for a PatchJob.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preStep")]
		public ExecStep PreStep { get; set; }
		
		/// <summary>
		/// Post-patch reboot settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rebootConfig")]
		public System.Nullable<PatchConfigRebootConfig> RebootConfig { get; set; }
		
		/// <summary>
		/// Windows patching is performed using the Windows Update Agent.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="windowsUpdate")]
		public WindowsUpdateSettings WindowsUpdate { get; set; }
		
		/// <summary>
		/// Yum patching is performed by executing `yum update`. Additional options can be set to control how this is executed. Note that not all settings are supported on all platforms.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="yum")]
		public YumSettings Yum { get; set; }
		
		/// <summary>
		/// Zypper patching is performed by running `zypper patch`. See also https://en.opensuse.org/SDB:Zypper_manual.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zypper")]
		public ZypperSettings Zypper { get; set; }
	}
	
	/// <summary>
	/// Googet patching is performed by running `googet update`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GooSettings
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PatchConfigRebootConfig
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REBOOT_CONFIG_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALWAYS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NEVER = 3,
	}
	
	/// <summary>
	/// Windows patching is performed using the Windows Update Agent.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WindowsUpdateSettings
	{
		
		/// <summary>
		/// Only apply updates of these windows update classifications. If empty, all updates are applied.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="classifications")]
		public string[] Classifications { get; set; }
		
		/// <summary>
		/// List of KBs to exclude from update.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="excludes")]
		public string[] Excludes { get; set; }
		
		/// <summary>
		/// An exclusive list of kbs to be updated. These are the only patches that will be updated. This field must not be used with other patch configurations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclusivePatches")]
		public string[] ExclusivePatches { get; set; }
	}
	
	/// <summary>
	/// Yum patching is performed by executing `yum update`. Additional options can be set to control how this is executed. Note that not all settings are supported on all platforms.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class YumSettings
	{
		
		/// <summary>
		/// List of packages to exclude from update. These packages are excluded by using the yum `--exclude` flag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="excludes")]
		public string[] Excludes { get; set; }
		
		/// <summary>
		/// An exclusive list of packages to be updated. These are the only packages that will be updated. If these packages are not installed, they will be ignored. This field must not be specified with any other patch configuration fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclusivePackages")]
		public string[] ExclusivePackages { get; set; }
		
		/// <summary>
		/// Will cause patch to run `yum update-minimal` instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimal")]
		public System.Nullable<System.Boolean> Minimal { get; set; }
		
		/// <summary>
		/// Adds the `--security` flag to `yum update`. Not supported on all platforms.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="security")]
		public System.Nullable<System.Boolean> Security { get; set; }
	}
	
	/// <summary>
	/// Zypper patching is performed by running `zypper patch`. See also https://en.opensuse.org/SDB:Zypper_manual.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ZypperSettings
	{
		
		/// <summary>
		/// Install only patches with these categories. Common categories include security, recommended, and feature.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="categories")]
		public string[] Categories { get; set; }
		
		/// <summary>
		/// List of patches to exclude from update.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="excludes")]
		public string[] Excludes { get; set; }
		
		/// <summary>
		/// An exclusive list of patches to be updated. These are the only patches that will be installed using 'zypper patch patch:' command. This field must not be used with any other patch configuration fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclusivePatches")]
		public string[] ExclusivePatches { get; set; }
		
		/// <summary>
		/// Install only patches with these severities. Common severities include critical, important, moderate, and low.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="severities")]
		public string[] Severities { get; set; }
		
		/// <summary>
		/// Adds the `--with-optional` flag to `zypper patch`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="withOptional")]
		public System.Nullable<System.Boolean> WithOptional { get; set; }
		
		/// <summary>
		/// Adds the `--with-update` flag, to `zypper patch`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="withUpdate")]
		public System.Nullable<System.Boolean> WithUpdate { get; set; }
	}
	
	/// <summary>
	/// Patch rollout configuration specifications. Contains details on the concurrency control when applying patch(es) to all targeted VMs.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PatchRollout
	{
		
		/// <summary>
		/// Message encapsulating a value that can be either absolute ("fixed") or relative ("percent") to a value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disruptionBudget")]
		public FixedOrPercent DisruptionBudget { get; set; }
		
		/// <summary>
		/// Mode of the patch rollout.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public System.Nullable<PatchRolloutMode> Mode { get; set; }
	}
	
	/// <summary>
	/// Message encapsulating a value that can be either absolute ("fixed") or relative ("percent") to a value.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FixedOrPercent
	{
		
		/// <summary>
		/// Specifies a fixed value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixed")]
		public System.Nullable<System.Int32> Fixed { get; set; }
		
		/// <summary>
		/// Specifies the relative value defined as a percentage, which will be multiplied by a reference value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percent")]
		public System.Nullable<System.Int32> Percent { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PatchRolloutMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ZONE_BY_ZONE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONCURRENT_ZONES = 2,
	}
	
	/// <summary>
	/// OS policy assignment operation metadata provided by OS policy assignment API methods that return long running operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleCloudOsconfigV1__OSPolicyAssignmentOperationMetadata
	{
		
		/// <summary>
		/// The OS policy assignment API method.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiMethod")]
		public System.Nullable<GoogleCloudOsconfigV1__OSPolicyAssignmentOperationMetadataApiMethod> ApiMethod { get; set; }
		
		/// <summary>
		/// Reference to the `OSPolicyAssignment` API resource. Format: `projects/{project_number}/locations/{location}/osPolicyAssignments/{os_policy_assignment_id@revision_id}`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osPolicyAssignment")]
		public string OsPolicyAssignment { get; set; }
		
		/// <summary>
		/// Rollout start time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rolloutStartTime")]
		public string RolloutStartTime { get; set; }
		
		/// <summary>
		/// State of the rollout
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rolloutState")]
		public System.Nullable<GoogleCloudOsconfigV1__OSPolicyAssignmentOperationMetadataRolloutState> RolloutState { get; set; }
		
		/// <summary>
		/// Rollout update time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rolloutUpdateTime")]
		public string RolloutUpdateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GoogleCloudOsconfigV1__OSPolicyAssignmentOperationMetadataApiMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		API_METHOD_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GoogleCloudOsconfigV1__OSPolicyAssignmentOperationMetadataRolloutState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ROLLOUT_STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IN_PROGRESS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANCELLING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANCELLED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCEEDED = 4,
	}
	
	/// <summary>
	/// An OS Config resource representing a guest configuration policy. These policies represent the desired state for VM instance guest environments including packages to install or remove, package repository configurations, and software to install.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GuestPolicy
	{
		
		/// <summary>
		/// An assignment represents the group or groups of VM instances that the policy applies to. If an assignment is empty, it applies to all VM instances. Otherwise, the targeted VM instances must meet all the criteria specified. So if both labels and zones are specified, the policy applies to VM instances with those labels and in those zones.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignment")]
		public Assignment Assignment { get; set; }
		
		/// <summary>
		/// Output only. Time this guest policy was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Description of the guest policy. Length of the description is limited to 1024 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The etag for this guest policy. If this is provided on update, it must match the server's etag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// Required. Unique name of the resource in this project using one of the following forms: `projects/{project_number}/guestPolicies/{guest_policy_id}`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A list of package repositories to configure on the VM instance. This is done before any other configs are applied so they can use these repos. Package repositories are only configured if the corresponding package manager(s) are available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="packageRepositories")]
		public PackageRepository[] PackageRepositories { get; set; }
		
		/// <summary>
		/// The software packages to be managed by this policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="packages")]
		public Package[] Packages { get; set; }
		
		/// <summary>
		/// A list of Recipes to install on the VM instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recipes")]
		public SoftwareRecipe[] Recipes { get; set; }
		
		/// <summary>
		/// Output only. Last time this guest policy was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// A response message for listing guest policies.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListGuestPoliciesResponse
	{
		
		/// <summary>
		/// The list of GuestPolicies.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestPolicies")]
		public GuestPolicy[] GuestPolicies { get; set; }
		
		/// <summary>
		/// A pagination token that can be used to get the next page of guest policies.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// A response message for listing patch deployments.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListPatchDeploymentsResponse
	{
		
		/// <summary>
		/// A pagination token that can be used to get the next page of patch deployments.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The list of patch deployments.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchDeployments")]
		public PatchDeployment[] PatchDeployments { get; set; }
	}
	
	/// <summary>
	/// Patch deployments are configurations that individual patch jobs use to complete a patch. These configurations include instance filter, package repository settings, and a schedule. For more information about creating and managing patch deployments, see [Scheduling patch jobs](https://cloud.google.com/compute/docs/os-patch-management/schedule-patch-jobs).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PatchDeployment
	{
		
		/// <summary>
		/// Output only. Time the patch deployment was created. Timestamp is in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Optional. Description of the patch deployment. Length of the description is limited to 1024 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Optional. Duration of the patch. After the duration ends, the patch times out.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public string Duration { get; set; }
		
		/// <summary>
		/// A filter to target VM instances for patching. The targeted VMs must meet all criteria specified. So if both labels and zones are specified, the patch job targets only VMs with those labels and in those zones.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceFilter")]
		public PatchInstanceFilter InstanceFilter { get; set; }
		
		/// <summary>
		/// Output only. The last time a patch job was started by this deployment. Timestamp is in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastExecuteTime")]
		public string LastExecuteTime { get; set; }
		
		/// <summary>
		/// Unique name for the patch deployment resource in a project. The patch deployment name is in the form: `projects/{project_id}/patchDeployments/{patch_deployment_id}`. This field is ignored when you create a new patch deployment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Sets the time for a one time patch deployment. Timestamp is in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oneTimeSchedule")]
		public OneTimeSchedule OneTimeSchedule { get; set; }
		
		/// <summary>
		/// Patch configuration specifications. Contains details on how to apply the patch(es) to a VM instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchConfig")]
		public PatchConfig PatchConfig { get; set; }
		
		/// <summary>
		/// Sets the time for recurring patch deployments.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recurringSchedule")]
		public RecurringSchedule RecurringSchedule { get; set; }
		
		/// <summary>
		/// Patch rollout configuration specifications. Contains details on the concurrency control when applying patch(es) to all targeted VMs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rollout")]
		public PatchRollout Rollout { get; set; }
		
		/// <summary>
		/// Output only. Current state of the patch deployment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<PatchDeploymentState> State { get; set; }
		
		/// <summary>
		/// Output only. Time the patch deployment was last updated. Timestamp is in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// Sets the time for a one time patch deployment. Timestamp is in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OneTimeSchedule
	{
		
		/// <summary>
		/// Required. The desired patch job execution time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executeTime")]
		public string ExecuteTime { get; set; }
	}
	
	/// <summary>
	/// Sets the time for recurring patch deployments.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RecurringSchedule
	{
		
		/// <summary>
		/// Optional. The end time at which a recurring patch deployment schedule is no longer active.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// Required. The frequency unit of this recurring schedule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="frequency")]
		public System.Nullable<RecurringScheduleFrequency> Frequency { get; set; }
		
		/// <summary>
		/// Output only. The time the last patch job ran successfully.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastExecuteTime")]
		public string LastExecuteTime { get; set; }
		
		/// <summary>
		/// Represents a monthly schedule. An example of a valid monthly schedule is "on the third Tuesday of the month" or "on the 15th of the month".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monthly")]
		public MonthlySchedule Monthly { get; set; }
		
		/// <summary>
		/// Output only. The time the next patch job is scheduled to run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextExecuteTime")]
		public string NextExecuteTime { get; set; }
		
		/// <summary>
		/// Optional. The time that the recurring schedule becomes effective. Defaults to `create_time` of the patch deployment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
		
		/// <summary>
		/// Represents a time of day. The date and time zone are either not significant or are specified elsewhere. An API may choose to allow leap seconds. Related types are google.type.Date and `google.protobuf.Timestamp`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeOfDay")]
		public TimeOfDay TimeOfDay { get; set; }
		
		/// <summary>
		/// Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeZone")]
		public TimeZone TimeZone { get; set; }
		
		/// <summary>
		/// Represents a weekly schedule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="weekly")]
		public WeeklySchedule Weekly { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RecurringScheduleFrequency
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FREQUENCY_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEEKLY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MONTHLY = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DAILY = 3,
	}
	
	/// <summary>
	/// Represents a monthly schedule. An example of a valid monthly schedule is "on the third Tuesday of the month" or "on the 15th of the month".
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MonthlySchedule
	{
		
		/// <summary>
		/// Required. One day of the month. 1-31 indicates the 1st to the 31st day. -1 indicates the last day of the month. Months without the target day will be skipped. For example, a schedule to run "every month on the 31st" will not run in February, April, June, etc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monthDay")]
		public System.Nullable<System.Int32> MonthDay { get; set; }
		
		/// <summary>
		/// Represents one week day in a month. An example is "the 4th Sunday".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="weekDayOfMonth")]
		public WeekDayOfMonth WeekDayOfMonth { get; set; }
	}
	
	/// <summary>
	/// Represents one week day in a month. An example is "the 4th Sunday".
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WeekDayOfMonth
	{
		
		/// <summary>
		/// Required. A day of the week.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dayOfWeek")]
		public System.Nullable<WeekDayOfMonthDayOfWeek> DayOfWeek { get; set; }
		
		/// <summary>
		/// Optional. Represents the number of days before or after the given week day of month that the patch deployment is scheduled for. For example if `week_ordinal` and `day_of_week` values point to the second day of the month and this `day_offset` value is set to `3`, the patch deployment takes place three days after the second Tuesday of the month. If this value is negative, for example -5, the patches are deployed five days before before the second Tuesday of the month. Allowed values are in range [-30, 30].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dayOffset")]
		public System.Nullable<System.Int32> DayOffset { get; set; }
		
		/// <summary>
		/// Required. Week number in a month. 1-4 indicates the 1st to 4th week of the month. -1 indicates the last week of the month.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="weekOrdinal")]
		public System.Nullable<System.Int32> WeekOrdinal { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum WeekDayOfMonthDayOfWeek
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DAY_OF_WEEK_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MONDAY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TUESDAY = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEDNESDAY = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		THURSDAY = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FRIDAY = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SATURDAY = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUNDAY = 7,
	}
	
	/// <summary>
	/// Represents a time of day. The date and time zone are either not significant or are specified elsewhere. An API may choose to allow leap seconds. Related types are google.type.Date and `google.protobuf.Timestamp`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TimeOfDay
	{
		
		/// <summary>
		/// Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hours")]
		public System.Nullable<System.Int32> Hours { get; set; }
		
		/// <summary>
		/// Minutes of hour of day. Must be from 0 to 59.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minutes")]
		public System.Nullable<System.Int32> Minutes { get; set; }
		
		/// <summary>
		/// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nanos")]
		public System.Nullable<System.Int32> Nanos { get; set; }
		
		/// <summary>
		/// Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seconds")]
		public System.Nullable<System.Int32> Seconds { get; set; }
	}
	
	/// <summary>
	/// Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TimeZone
	{
		
		/// <summary>
		/// IANA Time Zone Database time zone, e.g. "America/New_York".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Optional. IANA Time Zone Database version number, e.g. "2019a".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Represents a weekly schedule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WeeklySchedule
	{
		
		/// <summary>
		/// Required. Day of the week.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dayOfWeek")]
		public WeekDayOfMonthDayOfWeek DayOfWeek { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PatchDeploymentState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PAUSED = 2,
	}
	
	/// <summary>
	/// A response message for listing the instances details for a patch job.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListPatchJobInstanceDetailsResponse
	{
		
		/// <summary>
		/// A pagination token that can be used to get the next page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// A list of instance status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchJobInstanceDetails")]
		public PatchJobInstanceDetails[] PatchJobInstanceDetails { get; set; }
	}
	
	/// <summary>
	/// Patch details for a VM instance. For more information about reviewing VM instance details, see [Listing all VM instance details for a specific patch job](https://cloud.google.com/compute/docs/os-patch-management/manage-patch-jobs#list-instance-details).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PatchJobInstanceDetails
	{
		
		/// <summary>
		/// The number of times the agent that the agent attempts to apply the patch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="attemptCount")]
		public string AttemptCount { get; set; }
		
		/// <summary>
		/// If the patch fails, this field provides the reason.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failureReason")]
		public string FailureReason { get; set; }
		
		/// <summary>
		/// The unique identifier for the instance. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceSystemId")]
		public string InstanceSystemId { get; set; }
		
		/// <summary>
		/// The instance name in the form `projects/*/zones/*/instances/*`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Current state of instance patch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<PatchJobInstanceDetailsState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PatchJobInstanceDetailsState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PATCH_STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INACTIVE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOTIFIED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARTED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOWNLOADING_PATCHES = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		APPLYING_PATCHES = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REBOOTING = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCEEDED = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCEEDED_REBOOT_REQUIRED = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACKED = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TIMED_OUT = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING_PRE_PATCH_STEP = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING_POST_PATCH_STEP = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO_AGENT_DETECTED = 15,
	}
	
	/// <summary>
	/// A response message for listing patch jobs.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListPatchJobsResponse
	{
		
		/// <summary>
		/// A pagination token that can be used to get the next page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The list of patch jobs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchJobs")]
		public PatchJob[] PatchJobs { get; set; }
	}
	
	/// <summary>
	/// A high level representation of a patch job that is either in progress or has completed. Instance details are not included in the job. To paginate through instance details, use `ListPatchJobInstanceDetails`. For more information about patch jobs, see [Creating patch jobs](https://cloud.google.com/compute/docs/os-patch-management/create-patch-job).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PatchJob
	{
		
		/// <summary>
		/// Time this patch job was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Description of the patch job. Length of the description is limited to 1024 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Display name for this patch job. This is not a unique identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// If this patch job is a dry run, the agent reports that it has finished without running any updates on the VM instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dryRun")]
		public System.Nullable<System.Boolean> DryRun { get; set; }
		
		/// <summary>
		/// Duration of the patch job. After the duration ends, the patch job times out.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public string Duration { get; set; }
		
		/// <summary>
		/// If this patch job failed, this message provides information about the failure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorMessage")]
		public string ErrorMessage { get; set; }
		
		/// <summary>
		/// A summary of the current patch state across all instances that this patch job affects. Contains counts of instances in different states. These states map to `InstancePatchState`. List patch job instance details to see the specific states of each instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceDetailsSummary")]
		public PatchJobInstanceDetailsSummary InstanceDetailsSummary { get; set; }
		
		/// <summary>
		/// A filter to target VM instances for patching. The targeted VMs must meet all criteria specified. So if both labels and zones are specified, the patch job targets only VMs with those labels and in those zones.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceFilter")]
		public PatchInstanceFilter InstanceFilter { get; set; }
		
		/// <summary>
		/// Unique identifier for this patch job in the form `projects/*/patchJobs/*`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Patch configuration specifications. Contains details on how to apply the patch(es) to a VM instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchConfig")]
		public PatchConfig PatchConfig { get; set; }
		
		/// <summary>
		/// Output only. Name of the patch deployment that created this patch job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="patchDeployment")]
		public string PatchDeployment { get; set; }
		
		/// <summary>
		/// Reflects the overall progress of the patch job in the range of 0.0 being no progress to 100.0 being complete.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentComplete")]
		public System.Nullable<System.Double> PercentComplete { get; set; }
		
		/// <summary>
		/// Patch rollout configuration specifications. Contains details on the concurrency control when applying patch(es) to all targeted VMs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rollout")]
		public PatchRollout Rollout { get; set; }
		
		/// <summary>
		/// The current state of the PatchJob.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<PatchJobState> State { get; set; }
		
		/// <summary>
		/// Last time this patch job was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// A summary of the current patch state across all instances that this patch job affects. Contains counts of instances in different states. These states map to `InstancePatchState`. List patch job instance details to see the specific states of each instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PatchJobInstanceDetailsSummary
	{
		
		/// <summary>
		/// Number of instances that have acked and will start shortly.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ackedInstanceCount")]
		public string AckedInstanceCount { get; set; }
		
		/// <summary>
		/// Number of instances that are applying patches.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applyingPatchesInstanceCount")]
		public string ApplyingPatchesInstanceCount { get; set; }
		
		/// <summary>
		/// Number of instances that are downloading patches.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="downloadingPatchesInstanceCount")]
		public string DownloadingPatchesInstanceCount { get; set; }
		
		/// <summary>
		/// Number of instances that failed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failedInstanceCount")]
		public string FailedInstanceCount { get; set; }
		
		/// <summary>
		/// Number of instances that are inactive.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inactiveInstanceCount")]
		public string InactiveInstanceCount { get; set; }
		
		/// <summary>
		/// Number of instances that do not appear to be running the agent. Check to ensure that the agent is installed, running, and able to communicate with the service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noAgentDetectedInstanceCount")]
		public string NoAgentDetectedInstanceCount { get; set; }
		
		/// <summary>
		/// Number of instances notified about patch job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notifiedInstanceCount")]
		public string NotifiedInstanceCount { get; set; }
		
		/// <summary>
		/// Number of instances pending patch job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pendingInstanceCount")]
		public string PendingInstanceCount { get; set; }
		
		/// <summary>
		/// Number of instances that are running the post-patch step.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postPatchStepInstanceCount")]
		public string PostPatchStepInstanceCount { get; set; }
		
		/// <summary>
		/// Number of instances that are running the pre-patch step.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prePatchStepInstanceCount")]
		public string PrePatchStepInstanceCount { get; set; }
		
		/// <summary>
		/// Number of instances rebooting.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rebootingInstanceCount")]
		public string RebootingInstanceCount { get; set; }
		
		/// <summary>
		/// Number of instances that have started.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startedInstanceCount")]
		public string StartedInstanceCount { get; set; }
		
		/// <summary>
		/// Number of instances that have completed successfully.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="succeededInstanceCount")]
		public string SucceededInstanceCount { get; set; }
		
		/// <summary>
		/// Number of instances that require reboot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="succeededRebootRequiredInstanceCount")]
		public string SucceededRebootRequiredInstanceCount { get; set; }
		
		/// <summary>
		/// Number of instances that exceeded the time out while applying the patch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timedOutInstanceCount")]
		public string TimedOutInstanceCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PatchJobState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARTED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INSTANCE_LOOKUP = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PATCHING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCEEDED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED_WITH_ERRORS = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANCELED = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TIMED_OUT = 7,
	}
	
	/// <summary>
	/// A request message for getting the effective guest policy assigned to the instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LookupEffectiveGuestPolicyRequest
	{
		
		/// <summary>
		/// Architecture of OS running on the instance. The OS Config agent only provides this field for targeting if OS Inventory is enabled for that instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osArchitecture")]
		public string OsArchitecture { get; set; }
		
		/// <summary>
		/// Short name of the OS running on the instance. The OS Config agent only provides this field for targeting if OS Inventory is enabled for that instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osShortName")]
		public string OsShortName { get; set; }
		
		/// <summary>
		/// Version of the OS running on the instance. The OS Config agent only provides this field for targeting if OS Inventory is enabled for that VM instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osVersion")]
		public string OsVersion { get; set; }
	}
	
	/// <summary>
	/// OS policy assignment operation metadata provided by OS policy assignment API methods that return long running operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OSPolicyAssignmentOperationMetadata
	{
		
		/// <summary>
		/// The OS policy assignment API method.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiMethod")]
		public GoogleCloudOsconfigV1__OSPolicyAssignmentOperationMetadataApiMethod ApiMethod { get; set; }
		
		/// <summary>
		/// Reference to the `OSPolicyAssignment` API resource. Format: `projects/{project_number}/locations/{location}/osPolicyAssignments/{os_policy_assignment_id@revision_id}`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osPolicyAssignment")]
		public string OsPolicyAssignment { get; set; }
		
		/// <summary>
		/// Rollout start time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rolloutStartTime")]
		public string RolloutStartTime { get; set; }
		
		/// <summary>
		/// State of the rollout
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rolloutState")]
		public GoogleCloudOsconfigV1__OSPolicyAssignmentOperationMetadataRolloutState RolloutState { get; set; }
		
		/// <summary>
		/// Rollout update time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rolloutUpdateTime")]
		public string RolloutUpdateTime { get; set; }
	}
	
	/// <summary>
	/// A request message for pausing a patch deployment.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PausePatchDeploymentRequest
	{
	}
	
	/// <summary>
	/// A request message for resuming a patch deployment.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ResumePatchDeploymentRequest
	{
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Lookup the effective guest policy that applies to a VM instance. This lookup merges all policies that are assigned to the instance ancestry.
		/// Osconfig_projects_zones_instances_lookupEffectiveGuestPolicy v1beta/{instance}:lookupEffectiveGuestPolicy
		/// </summary>
		/// <param name="instance">Required. The VM instance whose policies are being looked up.</param>
		/// <returns>Successful response</returns>
		public async Task<EffectiveGuestPolicy> Osconfig_projects_zones_instances_lookupEffectiveGuestPolicyAsync(string instance, LookupEffectiveGuestPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+":lookupEffectiveGuestPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<EffectiveGuestPolicy>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an OS Config patch deployment.
		/// Osconfig_projects_patchDeployments_delete v1beta/{name}
		/// </summary>
		/// <param name="name">Required. The resource name of the patch deployment in the form `projects/*/patchDeployments/*`.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Osconfig_projects_patchDeployments_deleteAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the patch job. This can be used to track the progress of an ongoing patch job or review the details of completed jobs.
		/// Osconfig_projects_patchJobs_get v1beta/{name}
		/// </summary>
		/// <param name="name">Required. Name of the patch in the form `projects/*/patchJobs/*`</param>
		/// <returns>Successful response</returns>
		public async Task<PatchJob> Osconfig_projects_patchJobs_getAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PatchJob>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an OS Config patch deployment.
		/// Osconfig_projects_patchDeployments_patch v1beta/{name}
		/// </summary>
		/// <param name="name">Unique name for the patch deployment resource in a project. The patch deployment name is in the form: `projects/{project_id}/patchDeployments/{patch_deployment_id}`. This field is ignored when you create a new patch deployment.</param>
		/// <param name="updateMask">Optional. Field mask that controls which fields of the patch deployment should be updated.</param>
		/// <returns>Successful response</returns>
		public async Task<PatchDeployment> Osconfig_projects_patchDeployments_patchAsync(string name, string updateMask, PatchDeployment requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PatchDeployment>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Cancel a patch job. The patch job must be active. Canceled patch jobs cannot be restarted.
		/// Osconfig_projects_patchJobs_cancel v1beta/{name}:cancel
		/// </summary>
		/// <param name="name">Required. Name of the patch in the form `projects/*/patchJobs/*`</param>
		/// <returns>Successful response</returns>
		public async Task<PatchJob> Osconfig_projects_patchJobs_cancelAsync(string name, CancelPatchJobRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":cancel";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PatchJob>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Change state of patch deployment to "PAUSED". Patch deployment in paused state doesn't generate patch jobs.
		/// Osconfig_projects_patchDeployments_pause v1beta/{name}:pause
		/// </summary>
		/// <param name="name">Required. The resource name of the patch deployment in the form `projects/*/patchDeployments/*`.</param>
		/// <returns>Successful response</returns>
		public async Task<PatchDeployment> Osconfig_projects_patchDeployments_pauseAsync(string name, PausePatchDeploymentRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":pause";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PatchDeployment>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Change state of patch deployment back to "ACTIVE". Patch deployment in active state continues to generate patch jobs.
		/// Osconfig_projects_patchDeployments_resume v1beta/{name}:resume
		/// </summary>
		/// <param name="name">Required. The resource name of the patch deployment in the form `projects/*/patchDeployments/*`.</param>
		/// <returns>Successful response</returns>
		public async Task<PatchDeployment> Osconfig_projects_patchDeployments_resumeAsync(string name, ResumePatchDeploymentRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":resume";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PatchDeployment>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a page of OS Config guest policies.
		/// Osconfig_projects_guestPolicies_list v1beta/{parent}/guestPolicies
		/// </summary>
		/// <param name="parent">Required. The resource name of the parent using one of the following forms: `projects/{project_number}`.</param>
		/// <param name="pageSize">The maximum number of guest policies to return.</param>
		/// <param name="pageToken">A pagination token returned from a previous call to `ListGuestPolicies` that indicates where this listing should continue from.</param>
		/// <returns>Successful response</returns>
		public async Task<ListGuestPoliciesResponse> Osconfig_projects_guestPolicies_listAsync(string parent, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/guestPolicies&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListGuestPoliciesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an OS Config guest policy.
		/// Osconfig_projects_guestPolicies_create v1beta/{parent}/guestPolicies
		/// </summary>
		/// <param name="parent">Required. The resource name of the parent using one of the following forms: `projects/{project_number}`.</param>
		/// <param name="guestPolicyId">Required. The logical name of the guest policy in the project with the following restrictions: * Must contain only lowercase letters, numbers, and hyphens. * Must start with a letter. * Must be between 1-63 characters. * Must end with a number or a letter. * Must be unique within the project.</param>
		/// <returns>Successful response</returns>
		public async Task<GuestPolicy> Osconfig_projects_guestPolicies_createAsync(string parent, string guestPolicyId, GuestPolicy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/guestPolicies&guestPolicyId=" + (guestPolicyId==null? "" : System.Uri.EscapeDataString(guestPolicyId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GuestPolicy>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a list of instance details for a given patch job.
		/// Osconfig_projects_patchJobs_instanceDetails_list v1beta/{parent}/instanceDetails
		/// </summary>
		/// <param name="parent">Required. The parent for the instances are in the form of `projects/*/patchJobs/*`.</param>
		/// <param name="filter">A filter expression that filters results listed in the response. This field supports filtering results by instance zone, name, state, or `failure_reason`.</param>
		/// <param name="pageSize">The maximum number of instance details records to return. Default is 100.</param>
		/// <param name="pageToken">A pagination token returned from a previous call that indicates where this listing should continue from.</param>
		/// <returns>Successful response</returns>
		public async Task<ListPatchJobInstanceDetailsResponse> Osconfig_projects_patchJobs_instanceDetails_listAsync(string parent, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/instanceDetails&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListPatchJobInstanceDetailsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a page of OS Config patch deployments.
		/// Osconfig_projects_patchDeployments_list v1beta/{parent}/patchDeployments
		/// </summary>
		/// <param name="parent">Required. The resource name of the parent in the form `projects/*`.</param>
		/// <param name="pageSize">Optional. The maximum number of patch deployments to return. Default is 100.</param>
		/// <param name="pageToken">Optional. A pagination token returned from a previous call to ListPatchDeployments that indicates where this listing should continue from.</param>
		/// <returns>Successful response</returns>
		public async Task<ListPatchDeploymentsResponse> Osconfig_projects_patchDeployments_listAsync(string parent, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/patchDeployments&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListPatchDeploymentsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an OS Config patch deployment.
		/// Osconfig_projects_patchDeployments_create v1beta/{parent}/patchDeployments
		/// </summary>
		/// <param name="parent">Required. The project to apply this patch deployment to in the form `projects/*`.</param>
		/// <param name="patchDeploymentId">Required. A name for the patch deployment in the project. When creating a name the following rules apply: * Must contain only lowercase letters, numbers, and hyphens. * Must start with a letter. * Must be between 1-63 characters. * Must end with a number or a letter. * Must be unique within the project.</param>
		/// <returns>Successful response</returns>
		public async Task<PatchDeployment> Osconfig_projects_patchDeployments_createAsync(string parent, string patchDeploymentId, PatchDeployment requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/patchDeployments&patchDeploymentId=" + (patchDeploymentId==null? "" : System.Uri.EscapeDataString(patchDeploymentId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PatchDeployment>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a list of patch jobs.
		/// Osconfig_projects_patchJobs_list v1beta/{parent}/patchJobs
		/// </summary>
		/// <param name="parent">Required. In the form of `projects/*`</param>
		/// <param name="filter">If provided, this field specifies the criteria that must be met by patch jobs to be included in the response. Currently, filtering is only available on the patch_deployment field.</param>
		/// <param name="pageSize">The maximum number of instance status to return.</param>
		/// <param name="pageToken">A pagination token returned from a previous call that indicates where this listing should continue from.</param>
		/// <returns>Successful response</returns>
		public async Task<ListPatchJobsResponse> Osconfig_projects_patchJobs_listAsync(string parent, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/patchJobs&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListPatchJobsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patch VM instances by creating and running a patch job.
		/// Osconfig_projects_patchJobs_execute v1beta/{parent}/patchJobs:execute
		/// </summary>
		/// <param name="parent">Required. The project in which to run this patch in the form `projects/*`</param>
		/// <returns>Successful response</returns>
		public async Task<PatchJob> Osconfig_projects_patchJobs_executeAsync(string parent, ExecutePatchJobRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/patchJobs:execute";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PatchJob>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
