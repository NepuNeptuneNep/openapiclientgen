//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CertChain
	{
		
		/// <summary>
		/// The certificates that form the CA chain, from leaf to root order.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificates")]
		public string[] Certificates { get; set; }
	}
	
	/// <summary>
	/// Redis cluster certificate authority
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CertificateAuthority
	{
		
		[System.Runtime.Serialization.DataMember(Name="managedServerCa")]
		public ManagedCertificateAuthority ManagedServerCa { get; set; }
		
		/// <summary>
		/// Identifier. Unique name of the resource in this scope including project, location and cluster using the form: `projects/{project}/locations/{location}/clusters/{cluster}/certificateAuthority`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ManagedCertificateAuthority
	{
		
		/// <summary>
		/// The PEM encoded CA certificate chains for redis managed server authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caCerts")]
		public CertChain[] CaCerts { get; set; }
	}
	
	/// <summary>
	/// A cluster instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Cluster
	{
		
		/// <summary>
		/// Optional. The authorization mode of the Redis cluster. If not provided, auth feature is disabled for the cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizationMode")]
		public System.Nullable<ClusterAuthorizationMode> AuthorizationMode { get; set; }
		
		/// <summary>
		/// Output only. The timestamp associated with the cluster creation request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Output only. Endpoints created on each given network, for Redis clients to connect to the cluster. Currently only one discovery endpoint is supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="discoveryEndpoints")]
		public DiscoveryEndpoint[] DiscoveryEndpoints { get; set; }
		
		/// <summary>
		/// Required. Unique name of the resource in this scope including project and location using the form: `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required. Each PscConfig configures the consumer network where IPs will be designated to the cluster for client access through Private Service Connect Automation. Currently, only one PscConfig is supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pscConfigs")]
		public PscConfig[] PscConfigs { get; set; }
		
		/// <summary>
		/// Output only. PSC connections for discovery of the cluster topology and accessing the cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pscConnections")]
		public PscConnection[] PscConnections { get; set; }
		
		/// <summary>
		/// Optional. The number of replica nodes per shard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replicaCount")]
		public System.Nullable<System.Int32> ReplicaCount { get; set; }
		
		/// <summary>
		/// Required. Number of shards for the Redis cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shardCount")]
		public System.Nullable<System.Int32> ShardCount { get; set; }
		
		/// <summary>
		/// Output only. Redis memory size in GB for the entire cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sizeGb")]
		public System.Nullable<System.Int32> SizeGb { get; set; }
		
		/// <summary>
		/// Output only. The current state of this cluster. Can be CREATING, READY, UPDATING, DELETING and SUSPENDED
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<ClusterState> State { get; set; }
		
		/// <summary>
		/// Represents additional information about the state of the cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stateInfo")]
		public StateInfo StateInfo { get; set; }
		
		/// <summary>
		/// Optional. The in-transit encryption for the Redis cluster. If not provided, encryption is disabled for the cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transitEncryptionMode")]
		public System.Nullable<ClusterTransitEncryptionMode> TransitEncryptionMode { get; set; }
		
		/// <summary>
		/// Output only. System assigned, unique identifier for the cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uid")]
		public string Uid { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ClusterAuthorizationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTH_MODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTH_MODE_IAM_AUTH = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTH_MODE_DISABLED = 2,
	}
	
	/// <summary>
	/// Endpoints on each network, for Redis clients to connect to the cluster.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DiscoveryEndpoint
	{
		
		/// <summary>
		/// Output only. Address of the exposed Redis endpoint used by clients to connect to the service. The address could be either IP or hostname.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// Output only. The port number of the exposed Redis endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pscConfig")]
		public PscConfig PscConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PscConfig
	{
		
		/// <summary>
		/// Required. The network where the IP address of the discovery endpoint will be reserved, in the form of projects/{network_project}/global/networks/{network_id}.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
	}
	
	/// <summary>
	/// Details of consumer resources in a PSC connection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PscConnection
	{
		
		/// <summary>
		/// Output only. The IP allocated on the consumer network for the PSC forwarding rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// Output only. The URI of the consumer side forwarding rule. Example: projects/{projectNumOrId}/regions/us-east1/forwardingRules/{resourceId}.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forwardingRule")]
		public string ForwardingRule { get; set; }
		
		/// <summary>
		/// The consumer network where the IP address resides, in the form of projects/{project_id}/global/networks/{network_id}.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// Output only. The consumer project_id where the forwarding rule is created from.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="projectId")]
		public string ProjectId { get; set; }
		
		/// <summary>
		/// Output only. The PSC connection id of the forwarding rule connected to the service attachment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pscConnectionId")]
		public string PscConnectionId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ClusterState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 4,
	}
	
	/// <summary>
	/// Represents additional information about the state of the cluster.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StateInfo
	{
		
		/// <summary>
		/// Represents information about an updating cluster.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateInfo")]
		public UpdateInfo UpdateInfo { get; set; }
	}
	
	/// <summary>
	/// Represents information about an updating cluster.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateInfo
	{
		
		/// <summary>
		/// Target number of replica nodes per shard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetReplicaCount")]
		public System.Nullable<System.Int32> TargetReplicaCount { get; set; }
		
		/// <summary>
		/// Target number of shards for redis cluster
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetShardCount")]
		public System.Nullable<System.Int32> TargetShardCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ClusterTransitEncryptionMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TRANSIT_ENCRYPTION_MODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TRANSIT_ENCRYPTION_MODE_DISABLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TRANSIT_ENCRYPTION_MODE_SERVER_AUTHENTICATION = 2,
	}
	
	/// <summary>
	/// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Empty
	{
	}
	
	/// <summary>
	/// Request for Export.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ExportInstanceRequest
	{
		
		/// <summary>
		/// The output content
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputConfig")]
		public OutputConfig OutputConfig { get; set; }
	}
	
	/// <summary>
	/// The output content
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OutputConfig
	{
		
		/// <summary>
		/// The Cloud Storage location for the output content
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gcsDestination")]
		public GcsDestination GcsDestination { get; set; }
	}
	
	/// <summary>
	/// The Cloud Storage location for the output content
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GcsDestination
	{
		
		/// <summary>
		/// Required. Data destination URI (e.g. 'gs://my_bucket/my_object'). Existing files will be overwritten.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
	}
	
	/// <summary>
	/// Request for Failover.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FailoverInstanceRequest
	{
		
		/// <summary>
		/// Optional. Available data protection modes that the user can choose. If it's unspecified, data protection mode will be LIMITED_DATA_LOSS by default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataProtectionMode")]
		public System.Nullable<FailoverInstanceRequestDataProtectionMode> DataProtectionMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum FailoverInstanceRequestDataProtectionMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_PROTECTION_MODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LIMITED_DATA_LOSS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FORCE_DATA_LOSS = 2,
	}
	
	/// <summary>
	/// The Cloud Storage location for the input content
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GcsSource
	{
		
		/// <summary>
		/// Required. Source data URI. (e.g. 'gs://my_bucket/my_object').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
	}
	
	/// <summary>
	/// This location metadata represents additional configuration options for a given location where a Redis instance may be created. All fields are output only. It is returned as content of the `google.cloud.location.Location.metadata` field.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleCloudRedisV1LocationMetadata
	{
		
		/// <summary>
		/// Output only. The set of available zones in the location. The map is keyed by the lowercase ID of each zone, as defined by GCE. These keys can be specified in `location_id` or `alternative_location_id` fields when creating a Redis instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableZones")]
		public System.Collections.Generic.Dictionary<string, GoogleCloudRedisV1ZoneMetadata> AvailableZones { get; set; }
	}
	
	/// <summary>
	/// Defines specific information for a particular zone. Currently empty and reserved for future use only.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleCloudRedisV1ZoneMetadata
	{
	}
	
	/// <summary>
	/// Represents the v1 metadata of the long-running operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleCloudRedisV1OperationMetadata
	{
		
		/// <summary>
		/// API version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiVersion")]
		public string ApiVersion { get; set; }
		
		/// <summary>
		/// Specifies if cancellation was requested for the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cancelRequested")]
		public System.Nullable<System.Boolean> CancelRequested { get; set; }
		
		/// <summary>
		/// Creation timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// End timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// Operation status details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusDetail")]
		public string StatusDetail { get; set; }
		
		/// <summary>
		/// Operation target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
		
		/// <summary>
		/// Operation verb.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="verb")]
		public string Verb { get; set; }
	}
	
	/// <summary>
	/// Request for Import.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ImportInstanceRequest
	{
		
		/// <summary>
		/// The input content
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inputConfig")]
		public InputConfig InputConfig { get; set; }
	}
	
	/// <summary>
	/// The input content
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InputConfig
	{
		
		/// <summary>
		/// The Cloud Storage location for the input content
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gcsSource")]
		public GcsSource GcsSource { get; set; }
	}
	
	/// <summary>
	/// A Memorystore for Redis instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Instance
	{
		
		/// <summary>
		/// Optional. If specified, at least one node will be provisioned in this zone in addition to the zone specified in location_id. Only applicable to standard tier. If provided, it must be a different zone from the one provided in [location_id]. Additional nodes beyond the first 2 will be placed in zones selected by the service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alternativeLocationId")]
		public string AlternativeLocationId { get; set; }
		
		/// <summary>
		/// Optional. Indicates whether OSS Redis AUTH is enabled for the instance. If set to "true" AUTH is enabled on the instance. Default value is "false" meaning AUTH is disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authEnabled")]
		public System.Nullable<System.Boolean> AuthEnabled { get; set; }
		
		/// <summary>
		/// Optional. The full name of the Google Compute Engine [network](https://cloud.google.com/vpc/docs/vpc) to which the instance is connected. If left unspecified, the `default` network will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizedNetwork")]
		public string AuthorizedNetwork { get; set; }
		
		/// <summary>
		/// Optional. The available maintenance versions that an instance could update to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableMaintenanceVersions")]
		public string[] AvailableMaintenanceVersions { get; set; }
		
		/// <summary>
		/// Optional. The network connect mode of the Redis instance. If not provided, the connect mode defaults to DIRECT_PEERING.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectMode")]
		public System.Nullable<InstanceConnectMode> ConnectMode { get; set; }
		
		/// <summary>
		/// Output only. The time the instance was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Output only. The current zone where the Redis primary node is located. In basic tier, this will always be the same as [location_id]. In standard tier, this can be the zone of any node in the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentLocationId")]
		public string CurrentLocationId { get; set; }
		
		/// <summary>
		/// Optional. The KMS key reference that the customer provides when trying to create the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customerManagedKey")]
		public string CustomerManagedKey { get; set; }
		
		/// <summary>
		/// An arbitrary and optional user-provided name for the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Output only. Hostname or IP address of the exposed Redis endpoint used by clients to connect to the service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// Resource labels to represent user provided metadata
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Optional. The zone where the instance will be provisioned. If not provided, the service will choose a zone from the specified region for the instance. For standard tier, additional nodes will be added across multiple zones for protection against zonal failures. If specified, at least one node will be provisioned in this zone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationId")]
		public string LocationId { get; set; }
		
		/// <summary>
		/// Maintenance policy for an instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maintenancePolicy")]
		public MaintenancePolicy MaintenancePolicy { get; set; }
		
		/// <summary>
		/// Upcoming maintenance schedule. If no maintenance is scheduled, fields are not populated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maintenanceSchedule")]
		public MaintenanceSchedule MaintenanceSchedule { get; set; }
		
		/// <summary>
		/// Optional. The self service update maintenance version. The version is date based such as "20210712_00_00".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maintenanceVersion")]
		public string MaintenanceVersion { get; set; }
		
		/// <summary>
		/// Required. Redis memory size in GiB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memorySizeGb")]
		public System.Nullable<System.Int32> MemorySizeGb { get; set; }
		
		/// <summary>
		/// Required. Unique name of the resource in this scope including project and location using the form: `projects/{project_id}/locations/{location_id}/instances/{instance_id}` Note: Redis instances are managed and addressed at regional level so location_id here refers to a GCP region; however, users may choose which specific zone (or collection of zones for cross-zone instances) an instance should be provisioned in. Refer to location_id and alternative_location_id fields for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. Info per node.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodes")]
		public NodeInfo[] Nodes { get; set; }
		
		/// <summary>
		/// Configuration of the persistence functionality.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="persistenceConfig")]
		public PersistenceConfig PersistenceConfig { get; set; }
		
		/// <summary>
		/// Output only. Cloud IAM identity used by import / export operations to transfer data to/from Cloud Storage. Format is "serviceAccount:". The value may change over time for a given instance so should be checked before each import/export operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="persistenceIamIdentity")]
		public string PersistenceIamIdentity { get; set; }
		
		/// <summary>
		/// Output only. The port number of the exposed Redis endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Output only. Hostname or IP address of the exposed readonly Redis endpoint. Standard tier only. Targets all healthy replica nodes in instance. Replication is asynchronous and replica nodes will exhibit some lag behind the primary. Write requests must target 'host'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="readEndpoint")]
		public string ReadEndpoint { get; set; }
		
		/// <summary>
		/// Output only. The port number of the exposed readonly redis endpoint. Standard tier only. Write requests should target 'port'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="readEndpointPort")]
		public System.Nullable<System.Int32> ReadEndpointPort { get; set; }
		
		/// <summary>
		/// Optional. Read replicas mode for the instance. Defaults to READ_REPLICAS_DISABLED.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="readReplicasMode")]
		public System.Nullable<InstanceReadReplicasMode> ReadReplicasMode { get; set; }
		
		/// <summary>
		/// Optional. Redis configuration parameters, according to http://redis.io/topics/config. Currently, the only supported parameters are: Redis version 3.2 and newer: * maxmemory-policy * notify-keyspace-events Redis version 4.0 and newer: * activedefrag * lfu-decay-time * lfu-log-factor * maxmemory-gb Redis version 5.0 and newer: * stream-node-max-bytes * stream-node-max-entries
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redisConfigs")]
		public System.Collections.Generic.Dictionary<string, string> RedisConfigs { get; set; }
		
		/// <summary>
		/// Optional. The version of Redis software. If not provided, latest supported version will be used. Currently, the supported values are: * `REDIS_3_2` for Redis 3.2 compatibility * `REDIS_4_0` for Redis 4.0 compatibility (default) * `REDIS_5_0` for Redis 5.0 compatibility * `REDIS_6_X` for Redis 6.x compatibility
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redisVersion")]
		public string RedisVersion { get; set; }
		
		/// <summary>
		/// Optional. The number of replica nodes. The valid range for the Standard Tier with read replicas enabled is [1-5] and defaults to 2. If read replicas are not enabled for a Standard Tier instance, the only valid value is 1 and the default is 1. The valid value for basic tier is 0 and the default is also 0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replicaCount")]
		public System.Nullable<System.Int32> ReplicaCount { get; set; }
		
		/// <summary>
		/// Optional. For DIRECT_PEERING mode, the CIDR range of internal addresses that are reserved for this instance. Range must be unique and non-overlapping with existing subnets in an authorized network. For PRIVATE_SERVICE_ACCESS mode, the name of one allocated IP address ranges associated with this private service access connection. If not provided, the service will choose an unused /29 block, for example, 10.0.0.0/29 or 192.168.0.0/29. For READ_REPLICAS_ENABLED the default block size is /28.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservedIpRange")]
		public string ReservedIpRange { get; set; }
		
		/// <summary>
		/// Optional. Output only. Reserved for future use. Zone Isolation compliance state of the instance. Field name and documentation is obfuscated according to go/per-resource-zi-bit-semantics.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="satisfiesPzi")]
		public System.Nullable<System.Boolean> SatisfiesPzi { get; set; }
		
		/// <summary>
		/// Optional. Output only. Reserved for future use. Zone Separation compliance state of the instance. Field name and documentation is obfuscated according to go/zs-resource-status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="satisfiesPzs")]
		public System.Nullable<System.Boolean> SatisfiesPzs { get; set; }
		
		/// <summary>
		/// Optional. Additional IP range for node placement. Required when enabling read replicas on an existing instance. For DIRECT_PEERING mode value must be a CIDR range of size /28, or "auto". For PRIVATE_SERVICE_ACCESS mode value must be the name of an allocated address range associated with the private service access connection, or "auto".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondaryIpRange")]
		public string SecondaryIpRange { get; set; }
		
		/// <summary>
		/// Output only. List of server CA certificates for the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serverCaCerts")]
		public TlsCertificate[] ServerCaCerts { get; set; }
		
		/// <summary>
		/// Output only. The current state of this instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<InstanceState> State { get; set; }
		
		/// <summary>
		/// Output only. Additional information about the current status of this instance, if available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusMessage")]
		public string StatusMessage { get; set; }
		
		/// <summary>
		/// Optional. reasons that causes instance in "SUSPENDED" state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="suspensionReasons")]
		public string[] SuspensionReasons { get; set; }
		
		/// <summary>
		/// Required. The service tier of the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tier")]
		public System.Nullable<InstanceTier> Tier { get; set; }
		
		/// <summary>
		/// Optional. The TLS mode of the Redis instance. If not provided, TLS is disabled for the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transitEncryptionMode")]
		public System.Nullable<InstanceTransitEncryptionMode> TransitEncryptionMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum InstanceConnectMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONNECT_MODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DIRECT_PEERING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIVATE_SERVICE_ACCESS = 2,
	}
	
	/// <summary>
	/// Maintenance policy for an instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MaintenancePolicy
	{
		
		/// <summary>
		/// Output only. The time when the policy was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Optional. Description of what this policy is for. Create/Update methods return INVALID_ARGUMENT if the length is greater than 512.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Output only. The time when the policy was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
		
		/// <summary>
		/// Optional. Maintenance window that is applied to resources covered by this policy. Minimum 1. For the current version, the maximum number of weekly_window is expected to be one.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="weeklyMaintenanceWindow")]
		public WeeklyMaintenanceWindow[] WeeklyMaintenanceWindow { get; set; }
	}
	
	/// <summary>
	/// Time window in which disruptive maintenance updates occur. Non-disruptive updates can occur inside or outside this window.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WeeklyMaintenanceWindow
	{
		
		/// <summary>
		/// Required. The day of week that maintenance updates occur.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="day")]
		public System.Nullable<WeeklyMaintenanceWindowDay> Day { get; set; }
		
		/// <summary>
		/// Output only. Duration of the maintenance window. The current window is fixed at 1 hour.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public string Duration { get; set; }
		
		/// <summary>
		/// Represents a time of day. The date and time zone are either not significant or are specified elsewhere. An API may choose to allow leap seconds. Related types are google.type.Date and `google.protobuf.Timestamp`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public TimeOfDay StartTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum WeeklyMaintenanceWindowDay
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DAY_OF_WEEK_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MONDAY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TUESDAY = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEDNESDAY = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		THURSDAY = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FRIDAY = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SATURDAY = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUNDAY = 7,
	}
	
	/// <summary>
	/// Represents a time of day. The date and time zone are either not significant or are specified elsewhere. An API may choose to allow leap seconds. Related types are google.type.Date and `google.protobuf.Timestamp`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TimeOfDay
	{
		
		/// <summary>
		/// Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hours")]
		public System.Nullable<System.Int32> Hours { get; set; }
		
		/// <summary>
		/// Minutes of hour of day. Must be from 0 to 59.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minutes")]
		public System.Nullable<System.Int32> Minutes { get; set; }
		
		/// <summary>
		/// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nanos")]
		public System.Nullable<System.Int32> Nanos { get; set; }
		
		/// <summary>
		/// Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seconds")]
		public System.Nullable<System.Int32> Seconds { get; set; }
	}
	
	/// <summary>
	/// Upcoming maintenance schedule. If no maintenance is scheduled, fields are not populated.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MaintenanceSchedule
	{
		
		/// <summary>
		/// If the scheduled maintenance can be rescheduled, default is true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canReschedule")]
		public System.Nullable<System.Boolean> CanReschedule { get; set; }
		
		/// <summary>
		/// Output only. The end time of any upcoming scheduled maintenance for this instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// Output only. The deadline that the maintenance schedule start time can not go beyond, including reschedule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleDeadlineTime")]
		public string ScheduleDeadlineTime { get; set; }
		
		/// <summary>
		/// Output only. The start time of any upcoming scheduled maintenance for this instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
	}
	
	/// <summary>
	/// Node specific properties.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NodeInfo
	{
		
		/// <summary>
		/// Output only. Node identifying string. e.g. 'node-0', 'node-1'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Output only. Location of the node.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	/// <summary>
	/// Configuration of the persistence functionality.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PersistenceConfig
	{
		
		/// <summary>
		/// Optional. Controls whether Persistence features are enabled. If not provided, the existing value will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="persistenceMode")]
		public System.Nullable<PersistenceConfigPersistenceMode> PersistenceMode { get; set; }
		
		/// <summary>
		/// Output only. The next time that a snapshot attempt is scheduled to occur.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rdbNextSnapshotTime")]
		public string RdbNextSnapshotTime { get; set; }
		
		/// <summary>
		/// Optional. Period between RDB snapshots. Snapshots will be attempted every period starting from the provided snapshot start time. For example, a start time of 01/01/2033 06:45 and SIX_HOURS snapshot period will do nothing until 01/01/2033, and then trigger snapshots every day at 06:45, 12:45, 18:45, and 00:45 the next day, and so on. If not provided, TWENTY_FOUR_HOURS will be used as default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rdbSnapshotPeriod")]
		public System.Nullable<PersistenceConfigRdbSnapshotPeriod> RdbSnapshotPeriod { get; set; }
		
		/// <summary>
		/// Optional. Date and time that the first snapshot was/will be attempted, and to which future snapshots will be aligned. If not provided, the current time will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rdbSnapshotStartTime")]
		public string RdbSnapshotStartTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PersistenceConfigPersistenceMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PERSISTENCE_MODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RDB = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PersistenceConfigRdbSnapshotPeriod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SNAPSHOT_PERIOD_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONE_HOUR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SIX_HOURS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TWELVE_HOURS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TWENTY_FOUR_HOURS = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum InstanceReadReplicasMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READ_REPLICAS_MODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READ_REPLICAS_DISABLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READ_REPLICAS_ENABLED = 2,
	}
	
	/// <summary>
	/// TlsCertificate Resource
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TlsCertificate
	{
		
		/// <summary>
		/// PEM representation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cert")]
		public string Cert { get; set; }
		
		/// <summary>
		/// Output only. The time when the certificate was created in [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example `2020-05-18T00:00:00.094Z`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Output only. The time when the certificate expires in [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example `2020-05-18T00:00:00.094Z`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expireTime")]
		public string ExpireTime { get; set; }
		
		/// <summary>
		/// Serial number, as extracted from the certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serialNumber")]
		public string SerialNumber { get; set; }
		
		/// <summary>
		/// Sha1 Fingerprint of the certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sha1Fingerprint")]
		public string Sha1Fingerprint { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum InstanceState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READY = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REPAIRING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MAINTENANCE = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IMPORTING = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILING_OVER = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum InstanceTier
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TIER_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BASIC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STANDARD_HA = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum InstanceTransitEncryptionMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TRANSIT_ENCRYPTION_MODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SERVER_AUTHENTICATION = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 2,
	}
	
	/// <summary>
	/// Instance AUTH string details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InstanceAuthString
	{
		
		/// <summary>
		/// AUTH string set on the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authString")]
		public string AuthString { get; set; }
	}
	
	/// <summary>
	/// Response for ListClusters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListClustersResponse
	{
		
		/// <summary>
		/// A list of Redis clusters in the project in the specified location, or across all locations. If the `location_id` in the parent field of the request is "-", all regions available to the project are queried, and the results aggregated. If in such an aggregated query a location is unavailable, a placeholder Redis entry is included in the response with the `name` field set to a value of the form `projects/{project_id}/locations/{location_id}/clusters/`- and the `status` field set to ERROR and `status_message` field set to "location not available for ListClusters".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clusters")]
		public Cluster[] Clusters { get; set; }
		
		/// <summary>
		/// Token to retrieve the next page of results, or empty if there are no more results in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// Response for ListInstances.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListInstancesResponse
	{
		
		/// <summary>
		/// A list of Redis instances in the project in the specified location, or across all locations. If the `location_id` in the parent field of the request is "-", all regions available to the project are queried, and the results aggregated. If in such an aggregated query a location is unavailable, a placeholder Redis entry is included in the response with the `name` field set to a value of the form `projects/{project_id}/locations/{location_id}/instances/`- and the `status` field set to ERROR and `status_message` field set to "location not available for ListInstances".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public Instance[] Instances { get; set; }
		
		/// <summary>
		/// Token to retrieve the next page of results, or empty if there are no more results in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// The response message for Locations.ListLocations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListLocationsResponse
	{
		
		/// <summary>
		/// A list of locations that matches the specified filter in the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locations")]
		public Location[] Locations { get; set; }
		
		/// <summary>
		/// The standard List next-page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// A resource that represents a Google Cloud location.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Location
	{
		
		/// <summary>
		/// The friendly name for this location, typically a nearby city name. For example, "Tokyo".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Cross-service attributes for the location. For example {"cloud.googleapis.com/region": "us-east1"}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Resource ID for the region. For example: "us-east1".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationId")]
		public string LocationId { get; set; }
		
		/// <summary>
		/// Output only. The set of available zones in the location. The map is keyed by the lowercase ID of each zone, as defined by Compute Engine. These keys can be specified in `location_id` or `alternative_location_id` fields when creating a Redis instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, object> Metadata { get; set; }
		
		/// <summary>
		/// Full resource name for the region. For example: "projects/example-project/locations/us-east1".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// The response message for Operations.ListOperations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListOperationsResponse
	{
		
		/// <summary>
		/// The standard List next-page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// A list of operations that matches the specified filter in the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operations")]
		public Operation[] Operations { get; set; }
	}
	
	/// <summary>
	/// This resource represents a long-running operation that is the result of a network API call.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Operation
	{
		
		/// <summary>
		/// If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="done")]
		public System.Nullable<System.Boolean> Done { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Status Error { get; set; }
		
		/// <summary>
		/// { `createTime`: The time the operation was created. `endTime`: The time the operation finished running. `target`: Server-defined resource path for the target of the operation. `verb`: Name of the verb executed by the operation. `statusDetail`: Human-readable status of the operation, if any. `cancelRequested`: Identifies whether the user has requested cancellation of the operation. Operations that have successfully been cancelled have Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`. `apiVersion`: API version used to start the operation. }
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, object> Metadata { get; set; }
		
		/// <summary>
		/// The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public System.Collections.Generic.Dictionary<string, object> Response { get; set; }
	}
	
	/// <summary>
	/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Status
	{
		
		/// <summary>
		/// The status code, which should be an enum value of google.rpc.Code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// A list of messages that carry the error details. There is a common set of message types for APIs to use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string[] Details { get; set; }
		
		/// <summary>
		/// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// Pre-defined metadata fields.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OperationMetadata
	{
		
		/// <summary>
		/// Output only. API version used to start the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiVersion")]
		public string ApiVersion { get; set; }
		
		/// <summary>
		/// Output only. The time the operation was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Output only. The time the operation finished running.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// Output only. Identifies whether the user has requested cancellation of the operation. Operations that have successfully been cancelled have Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestedCancellation")]
		public System.Nullable<System.Boolean> RequestedCancellation { get; set; }
		
		/// <summary>
		/// Output only. Human-readable status of the operation, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusMessage")]
		public string StatusMessage { get; set; }
		
		/// <summary>
		/// Output only. Server-defined resource path for the target of the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
		
		/// <summary>
		/// Output only. Name of the verb executed by the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="verb")]
		public string Verb { get; set; }
	}
	
	/// <summary>
	/// Operation metadata returned by the CLH during resource state reconciliation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ReconciliationOperationMetadata
	{
		
		/// <summary>
		/// DEPRECATED. Use exclusive_action instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deleteResource")]
		public System.Nullable<System.Boolean> DeleteResource { get; set; }
		
		/// <summary>
		/// Excluisive action returned by the CLH.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclusiveAction")]
		public System.Nullable<ReconciliationOperationMetadataExclusiveAction> ExclusiveAction { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ReconciliationOperationMetadataExclusiveAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN_REPAIR_ACTION = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RETRY = 2,
	}
	
	/// <summary>
	/// Request for RescheduleMaintenance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RescheduleMaintenanceRequest
	{
		
		/// <summary>
		/// Required. If reschedule type is SPECIFIC_TIME, must set up schedule_time as well.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rescheduleType")]
		public System.Nullable<RescheduleMaintenanceRequestRescheduleType> RescheduleType { get; set; }
		
		/// <summary>
		/// Optional. Timestamp when the maintenance shall be rescheduled to if reschedule_type=SPECIFIC_TIME, in RFC 3339 format, for example `2012-11-15T16:19:00.094Z`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleTime")]
		public string ScheduleTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RescheduleMaintenanceRequestRescheduleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESCHEDULE_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IMMEDIATE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NEXT_AVAILABLE_WINDOW = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SPECIFIC_TIME = 3,
	}
	
	/// <summary>
	/// Request for UpgradeInstance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpgradeInstanceRequest
	{
		
		/// <summary>
		/// Required. Specifies the target version of Redis software to upgrade to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redisVersion")]
		public string RedisVersion { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Deletes a long-running operation. This method indicates that the client is no longer interested in the operation result. It does not cancel the operation. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
		/// Redis_projects_locations_operations_delete v1/{name}
		/// </summary>
		/// <param name="name">The name of the operation resource to be deleted.</param>
		/// <param name="requestId">Idempotent request UUID.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Redis_projects_locations_operations_deleteAsync(string name, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the latest state of a long-running operation. Clients can use this method to poll the operation result at intervals as recommended by the API service.
		/// Redis_projects_locations_operations_get v1/{name}
		/// </summary>
		/// <param name="name">The name of the operation resource.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Redis_projects_locations_operations_getAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the metadata and configuration of a specific Redis instance. Completed longrunning.Operation will contain the new instance object in the response field. The returned operation is automatically deleted after a few hours, so there is no need to call DeleteOperation.
		/// Redis_projects_locations_instances_patch v1/{name}
		/// </summary>
		/// <param name="name">Required. Unique name of the resource in this scope including project and location using the form: `projects/{project_id}/locations/{location_id}/instances/{instance_id}` Note: Redis instances are managed and addressed at regional level so location_id here refers to a GCP region; however, users may choose which specific zone (or collection of zones for cross-zone instances) an instance should be provisioned in. Refer to location_id and alternative_location_id fields for more details.</param>
		/// <param name="updateMask">Required. Mask of fields to update. At least one path must be supplied in this field. The elements of the repeated paths field may only include these fields from Instance: * `displayName` * `labels` * `memorySizeGb` * `redisConfig` * `replica_count`</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Redis_projects_locations_instances_patchAsync(string name, string updateMask, Instance requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the AUTH string for a Redis instance. If AUTH is not enabled for the instance the response will be empty. This information is not included in the details returned to GetInstance.
		/// Redis_projects_locations_instances_getAuthString v1/{name}/authString
		/// </summary>
		/// <param name="name">Required. Redis instance resource name using the form: `projects/{project_id}/locations/{location_id}/instances/{instance_id}` where `location_id` refers to a GCP region.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceAuthString> Redis_projects_locations_instances_getAuthStringAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/authString";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<InstanceAuthString>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the details of certificate authority information for Redis cluster.
		/// Redis_projects_locations_clusters_getCertificateAuthority v1/{name}/certificateAuthority
		/// </summary>
		/// <param name="name">Required. Redis cluster certificate authority resource name using the form: `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}/certificateAuthority` where `location_id` refers to a GCP region.</param>
		/// <returns>Successful response</returns>
		public async Task<CertificateAuthority> Redis_projects_locations_clusters_getCertificateAuthorityAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/certificateAuthority";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CertificateAuthority>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists information about the supported locations for this service.
		/// Redis_projects_locations_list v1/{name}/locations
		/// </summary>
		/// <param name="name">The resource that owns the locations collection, if applicable.</param>
		/// <param name="filter">A filter to narrow down results to a preferred subset. The filtering language accepts strings like `"displayName=tokyo"`, and is documented in more detail in [AIP-160](https://google.aip.dev/160).</param>
		/// <param name="pageSize">The maximum number of results to return. If not set, the service selects a default.</param>
		/// <param name="pageToken">A page token received from the `next_page_token` field in the response. Send that page token to receive the subsequent page.</param>
		/// <returns>Successful response</returns>
		public async Task<ListLocationsResponse> Redis_projects_locations_listAsync(string name, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/locations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListLocationsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists operations that match the specified filter in the request. If the server doesn't support this method, it returns `UNIMPLEMENTED`.
		/// Redis_projects_locations_operations_list v1/{name}/operations
		/// </summary>
		/// <param name="name">The name of the operation's parent resource.</param>
		/// <param name="filter">The standard list filter.</param>
		/// <param name="pageSize">The standard list page size.</param>
		/// <param name="pageToken">The standard list page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListOperationsResponse> Redis_projects_locations_operations_listAsync(string name, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/operations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListOperationsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`.
		/// Redis_projects_locations_operations_cancel v1/{name}:cancel
		/// </summary>
		/// <param name="name">The name of the operation resource to be cancelled.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Redis_projects_locations_operations_cancelAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":cancel";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Export Redis instance data into a Redis RDB format file in Cloud Storage. Redis will continue serving during this operation. The returned operation is automatically deleted after a few hours, so there is no need to call DeleteOperation.
		/// Redis_projects_locations_instances_export v1/{name}:export
		/// </summary>
		/// <param name="name">Required. Redis instance resource name using the form: `projects/{project_id}/locations/{location_id}/instances/{instance_id}` where `location_id` refers to a GCP region.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Redis_projects_locations_instances_exportAsync(string name, ExportInstanceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":export";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Initiates a failover of the primary node to current replica node for a specific STANDARD tier Cloud Memorystore for Redis instance.
		/// Redis_projects_locations_instances_failover v1/{name}:failover
		/// </summary>
		/// <param name="name">Required. Redis instance resource name using the form: `projects/{project_id}/locations/{location_id}/instances/{instance_id}` where `location_id` refers to a GCP region.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Redis_projects_locations_instances_failoverAsync(string name, FailoverInstanceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":failover";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Import a Redis RDB snapshot file from Cloud Storage into a Redis instance. Redis may stop serving during this operation. Instance state will be IMPORTING for entire operation. When complete, the instance will contain only data from the imported file. The returned operation is automatically deleted after a few hours, so there is no need to call DeleteOperation.
		/// Redis_projects_locations_instances_import v1/{name}:import
		/// </summary>
		/// <param name="name">Required. Redis instance resource name using the form: `projects/{project_id}/locations/{location_id}/instances/{instance_id}` where `location_id` refers to a GCP region.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Redis_projects_locations_instances_importAsync(string name, ImportInstanceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":import";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reschedule maintenance for a given instance in a given project and location.
		/// Redis_projects_locations_instances_rescheduleMaintenance v1/{name}:rescheduleMaintenance
		/// </summary>
		/// <param name="name">Required. Redis instance resource name using the form: `projects/{project_id}/locations/{location_id}/instances/{instance_id}` where `location_id` refers to a GCP region.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Redis_projects_locations_instances_rescheduleMaintenanceAsync(string name, RescheduleMaintenanceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":rescheduleMaintenance";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Upgrades Redis instance to the newer Redis version specified in the request.
		/// Redis_projects_locations_instances_upgrade v1/{name}:upgrade
		/// </summary>
		/// <param name="name">Required. Redis instance resource name using the form: `projects/{project_id}/locations/{location_id}/instances/{instance_id}` where `location_id` refers to a GCP region.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Redis_projects_locations_instances_upgradeAsync(string name, UpgradeInstanceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":upgrade";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all Redis clusters owned by a project in either the specified location (region) or all locations. The location should have the following format: * `projects/{project_id}/locations/{location_id}` If `location_id` is specified as `-` (wildcard), then all regions available to the project are queried, and the results are aggregated.
		/// Redis_projects_locations_clusters_list v1/{parent}/clusters
		/// </summary>
		/// <param name="parent">Required. The resource name of the cluster location using the form: `projects/{project_id}/locations/{location_id}` where `location_id` refers to a GCP region.</param>
		/// <param name="pageSize">The maximum number of items to return. If not specified, a default value of 1000 will be used by the service. Regardless of the page_size value, the response may include a partial list and a caller should only rely on response's `next_page_token` to determine if there are more clusters left to be queried.</param>
		/// <param name="pageToken">The `next_page_token` value returned from a previous ListClusters request, if any.</param>
		/// <returns>Successful response</returns>
		public async Task<ListClustersResponse> Redis_projects_locations_clusters_listAsync(string parent, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/clusters&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListClustersResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a Redis cluster based on the specified properties. The creation is executed asynchronously and callers may check the returned operation to track its progress. Once the operation is completed the Redis cluster will be fully functional. The completed longrunning.Operation will contain the new cluster object in the response field. The returned operation is automatically deleted after a few hours, so there is no need to call DeleteOperation.
		/// Redis_projects_locations_clusters_create v1/{parent}/clusters
		/// </summary>
		/// <param name="parent">Required. The resource name of the cluster location using the form: `projects/{project_id}/locations/{location_id}` where `location_id` refers to a GCP region.</param>
		/// <param name="clusterId">Required. The logical name of the Redis cluster in the customer project with the following restrictions: * Must contain only lowercase letters, numbers, and hyphens. * Must start with a letter. * Must be between 1-63 characters. * Must end with a number or a letter. * Must be unique within the customer project / location</param>
		/// <param name="requestId">Idempotent request UUID.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Redis_projects_locations_clusters_createAsync(string parent, string clusterId, string requestId, Cluster requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/clusters&clusterId=" + (clusterId==null? "" : System.Uri.EscapeDataString(clusterId))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all Redis instances owned by a project in either the specified location (region) or all locations. The location should have the following format: * `projects/{project_id}/locations/{location_id}` If `location_id` is specified as `-` (wildcard), then all regions available to the project are queried, and the results are aggregated.
		/// Redis_projects_locations_instances_list v1/{parent}/instances
		/// </summary>
		/// <param name="parent">Required. The resource name of the instance location using the form: `projects/{project_id}/locations/{location_id}` where `location_id` refers to a GCP region.</param>
		/// <param name="pageSize">The maximum number of items to return. If not specified, a default value of 1000 will be used by the service. Regardless of the page_size value, the response may include a partial list and a caller should only rely on response's `next_page_token` to determine if there are more instances left to be queried.</param>
		/// <param name="pageToken">The `next_page_token` value returned from a previous ListInstances request, if any.</param>
		/// <returns>Successful response</returns>
		public async Task<ListInstancesResponse> Redis_projects_locations_instances_listAsync(string parent, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/instances&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListInstancesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a Redis instance based on the specified tier and memory size. By default, the instance is accessible from the project's [default network](https://cloud.google.com/vpc/docs/vpc). The creation is executed asynchronously and callers may check the returned operation to track its progress. Once the operation is completed the Redis instance will be fully functional. Completed longrunning.Operation will contain the new instance object in the response field. The returned operation is automatically deleted after a few hours, so there is no need to call DeleteOperation.
		/// Redis_projects_locations_instances_create v1/{parent}/instances
		/// </summary>
		/// <param name="parent">Required. The resource name of the instance location using the form: `projects/{project_id}/locations/{location_id}` where `location_id` refers to a GCP region.</param>
		/// <param name="instanceId">Required. The logical name of the Redis instance in the customer project with the following restrictions: * Must contain only lowercase letters, numbers, and hyphens. * Must start with a letter. * Must be between 1-40 characters. * Must end with a number or a letter. * Must be unique within the customer project / location</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Redis_projects_locations_instances_createAsync(string parent, string instanceId, Instance requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/instances&instanceId=" + (instanceId==null? "" : System.Uri.EscapeDataString(instanceId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
