//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BadRequestException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ForbiddenException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotFoundException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UnauthorizedClientException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConflictException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ThrottledClientException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServiceUnavailableException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServiceFailureException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchCreateChannelMembershipResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BatchChannelMemberships BatchChannelMemberships { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BatchCreateChannelMembershipError[] Errors { get; set; }
	}
	
	/// <summary>
	/// The membership information, including member ARNs, the channel ARN, and membership types.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchChannelMemberships
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Identity InvitedBy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMembershipType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Identity[] Members { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SubChannelId { get; set; }
	}
	
	/// <summary>
	/// The details of a user or bot.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Identity
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ChannelMembershipType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DEFAULT")]
		DEFAULT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HIDDEN")]
		HIDDEN = 1,
	}
	
	/// <summary>
	/// A list of failed member ARNs, error codes, and error messages.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchCreateChannelMembershipError
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string MemberArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ErrorCode ErrorCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ErrorMessage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ErrorCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BadRequest")]
		BadRequest = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Conflict")]
		Conflict = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Forbidden")]
		Forbidden = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NotFound")]
		NotFound = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PreconditionFailed")]
		PreconditionFailed = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ResourceLimitExceeded")]
		ResourceLimitExceeded = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ServiceFailure")]
		ServiceFailure = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AccessDenied")]
		AccessDenied = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ServiceUnavailable")]
		ServiceUnavailable = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Throttled")]
		Throttled = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Throttling")]
		Throttling = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unauthorized")]
		Unauthorized = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unprocessable")]
		Unprocessable = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VoiceConnectorGroupAssociationsExist")]
		VoiceConnectorGroupAssociationsExist = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PhoneNumberAssociationsExist")]
		PhoneNumberAssociationsExist = 14,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceLimitExceededException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelFlowCallbackResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CallbackId { get; set; }
	}
	
	/// <summary>
	/// The push notification configuration of the message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PushNotificationConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Body { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PushNotificationType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PushNotificationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DEFAULT")]
		DEFAULT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VOIP")]
		VOIP = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MessageAttributeMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateChannelResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
	}
	
	/// <summary>
	/// A tag object containing a key-value pair.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Tag
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ExpirationCriterion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CREATED_TIMESTAMP")]
		CREATED_TIMESTAMP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LAST_MESSAGE_TIMESTAMP")]
		LAST_MESSAGE_TIMESTAMP = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateChannelBanResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Identity Member { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateChannelFlowResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelFlowArn { get; set; }
	}
	
	/// <summary>
	/// The information about a processor in a channel flow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Processor
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ProcessorConfiguration Configuration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int ExecutionOrder { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public FallbackAction FallbackAction { get; set; }
	}
	
	/// <summary>
	/// A processor's metadata.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProcessorConfiguration
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public LambdaConfiguration Lambda { get; set; }
	}
	
	/// <summary>
	/// Stores metadata about a Lambda processor.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LambdaConfiguration
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public InvocationType InvocationType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum InvocationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ASYNC")]
		ASYNC = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum FallbackAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CONTINUE")]
		CONTINUE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ABORT")]
		ABORT = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateChannelMembershipResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Identity Member { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SubChannelId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateChannelModeratorResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Identity ChannelModerator { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeChannelResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Channel Channel { get; set; }
	}
	
	/// <summary>
	/// The details of a channel.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Channel
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMode Mode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelPrivacy Privacy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Identity CreatedBy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastMessageTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastUpdatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelFlowArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ElasticChannelConfiguration ElasticChannelConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpirationSettings ExpirationSettings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ChannelMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UNRESTRICTED")]
		UNRESTRICTED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RESTRICTED")]
		RESTRICTED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ChannelPrivacy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PUBLIC")]
		PUBLIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PRIVATE")]
		PRIVATE = 1,
	}
	
	/// <summary>
	/// The attributes required to configure and create an elastic channel. An elastic channel can support a maximum of 1-million members.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ElasticChannelConfiguration
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int MaximumSubChannels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int TargetMembershipsPerSubChannel { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int MinimumMembershipPercentage { get; set; }
	}
	
	/// <summary>
	/// Settings that control the interval after which a channel is deleted.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExpirationSettings
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int ExpirationDays { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ExpirationCriterion ExpirationCriterion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeChannelBanResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelBan ChannelBan { get; set; }
	}
	
	/// <summary>
	/// The details of a channel ban.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelBan
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Identity Member { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Identity CreatedBy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeChannelFlowResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelFlow ChannelFlow { get; set; }
	}
	
	/// <summary>
	/// The details of a channel flow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelFlow
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelFlowArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Processor[] Processors { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastUpdatedTimestamp { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeChannelMembershipResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMembership ChannelMembership { get; set; }
	}
	
	/// <summary>
	/// The details of a channel member.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelMembership
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Identity InvitedBy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMembershipType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Identity Member { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastUpdatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SubChannelId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeChannelMembershipForAppInstanceUserResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMembershipForAppInstanceUserSummary ChannelMembership { get; set; }
	}
	
	/// <summary>
	/// Summary of the channel membership details of an <code>AppInstanceUser</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelMembershipForAppInstanceUserSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelSummary ChannelSummary { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AppInstanceUserMembershipSummary AppInstanceUserMembershipSummary { get; set; }
	}
	
	/// <summary>
	/// Summary of the details of a <code>Channel</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMode Mode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelPrivacy Privacy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastMessageTimestamp { get; set; }
	}
	
	/// <summary>
	/// Summary of the membership details of an <code>AppInstanceUser</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AppInstanceUserMembershipSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMembershipType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ReadMarkerTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SubChannelId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeChannelModeratedByAppInstanceUserResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelModeratedByAppInstanceUserSummary Channel { get; set; }
	}
	
	/// <summary>
	/// Summary of the details of a moderated channel.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelModeratedByAppInstanceUserSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelSummary ChannelSummary { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeChannelModeratorResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelModerator ChannelModerator { get; set; }
	}
	
	/// <summary>
	/// The details of a channel moderator.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelModerator
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Identity Moderator { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Identity CreatedBy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetChannelMembershipPreferencesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Identity Member { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMembershipPreferences Preferences { get; set; }
	}
	
	/// <summary>
	/// The channel membership preferences for an <code>AppInstanceUser</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelMembershipPreferences
	{
		
		[System.Runtime.Serialization.DataMember()]
		public PushNotificationPreferences PushNotifications { get; set; }
	}
	
	/// <summary>
	/// The channel membership preferences for push notification.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PushNotificationPreferences
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AllowNotifications AllowNotifications { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string FilterRule { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AllowNotifications
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ALL")]
		ALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NONE")]
		NONE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FILTERED")]
		FILTERED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetChannelMessageResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMessage ChannelMessage { get; set; }
	}
	
	/// <summary>
	/// The details of a message in a channel.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelMessage
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string MessageId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Content { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMessageType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastEditedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastUpdatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Identity Sender { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Redacted { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMessagePersistenceType Persistence { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMessageStatusStructure Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MessageAttributeMap MessageAttributes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SubChannelId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ContentType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Target[] Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ChannelMessageType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="STANDARD")]
		STANDARD = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CONTROL")]
		CONTROL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ChannelMessagePersistenceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PERSISTENT")]
		PERSISTENT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NON_PERSISTENT")]
		NON_PERSISTENT = 1,
	}
	
	/// <summary>
	/// Stores information about a message status.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelMessageStatusStructure
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMessageStatus Value { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Detail { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ChannelMessageStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SENT")]
		SENT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PENDING")]
		PENDING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FAILED")]
		FAILED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DENIED")]
		DENIED = 3,
	}
	
	/// <summary>
	/// The target of a message, a sender, a user, or a bot. Only the target and the sender can view targeted messages. Only users who can see targeted messages can take actions on them. However, administrators can delete targeted messages that they can’t see.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Target
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string MemberArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetChannelMessageStatusResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMessageStatusStructure Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetMessagingSessionEndpointResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public MessagingSessionEndpoint Endpoint { get; set; }
	}
	
	/// <summary>
	/// The websocket endpoint used to connect to Amazon Chime SDK messaging.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MessagingSessionEndpoint
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetMessagingStreamingConfigurationsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public StreamingConfiguration[] StreamingConfigurations { get; set; }
	}
	
	/// <summary>
	/// The configuration for connecting a messaging stream to Amazon Kinesis.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StreamingConfiguration
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public MessagingDataType DataType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MessagingDataType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Channel")]
		Channel = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ChannelMessage")]
		ChannelMessage = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelBansResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelBanSummary[] ChannelBans { get; set; }
	}
	
	/// <summary>
	/// Summary of the details of a <code>ChannelBan</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelBanSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Identity Member { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelFlowsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelFlowSummary[] ChannelFlows { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Summary of details of a channel flow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelFlowSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelFlowArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Processor[] Processors { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelMembershipsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMembershipSummary[] ChannelMemberships { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Summary of the details of a <code>ChannelMembership</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelMembershipSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Identity Member { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelMembershipsForAppInstanceUserResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMembershipForAppInstanceUserSummary[] ChannelMemberships { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelMessagesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMessageSummary[] ChannelMessages { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SubChannelId { get; set; }
	}
	
	/// <summary>
	/// Summary of the messages in a <code>Channel</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelMessageSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string MessageId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Content { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMessageType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastUpdatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastEditedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Identity Sender { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Redacted { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMessageStatusStructure Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MessageAttributeMap MessageAttributes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ContentType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Target[] Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelModeratorsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelModeratorSummary[] ChannelModerators { get; set; }
	}
	
	/// <summary>
	/// Summary of the details of a <code>ChannelModerator</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelModeratorSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Identity Moderator { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelSummary[] Channels { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelsAssociatedWithChannelFlowResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelAssociatedWithFlowSummary[] Channels { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Summary of details of a channel associated with channel flow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelAssociatedWithFlowSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMode Mode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelPrivacy Privacy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Metadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelsModeratedByAppInstanceUserResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelModeratedByAppInstanceUserSummary[] Channels { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListSubChannelsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SubChannelSummary[] SubChannels { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Summary of the sub-channels associated with the elastic channel.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubChannelSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string SubChannelId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MembershipCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutChannelExpirationSettingsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpirationSettings ExpirationSettings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutChannelMembershipPreferencesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Identity Member { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMembershipPreferences Preferences { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutMessagingStreamingConfigurationsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public StreamingConfiguration[] StreamingConfigurations { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RedactChannelMessageResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string MessageId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SubChannelId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SearchChannelsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelSummary[] Channels { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// A <code>Field</code> of the channel that you want to search.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SearchField
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public SearchFieldKey Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] Values { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public SearchFieldOperator Operator { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SearchFieldKey
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MEMBERS")]
		MEMBERS = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SearchFieldOperator
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="EQUALS")]
		EQUALS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INCLUDES")]
		INCLUDES = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SendChannelMessageResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string MessageId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMessageStatusStructure Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SubChannelId { get; set; }
	}
	
	/// <summary>
	/// A list of message attribute values.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MessageAttributeValue
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string[] StringValues { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateChannelResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateChannelFlowResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelFlowArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateChannelMessageResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string MessageId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMessageStatusStructure Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SubChannelId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateChannelReadMarkerResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AssociateChannelFlowRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ChannelFlowArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchCreateChannelMembershipRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMembershipType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] MemberArns { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SubChannelId { get; set; }
	}
	
	/// <summary>
	/// Stores information about a callback.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelMessageCallback
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string MessageId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Content { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PushNotificationConfiguration PushNotification { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MessageAttributeMap MessageAttributes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SubChannelId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ContentType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChannelFlowCallbackRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CallbackId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> DeleteResource { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChannelMessageCallback ChannelMessage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateChannelBanRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string MemberArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateChannelFlowRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AppInstanceArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Processor[] Processors { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ClientRequestToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateChannelMembershipRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string MemberArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChannelMembershipType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SubChannelId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateChannelModeratorRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ChannelModeratorArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateChannelRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AppInstanceArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMode Mode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelPrivacy Privacy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Metadata { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ClientRequestToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ChannelId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] MemberArns { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] ModeratorArns { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ElasticChannelConfiguration ElasticChannelConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpirationSettings ExpirationSettings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteChannelBanRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteChannelFlowRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteChannelMembershipRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteChannelMessageRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteChannelModeratorRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteChannelRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteMessagingStreamingConfigurationsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeChannelBanRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeChannelFlowRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeChannelMembershipForAppInstanceUserRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeChannelMembershipRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeChannelModeratedByAppInstanceUserRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeChannelModeratorRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeChannelRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisassociateChannelFlowRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetChannelMembershipPreferencesRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetChannelMessageRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetChannelMessageStatusRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetMessagingSessionEndpointRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetMessagingStreamingConfigurationsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelBansRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelFlowsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelMembershipsForAppInstanceUserRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelMembershipsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SortOrder
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ASCENDING")]
		ASCENDING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DESCENDING")]
		DESCENDING = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelMessagesRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelModeratorsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelsAssociatedWithChannelFlowRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelsModeratedByAppInstanceUserRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListChannelsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListSubChannelsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutChannelExpirationSettingsRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ExpirationSettings ExpirationSettings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutChannelMembershipPreferencesRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChannelMembershipPreferences Preferences { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutMessagingStreamingConfigurationsRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public StreamingConfiguration[] StreamingConfigurations { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RedactChannelMessageRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string SubChannelId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SearchChannelsRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public SearchField[] Fields { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SendChannelMessageRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Content { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChannelMessageType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChannelMessagePersistenceType Persistence { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Metadata { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ClientRequestToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PushNotificationConfiguration PushNotification { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MessageAttributeMap MessageAttributes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SubChannelId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ContentType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Target[] Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagResourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceARN { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UntagResourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceARN { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] TagKeys { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateChannelFlowRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Processor[] Processors { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateChannelMessageRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Content { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SubChannelId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ContentType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateChannelReadMarkerRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateChannelRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ChannelMode Mode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Metadata { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// <p>Associates a channel flow with a channel. Once associated, all messages to that channel go through channel flow processors. To stop processing, use the <code>DisassociateChannelFlow</code> API.</p> <note> <p>Only administrators or channel moderators can associate a channel flow. The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// AssociateChannelFlow channels/{channelArn}/channel-flow#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <returns>Success</returns>
		public async Task AssociateChannelFlowAsync(string channelArn, AssociateChannelFlowPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/channel-flow#x-amz-chime-bearer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds a specified number of users and bots to a channel.
		/// BatchCreateChannelMembership channels/{channelArn}/memberships#operation=batch-create&x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel to which you're adding users or bots.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <returns>Success</returns>
		public async Task<BatchCreateChannelMembershipResponse> BatchCreateChannelMembershipAsync(string channelArn, BatchCreateChannelMembershipOperation operation, BatchCreateChannelMembershipPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/memberships#operation=batch-create&x-amz-chime-bearer&operation=" + operation;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BatchCreateChannelMembershipResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Calls back Amazon Chime SDK messaging with a processing response message. This should be invoked from the processor Lambda. This is a developer API.</p> <p>You can return one of the following processing responses:</p> <ul> <li> <p>Update message content or metadata</p> </li> <li> <p>Deny a message</p> </li> <li> <p>Make no changes to the message</p> </li> </ul>
		/// ChannelFlowCallback channels/{channelArn}#operation=channel-flow-callback
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <returns>Success</returns>
		public async Task<ChannelFlowCallbackResponse> ChannelFlowCallbackAsync(string channelArn, ChannelFlowCallbackOperation operation, ChannelFlowCallbackPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"#operation=channel-flow-callback&operation=" + operation;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ChannelFlowCallbackResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a channel to which you can add users and send messages.</p> <p> <b>Restriction</b>: You can't change a channel's privacy.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// CreateChannel channels#x-amz-chime-bearer
		/// </summary>
		public async Task CreateChannelAsync(CreateChannelPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels#x-amz-chime-bearer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Permanently bans a member from a channel. Moderators can't add banned members to a channel. To undo a ban, you first have to <code>DeleteChannelBan</code>, and then <code>CreateChannelMembership</code>. Bans are cleaned up when you delete users or channels.</p> <p>If you ban a user who is already part of a channel, that user is automatically kicked from the channel.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// CreateChannelBan channels/{channelArn}/bans#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the ban request.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		public async Task CreateChannelBanAsync(string channelArn, CreateChannelBanPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/bans#x-amz-chime-bearer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Lists all the users and bots banned from a particular channel.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// ListChannelBans channels/{channelArn}/bans#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="max_results">The maximum number of bans that you want returned.
		/// Minimum: 1
		/// Maximum: 50
		// </param>
		/// <param name="next_token">The token passed by previous API calls until all requested bans are returned.
		/// Max length: 2048
		/// Min length: 0
		// </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListChannelBansResponse> ListChannelBansAsync(string channelArn, int max_results, string next_token, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/bans#x-amz-chime-bearer&max-results="+max_results+"&next-token=" + (next_token==null? "" : System.Uri.EscapeDataString(next_token))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListChannelBansResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a channel flow, a container for processors. Processors are AWS Lambda functions that perform actions on chat messages, such as stripping out profanity. You can associate channel flows with channels, and the processors in the channel flow then take action on all messages sent to that channel. This is a developer API.</p> <p>Channel flows process the following items:</p> <ol> <li> <p>New and updated messages</p> </li> <li> <p>Persistent and non-persistent messages</p> </li> <li> <p>The Standard message type</p> </li> </ol> <note> <p>Channel flows don't process Control or System messages. For more information about the message types provided by Chime SDK messaging, refer to <a href="https://docs.aws.amazon.com/chime/latest/dg/using-the-messaging-sdk.html#msg-types">Message types</a> in the <i>Amazon Chime developer guide</i>.</p> </note>
		/// CreateChannelFlow channel-flows
		/// </summary>
		public async Task CreateChannelFlowAsync(CreateChannelFlowPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channel-flows";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Adds a member to a channel. The <code>InvitedBy</code> field in <code>ChannelMembership</code> is derived from the request header. A channel member can:</p> <ul> <li> <p>List messages</p> </li> <li> <p>Send messages</p> </li> <li> <p>Receive messages</p> </li> <li> <p>Edit their own messages</p> </li> <li> <p>Leave the channel</p> </li> </ul> <p>Privacy settings impact this action as follows:</p> <ul> <li> <p>Public Channels: You do not need to be a member to list messages, but you must be a member to send messages.</p> </li> <li> <p>Private Channels: You must be a member to list or send messages.</p> </li> </ul> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUserArn</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// CreateChannelMembership channels/{channelArn}/memberships#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel to which you're adding users.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		public async Task CreateChannelMembershipAsync(string channelArn, CreateChannelMembershipPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/memberships#x-amz-chime-bearer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Lists all channel memberships in a channel.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note> <p>If you want to list the channels to which a specific app instance user belongs, see the <a href="https://docs.aws.amazon.com/chime/latest/APIReference/API_messaging-chime_ListChannelMembershipsForAppInstanceUser.html">ListChannelMembershipsForAppInstanceUser</a> API.</p>
		/// ListChannelMemberships channels/{channelArn}/memberships#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The maximum number of channel memberships that you want returned.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="type">The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default members are returned as part of <code>ListChannelMemberships</code> if no type is specified. Hidden members are only returned if the type filter in <code>ListChannelMemberships</code> equals <code>HIDDEN</code>.</param>
		/// <param name="max_results">The maximum number of channel memberships that you want returned.
		/// Minimum: 1
		/// Maximum: 50
		// </param>
		/// <param name="next_token">The token passed by previous API calls until all requested channel memberships are returned.
		/// Max length: 2048
		/// Min length: 0
		// </param>
		/// <param name="sub_channel_id"><p>The ID of the SubChannel in the request.</p> <note> <p>Only required when listing a user's memberships in a particular sub-channel of an elastic channel.</p> </note>
		/// Max length: 128
		/// Min length: 1
		// </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListChannelMembershipsResponse> ListChannelMembershipsAsync(string channelArn, ChannelMembershipType type, int max_results, string next_token, string sub_channel_id, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/memberships#x-amz-chime-bearer&type=" + type+"&max-results="+max_results+"&next-token=" + (next_token==null? "" : System.Uri.EscapeDataString(next_token))+"&sub-channel-id=" + (sub_channel_id==null? "" : System.Uri.EscapeDataString(sub_channel_id))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListChannelMembershipsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a new <code>ChannelModerator</code>. A channel moderator can:</p> <ul> <li> <p>Add and remove other members of the channel.</p> </li> <li> <p>Add and remove other moderators of the channel.</p> </li> <li> <p>Add and remove user bans for the channel.</p> </li> <li> <p>Redact messages in the channel.</p> </li> <li> <p>List messages in the channel.</p> </li> </ul> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code>of the user that makes the API call as the value in the header.</p> </note>
		/// CreateChannelModerator channels/{channelArn}/moderators#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		public async Task CreateChannelModeratorAsync(string channelArn, CreateChannelModeratorPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/moderators#x-amz-chime-bearer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Lists all the moderators for a channel.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// ListChannelModerators channels/{channelArn}/moderators#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="max_results">The maximum number of moderators that you want returned.
		/// Minimum: 1
		/// Maximum: 50
		// </param>
		/// <param name="next_token">The token passed by previous API calls until all requested moderators are returned.
		/// Max length: 2048
		/// Min length: 0
		// </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListChannelModeratorsResponse> ListChannelModeratorsAsync(string channelArn, int max_results, string next_token, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/moderators#x-amz-chime-bearer&max-results="+max_results+"&next-token=" + (next_token==null? "" : System.Uri.EscapeDataString(next_token))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListChannelModeratorsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Immediately makes a channel and its memberships inaccessible and marks them for deletion. This is an irreversible process.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUserArn</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// DeleteChannel channels/{channelArn}#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel being deleted.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		public async Task DeleteChannelAsync(string channelArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"#x-amz-chime-bearer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Returns the full details of a channel in an Amazon Chime <code>AppInstance</code>.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// DescribeChannel channels/{channelArn}#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <returns>Success</returns>
		public async Task<DescribeChannelResponse> DescribeChannelAsync(string channelArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"#x-amz-chime-bearer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeChannelResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Update a channel's attributes.</p> <p> <b>Restriction</b>: You can't change a channel's privacy. </p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// UpdateChannel channels/{channelArn}#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <returns>Success</returns>
		public async Task<UpdateChannelResponse> UpdateChannelAsync(string channelArn, UpdateChannelPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"#x-amz-chime-bearer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateChannelResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Removes a member from a channel's ban list.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// DeleteChannelBan channels/{channelArn}/bans/{memberArn}#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel from which the <code>AppInstanceUser</code> was banned.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="memberArn">The ARN of the <code>AppInstanceUser</code> that you want to reinstate.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		public async Task DeleteChannelBanAsync(string channelArn, string memberArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/bans/"+ (memberArn==null? "" : System.Uri.EscapeDataString(memberArn))+"#x-amz-chime-bearer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Returns the full details of a channel ban.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// DescribeChannelBan channels/{channelArn}/bans/{memberArn}#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel from which the user is banned.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="memberArn">The <code>AppInstanceUserArn</code> of the member being banned.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <returns>Success</returns>
		public async Task<DescribeChannelBanResponse> DescribeChannelBanAsync(string channelArn, string memberArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/bans/"+ (memberArn==null? "" : System.Uri.EscapeDataString(memberArn))+"#x-amz-chime-bearer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeChannelBanResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a channel flow, an irreversible process. This is a developer API.</p> <note> <p> This API works only when the channel flow is not associated with any channel. To get a list of all channels that a channel flow is associated with, use the <code>ListChannelsAssociatedWithChannelFlow</code> API. Use the <code>DisassociateChannelFlow</code> API to disassociate a channel flow from all channels. </p> </note>
		/// DeleteChannelFlow channel-flows/{channelFlowArn}
		/// </summary>
		/// <param name="channelFlowArn">The ARN of the channel flow.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		public async Task DeleteChannelFlowAsync(string channelFlowArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channel-flows/"+ (channelFlowArn==null? "" : System.Uri.EscapeDataString(channelFlowArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the full details of a channel flow in an Amazon Chime <code>AppInstance</code>. This is a developer API.
		/// DescribeChannelFlow channel-flows/{channelFlowArn}
		/// </summary>
		/// <param name="channelFlowArn">The ARN of the channel flow.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <returns>Success</returns>
		public async Task<DescribeChannelFlowResponse> DescribeChannelFlowAsync(string channelFlowArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channel-flows/"+ (channelFlowArn==null? "" : System.Uri.EscapeDataString(channelFlowArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeChannelFlowResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates channel flow attributes. This is a developer API.
		/// UpdateChannelFlow channel-flows/{channelFlowArn}
		/// </summary>
		/// <param name="channelFlowArn">The ARN of the channel flow.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <returns>Success</returns>
		public async Task<UpdateChannelFlowResponse> UpdateChannelFlowAsync(string channelFlowArn, UpdateChannelFlowPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channel-flows/"+ (channelFlowArn==null? "" : System.Uri.EscapeDataString(channelFlowArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateChannelFlowResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Removes a member from a channel.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the <code>AppInstanceUserArn</code> of the user that makes the API call as the value in the header.</p> </note>
		/// DeleteChannelMembership channels/{channelArn}/memberships/{memberArn}#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel from which you want to remove the user.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="memberArn">The <code>AppInstanceUserArn</code> of the member that you're removing from the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="sub_channel_id"><p>The ID of the SubChannel in the request.</p> <note> <p>Only for use by moderators.</p> </note>
		/// Max length: 128
		/// Min length: 1
		// </param>
		public async Task DeleteChannelMembershipAsync(string channelArn, string memberArn, string sub_channel_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/memberships/"+ (memberArn==null? "" : System.Uri.EscapeDataString(memberArn))+"#x-amz-chime-bearer&sub-channel-id=" + (sub_channel_id==null? "" : System.Uri.EscapeDataString(sub_channel_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Returns the full details of a user's channel membership.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// DescribeChannelMembership channels/{channelArn}/memberships/{memberArn}#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="memberArn">The <code>AppInstanceUserArn</code> of the member.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="sub_channel_id"><p>The ID of the SubChannel in the request. The response contains an <code>ElasticChannelConfiguration</code> object.</p> <note> <p>Only required to get a user’s SubChannel membership details.</p> </note>
		/// Max length: 128
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<DescribeChannelMembershipResponse> DescribeChannelMembershipAsync(string channelArn, string memberArn, string sub_channel_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/memberships/"+ (memberArn==null? "" : System.Uri.EscapeDataString(memberArn))+"#x-amz-chime-bearer&sub-channel-id=" + (sub_channel_id==null? "" : System.Uri.EscapeDataString(sub_channel_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeChannelMembershipResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a channel message. Only admins can perform this action. Deletion makes messages inaccessible immediately. A background process deletes any revisions created by <code>UpdateChannelMessage</code>.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// DeleteChannelMessage channels/{channelArn}/messages/{messageId}#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="messageId">The ID of the message being deleted.
		/// Max length: 128
		/// Min length: 1
		// </param>
		/// <param name="sub_channel_id"><p>The ID of the SubChannel in the request.</p> <note> <p>Only required when deleting messages in a SubChannel that the user belongs to.</p> </note>
		/// Max length: 128
		/// Min length: 1
		// </param>
		public async Task DeleteChannelMessageAsync(string channelArn, string messageId, string sub_channel_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/messages/"+ (messageId==null? "" : System.Uri.EscapeDataString(messageId))+"#x-amz-chime-bearer&sub-channel-id=" + (sub_channel_id==null? "" : System.Uri.EscapeDataString(sub_channel_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets the full details of a channel message.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// GetChannelMessage channels/{channelArn}/messages/{messageId}#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="messageId">The ID of the message.
		/// Max length: 128
		/// Min length: 1
		// </param>
		/// <param name="sub_channel_id"><p>The ID of the SubChannel in the request.</p> <note> <p>Only required when getting messages in a SubChannel that the user belongs to.</p> </note>
		/// Max length: 128
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<GetChannelMessageResponse> GetChannelMessageAsync(string channelArn, string messageId, string sub_channel_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/messages/"+ (messageId==null? "" : System.Uri.EscapeDataString(messageId))+"#x-amz-chime-bearer&sub-channel-id=" + (sub_channel_id==null? "" : System.Uri.EscapeDataString(sub_channel_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetChannelMessageResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Updates the content of a message.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// UpdateChannelMessage channels/{channelArn}/messages/{messageId}#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="messageId">The ID string of the message being updated.
		/// Max length: 128
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<UpdateChannelMessageResponse> UpdateChannelMessageAsync(string channelArn, string messageId, UpdateChannelMessagePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/messages/"+ (messageId==null? "" : System.Uri.EscapeDataString(messageId))+"#x-amz-chime-bearer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateChannelMessageResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a channel moderator.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// DeleteChannelModerator channels/{channelArn}/moderators/{channelModeratorArn}#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="channelModeratorArn">The <code>AppInstanceUserArn</code> of the moderator being deleted.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		public async Task DeleteChannelModeratorAsync(string channelArn, string channelModeratorArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/moderators/"+ (channelModeratorArn==null? "" : System.Uri.EscapeDataString(channelModeratorArn))+"#x-amz-chime-bearer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Returns the full details of a single ChannelModerator.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the <code>AppInstanceUserArn</code> of the user that makes the API call as the value in the header.</p> </note>
		/// DescribeChannelModerator channels/{channelArn}/moderators/{channelModeratorArn}#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="channelModeratorArn">The <code>AppInstanceUserArn</code> of the channel moderator.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <returns>Success</returns>
		public async Task<DescribeChannelModeratorResponse> DescribeChannelModeratorAsync(string channelArn, string channelModeratorArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/moderators/"+ (channelModeratorArn==null? "" : System.Uri.EscapeDataString(channelModeratorArn))+"#x-amz-chime-bearer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeChannelModeratorResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the streaming configurations for an <code>AppInstance</code>. For more information, see <a href="https://docs.aws.amazon.com/chime-sdk/latest/dg/streaming-export.html">Streaming messaging data</a> in the <i>Amazon Chime SDK Developer Guide</i>.
		/// DeleteMessagingStreamingConfigurations app-instances/{appInstanceArn}/streaming-configurations
		/// </summary>
		/// <param name="appInstanceArn">The ARN of the streaming configurations being deleted.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		public async Task DeleteMessagingStreamingConfigurationsAsync(string appInstanceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app-instances/"+ (appInstanceArn==null? "" : System.Uri.EscapeDataString(appInstanceArn))+"/streaming-configurations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the data streaming configuration for an <code>AppInstance</code>. For more information, see <a href="https://docs.aws.amazon.com/chime-sdk/latest/dg/streaming-export.html">Streaming messaging data</a> in the <i>Amazon Chime SDK Developer Guide</i>.
		/// GetMessagingStreamingConfigurations app-instances/{appInstanceArn}/streaming-configurations
		/// </summary>
		/// <param name="appInstanceArn">The ARN of the streaming configurations.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <returns>Success</returns>
		public async Task<GetMessagingStreamingConfigurationsResponse> GetMessagingStreamingConfigurationsAsync(string appInstanceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app-instances/"+ (appInstanceArn==null? "" : System.Uri.EscapeDataString(appInstanceArn))+"/streaming-configurations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetMessagingStreamingConfigurationsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the data streaming configuration for an <code>AppInstance</code>. For more information, see <a href="https://docs.aws.amazon.com/chime-sdk/latest/dg/streaming-export.html">Streaming messaging data</a> in the <i>Amazon Chime SDK Developer Guide</i>.
		/// PutMessagingStreamingConfigurations app-instances/{appInstanceArn}/streaming-configurations
		/// </summary>
		/// <param name="appInstanceArn">The ARN of the streaming configuration.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <returns>Success</returns>
		public async Task<PutMessagingStreamingConfigurationsResponse> PutMessagingStreamingConfigurationsAsync(string appInstanceArn, PutMessagingStreamingConfigurationsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app-instances/"+ (appInstanceArn==null? "" : System.Uri.EscapeDataString(appInstanceArn))+"/streaming-configurations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PutMessagingStreamingConfigurationsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p> Returns the details of a channel based on the membership of the specified <code>AppInstanceUser</code> or <code>AppInstanceBot</code>.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// DescribeChannelMembershipForAppInstanceUser channels/{channelArn}#scope=app-instance-user-membership&app-instance-user-arn&x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel to which the user belongs.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="app_instance_user_arn">The ARN of the user or bot in a channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <returns>Success</returns>
		public async Task<DescribeChannelMembershipForAppInstanceUserResponse> DescribeChannelMembershipForAppInstanceUserAsync(string channelArn, string app_instance_user_arn, DescribeChannelMembershipForAppInstanceUserScope scope, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"#scope=app-instance-user-membership&app-instance-user-arn&x-amz-chime-bearer&app-instance-user-arn=" + (app_instance_user_arn==null? "" : System.Uri.EscapeDataString(app_instance_user_arn))+"&scope=" + scope;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeChannelMembershipForAppInstanceUserResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Returns the full details of a channel moderated by the specified <code>AppInstanceUser</code> or <code>AppInstanceBot</code>.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// DescribeChannelModeratedByAppInstanceUser channels/{channelArn}#scope=app-instance-user-moderated-channel&app-instance-user-arn&x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the moderated channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="app_instance_user_arn">The ARN of the user or bot in the moderated channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <returns>Success</returns>
		public async Task<DescribeChannelModeratedByAppInstanceUserResponse> DescribeChannelModeratedByAppInstanceUserAsync(string channelArn, string app_instance_user_arn, DescribeChannelModeratedByAppInstanceUserScope scope, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"#scope=app-instance-user-moderated-channel&app-instance-user-arn&x-amz-chime-bearer&app-instance-user-arn=" + (app_instance_user_arn==null? "" : System.Uri.EscapeDataString(app_instance_user_arn))+"&scope=" + scope;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeChannelModeratedByAppInstanceUserResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Disassociates a channel flow from all its channels. Once disassociated, all messages to that channel stop going through the channel flow processor.</p> <note> <p>Only administrators or channel moderators can disassociate a channel flow.</p> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// DisassociateChannelFlow channels/{channelArn}/channel-flow/{channelFlowArn}#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="channelFlowArn">The ARN of the channel flow.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		public async Task DisassociateChannelFlowAsync(string channelArn, string channelFlowArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/channel-flow/"+ (channelFlowArn==null? "" : System.Uri.EscapeDataString(channelFlowArn))+"#x-amz-chime-bearer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets the membership preferences of an <code>AppInstanceUser</code> or <code>AppInstanceBot</code> for the specified channel. A user or a bot must be a member of the channel and own the membership in order to retrieve membership preferences. Users or bots in the <code>AppInstanceAdmin</code> and channel moderator roles can't retrieve preferences for other users or bots. Banned users or bots can't retrieve membership preferences for the channel from which they are banned.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// GetChannelMembershipPreferences channels/{channelArn}/memberships/{memberArn}/preferences#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="memberArn">The <code>AppInstanceUserArn</code> of the member retrieving the preferences.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <returns>Success</returns>
		public async Task<GetChannelMembershipPreferencesResponse> GetChannelMembershipPreferencesAsync(string channelArn, string memberArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/memberships/"+ (memberArn==null? "" : System.Uri.EscapeDataString(memberArn))+"/preferences#x-amz-chime-bearer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetChannelMembershipPreferencesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Sets the membership preferences of an <code>AppInstanceUser</code> or <code>AppInstanceBot</code> for the specified channel. The user or bot must be a member of the channel. Only the user or bot who owns the membership can set preferences. Users or bots in the <code>AppInstanceAdmin</code> and channel moderator roles can't set preferences for other users. Banned users or bots can't set membership preferences for the channel from which they are banned.</p> <note> <p>The x-amz-chime-bearer request header is mandatory. Use the ARN of an <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// PutChannelMembershipPreferences channels/{channelArn}/memberships/{memberArn}/preferences#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="memberArn">The ARN of the member setting the preferences.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <returns>Success</returns>
		public async Task<PutChannelMembershipPreferencesResponse> PutChannelMembershipPreferencesAsync(string channelArn, string memberArn, PutChannelMembershipPreferencesPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/memberships/"+ (memberArn==null? "" : System.Uri.EscapeDataString(memberArn))+"/preferences#x-amz-chime-bearer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PutChannelMembershipPreferencesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Gets message status for a specified <code>messageId</code>. Use this API to determine the intermediate status of messages going through channel flow processing. The API provides an alternative to retrieving message status if the event was not received because a client wasn't connected to a websocket. </p> <p>Messages can have any one of these statuses.</p> <dl> <dt>SENT</dt> <dd> <p>Message processed successfully</p> </dd> <dt>PENDING</dt> <dd> <p>Ongoing processing</p> </dd> <dt>FAILED</dt> <dd> <p>Processing failed</p> </dd> <dt>DENIED</dt> <dd> <p>Message denied by the processor</p> </dd> </dl> <note> <ul> <li> <p>This API does not return statuses for denied messages, because we don't store them once the processor denies them. </p> </li> <li> <p>Only the message sender can invoke this API.</p> </li> <li> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </li> </ul> </note>
		/// GetChannelMessageStatus channels/{channelArn}/messages/{messageId}#scope=message-status&x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="messageId">The ID of the message.
		/// Max length: 128
		/// Min length: 1
		// </param>
		/// <param name="sub_channel_id"><p>The ID of the SubChannel in the request.</p> <note> <p>Only required when getting message status in a SubChannel that the user belongs to.</p> </note>
		/// Max length: 128
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<GetChannelMessageStatusResponse> GetChannelMessageStatusAsync(string channelArn, string messageId, string sub_channel_id, GetChannelMessageStatusScope scope, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/messages/"+ (messageId==null? "" : System.Uri.EscapeDataString(messageId))+"#scope=message-status&x-amz-chime-bearer&sub-channel-id=" + (sub_channel_id==null? "" : System.Uri.EscapeDataString(sub_channel_id))+"&scope=" + scope;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetChannelMessageStatusResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// The details of the endpoint for the messaging session.
		/// GetMessagingSessionEndpoint endpoints/messaging-session
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetMessagingSessionEndpointResponse> GetMessagingSessionEndpointAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "endpoints/messaging-session";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetMessagingSessionEndpointResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a paginated lists of all the channel flows created under a single Chime. This is a developer API.
		/// ListChannelFlows channel-flows#app-instance-arn
		/// </summary>
		/// <param name="app_instance_arn">The ARN of the app instance.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="max_results">The maximum number of channel flows that you want to return.
		/// Minimum: 1
		/// Maximum: 50
		// </param>
		/// <param name="next_token">The token passed by previous API calls until all requested channel flows are returned.
		/// Max length: 2048
		/// Min length: 0
		// </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListChannelFlowsResponse> ListChannelFlowsAsync(string app_instance_arn, int max_results, string next_token, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channel-flows#app-instance-arn?app-instance-arn=" + (app_instance_arn==null? "" : System.Uri.EscapeDataString(app_instance_arn))+"&max-results="+max_results+"&next-token=" + (next_token==null? "" : System.Uri.EscapeDataString(next_token))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListChannelFlowsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p> Lists all channels that an <code>AppInstanceUser</code> or <code>AppInstanceBot</code> is a part of. Only an <code>AppInstanceAdmin</code> can call the API with a user ARN that is not their own. </p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// ListChannelMembershipsForAppInstanceUser channels#scope=app-instance-user-memberships&x-amz-chime-bearer
		/// </summary>
		/// <param name="app_instance_user_arn">The ARN of the user or bot.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="max_results">The maximum number of users that you want returned.
		/// Minimum: 1
		/// Maximum: 50
		// </param>
		/// <param name="next_token">The token returned from previous API requests until the number of channel memberships is reached.
		/// Max length: 2048
		/// Min length: 0
		// </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListChannelMembershipsForAppInstanceUserResponse> ListChannelMembershipsForAppInstanceUserAsync(string app_instance_user_arn, int max_results, string next_token, string MaxResults, string NextToken, ListChannelMembershipsForAppInstanceUserScope scope, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels#scope=app-instance-user-memberships&x-amz-chime-bearer?app-instance-user-arn=" + (app_instance_user_arn==null? "" : System.Uri.EscapeDataString(app_instance_user_arn))+"&max-results="+max_results+"&next-token=" + (next_token==null? "" : System.Uri.EscapeDataString(next_token))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken))+"&scope=" + scope;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListChannelMembershipsForAppInstanceUserResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>List all the messages in a channel. Returns a paginated list of <code>ChannelMessages</code>. By default, sorted by creation timestamp in descending order.</p> <note> <p>Redacted messages appear in the results as empty, since they are only redacted, not deleted. Deleted messages do not appear in the results. This action always returns the latest version of an edited message.</p> <p>Also, the <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// ListChannelMessages channels/{channelArn}/messages#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="sort_order">The order in which you want messages sorted. Default is Descending, based on time created.</param>
		/// <param name="not_before">The initial or starting time stamp for your requested messages.</param>
		/// <param name="not_after">The final or ending time stamp for your requested messages.</param>
		/// <param name="max_results">The maximum number of messages that you want returned.
		/// Minimum: 1
		/// Maximum: 50
		// </param>
		/// <param name="next_token">The token passed by previous API calls until all requested messages are returned.
		/// Max length: 2048
		/// Min length: 0
		// </param>
		/// <param name="sub_channel_id"><p>The ID of the SubChannel in the request.</p> <note> <p>Only required when listing the messages in a SubChannel that the user belongs to.</p> </note>
		/// Max length: 128
		/// Min length: 1
		// </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListChannelMessagesResponse> ListChannelMessagesAsync(string channelArn, SortOrder sort_order, System.DateTimeOffset not_before, System.DateTimeOffset not_after, int max_results, string next_token, string sub_channel_id, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/messages#x-amz-chime-bearer&sort-order=" + sort_order+"&not-before=" + not_before.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&not-after=" + not_after.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&max-results="+max_results+"&next-token=" + (next_token==null? "" : System.Uri.EscapeDataString(next_token))+"&sub-channel-id=" + (sub_channel_id==null? "" : System.Uri.EscapeDataString(sub_channel_id))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListChannelMessagesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Sends a message to a particular channel that the member is a part of.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> <p>Also, <code>STANDARD</code> messages can be up to 4KB in size and contain metadata. Metadata is arbitrary, and you can use it in a variety of ways, such as containing a link to an attachment.</p> <p> <code>CONTROL</code> messages are limited to 30 bytes and do not contain metadata.</p> </note>
		/// SendChannelMessage channels/{channelArn}/messages#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		public async Task SendChannelMessageAsync(string channelArn, SendChannelMessagePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/messages#x-amz-chime-bearer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Lists all Channels created under a single Chime App as a paginated list. You can specify filters to narrow results.</p> <p class="title"> <b>Functionality &amp; restrictions</b> </p> <ul> <li> <p>Use privacy = <code>PUBLIC</code> to retrieve all public channels in the account.</p> </li> <li> <p>Only an <code>AppInstanceAdmin</code> can set privacy = <code>PRIVATE</code> to list the private channels in an account.</p> </li> </ul> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// ListChannels channels#app-instance-arn&x-amz-chime-bearer
		/// </summary>
		/// <param name="app_instance_arn">The ARN of the <code>AppInstance</code>.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="privacy">The privacy setting. <code>PUBLIC</code> retrieves all the public channels. <code>PRIVATE</code> retrieves private channels. Only an <code>AppInstanceAdmin</code> can retrieve private channels. </param>
		/// <param name="max_results">The maximum number of channels that you want to return.
		/// Minimum: 1
		/// Maximum: 50
		// </param>
		/// <param name="next_token">The token passed by previous API calls until all requested channels are returned.
		/// Max length: 2048
		/// Min length: 0
		// </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListChannelsResponse> ListChannelsAsync(string app_instance_arn, ChannelPrivacy privacy, int max_results, string next_token, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels#app-instance-arn&x-amz-chime-bearer?app-instance-arn=" + (app_instance_arn==null? "" : System.Uri.EscapeDataString(app_instance_arn))+"&privacy=" + privacy+"&max-results="+max_results+"&next-token=" + (next_token==null? "" : System.Uri.EscapeDataString(next_token))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListChannelsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all channels associated with a specified channel flow. You can associate a channel flow with multiple channels, but you can only associate a channel with one channel flow. This is a developer API.
		/// ListChannelsAssociatedWithChannelFlow channels#scope=channel-flow-associations&channel-flow-arn
		/// </summary>
		/// <param name="channel_flow_arn">The ARN of the channel flow.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="max_results">The maximum number of channels that you want to return.
		/// Minimum: 1
		/// Maximum: 50
		// </param>
		/// <param name="next_token">The token passed by previous API calls until all requested channels are returned.
		/// Max length: 2048
		/// Min length: 0
		// </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListChannelsAssociatedWithChannelFlowResponse> ListChannelsAssociatedWithChannelFlowAsync(string channel_flow_arn, int max_results, string next_token, string MaxResults, string NextToken, ListChannelsAssociatedWithChannelFlowScope scope, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels#scope=channel-flow-associations&channel-flow-arn?channel-flow-arn=" + (channel_flow_arn==null? "" : System.Uri.EscapeDataString(channel_flow_arn))+"&max-results="+max_results+"&next-token=" + (next_token==null? "" : System.Uri.EscapeDataString(next_token))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken))+"&scope=" + scope;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListChannelsAssociatedWithChannelFlowResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>A list of the channels moderated by an <code>AppInstanceUser</code>.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// ListChannelsModeratedByAppInstanceUser channels#scope=app-instance-user-moderated-channels&x-amz-chime-bearer
		/// </summary>
		/// <param name="app_instance_user_arn">The ARN of the user or bot in the moderated channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="max_results">The maximum number of channels in the request.
		/// Minimum: 1
		/// Maximum: 50
		// </param>
		/// <param name="next_token">The token returned from previous API requests until the number of channels moderated by the user is reached.
		/// Max length: 2048
		/// Min length: 0
		// </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListChannelsModeratedByAppInstanceUserResponse> ListChannelsModeratedByAppInstanceUserAsync(string app_instance_user_arn, int max_results, string next_token, string MaxResults, string NextToken, ListChannelsModeratedByAppInstanceUserScope scope, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels#scope=app-instance-user-moderated-channels&x-amz-chime-bearer?app-instance-user-arn=" + (app_instance_user_arn==null? "" : System.Uri.EscapeDataString(app_instance_user_arn))+"&max-results="+max_results+"&next-token=" + (next_token==null? "" : System.Uri.EscapeDataString(next_token))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken))+"&scope=" + scope;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListChannelsModeratedByAppInstanceUserResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all the SubChannels in an elastic channel when given a channel ID. Available only to the app instance admins and channel moderators of elastic channels.
		/// ListSubChannels channels/{channelArn}/subchannels#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of elastic channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="max_results">The maximum number of sub-channels that you want to return.
		/// Minimum: 1
		/// Maximum: 50
		// </param>
		/// <param name="next_token">The token passed by previous API calls until all requested sub-channels are returned.
		/// Max length: 2048
		/// Min length: 0
		// </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListSubChannelsResponse> ListSubChannelsAsync(string channelArn, int max_results, string next_token, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/subchannels#x-amz-chime-bearer&max-results="+max_results+"&next-token=" + (next_token==null? "" : System.Uri.EscapeDataString(next_token))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListSubChannelsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the tags applied to an Amazon Chime SDK messaging resource.
		/// ListTagsForResource tags#arn
		/// </summary>
		/// <param name="arn">The ARN of the resource.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceResponse> ListTagsForResourceAsync(string arn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags#arn?arn=" + (arn==null? "" : System.Uri.EscapeDataString(arn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListTagsForResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Sets the number of days before the channel is automatically deleted.</p> <note> <ul> <li> <p>A background process deletes expired channels within 6 hours of expiration. Actual deletion times may vary.</p> </li> <li> <p>Expired channels that have not yet been deleted appear as active, and you can update their expiration settings. The system honors the new settings.</p> </li> <li> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </li> </ul> </note>
		/// PutChannelExpirationSettings channels/{channelArn}/expiration-settings
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <returns>Success</returns>
		public async Task<PutChannelExpirationSettingsResponse> PutChannelExpirationSettingsAsync(string channelArn, PutChannelExpirationSettingsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/expiration-settings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PutChannelExpirationSettingsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Redacts message content, but not metadata. The message exists in the back end, but the action returns null content, and the state shows as redacted.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// RedactChannelMessage channels/{channelArn}/messages/{messageId}#operation=redact&x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel containing the messages that you want to redact.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <param name="messageId">The ID of the message being redacted.
		/// Max length: 128
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<RedactChannelMessageResponse> RedactChannelMessageAsync(string channelArn, string messageId, RedactChannelMessageOperation operation, RedactChannelMessagePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/messages/"+ (messageId==null? "" : System.Uri.EscapeDataString(messageId))+"#operation=redact&x-amz-chime-bearer&operation=" + operation;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RedactChannelMessageResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Allows the <code>ChimeBearer</code> to search channels by channel members. Users or bots can search across the channels that they belong to. Users in the <code>AppInstanceAdmin</code> role can search across all channels.</p> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p>
		/// SearchChannels channels#operation=search
		/// </summary>
		/// <param name="max_results">The maximum number of channels that you want returned.
		/// Minimum: 1
		/// Maximum: 50
		// </param>
		/// <param name="next_token">The token returned from previous API requests until the number of channels is reached.
		/// Max length: 2048
		/// Min length: 0
		// </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<SearchChannelsResponse> SearchChannelsAsync(int max_results, string next_token, string MaxResults, string NextToken, SearchChannelsOperation operation, SearchChannelsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels#operation=search?max-results="+max_results+"&next-token=" + (next_token==null? "" : System.Uri.EscapeDataString(next_token))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken))+"&operation=" + operation;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SearchChannelsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Applies the specified tags to the specified Amazon Chime SDK messaging resource.
		/// TagResource tags#operation=tag-resource
		/// </summary>
		public async Task TagResourceAsync(TagResourceOperation operation, TagResourcePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags#operation=tag-resource?operation=" + operation;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes the specified tags from the specified Amazon Chime SDK messaging resource.
		/// UntagResource tags#operation=untag-resource
		/// </summary>
		public async Task UntagResourceAsync(UntagResourceOperation operation, UntagResourcePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tags#operation=untag-resource?operation=" + operation;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>The details of the time when a user last read messages in a channel.</p> <note> <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p> </note>
		/// UpdateChannelReadMarker channels/{channelArn}/readMarker#x-amz-chime-bearer
		/// </summary>
		/// <param name="channelArn">The ARN of the channel.
		/// Max length: 1600
		/// Min length: 5
		// </param>
		/// <returns>Success</returns>
		public async Task<UpdateChannelReadMarkerResponse> UpdateChannelReadMarkerAsync(string channelArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "channels/"+ (channelArn==null? "" : System.Uri.EscapeDataString(channelArn))+"/readMarker#x-amz-chime-bearer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateChannelReadMarkerResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public class AssociateChannelFlowPutBody
	{
		
		/// <summary>
		/// The ARN of the channel flow.
		/// Required
		/// Max length: 1600
		/// Min length: 5
		/// Pattern: arn:[a-z0-9-\.]{1,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[^/].{0,1023}
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(5)]
		[System.ComponentModel.DataAnnotations.MaxLength(1600)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"arn:[a-z0-9-\.]{1,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[^/].{0,1023}")]
		public string ChannelFlowArn { get; set; }
	}
	
	public enum BatchCreateChannelMembershipOperation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="batch-create")]
		batchMinuscreate = 0,
	}
	
	public class BatchCreateChannelMembershipPostBody
	{
		
		/// <summary>
		/// The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default members are always returned as part of <code>ListChannelMemberships</code>. Hidden members are only returned if the type filter in <code>ListChannelMemberships</code> equals <code>HIDDEN</code>. Otherwise hidden members are not returned. This is only supported by moderators.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ChannelMembershipType Type { get; set; }
		
		/// <summary>
		/// The ARNs of the members you want to add to the channel. Only <code>AppInstanceUsers</code> and <code>AppInstanceBots</code> can be added as a channel member.
		/// Required
		/// Minimum items: 1
		/// Maximum items: 100
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(100)]
		public string[] MemberArns { get; set; }
		
		/// <summary>
		/// <p>The ID of the SubChannel in the request. </p> <note> <p>Only required when creating membership in a SubChannel for a moderator in an elastic channel.</p> </note>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [-_a-zA-Z0-9]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[-_a-zA-Z0-9]*")]
		public string SubChannelId { get; set; }
	}
	
	public enum ChannelFlowCallbackOperation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="channel-flow-callback")]
		channelMinusflowMinuscallback = 0,
	}
	
	public class ChannelFlowCallbackPostBody
	{
		
		/// <summary>
		/// The identifier passed to the processor by the service when invoked. Use the identifier to call back the service.
		/// Required
		/// Max length: 64
		/// Min length: 32
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(32)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		public string CallbackId { get; set; }
		
		/// <summary>
		/// When a processor determines that a message needs to be <code>DENIED</code>, pass this parameter with a value of true.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> DeleteResource { get; set; }
		
		/// <summary>
		/// Stores information about a callback.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChannelFlowCallbackPostBodyChannelMessage ChannelMessage { get; set; }
	}
	
	public class ChannelFlowCallbackPostBodyChannelMessage
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string MessageId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Content { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PushNotificationConfiguration PushNotification { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MessageAttributeMap MessageAttributes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SubChannelId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ContentType { get; set; }
	}
	
	public class CreateChannelPostBody
	{
		
		/// <summary>
		/// The ARN of the channel request.
		/// Required
		/// Max length: 1600
		/// Min length: 5
		/// Pattern: arn:[a-z0-9-\.]{1,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[^/].{0,1023}
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(5)]
		[System.ComponentModel.DataAnnotations.MaxLength(1600)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"arn:[a-z0-9-\.]{1,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[^/].{0,1023}")]
		public string AppInstanceArn { get; set; }
		
		/// <summary>
		/// The name of the channel.
		/// Required
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [\u0009\u000A\u000D\u0020-\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\u0009\u000A\u000D\u0020-\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]*")]
		public string Name { get; set; }
		
		/// <summary>
		/// The channel mode: <code>UNRESTRICTED</code> or <code>RESTRICTED</code>. Administrators, moderators, and channel members can add themselves and other members to unrestricted channels. Only administrators and moderators can add members to restricted channels.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ChannelMode Mode { get; set; }
		
		/// <summary>
		/// The channel's privacy level: <code>PUBLIC</code> or <code>PRIVATE</code>. Private channels aren't discoverable by users outside the channel. Public channels are discoverable by anyone in the <code>AppInstance</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ChannelPrivacy Privacy { get; set; }
		
		/// <summary>
		/// The metadata of the creation request. Limited to 1KB and UTF-8.
		/// Max length: 1024
		/// Min length: 0
		/// Pattern: .*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(1024)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@".*")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// The client token for the request. An <code>Idempotency</code> token.
		/// Required
		/// Max length: 64
		/// Min length: 2
		/// Pattern: [-_a-zA-Z0-9]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[-_a-zA-Z0-9]*")]
		public string ClientRequestToken { get; set; }
		
		/// <summary>
		/// The tags for the creation request.
		/// Minimum items: 1
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public Tag[] Tags { get; set; }
		
		/// <summary>
		/// The ID of the channel in the request.
		/// Max length: 64
		/// Min length: 1
		/// Pattern: [A-Za-z0-9]([A-Za-z0-9\:\-\_\.\@]{0,62}[A-Za-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[A-Za-z0-9]([A-Za-z0-9\:\-\_\.\@]{0,62}[A-Za-z0-9])?")]
		public string ChannelId { get; set; }
		
		/// <summary>
		/// The ARNs of the channel members in the request.
		/// Minimum items: 1
		/// Maximum items: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(10)]
		public string[] MemberArns { get; set; }
		
		/// <summary>
		/// The ARNs of the channel moderators in the request.
		/// Minimum items: 1
		/// Maximum items: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(10)]
		public string[] ModeratorArns { get; set; }
		
		/// <summary>
		/// The attributes required to configure and create an elastic channel. An elastic channel can support a maximum of 1-million members.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateChannelPostBodyElasticChannelConfiguration ElasticChannelConfiguration { get; set; }
		
		/// <summary>
		/// Settings that control the interval after which a channel is deleted.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateChannelPostBodyExpirationSettings ExpirationSettings { get; set; }
	}
	
	public class CreateChannelPostBodyElasticChannelConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaximumSubChannels { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TargetMembershipsPerSubChannel { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MinimumMembershipPercentage { get; set; }
	}
	
	public class CreateChannelPostBodyExpirationSettings
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ExpirationDays { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpirationCriterion ExpirationCriterion { get; set; }
	}
	
	public class CreateChannelBanPostBody
	{
		
		/// <summary>
		/// The <code>AppInstanceUserArn</code> of the member being banned.
		/// Required
		/// Max length: 1600
		/// Min length: 5
		/// Pattern: arn:[a-z0-9-\.]{1,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[^/].{0,1023}
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(5)]
		[System.ComponentModel.DataAnnotations.MaxLength(1600)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"arn:[a-z0-9-\.]{1,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[^/].{0,1023}")]
		public string MemberArn { get; set; }
	}
	
	public class CreateChannelFlowPostBody
	{
		
		/// <summary>
		/// The ARN of the channel flow request.
		/// Required
		/// Max length: 1600
		/// Min length: 5
		/// Pattern: arn:[a-z0-9-\.]{1,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[^/].{0,1023}
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(5)]
		[System.ComponentModel.DataAnnotations.MaxLength(1600)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"arn:[a-z0-9-\.]{1,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[^/].{0,1023}")]
		public string AppInstanceArn { get; set; }
		
		/// <summary>
		/// Information about the processor Lambda functions.
		/// Required
		/// Minimum items: 1
		/// Maximum items: 3
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(3)]
		public Processor[] Processors { get; set; }
		
		/// <summary>
		/// The name of the channel flow.
		/// Required
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [\u0009\u000A\u000D\u0020-\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\u0009\u000A\u000D\u0020-\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]*")]
		public string Name { get; set; }
		
		/// <summary>
		/// The tags for the creation request.
		/// Minimum items: 1
		/// Maximum items: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public Tag[] Tags { get; set; }
		
		/// <summary>
		/// The client token for the request. An Idempotency token.
		/// Required
		/// Max length: 64
		/// Min length: 2
		/// Pattern: [-_a-zA-Z0-9]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[-_a-zA-Z0-9]*")]
		public string ClientRequestToken { get; set; }
	}
	
	public class CreateChannelMembershipPostBody
	{
		
		/// <summary>
		/// The <code>AppInstanceUserArn</code> of the member you want to add to the channel.
		/// Required
		/// Max length: 1600
		/// Min length: 5
		/// Pattern: arn:[a-z0-9-\.]{1,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[^/].{0,1023}
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(5)]
		[System.ComponentModel.DataAnnotations.MaxLength(1600)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"arn:[a-z0-9-\.]{1,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[^/].{0,1023}")]
		public string MemberArn { get; set; }
		
		/// <summary>
		/// The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default members are always returned as part of <code>ListChannelMemberships</code>. Hidden members are only returned if the type filter in <code>ListChannelMemberships</code> equals <code>HIDDEN</code>. Otherwise hidden members are not returned. This is only supported by moderators.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChannelMembershipType Type { get; set; }
		
		/// <summary>
		/// <p>The ID of the SubChannel in the request.</p> <note> <p>Only required when creating membership in a SubChannel for a moderator in an elastic channel.</p> </note>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [-_a-zA-Z0-9]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[-_a-zA-Z0-9]*")]
		public string SubChannelId { get; set; }
	}
	
	public class CreateChannelModeratorPostBody
	{
		
		/// <summary>
		/// The <code>AppInstanceUserArn</code> of the moderator.
		/// Required
		/// Max length: 1600
		/// Min length: 5
		/// Pattern: arn:[a-z0-9-\.]{1,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[^/].{0,1023}
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(5)]
		[System.ComponentModel.DataAnnotations.MaxLength(1600)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"arn:[a-z0-9-\.]{1,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[^/].{0,1023}")]
		public string ChannelModeratorArn { get; set; }
	}
	
	public class UpdateChannelPutBody
	{
		
		/// <summary>
		/// The name of the channel.
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [\u0009\u000A\u000D\u0020-\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\u0009\u000A\u000D\u0020-\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]*")]
		public string Name { get; set; }
		
		/// <summary>
		/// The mode of the update request.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ChannelMode Mode { get; set; }
		
		/// <summary>
		/// The metadata for the update request.
		/// Max length: 1024
		/// Min length: 0
		/// Pattern: .*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(1024)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@".*")]
		public string Metadata { get; set; }
	}
	
	public class UpdateChannelFlowPutBody
	{
		
		/// <summary>
		/// Information about the processor Lambda functions 
		/// Required
		/// Minimum items: 1
		/// Maximum items: 3
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(3)]
		public Processor[] Processors { get; set; }
		
		/// <summary>
		/// The name of the channel flow.
		/// Required
		/// Max length: 256
		/// Min length: 1
		/// Pattern: [\u0009\u000A\u000D\u0020-\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\u0009\u000A\u000D\u0020-\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]*")]
		public string Name { get; set; }
	}
	
	public class UpdateChannelMessagePutBody
	{
		
		/// <summary>
		/// The content of the channel message. 
		/// Required
		/// Min length: 1
		/// Pattern: [\s\S]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\s\S]*")]
		public string Content { get; set; }
		
		/// <summary>
		/// The metadata of the message being updated.
		/// Max length: 1024
		/// Min length: 0
		/// Pattern: .*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(1024)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@".*")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// <p>The ID of the SubChannel in the request.</p> <note> <p>Only required when updating messages in a SubChannel that the user belongs to.</p> </note>
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [-_a-zA-Z0-9]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[-_a-zA-Z0-9]*")]
		public string SubChannelId { get; set; }
		
		/// <summary>
		/// The content type of the channel message.
		/// Max length: 45
		/// Min length: 0
		/// Pattern: [\s\S]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(45)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\s\S]*")]
		public string ContentType { get; set; }
	}
	
	public class PutMessagingStreamingConfigurationsPutBody
	{
		
		/// <summary>
		/// The streaming configurations.
		/// Required
		/// Minimum items: 1
		/// Maximum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(2)]
		public StreamingConfiguration[] StreamingConfigurations { get; set; }
	}
	
	public enum DescribeChannelMembershipForAppInstanceUserScope
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="app-instance-user-membership")]
		appMinusinstanceMinususerMinusmembership = 0,
	}
	
	public enum DescribeChannelModeratedByAppInstanceUserScope
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="app-instance-user-moderated-channel")]
		appMinusinstanceMinususerMinusmoderatedMinuschannel = 0,
	}
	
	public class PutChannelMembershipPreferencesPutBody
	{
		
		/// <summary>
		/// The channel membership preferences for an <code>AppInstanceUser</code>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PutChannelMembershipPreferencesPutBodyPreferences Preferences { get; set; }
	}
	
	public class PutChannelMembershipPreferencesPutBodyPreferences
	{
		
		[System.Runtime.Serialization.DataMember()]
		public PushNotificationPreferences PushNotifications { get; set; }
	}
	
	public enum GetChannelMessageStatusScope
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="message-status")]
		messageMinusstatus = 0,
	}
	
	public enum ListChannelMembershipsForAppInstanceUserScope
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="app-instance-user-memberships")]
		appMinusinstanceMinususerMinusmemberships = 0,
	}
	
	public class SendChannelMessagePostBody
	{
		
		/// <summary>
		/// The content of the channel message.
		/// Required
		/// Min length: 1
		/// Pattern: [\s\S]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\s\S]*")]
		public string Content { get; set; }
		
		/// <summary>
		/// <p>The type of message, <code>STANDARD</code> or <code>CONTROL</code>.</p> <p> <code>STANDARD</code> messages can be up to 4KB in size and contain metadata. Metadata is arbitrary, and you can use it in a variety of ways, such as containing a link to an attachment.</p> <p> <code>CONTROL</code> messages are limited to 30 bytes and do not contain metadata.</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChannelMessageType Type { get; set; }
		
		/// <summary>
		/// Boolean that controls whether the message is persisted on the back end. Required.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChannelMessagePersistenceType Persistence { get; set; }
		
		/// <summary>
		/// The optional metadata for each message.
		/// Max length: 1024
		/// Min length: 0
		/// Pattern: .*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(1024)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@".*")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// The <code>Idempotency</code> token for each client request.
		/// Required
		/// Max length: 64
		/// Min length: 2
		/// Pattern: [-_a-zA-Z0-9]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[-_a-zA-Z0-9]*")]
		public string ClientRequestToken { get; set; }
		
		/// <summary>
		/// The push notification configuration of the message.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public SendChannelMessagePostBodyPushNotification PushNotification { get; set; }
		
		/// <summary>
		/// The attributes for the message, used for message filtering along with a <code>FilterRule</code> defined in the <code>PushNotificationPreferences</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, MessageAttributeValue> MessageAttributes { get; set; }
		
		/// <summary>
		/// The ID of the SubChannel in the request.
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [-_a-zA-Z0-9]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[-_a-zA-Z0-9]*")]
		public string SubChannelId { get; set; }
		
		/// <summary>
		/// The content type of the channel message.
		/// Max length: 45
		/// Min length: 0
		/// Pattern: [\s\S]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(45)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\s\S]*")]
		public string ContentType { get; set; }
		
		/// <summary>
		/// The target of a message. Must be a member of the channel, such as another user, a bot, or the sender. Only the target and the sender can view targeted messages. Only users who can see targeted messages can take actions on them. However, administrators can delete targeted messages that they can’t see. 
		/// Minimum items: 1
		/// Maximum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(1)]
		public Target[] Target { get; set; }
	}
	
	public class SendChannelMessagePostBodyPushNotification
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Body { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PushNotificationType Type { get; set; }
	}
	
	public enum ListChannelsAssociatedWithChannelFlowScope
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="channel-flow-associations")]
		channelMinusflowMinusassociations = 0,
	}
	
	public enum ListChannelsModeratedByAppInstanceUserScope
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="app-instance-user-moderated-channels")]
		appMinusinstanceMinususerMinusmoderatedMinuschannels = 0,
	}
	
	public class PutChannelExpirationSettingsPutBody
	{
		
		/// <summary>
		/// Settings that control the interval after which a channel is deleted.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PutChannelExpirationSettingsPutBodyExpirationSettings ExpirationSettings { get; set; }
	}
	
	public class PutChannelExpirationSettingsPutBodyExpirationSettings
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ExpirationDays { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpirationCriterion ExpirationCriterion { get; set; }
	}
	
	public enum RedactChannelMessageOperation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="redact")]
		redact = 0,
	}
	
	public class RedactChannelMessagePostBody
	{
		
		/// <summary>
		/// The ID of the SubChannel in the request.
		/// Max length: 128
		/// Min length: 1
		/// Pattern: [-_a-zA-Z0-9]*
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[-_a-zA-Z0-9]*")]
		public string SubChannelId { get; set; }
	}
	
	public enum SearchChannelsOperation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="search")]
		search = 0,
	}
	
	public class SearchChannelsPostBody
	{
		
		/// <summary>
		/// A list of the <code>Field</code> objects in the channel being searched.
		/// Required
		/// Minimum items: 1
		/// Maximum items: 20
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(20)]
		public SearchField[] Fields { get; set; }
	}
	
	public enum TagResourceOperation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="tag-resource")]
		tagMinusresource = 0,
	}
	
	public class TagResourcePostBody
	{
		
		/// <summary>
		/// The resource ARN.
		/// Required
		/// Max length: 1600
		/// Min length: 5
		/// Pattern: arn:[a-z0-9-\.]{1,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[^/].{0,1023}
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(5)]
		[System.ComponentModel.DataAnnotations.MaxLength(1600)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"arn:[a-z0-9-\.]{1,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[^/].{0,1023}")]
		public string ResourceARN { get; set; }
		
		/// <summary>
		/// The tag key-value pairs.
		/// Required
		/// Minimum items: 1
		/// Maximum items: 50
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public Tag[] Tags { get; set; }
	}
	
	public enum UntagResourceOperation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="untag-resource")]
		untagMinusresource = 0,
	}
	
	public class UntagResourcePostBody
	{
		
		/// <summary>
		/// The resource ARN.
		/// Required
		/// Max length: 1600
		/// Min length: 5
		/// Pattern: arn:[a-z0-9-\.]{1,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[^/].{0,1023}
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(5)]
		[System.ComponentModel.DataAnnotations.MaxLength(1600)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"arn:[a-z0-9-\.]{1,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[a-z0-9-\.]{0,63}:[^/].{0,1023}")]
		public string ResourceARN { get; set; }
		
		/// <summary>
		/// The tag keys.
		/// Required
		/// Minimum items: 1
		/// Maximum items: 50
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public string[] TagKeys { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
